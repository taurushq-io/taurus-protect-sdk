// Code generated by protoc-gen-ts_proto. DO NOT EDIT.
// versions:
//   protoc-gen-ts_proto  v1.181.2
//   protoc               v6.33.4
// source: health.proto

/* eslint-disable */
import Long from "long";
import _m0 from "protobufjs/minimal";
import { Timestamp } from "./google/protobuf/timestamp";
import { BoolValue } from "./google/protobuf/wrappers";

export const protobufPackage = "tgvalidatord";

export interface ClientStatus {
  hostPort: string;
  connected: boolean | undefined;
  error: string;
  lastPing: Date | undefined;
}

export interface HealthReport {
  name: string;
  status: string;
  message: string;
  duration: string;
  error: string;
  results: { [key: string]: string };
  vaultdClients: ClientStatus[];
}

export interface HealthReport_ResultsEntry {
  key: string;
  value: string;
}

export interface Health {
  tenantId: number;
  componentName: string;
  componentId: string;
  group: string;
  healthCheck: string;
  status: string;
  report: HealthReport | undefined;
  lastUpdateDate: Date | undefined;
  validUntilDate: Date | undefined;
}

export interface HealthGroup {
  healthChecks: Health[];
}

export interface HealthComponent {
  groups: { [key: string]: HealthGroup };
}

export interface HealthComponent_GroupsEntry {
  key: string;
  value: HealthGroup | undefined;
}

function createBaseClientStatus(): ClientStatus {
  return { hostPort: "", connected: undefined, error: "", lastPing: undefined };
}

export const ClientStatus = {
  encode(message: ClientStatus, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.hostPort !== "") {
      writer.uint32(10).string(message.hostPort);
    }
    if (message.connected !== undefined) {
      BoolValue.encode({ value: message.connected! }, writer.uint32(18).fork()).ldelim();
    }
    if (message.error !== "") {
      writer.uint32(26).string(message.error);
    }
    if (message.lastPing !== undefined) {
      Timestamp.encode(toTimestamp(message.lastPing), writer.uint32(34).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): ClientStatus {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseClientStatus();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.hostPort = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.connected = BoolValue.decode(reader, reader.uint32()).value;
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.error = reader.string();
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.lastPing = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ClientStatus {
    return {
      hostPort: isSet(object.hostPort) ? globalThis.String(object.hostPort) : "",
      connected: isSet(object.connected) ? Boolean(object.connected) : undefined,
      error: isSet(object.error) ? globalThis.String(object.error) : "",
      lastPing: isSet(object.lastPing) ? fromJsonTimestamp(object.lastPing) : undefined,
    };
  },

  toJSON(message: ClientStatus): unknown {
    const obj: any = {};
    if (message.hostPort !== "") {
      obj.hostPort = message.hostPort;
    }
    if (message.connected !== undefined) {
      obj.connected = message.connected;
    }
    if (message.error !== "") {
      obj.error = message.error;
    }
    if (message.lastPing !== undefined) {
      obj.lastPing = message.lastPing.toISOString();
    }
    return obj;
  },

  create(base?: DeepPartial<ClientStatus>): ClientStatus {
    return ClientStatus.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ClientStatus>): ClientStatus {
    const message = createBaseClientStatus();
    message.hostPort = object.hostPort ?? "";
    message.connected = object.connected ?? undefined;
    message.error = object.error ?? "";
    message.lastPing = object.lastPing ?? undefined;
    return message;
  },
};

function createBaseHealthReport(): HealthReport {
  return { name: "", status: "", message: "", duration: "", error: "", results: {}, vaultdClients: [] };
}

export const HealthReport = {
  encode(message: HealthReport, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    if (message.status !== "") {
      writer.uint32(18).string(message.status);
    }
    if (message.message !== "") {
      writer.uint32(26).string(message.message);
    }
    if (message.duration !== "") {
      writer.uint32(34).string(message.duration);
    }
    if (message.error !== "") {
      writer.uint32(42).string(message.error);
    }
    Object.entries(message.results).forEach(([key, value]) => {
      HealthReport_ResultsEntry.encode({ key: key as any, value }, writer.uint32(50).fork()).ldelim();
    });
    for (const v of message.vaultdClients) {
      ClientStatus.encode(v!, writer.uint32(58).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): HealthReport {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseHealthReport();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.status = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.message = reader.string();
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.duration = reader.string();
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.error = reader.string();
          continue;
        case 6:
          if (tag !== 50) {
            break;
          }

          const entry6 = HealthReport_ResultsEntry.decode(reader, reader.uint32());
          if (entry6.value !== undefined) {
            message.results[entry6.key] = entry6.value;
          }
          continue;
        case 7:
          if (tag !== 58) {
            break;
          }

          message.vaultdClients.push(ClientStatus.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): HealthReport {
    return {
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      status: isSet(object.status) ? globalThis.String(object.status) : "",
      message: isSet(object.message) ? globalThis.String(object.message) : "",
      duration: isSet(object.duration) ? globalThis.String(object.duration) : "",
      error: isSet(object.error) ? globalThis.String(object.error) : "",
      results: isObject(object.results)
        ? Object.entries(object.results).reduce<{ [key: string]: string }>((acc, [key, value]) => {
          acc[key] = String(value);
          return acc;
        }, {})
        : {},
      vaultdClients: globalThis.Array.isArray(object?.vaultdClients)
        ? object.vaultdClients.map((e: any) => ClientStatus.fromJSON(e))
        : [],
    };
  },

  toJSON(message: HealthReport): unknown {
    const obj: any = {};
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.status !== "") {
      obj.status = message.status;
    }
    if (message.message !== "") {
      obj.message = message.message;
    }
    if (message.duration !== "") {
      obj.duration = message.duration;
    }
    if (message.error !== "") {
      obj.error = message.error;
    }
    if (message.results) {
      const entries = Object.entries(message.results);
      if (entries.length > 0) {
        obj.results = {};
        entries.forEach(([k, v]) => {
          obj.results[k] = v;
        });
      }
    }
    if (message.vaultdClients?.length) {
      obj.vaultdClients = message.vaultdClients.map((e) => ClientStatus.toJSON(e));
    }
    return obj;
  },

  create(base?: DeepPartial<HealthReport>): HealthReport {
    return HealthReport.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<HealthReport>): HealthReport {
    const message = createBaseHealthReport();
    message.name = object.name ?? "";
    message.status = object.status ?? "";
    message.message = object.message ?? "";
    message.duration = object.duration ?? "";
    message.error = object.error ?? "";
    message.results = Object.entries(object.results ?? {}).reduce<{ [key: string]: string }>((acc, [key, value]) => {
      if (value !== undefined) {
        acc[key] = globalThis.String(value);
      }
      return acc;
    }, {});
    message.vaultdClients = object.vaultdClients?.map((e) => ClientStatus.fromPartial(e)) || [];
    return message;
  },
};

function createBaseHealthReport_ResultsEntry(): HealthReport_ResultsEntry {
  return { key: "", value: "" };
}

export const HealthReport_ResultsEntry = {
  encode(message: HealthReport_ResultsEntry, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.key !== "") {
      writer.uint32(10).string(message.key);
    }
    if (message.value !== "") {
      writer.uint32(18).string(message.value);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): HealthReport_ResultsEntry {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseHealthReport_ResultsEntry();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.key = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.value = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): HealthReport_ResultsEntry {
    return {
      key: isSet(object.key) ? globalThis.String(object.key) : "",
      value: isSet(object.value) ? globalThis.String(object.value) : "",
    };
  },

  toJSON(message: HealthReport_ResultsEntry): unknown {
    const obj: any = {};
    if (message.key !== "") {
      obj.key = message.key;
    }
    if (message.value !== "") {
      obj.value = message.value;
    }
    return obj;
  },

  create(base?: DeepPartial<HealthReport_ResultsEntry>): HealthReport_ResultsEntry {
    return HealthReport_ResultsEntry.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<HealthReport_ResultsEntry>): HealthReport_ResultsEntry {
    const message = createBaseHealthReport_ResultsEntry();
    message.key = object.key ?? "";
    message.value = object.value ?? "";
    return message;
  },
};

function createBaseHealth(): Health {
  return {
    tenantId: 0,
    componentName: "",
    componentId: "",
    group: "",
    healthCheck: "",
    status: "",
    report: undefined,
    lastUpdateDate: undefined,
    validUntilDate: undefined,
  };
}

export const Health = {
  encode(message: Health, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.tenantId !== 0) {
      writer.uint32(8).uint64(message.tenantId);
    }
    if (message.componentName !== "") {
      writer.uint32(18).string(message.componentName);
    }
    if (message.componentId !== "") {
      writer.uint32(26).string(message.componentId);
    }
    if (message.group !== "") {
      writer.uint32(34).string(message.group);
    }
    if (message.healthCheck !== "") {
      writer.uint32(42).string(message.healthCheck);
    }
    if (message.status !== "") {
      writer.uint32(50).string(message.status);
    }
    if (message.report !== undefined) {
      HealthReport.encode(message.report, writer.uint32(58).fork()).ldelim();
    }
    if (message.lastUpdateDate !== undefined) {
      Timestamp.encode(toTimestamp(message.lastUpdateDate), writer.uint32(66).fork()).ldelim();
    }
    if (message.validUntilDate !== undefined) {
      Timestamp.encode(toTimestamp(message.validUntilDate), writer.uint32(74).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): Health {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseHealth();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.tenantId = longToNumber(reader.uint64() as Long);
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.componentName = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.componentId = reader.string();
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.group = reader.string();
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.healthCheck = reader.string();
          continue;
        case 6:
          if (tag !== 50) {
            break;
          }

          message.status = reader.string();
          continue;
        case 7:
          if (tag !== 58) {
            break;
          }

          message.report = HealthReport.decode(reader, reader.uint32());
          continue;
        case 8:
          if (tag !== 66) {
            break;
          }

          message.lastUpdateDate = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        case 9:
          if (tag !== 74) {
            break;
          }

          message.validUntilDate = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Health {
    return {
      tenantId: isSet(object.tenantId) ? globalThis.Number(object.tenantId) : 0,
      componentName: isSet(object.componentName) ? globalThis.String(object.componentName) : "",
      componentId: isSet(object.componentId) ? globalThis.String(object.componentId) : "",
      group: isSet(object.group) ? globalThis.String(object.group) : "",
      healthCheck: isSet(object.healthCheck) ? globalThis.String(object.healthCheck) : "",
      status: isSet(object.status) ? globalThis.String(object.status) : "",
      report: isSet(object.report) ? HealthReport.fromJSON(object.report) : undefined,
      lastUpdateDate: isSet(object.lastUpdateDate) ? fromJsonTimestamp(object.lastUpdateDate) : undefined,
      validUntilDate: isSet(object.validUntilDate) ? fromJsonTimestamp(object.validUntilDate) : undefined,
    };
  },

  toJSON(message: Health): unknown {
    const obj: any = {};
    if (message.tenantId !== 0) {
      obj.tenantId = Math.round(message.tenantId);
    }
    if (message.componentName !== "") {
      obj.componentName = message.componentName;
    }
    if (message.componentId !== "") {
      obj.componentId = message.componentId;
    }
    if (message.group !== "") {
      obj.group = message.group;
    }
    if (message.healthCheck !== "") {
      obj.healthCheck = message.healthCheck;
    }
    if (message.status !== "") {
      obj.status = message.status;
    }
    if (message.report !== undefined) {
      obj.report = HealthReport.toJSON(message.report);
    }
    if (message.lastUpdateDate !== undefined) {
      obj.lastUpdateDate = message.lastUpdateDate.toISOString();
    }
    if (message.validUntilDate !== undefined) {
      obj.validUntilDate = message.validUntilDate.toISOString();
    }
    return obj;
  },

  create(base?: DeepPartial<Health>): Health {
    return Health.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<Health>): Health {
    const message = createBaseHealth();
    message.tenantId = object.tenantId ?? 0;
    message.componentName = object.componentName ?? "";
    message.componentId = object.componentId ?? "";
    message.group = object.group ?? "";
    message.healthCheck = object.healthCheck ?? "";
    message.status = object.status ?? "";
    message.report = (object.report !== undefined && object.report !== null)
      ? HealthReport.fromPartial(object.report)
      : undefined;
    message.lastUpdateDate = object.lastUpdateDate ?? undefined;
    message.validUntilDate = object.validUntilDate ?? undefined;
    return message;
  },
};

function createBaseHealthGroup(): HealthGroup {
  return { healthChecks: [] };
}

export const HealthGroup = {
  encode(message: HealthGroup, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    for (const v of message.healthChecks) {
      Health.encode(v!, writer.uint32(10).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): HealthGroup {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseHealthGroup();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.healthChecks.push(Health.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): HealthGroup {
    return {
      healthChecks: globalThis.Array.isArray(object?.healthChecks)
        ? object.healthChecks.map((e: any) => Health.fromJSON(e))
        : [],
    };
  },

  toJSON(message: HealthGroup): unknown {
    const obj: any = {};
    if (message.healthChecks?.length) {
      obj.healthChecks = message.healthChecks.map((e) => Health.toJSON(e));
    }
    return obj;
  },

  create(base?: DeepPartial<HealthGroup>): HealthGroup {
    return HealthGroup.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<HealthGroup>): HealthGroup {
    const message = createBaseHealthGroup();
    message.healthChecks = object.healthChecks?.map((e) => Health.fromPartial(e)) || [];
    return message;
  },
};

function createBaseHealthComponent(): HealthComponent {
  return { groups: {} };
}

export const HealthComponent = {
  encode(message: HealthComponent, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    Object.entries(message.groups).forEach(([key, value]) => {
      HealthComponent_GroupsEntry.encode({ key: key as any, value }, writer.uint32(10).fork()).ldelim();
    });
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): HealthComponent {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseHealthComponent();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          const entry1 = HealthComponent_GroupsEntry.decode(reader, reader.uint32());
          if (entry1.value !== undefined) {
            message.groups[entry1.key] = entry1.value;
          }
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): HealthComponent {
    return {
      groups: isObject(object.groups)
        ? Object.entries(object.groups).reduce<{ [key: string]: HealthGroup }>((acc, [key, value]) => {
          acc[key] = HealthGroup.fromJSON(value);
          return acc;
        }, {})
        : {},
    };
  },

  toJSON(message: HealthComponent): unknown {
    const obj: any = {};
    if (message.groups) {
      const entries = Object.entries(message.groups);
      if (entries.length > 0) {
        obj.groups = {};
        entries.forEach(([k, v]) => {
          obj.groups[k] = HealthGroup.toJSON(v);
        });
      }
    }
    return obj;
  },

  create(base?: DeepPartial<HealthComponent>): HealthComponent {
    return HealthComponent.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<HealthComponent>): HealthComponent {
    const message = createBaseHealthComponent();
    message.groups = Object.entries(object.groups ?? {}).reduce<{ [key: string]: HealthGroup }>((acc, [key, value]) => {
      if (value !== undefined) {
        acc[key] = HealthGroup.fromPartial(value);
      }
      return acc;
    }, {});
    return message;
  },
};

function createBaseHealthComponent_GroupsEntry(): HealthComponent_GroupsEntry {
  return { key: "", value: undefined };
}

export const HealthComponent_GroupsEntry = {
  encode(message: HealthComponent_GroupsEntry, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.key !== "") {
      writer.uint32(10).string(message.key);
    }
    if (message.value !== undefined) {
      HealthGroup.encode(message.value, writer.uint32(18).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): HealthComponent_GroupsEntry {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseHealthComponent_GroupsEntry();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.key = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.value = HealthGroup.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): HealthComponent_GroupsEntry {
    return {
      key: isSet(object.key) ? globalThis.String(object.key) : "",
      value: isSet(object.value) ? HealthGroup.fromJSON(object.value) : undefined,
    };
  },

  toJSON(message: HealthComponent_GroupsEntry): unknown {
    const obj: any = {};
    if (message.key !== "") {
      obj.key = message.key;
    }
    if (message.value !== undefined) {
      obj.value = HealthGroup.toJSON(message.value);
    }
    return obj;
  },

  create(base?: DeepPartial<HealthComponent_GroupsEntry>): HealthComponent_GroupsEntry {
    return HealthComponent_GroupsEntry.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<HealthComponent_GroupsEntry>): HealthComponent_GroupsEntry {
    const message = createBaseHealthComponent_GroupsEntry();
    message.key = object.key ?? "";
    message.value = (object.value !== undefined && object.value !== null)
      ? HealthGroup.fromPartial(object.value)
      : undefined;
    return message;
  },
};

type Builtin = Date | Function | Uint8Array | string | number | boolean | undefined;

export type DeepPartial<T> = T extends Builtin ? T
  : T extends globalThis.Array<infer U> ? globalThis.Array<DeepPartial<U>>
  : T extends ReadonlyArray<infer U> ? ReadonlyArray<DeepPartial<U>>
  : T extends {} ? { [K in keyof T]?: DeepPartial<T[K]> }
  : Partial<T>;

function toTimestamp(date: Date): Timestamp {
  const seconds = Math.trunc(date.getTime() / 1_000);
  const nanos = (date.getTime() % 1_000) * 1_000_000;
  return { seconds, nanos };
}

function fromTimestamp(t: Timestamp): Date {
  let millis = (t.seconds || 0) * 1_000;
  millis += (t.nanos || 0) / 1_000_000;
  return new globalThis.Date(millis);
}

function fromJsonTimestamp(o: any): Date {
  if (o instanceof globalThis.Date) {
    return o;
  } else if (typeof o === "string") {
    return new globalThis.Date(o);
  } else {
    return fromTimestamp(Timestamp.fromJSON(o));
  }
}

function longToNumber(long: Long): number {
  if (long.gt(globalThis.Number.MAX_SAFE_INTEGER)) {
    throw new globalThis.Error("Value is larger than Number.MAX_SAFE_INTEGER");
  }
  if (long.lt(globalThis.Number.MIN_SAFE_INTEGER)) {
    throw new globalThis.Error("Value is smaller than Number.MIN_SAFE_INTEGER");
  }
  return long.toNumber();
}

if (_m0.util.Long !== Long) {
  _m0.util.Long = Long as any;
  _m0.configure();
}

function isObject(value: any): boolean {
  return typeof value === "object" && value !== null;
}

function isSet(value: any): boolean {
  return value !== null && value !== undefined;
}
