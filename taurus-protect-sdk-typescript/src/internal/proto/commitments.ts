// Code generated by protoc-gen-ts_proto. DO NOT EDIT.
// versions:
//   protoc-gen-ts_proto  v1.181.2
//   protoc               v6.33.4
// source: tp_messages/commitments.proto

/* eslint-disable */
import Long from "long";
import _m0 from "protobufjs/minimal";

export const protobufPackage = "tp_messages";

export enum CommitmentKind {
  UTXO = 0,
  Account = 1,
  Algo = 2,
  ETHwrapped = 3,
  Icp = 4,
  Hash = 5,
  HederaTransactions = 6,
  UNRECOGNIZED = -1,
}

export function commitmentKindFromJSON(object: any): CommitmentKind {
  switch (object) {
    case 0:
    case "UTXO":
      return CommitmentKind.UTXO;
    case 1:
    case "Account":
      return CommitmentKind.Account;
    case 2:
    case "Algo":
      return CommitmentKind.Algo;
    case 3:
    case "ETHwrapped":
      return CommitmentKind.ETHwrapped;
    case 4:
    case "Icp":
      return CommitmentKind.Icp;
    case 5:
    case "Hash":
      return CommitmentKind.Hash;
    case 6:
    case "HederaTransactions":
      return CommitmentKind.HederaTransactions;
    case -1:
    case "UNRECOGNIZED":
    default:
      return CommitmentKind.UNRECOGNIZED;
  }
}

export function commitmentKindToJSON(object: CommitmentKind): string {
  switch (object) {
    case CommitmentKind.UTXO:
      return "UTXO";
    case CommitmentKind.Account:
      return "Account";
    case CommitmentKind.Algo:
      return "Algo";
    case CommitmentKind.ETHwrapped:
      return "ETHwrapped";
    case CommitmentKind.Icp:
      return "Icp";
    case CommitmentKind.Hash:
      return "Hash";
    case CommitmentKind.HederaTransactions:
      return "HederaTransactions";
    case CommitmentKind.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

/**
 * Is the commitment type for:
 * Avax,Cosmos,DOT,ETH,FTM,NEAR,Polygon,XLM,XRP,XTZ
 */
export interface AccountCommitment {
  /**
   * Strong binding to the committer
   * Different committers operate on different networks, and will refuse to sign data from another network.
   * This information is cross checked within the metadata
   * In itself, this isn't enough to prevent replays across networks, but combined with the chainId, it's enough.
   */
  network: string;
  /**
   * A generic chain identifier, used to distinguish between chain networks.
   * Avax,ETH,FTM,Polygon: the chain id
   * Cosmos: the chain id
   * DOT: the genesis hash
   * NEAR: a recent block hash
   * XLM: hash of the network passphrase
   * XRP: network ID
   * XTZ: a recent block hash
   */
  chainId: Uint8Array;
  bindings: AccountCommitment_AccountBinding[];
  blockchain: string;
}

export interface AccountCommitment_AccountBinding {
  address: string;
  nonce: Uint8Array;
  amount: Uint8Array;
}

/**
 * Is the commitment type for
 * ADA,BCH,BTC,LTC requests
 */
export interface UTXOCommitment {
  network: string;
  chainId: Uint8Array;
  bindings: UTXOCommitment_InputBinding[];
  blockchain: string;
}

/**
 * Inputs are very susceptible to being malleable
 * transfers from addresses/wallets can use any utxo for the address/wallet and lie about its amount (pay the excess in fees)
 * Outputs however, are not malleable in a useful way:
 * - changing the target destination results in a metadata mismatch
 * - changing the change destination results in either a correct request or a metadata mismatch
 * On the other hand, inputs of a transaction are enough to completely distinguish it
 * Making them ideal for commitments
 */
export interface UTXOCommitment_InputBinding {
  hash: Uint8Array;
  index: number;
  amount: Uint8Array;
}

/**
 * Algo commitments
 * The unicity constraint enforced on-chain is that two identical transactions cannot be mined,
 * and that two transactions cannot have the same (sender,lease) pair within their validity window (max 1000 blocks).
 * Algorand commitments bind on the lease and validity window of a transaction:
 * * the lease `lx` allows us to identify broadcasted transactions on the blockchain. It is globally unique and fixed in the metadata.
 * * the validity window `lv` determines when a commitment expires
 */
export interface AlgoCommitment {
  blockchain: string;
  network: string;
  /** ALGO genesis ID */
  chainId: string;
  bindings: AlgoCommitment_TxBinding[];
}

export interface AlgoCommitment_TxBinding {
  address: string;
  lx: Uint8Array;
  lv: number;
}

/**
 * ICP commitments
 * hash == hash(from, to, amount, fee, memo, created_at_time)
 *  or hash(from, amount, memo, created_at_time) for Burn and to instead of from for Mint.
 * Only 1 transaction with the same fields can pass
 */
export interface ICPCommitment {
  network: string;
  bindings: ICPCommitment_TxBinding[];
  blockchain: string;
}

export interface ICPCommitment_TxBinding {
  hash: string;
}

/**
 * "Wrapped" EVM commitment, for gasless transactions
 * Ignores the amount, binds to address and nonce, adds the forwarder address
 */
export interface ETHWrappedCommitment {
  network: string;
  bindings: ETHWrappedCommitment_Binding[];
  blockchain: string;
}

export interface ETHWrappedCommitment_Binding {
  address: string;
  nonce: Uint8Array;
}

/**
 * Hash commitments
 * Each tx is identified by its (pre-signature) tx hash
 */
export interface HashCommitment {
  blockchain: string;
  network: string;
  chainId: Uint8Array;
  bindings: HashCommitment_TxBinding[];
}

export interface HashCommitment_TxBinding {
  hash: Uint8Array;
  address: string;
}

/**
 * Hedera commitments
 * A special kind of account commitment, with no chain_id
 * The nonce is replaced by a timestamp
 */
export interface HederaCommitment {
  /**
   * The network is still used to strongly tie to a committer
   * but the lack of chain_id means the same commitment
   * can be used to generate transactions valid on multiple networks
   * Due to Hedera's structure,
   */
  network: string;
  bindings: HederaCommitment_HederaBinding[];
  blockchain: string;
}

/** Stutter because of swagger's weird namespacing..? */
export interface HederaCommitment_HederaTimestamp {
  seconds: number;
  nanos: number;
}

export interface HederaCommitment_HederaBinding {
  /**
   * Hedera addresses are represented as <shardnum>.<realmnum>.<accountid>
   * Where <accountid> has no relation to the key
   * This means given only an address, we cannot tie it to a public key
   * This explains the presence of the publicKey (compressed ECDSA) field in the binding
   */
  address: string;
  publicKey: Uint8Array;
  /** Hedera transactions by themselves don't have amounts */
  timestamp: HederaCommitment_HederaTimestamp | undefined;
}

function createBaseAccountCommitment(): AccountCommitment {
  return { network: "", chainId: new Uint8Array(0), bindings: [], blockchain: "" };
}

export const AccountCommitment = {
  encode(message: AccountCommitment, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.network !== "") {
      writer.uint32(10).string(message.network);
    }
    if (message.chainId.length !== 0) {
      writer.uint32(18).bytes(message.chainId);
    }
    for (const v of message.bindings) {
      AccountCommitment_AccountBinding.encode(v!, writer.uint32(26).fork()).ldelim();
    }
    if (message.blockchain !== "") {
      writer.uint32(34).string(message.blockchain);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): AccountCommitment {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseAccountCommitment();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.network = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.chainId = reader.bytes();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.bindings.push(AccountCommitment_AccountBinding.decode(reader, reader.uint32()));
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.blockchain = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): AccountCommitment {
    return {
      network: isSet(object.network) ? globalThis.String(object.network) : "",
      chainId: isSet(object.chainId) ? bytesFromBase64(object.chainId) : new Uint8Array(0),
      bindings: globalThis.Array.isArray(object?.bindings)
        ? object.bindings.map((e: any) => AccountCommitment_AccountBinding.fromJSON(e))
        : [],
      blockchain: isSet(object.blockchain) ? globalThis.String(object.blockchain) : "",
    };
  },

  toJSON(message: AccountCommitment): unknown {
    const obj: any = {};
    if (message.network !== "") {
      obj.network = message.network;
    }
    if (message.chainId.length !== 0) {
      obj.chainId = base64FromBytes(message.chainId);
    }
    if (message.bindings?.length) {
      obj.bindings = message.bindings.map((e) => AccountCommitment_AccountBinding.toJSON(e));
    }
    if (message.blockchain !== "") {
      obj.blockchain = message.blockchain;
    }
    return obj;
  },

  create(base?: DeepPartial<AccountCommitment>): AccountCommitment {
    return AccountCommitment.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<AccountCommitment>): AccountCommitment {
    const message = createBaseAccountCommitment();
    message.network = object.network ?? "";
    message.chainId = object.chainId ?? new Uint8Array(0);
    message.bindings = object.bindings?.map((e) => AccountCommitment_AccountBinding.fromPartial(e)) || [];
    message.blockchain = object.blockchain ?? "";
    return message;
  },
};

function createBaseAccountCommitment_AccountBinding(): AccountCommitment_AccountBinding {
  return { address: "", nonce: new Uint8Array(0), amount: new Uint8Array(0) };
}

export const AccountCommitment_AccountBinding = {
  encode(message: AccountCommitment_AccountBinding, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.address !== "") {
      writer.uint32(10).string(message.address);
    }
    if (message.nonce.length !== 0) {
      writer.uint32(18).bytes(message.nonce);
    }
    if (message.amount.length !== 0) {
      writer.uint32(26).bytes(message.amount);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): AccountCommitment_AccountBinding {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseAccountCommitment_AccountBinding();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.address = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.nonce = reader.bytes();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.amount = reader.bytes();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): AccountCommitment_AccountBinding {
    return {
      address: isSet(object.address) ? globalThis.String(object.address) : "",
      nonce: isSet(object.nonce) ? bytesFromBase64(object.nonce) : new Uint8Array(0),
      amount: isSet(object.amount) ? bytesFromBase64(object.amount) : new Uint8Array(0),
    };
  },

  toJSON(message: AccountCommitment_AccountBinding): unknown {
    const obj: any = {};
    if (message.address !== "") {
      obj.address = message.address;
    }
    if (message.nonce.length !== 0) {
      obj.nonce = base64FromBytes(message.nonce);
    }
    if (message.amount.length !== 0) {
      obj.amount = base64FromBytes(message.amount);
    }
    return obj;
  },

  create(base?: DeepPartial<AccountCommitment_AccountBinding>): AccountCommitment_AccountBinding {
    return AccountCommitment_AccountBinding.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<AccountCommitment_AccountBinding>): AccountCommitment_AccountBinding {
    const message = createBaseAccountCommitment_AccountBinding();
    message.address = object.address ?? "";
    message.nonce = object.nonce ?? new Uint8Array(0);
    message.amount = object.amount ?? new Uint8Array(0);
    return message;
  },
};

function createBaseUTXOCommitment(): UTXOCommitment {
  return { network: "", chainId: new Uint8Array(0), bindings: [], blockchain: "" };
}

export const UTXOCommitment = {
  encode(message: UTXOCommitment, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.network !== "") {
      writer.uint32(10).string(message.network);
    }
    if (message.chainId.length !== 0) {
      writer.uint32(18).bytes(message.chainId);
    }
    for (const v of message.bindings) {
      UTXOCommitment_InputBinding.encode(v!, writer.uint32(26).fork()).ldelim();
    }
    if (message.blockchain !== "") {
      writer.uint32(34).string(message.blockchain);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): UTXOCommitment {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseUTXOCommitment();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.network = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.chainId = reader.bytes();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.bindings.push(UTXOCommitment_InputBinding.decode(reader, reader.uint32()));
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.blockchain = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): UTXOCommitment {
    return {
      network: isSet(object.network) ? globalThis.String(object.network) : "",
      chainId: isSet(object.chainId) ? bytesFromBase64(object.chainId) : new Uint8Array(0),
      bindings: globalThis.Array.isArray(object?.bindings)
        ? object.bindings.map((e: any) => UTXOCommitment_InputBinding.fromJSON(e))
        : [],
      blockchain: isSet(object.blockchain) ? globalThis.String(object.blockchain) : "",
    };
  },

  toJSON(message: UTXOCommitment): unknown {
    const obj: any = {};
    if (message.network !== "") {
      obj.network = message.network;
    }
    if (message.chainId.length !== 0) {
      obj.chainId = base64FromBytes(message.chainId);
    }
    if (message.bindings?.length) {
      obj.bindings = message.bindings.map((e) => UTXOCommitment_InputBinding.toJSON(e));
    }
    if (message.blockchain !== "") {
      obj.blockchain = message.blockchain;
    }
    return obj;
  },

  create(base?: DeepPartial<UTXOCommitment>): UTXOCommitment {
    return UTXOCommitment.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<UTXOCommitment>): UTXOCommitment {
    const message = createBaseUTXOCommitment();
    message.network = object.network ?? "";
    message.chainId = object.chainId ?? new Uint8Array(0);
    message.bindings = object.bindings?.map((e) => UTXOCommitment_InputBinding.fromPartial(e)) || [];
    message.blockchain = object.blockchain ?? "";
    return message;
  },
};

function createBaseUTXOCommitment_InputBinding(): UTXOCommitment_InputBinding {
  return { hash: new Uint8Array(0), index: 0, amount: new Uint8Array(0) };
}

export const UTXOCommitment_InputBinding = {
  encode(message: UTXOCommitment_InputBinding, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.hash.length !== 0) {
      writer.uint32(10).bytes(message.hash);
    }
    if (message.index !== 0) {
      writer.uint32(16).uint64(message.index);
    }
    if (message.amount.length !== 0) {
      writer.uint32(26).bytes(message.amount);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): UTXOCommitment_InputBinding {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseUTXOCommitment_InputBinding();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.hash = reader.bytes();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.index = longToNumber(reader.uint64() as Long);
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.amount = reader.bytes();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): UTXOCommitment_InputBinding {
    return {
      hash: isSet(object.hash) ? bytesFromBase64(object.hash) : new Uint8Array(0),
      index: isSet(object.index) ? globalThis.Number(object.index) : 0,
      amount: isSet(object.amount) ? bytesFromBase64(object.amount) : new Uint8Array(0),
    };
  },

  toJSON(message: UTXOCommitment_InputBinding): unknown {
    const obj: any = {};
    if (message.hash.length !== 0) {
      obj.hash = base64FromBytes(message.hash);
    }
    if (message.index !== 0) {
      obj.index = Math.round(message.index);
    }
    if (message.amount.length !== 0) {
      obj.amount = base64FromBytes(message.amount);
    }
    return obj;
  },

  create(base?: DeepPartial<UTXOCommitment_InputBinding>): UTXOCommitment_InputBinding {
    return UTXOCommitment_InputBinding.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<UTXOCommitment_InputBinding>): UTXOCommitment_InputBinding {
    const message = createBaseUTXOCommitment_InputBinding();
    message.hash = object.hash ?? new Uint8Array(0);
    message.index = object.index ?? 0;
    message.amount = object.amount ?? new Uint8Array(0);
    return message;
  },
};

function createBaseAlgoCommitment(): AlgoCommitment {
  return { blockchain: "", network: "", chainId: "", bindings: [] };
}

export const AlgoCommitment = {
  encode(message: AlgoCommitment, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.blockchain !== "") {
      writer.uint32(10).string(message.blockchain);
    }
    if (message.network !== "") {
      writer.uint32(18).string(message.network);
    }
    if (message.chainId !== "") {
      writer.uint32(26).string(message.chainId);
    }
    for (const v of message.bindings) {
      AlgoCommitment_TxBinding.encode(v!, writer.uint32(34).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): AlgoCommitment {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseAlgoCommitment();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.blockchain = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.network = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.chainId = reader.string();
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.bindings.push(AlgoCommitment_TxBinding.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): AlgoCommitment {
    return {
      blockchain: isSet(object.blockchain) ? globalThis.String(object.blockchain) : "",
      network: isSet(object.network) ? globalThis.String(object.network) : "",
      chainId: isSet(object.chainId) ? globalThis.String(object.chainId) : "",
      bindings: globalThis.Array.isArray(object?.bindings)
        ? object.bindings.map((e: any) => AlgoCommitment_TxBinding.fromJSON(e))
        : [],
    };
  },

  toJSON(message: AlgoCommitment): unknown {
    const obj: any = {};
    if (message.blockchain !== "") {
      obj.blockchain = message.blockchain;
    }
    if (message.network !== "") {
      obj.network = message.network;
    }
    if (message.chainId !== "") {
      obj.chainId = message.chainId;
    }
    if (message.bindings?.length) {
      obj.bindings = message.bindings.map((e) => AlgoCommitment_TxBinding.toJSON(e));
    }
    return obj;
  },

  create(base?: DeepPartial<AlgoCommitment>): AlgoCommitment {
    return AlgoCommitment.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<AlgoCommitment>): AlgoCommitment {
    const message = createBaseAlgoCommitment();
    message.blockchain = object.blockchain ?? "";
    message.network = object.network ?? "";
    message.chainId = object.chainId ?? "";
    message.bindings = object.bindings?.map((e) => AlgoCommitment_TxBinding.fromPartial(e)) || [];
    return message;
  },
};

function createBaseAlgoCommitment_TxBinding(): AlgoCommitment_TxBinding {
  return { address: "", lx: new Uint8Array(0), lv: 0 };
}

export const AlgoCommitment_TxBinding = {
  encode(message: AlgoCommitment_TxBinding, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.address !== "") {
      writer.uint32(10).string(message.address);
    }
    if (message.lx.length !== 0) {
      writer.uint32(18).bytes(message.lx);
    }
    if (message.lv !== 0) {
      writer.uint32(24).uint64(message.lv);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): AlgoCommitment_TxBinding {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseAlgoCommitment_TxBinding();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.address = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.lx = reader.bytes();
          continue;
        case 3:
          if (tag !== 24) {
            break;
          }

          message.lv = longToNumber(reader.uint64() as Long);
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): AlgoCommitment_TxBinding {
    return {
      address: isSet(object.address) ? globalThis.String(object.address) : "",
      lx: isSet(object.lx) ? bytesFromBase64(object.lx) : new Uint8Array(0),
      lv: isSet(object.lv) ? globalThis.Number(object.lv) : 0,
    };
  },

  toJSON(message: AlgoCommitment_TxBinding): unknown {
    const obj: any = {};
    if (message.address !== "") {
      obj.address = message.address;
    }
    if (message.lx.length !== 0) {
      obj.lx = base64FromBytes(message.lx);
    }
    if (message.lv !== 0) {
      obj.lv = Math.round(message.lv);
    }
    return obj;
  },

  create(base?: DeepPartial<AlgoCommitment_TxBinding>): AlgoCommitment_TxBinding {
    return AlgoCommitment_TxBinding.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<AlgoCommitment_TxBinding>): AlgoCommitment_TxBinding {
    const message = createBaseAlgoCommitment_TxBinding();
    message.address = object.address ?? "";
    message.lx = object.lx ?? new Uint8Array(0);
    message.lv = object.lv ?? 0;
    return message;
  },
};

function createBaseICPCommitment(): ICPCommitment {
  return { network: "", bindings: [], blockchain: "" };
}

export const ICPCommitment = {
  encode(message: ICPCommitment, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.network !== "") {
      writer.uint32(10).string(message.network);
    }
    for (const v of message.bindings) {
      ICPCommitment_TxBinding.encode(v!, writer.uint32(18).fork()).ldelim();
    }
    if (message.blockchain !== "") {
      writer.uint32(26).string(message.blockchain);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): ICPCommitment {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseICPCommitment();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.network = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.bindings.push(ICPCommitment_TxBinding.decode(reader, reader.uint32()));
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.blockchain = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ICPCommitment {
    return {
      network: isSet(object.network) ? globalThis.String(object.network) : "",
      bindings: globalThis.Array.isArray(object?.bindings)
        ? object.bindings.map((e: any) => ICPCommitment_TxBinding.fromJSON(e))
        : [],
      blockchain: isSet(object.blockchain) ? globalThis.String(object.blockchain) : "",
    };
  },

  toJSON(message: ICPCommitment): unknown {
    const obj: any = {};
    if (message.network !== "") {
      obj.network = message.network;
    }
    if (message.bindings?.length) {
      obj.bindings = message.bindings.map((e) => ICPCommitment_TxBinding.toJSON(e));
    }
    if (message.blockchain !== "") {
      obj.blockchain = message.blockchain;
    }
    return obj;
  },

  create(base?: DeepPartial<ICPCommitment>): ICPCommitment {
    return ICPCommitment.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ICPCommitment>): ICPCommitment {
    const message = createBaseICPCommitment();
    message.network = object.network ?? "";
    message.bindings = object.bindings?.map((e) => ICPCommitment_TxBinding.fromPartial(e)) || [];
    message.blockchain = object.blockchain ?? "";
    return message;
  },
};

function createBaseICPCommitment_TxBinding(): ICPCommitment_TxBinding {
  return { hash: "" };
}

export const ICPCommitment_TxBinding = {
  encode(message: ICPCommitment_TxBinding, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.hash !== "") {
      writer.uint32(10).string(message.hash);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): ICPCommitment_TxBinding {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseICPCommitment_TxBinding();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.hash = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ICPCommitment_TxBinding {
    return { hash: isSet(object.hash) ? globalThis.String(object.hash) : "" };
  },

  toJSON(message: ICPCommitment_TxBinding): unknown {
    const obj: any = {};
    if (message.hash !== "") {
      obj.hash = message.hash;
    }
    return obj;
  },

  create(base?: DeepPartial<ICPCommitment_TxBinding>): ICPCommitment_TxBinding {
    return ICPCommitment_TxBinding.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ICPCommitment_TxBinding>): ICPCommitment_TxBinding {
    const message = createBaseICPCommitment_TxBinding();
    message.hash = object.hash ?? "";
    return message;
  },
};

function createBaseETHWrappedCommitment(): ETHWrappedCommitment {
  return { network: "", bindings: [], blockchain: "" };
}

export const ETHWrappedCommitment = {
  encode(message: ETHWrappedCommitment, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.network !== "") {
      writer.uint32(10).string(message.network);
    }
    for (const v of message.bindings) {
      ETHWrappedCommitment_Binding.encode(v!, writer.uint32(34).fork()).ldelim();
    }
    if (message.blockchain !== "") {
      writer.uint32(42).string(message.blockchain);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): ETHWrappedCommitment {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseETHWrappedCommitment();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.network = reader.string();
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.bindings.push(ETHWrappedCommitment_Binding.decode(reader, reader.uint32()));
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.blockchain = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ETHWrappedCommitment {
    return {
      network: isSet(object.network) ? globalThis.String(object.network) : "",
      bindings: globalThis.Array.isArray(object?.bindings)
        ? object.bindings.map((e: any) => ETHWrappedCommitment_Binding.fromJSON(e))
        : [],
      blockchain: isSet(object.blockchain) ? globalThis.String(object.blockchain) : "",
    };
  },

  toJSON(message: ETHWrappedCommitment): unknown {
    const obj: any = {};
    if (message.network !== "") {
      obj.network = message.network;
    }
    if (message.bindings?.length) {
      obj.bindings = message.bindings.map((e) => ETHWrappedCommitment_Binding.toJSON(e));
    }
    if (message.blockchain !== "") {
      obj.blockchain = message.blockchain;
    }
    return obj;
  },

  create(base?: DeepPartial<ETHWrappedCommitment>): ETHWrappedCommitment {
    return ETHWrappedCommitment.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ETHWrappedCommitment>): ETHWrappedCommitment {
    const message = createBaseETHWrappedCommitment();
    message.network = object.network ?? "";
    message.bindings = object.bindings?.map((e) => ETHWrappedCommitment_Binding.fromPartial(e)) || [];
    message.blockchain = object.blockchain ?? "";
    return message;
  },
};

function createBaseETHWrappedCommitment_Binding(): ETHWrappedCommitment_Binding {
  return { address: "", nonce: new Uint8Array(0) };
}

export const ETHWrappedCommitment_Binding = {
  encode(message: ETHWrappedCommitment_Binding, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.address !== "") {
      writer.uint32(10).string(message.address);
    }
    if (message.nonce.length !== 0) {
      writer.uint32(18).bytes(message.nonce);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): ETHWrappedCommitment_Binding {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseETHWrappedCommitment_Binding();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.address = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.nonce = reader.bytes();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ETHWrappedCommitment_Binding {
    return {
      address: isSet(object.address) ? globalThis.String(object.address) : "",
      nonce: isSet(object.nonce) ? bytesFromBase64(object.nonce) : new Uint8Array(0),
    };
  },

  toJSON(message: ETHWrappedCommitment_Binding): unknown {
    const obj: any = {};
    if (message.address !== "") {
      obj.address = message.address;
    }
    if (message.nonce.length !== 0) {
      obj.nonce = base64FromBytes(message.nonce);
    }
    return obj;
  },

  create(base?: DeepPartial<ETHWrappedCommitment_Binding>): ETHWrappedCommitment_Binding {
    return ETHWrappedCommitment_Binding.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ETHWrappedCommitment_Binding>): ETHWrappedCommitment_Binding {
    const message = createBaseETHWrappedCommitment_Binding();
    message.address = object.address ?? "";
    message.nonce = object.nonce ?? new Uint8Array(0);
    return message;
  },
};

function createBaseHashCommitment(): HashCommitment {
  return { blockchain: "", network: "", chainId: new Uint8Array(0), bindings: [] };
}

export const HashCommitment = {
  encode(message: HashCommitment, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.blockchain !== "") {
      writer.uint32(10).string(message.blockchain);
    }
    if (message.network !== "") {
      writer.uint32(18).string(message.network);
    }
    if (message.chainId.length !== 0) {
      writer.uint32(26).bytes(message.chainId);
    }
    for (const v of message.bindings) {
      HashCommitment_TxBinding.encode(v!, writer.uint32(34).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): HashCommitment {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseHashCommitment();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.blockchain = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.network = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.chainId = reader.bytes();
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.bindings.push(HashCommitment_TxBinding.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): HashCommitment {
    return {
      blockchain: isSet(object.blockchain) ? globalThis.String(object.blockchain) : "",
      network: isSet(object.network) ? globalThis.String(object.network) : "",
      chainId: isSet(object.chainId) ? bytesFromBase64(object.chainId) : new Uint8Array(0),
      bindings: globalThis.Array.isArray(object?.bindings)
        ? object.bindings.map((e: any) => HashCommitment_TxBinding.fromJSON(e))
        : [],
    };
  },

  toJSON(message: HashCommitment): unknown {
    const obj: any = {};
    if (message.blockchain !== "") {
      obj.blockchain = message.blockchain;
    }
    if (message.network !== "") {
      obj.network = message.network;
    }
    if (message.chainId.length !== 0) {
      obj.chainId = base64FromBytes(message.chainId);
    }
    if (message.bindings?.length) {
      obj.bindings = message.bindings.map((e) => HashCommitment_TxBinding.toJSON(e));
    }
    return obj;
  },

  create(base?: DeepPartial<HashCommitment>): HashCommitment {
    return HashCommitment.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<HashCommitment>): HashCommitment {
    const message = createBaseHashCommitment();
    message.blockchain = object.blockchain ?? "";
    message.network = object.network ?? "";
    message.chainId = object.chainId ?? new Uint8Array(0);
    message.bindings = object.bindings?.map((e) => HashCommitment_TxBinding.fromPartial(e)) || [];
    return message;
  },
};

function createBaseHashCommitment_TxBinding(): HashCommitment_TxBinding {
  return { hash: new Uint8Array(0), address: "" };
}

export const HashCommitment_TxBinding = {
  encode(message: HashCommitment_TxBinding, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.hash.length !== 0) {
      writer.uint32(10).bytes(message.hash);
    }
    if (message.address !== "") {
      writer.uint32(18).string(message.address);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): HashCommitment_TxBinding {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseHashCommitment_TxBinding();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.hash = reader.bytes();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.address = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): HashCommitment_TxBinding {
    return {
      hash: isSet(object.hash) ? bytesFromBase64(object.hash) : new Uint8Array(0),
      address: isSet(object.address) ? globalThis.String(object.address) : "",
    };
  },

  toJSON(message: HashCommitment_TxBinding): unknown {
    const obj: any = {};
    if (message.hash.length !== 0) {
      obj.hash = base64FromBytes(message.hash);
    }
    if (message.address !== "") {
      obj.address = message.address;
    }
    return obj;
  },

  create(base?: DeepPartial<HashCommitment_TxBinding>): HashCommitment_TxBinding {
    return HashCommitment_TxBinding.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<HashCommitment_TxBinding>): HashCommitment_TxBinding {
    const message = createBaseHashCommitment_TxBinding();
    message.hash = object.hash ?? new Uint8Array(0);
    message.address = object.address ?? "";
    return message;
  },
};

function createBaseHederaCommitment(): HederaCommitment {
  return { network: "", bindings: [], blockchain: "" };
}

export const HederaCommitment = {
  encode(message: HederaCommitment, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.network !== "") {
      writer.uint32(10).string(message.network);
    }
    for (const v of message.bindings) {
      HederaCommitment_HederaBinding.encode(v!, writer.uint32(26).fork()).ldelim();
    }
    if (message.blockchain !== "") {
      writer.uint32(34).string(message.blockchain);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): HederaCommitment {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseHederaCommitment();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.network = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.bindings.push(HederaCommitment_HederaBinding.decode(reader, reader.uint32()));
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.blockchain = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): HederaCommitment {
    return {
      network: isSet(object.network) ? globalThis.String(object.network) : "",
      bindings: globalThis.Array.isArray(object?.bindings)
        ? object.bindings.map((e: any) => HederaCommitment_HederaBinding.fromJSON(e))
        : [],
      blockchain: isSet(object.blockchain) ? globalThis.String(object.blockchain) : "",
    };
  },

  toJSON(message: HederaCommitment): unknown {
    const obj: any = {};
    if (message.network !== "") {
      obj.network = message.network;
    }
    if (message.bindings?.length) {
      obj.bindings = message.bindings.map((e) => HederaCommitment_HederaBinding.toJSON(e));
    }
    if (message.blockchain !== "") {
      obj.blockchain = message.blockchain;
    }
    return obj;
  },

  create(base?: DeepPartial<HederaCommitment>): HederaCommitment {
    return HederaCommitment.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<HederaCommitment>): HederaCommitment {
    const message = createBaseHederaCommitment();
    message.network = object.network ?? "";
    message.bindings = object.bindings?.map((e) => HederaCommitment_HederaBinding.fromPartial(e)) || [];
    message.blockchain = object.blockchain ?? "";
    return message;
  },
};

function createBaseHederaCommitment_HederaTimestamp(): HederaCommitment_HederaTimestamp {
  return { seconds: 0, nanos: 0 };
}

export const HederaCommitment_HederaTimestamp = {
  encode(message: HederaCommitment_HederaTimestamp, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.seconds !== 0) {
      writer.uint32(8).uint64(message.seconds);
    }
    if (message.nanos !== 0) {
      writer.uint32(16).uint64(message.nanos);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): HederaCommitment_HederaTimestamp {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseHederaCommitment_HederaTimestamp();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.seconds = longToNumber(reader.uint64() as Long);
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.nanos = longToNumber(reader.uint64() as Long);
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): HederaCommitment_HederaTimestamp {
    return {
      seconds: isSet(object.seconds) ? globalThis.Number(object.seconds) : 0,
      nanos: isSet(object.nanos) ? globalThis.Number(object.nanos) : 0,
    };
  },

  toJSON(message: HederaCommitment_HederaTimestamp): unknown {
    const obj: any = {};
    if (message.seconds !== 0) {
      obj.seconds = Math.round(message.seconds);
    }
    if (message.nanos !== 0) {
      obj.nanos = Math.round(message.nanos);
    }
    return obj;
  },

  create(base?: DeepPartial<HederaCommitment_HederaTimestamp>): HederaCommitment_HederaTimestamp {
    return HederaCommitment_HederaTimestamp.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<HederaCommitment_HederaTimestamp>): HederaCommitment_HederaTimestamp {
    const message = createBaseHederaCommitment_HederaTimestamp();
    message.seconds = object.seconds ?? 0;
    message.nanos = object.nanos ?? 0;
    return message;
  },
};

function createBaseHederaCommitment_HederaBinding(): HederaCommitment_HederaBinding {
  return { address: "", publicKey: new Uint8Array(0), timestamp: undefined };
}

export const HederaCommitment_HederaBinding = {
  encode(message: HederaCommitment_HederaBinding, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.address !== "") {
      writer.uint32(10).string(message.address);
    }
    if (message.publicKey.length !== 0) {
      writer.uint32(18).bytes(message.publicKey);
    }
    if (message.timestamp !== undefined) {
      HederaCommitment_HederaTimestamp.encode(message.timestamp, writer.uint32(26).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): HederaCommitment_HederaBinding {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseHederaCommitment_HederaBinding();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.address = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.publicKey = reader.bytes();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.timestamp = HederaCommitment_HederaTimestamp.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): HederaCommitment_HederaBinding {
    return {
      address: isSet(object.address) ? globalThis.String(object.address) : "",
      publicKey: isSet(object.publicKey) ? bytesFromBase64(object.publicKey) : new Uint8Array(0),
      timestamp: isSet(object.timestamp) ? HederaCommitment_HederaTimestamp.fromJSON(object.timestamp) : undefined,
    };
  },

  toJSON(message: HederaCommitment_HederaBinding): unknown {
    const obj: any = {};
    if (message.address !== "") {
      obj.address = message.address;
    }
    if (message.publicKey.length !== 0) {
      obj.publicKey = base64FromBytes(message.publicKey);
    }
    if (message.timestamp !== undefined) {
      obj.timestamp = HederaCommitment_HederaTimestamp.toJSON(message.timestamp);
    }
    return obj;
  },

  create(base?: DeepPartial<HederaCommitment_HederaBinding>): HederaCommitment_HederaBinding {
    return HederaCommitment_HederaBinding.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<HederaCommitment_HederaBinding>): HederaCommitment_HederaBinding {
    const message = createBaseHederaCommitment_HederaBinding();
    message.address = object.address ?? "";
    message.publicKey = object.publicKey ?? new Uint8Array(0);
    message.timestamp = (object.timestamp !== undefined && object.timestamp !== null)
      ? HederaCommitment_HederaTimestamp.fromPartial(object.timestamp)
      : undefined;
    return message;
  },
};

function bytesFromBase64(b64: string): Uint8Array {
  const bin = globalThis.atob(b64);
  const arr = new Uint8Array(bin.length);
  for (let i = 0; i < bin.length; ++i) {
    arr[i] = bin.charCodeAt(i);
  }
  return arr;
}

function base64FromBytes(arr: Uint8Array): string {
  const bin: string[] = [];
  arr.forEach((byte) => {
    bin.push(globalThis.String.fromCharCode(byte));
  });
  return globalThis.btoa(bin.join(""));
}

type Builtin = Date | Function | Uint8Array | string | number | boolean | undefined;

export type DeepPartial<T> = T extends Builtin ? T
  : T extends globalThis.Array<infer U> ? globalThis.Array<DeepPartial<U>>
  : T extends ReadonlyArray<infer U> ? ReadonlyArray<DeepPartial<U>>
  : T extends {} ? { [K in keyof T]?: DeepPartial<T[K]> }
  : Partial<T>;

function longToNumber(long: Long): number {
  if (long.gt(globalThis.Number.MAX_SAFE_INTEGER)) {
    throw new globalThis.Error("Value is larger than Number.MAX_SAFE_INTEGER");
  }
  if (long.lt(globalThis.Number.MIN_SAFE_INTEGER)) {
    throw new globalThis.Error("Value is smaller than Number.MIN_SAFE_INTEGER");
  }
  return long.toNumber();
}

if (_m0.util.Long !== Long) {
  _m0.util.Long = Long as any;
  _m0.configure();
}

function isSet(value: any): boolean {
  return value !== null && value !== undefined;
}
