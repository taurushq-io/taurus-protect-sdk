/*
Taurus-PROTECT APIs

Taurus-PROTECT APIs description

API version: 1.0
*/

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package openapi

import (
	"bytes"
	"context"
	"io"
	"net/http"
	"net/url"
	"strings"
	"time"
	"reflect"
)


// TransactionsAPIService TransactionsAPI service
type TransactionsAPIService service

type ApiTransactionServiceExportTransactionTravelRuleRequest struct {
	ctx context.Context
	ApiService *TransactionsAPIService
	transactionID string
	format *string
}

// Desired output format, can be json or iso20022_pacs008_xml.
func (r ApiTransactionServiceExportTransactionTravelRuleRequest) Format(format string) ApiTransactionServiceExportTransactionTravelRuleRequest {
	r.format = &format
	return r
}

func (r ApiTransactionServiceExportTransactionTravelRuleRequest) Execute() (*TgvalidatordExportTransactionTravelRuleReply, *http.Response, error) {
	return r.ApiService.TransactionServiceExportTransactionTravelRuleExecute(r)
}

/*
TransactionServiceExportTransactionTravelRule Export the travel rule data of a transaction

This endpoint exports the formatted travel rule data of a transaction if there are any.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param transactionID
 @return ApiTransactionServiceExportTransactionTravelRuleRequest
*/
func (a *TransactionsAPIService) TransactionServiceExportTransactionTravelRule(ctx context.Context, transactionID string) ApiTransactionServiceExportTransactionTravelRuleRequest {
	return ApiTransactionServiceExportTransactionTravelRuleRequest{
		ApiService: a,
		ctx: ctx,
		transactionID: transactionID,
	}
}

// Execute executes the request
//  @return TgvalidatordExportTransactionTravelRuleReply
func (a *TransactionsAPIService) TransactionServiceExportTransactionTravelRuleExecute(r ApiTransactionServiceExportTransactionTravelRuleRequest) (*TgvalidatordExportTransactionTravelRuleReply, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *TgvalidatordExportTransactionTravelRuleReply
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "TransactionsAPIService.TransactionServiceExportTransactionTravelRule")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/rest/v1/transactions/{transactionID}/travelrule/export"
	localVarPath = strings.Replace(localVarPath, "{"+"transactionID"+"}", url.PathEscape(parameterValueToString(r.transactionID, "transactionID")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.format != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "format", r.format, "", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["ApiKeyTPV1"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v map[string]interface{}
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v map[string]interface{}
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v map[string]interface{}
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v map[string]interface{}
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v map[string]interface{}
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 503 {
			var v map[string]interface{}
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
			var v GooglerpcStatus
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiTransactionServiceExportTransactionsRequest struct {
	ctx context.Context
	ApiService *TransactionsAPIService
	currency *string
	direction *string
	query *string
	limit *string
	offset *string
	from *time.Time
	to *time.Time
	transactionIds *[]string
	format *string
	type_ *string
	source *string
	destination *string
	ids *[]string
	blockchain *string
	network *string
	fromBlockNumber *string
	toBlockNumber *string
	amountAbove *string
	excludeUnknownSourceDestination *bool
	hashes *[]string
	address *string
}

// Filter on ID or symbol of the currency
func (r ApiTransactionServiceExportTransactionsRequest) Currency(currency string) ApiTransactionServiceExportTransactionsRequest {
	r.currency = &currency
	return r
}

func (r ApiTransactionServiceExportTransactionsRequest) Direction(direction string) ApiTransactionServiceExportTransactionsRequest {
	r.direction = &direction
	return r
}

func (r ApiTransactionServiceExportTransactionsRequest) Query(query string) ApiTransactionServiceExportTransactionsRequest {
	r.query = &query
	return r
}

func (r ApiTransactionServiceExportTransactionsRequest) Limit(limit string) ApiTransactionServiceExportTransactionsRequest {
	r.limit = &limit
	return r
}

func (r ApiTransactionServiceExportTransactionsRequest) Offset(offset string) ApiTransactionServiceExportTransactionsRequest {
	r.offset = &offset
	return r
}

func (r ApiTransactionServiceExportTransactionsRequest) From(from time.Time) ApiTransactionServiceExportTransactionsRequest {
	r.from = &from
	return r
}

func (r ApiTransactionServiceExportTransactionsRequest) To(to time.Time) ApiTransactionServiceExportTransactionsRequest {
	r.to = &to
	return r
}

func (r ApiTransactionServiceExportTransactionsRequest) TransactionIds(transactionIds []string) ApiTransactionServiceExportTransactionsRequest {
	r.transactionIds = &transactionIds
	return r
}

// Desired file format, can be json, csv or csv_simple.
func (r ApiTransactionServiceExportTransactionsRequest) Format(format string) ApiTransactionServiceExportTransactionsRequest {
	r.format = &format
	return r
}

func (r ApiTransactionServiceExportTransactionsRequest) Type_(type_ string) ApiTransactionServiceExportTransactionsRequest {
	r.type_ = &type_
	return r
}

// Returns only transaction that have this address as a source
func (r ApiTransactionServiceExportTransactionsRequest) Source(source string) ApiTransactionServiceExportTransactionsRequest {
	r.source = &source
	return r
}

// Returns only transaction that have this address as a destination
func (r ApiTransactionServiceExportTransactionsRequest) Destination(destination string) ApiTransactionServiceExportTransactionsRequest {
	r.destination = &destination
	return r
}

// Filter on Protect transaction ID, as visible in the transaction objects.
func (r ApiTransactionServiceExportTransactionsRequest) Ids(ids []string) ApiTransactionServiceExportTransactionsRequest {
	r.ids = &ids
	return r
}

func (r ApiTransactionServiceExportTransactionsRequest) Blockchain(blockchain string) ApiTransactionServiceExportTransactionsRequest {
	r.blockchain = &blockchain
	return r
}

func (r ApiTransactionServiceExportTransactionsRequest) Network(network string) ApiTransactionServiceExportTransactionsRequest {
	r.network = &network
	return r
}

func (r ApiTransactionServiceExportTransactionsRequest) FromBlockNumber(fromBlockNumber string) ApiTransactionServiceExportTransactionsRequest {
	r.fromBlockNumber = &fromBlockNumber
	return r
}

func (r ApiTransactionServiceExportTransactionsRequest) ToBlockNumber(toBlockNumber string) ApiTransactionServiceExportTransactionsRequest {
	r.toBlockNumber = &toBlockNumber
	return r
}

// Returns only transactions with an amount strictly above the given amount
func (r ApiTransactionServiceExportTransactionsRequest) AmountAbove(amountAbove string) ApiTransactionServiceExportTransactionsRequest {
	r.amountAbove = &amountAbove
	return r
}

// Returns only transactions with a known source and destination, default false
func (r ApiTransactionServiceExportTransactionsRequest) ExcludeUnknownSourceDestination(excludeUnknownSourceDestination bool) ApiTransactionServiceExportTransactionsRequest {
	r.excludeUnknownSourceDestination = &excludeUnknownSourceDestination
	return r
}

// Filter on transaction hash, as visible in the transaction objects.
func (r ApiTransactionServiceExportTransactionsRequest) Hashes(hashes []string) ApiTransactionServiceExportTransactionsRequest {
	r.hashes = &hashes
	return r
}

// Returns only transaction that have this address as either a source or a destination
func (r ApiTransactionServiceExportTransactionsRequest) Address(address string) ApiTransactionServiceExportTransactionsRequest {
	r.address = &address
	return r
}

func (r ApiTransactionServiceExportTransactionsRequest) Execute() (*TgvalidatordExportTransactionsReply, *http.Response, error) {
	return r.ApiService.TransactionServiceExportTransactionsExecute(r)
}

/*
TransactionServiceExportTransactions Export transactions

This endpoint exports a list of transactions

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiTransactionServiceExportTransactionsRequest
*/
func (a *TransactionsAPIService) TransactionServiceExportTransactions(ctx context.Context) ApiTransactionServiceExportTransactionsRequest {
	return ApiTransactionServiceExportTransactionsRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return TgvalidatordExportTransactionsReply
func (a *TransactionsAPIService) TransactionServiceExportTransactionsExecute(r ApiTransactionServiceExportTransactionsRequest) (*TgvalidatordExportTransactionsReply, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *TgvalidatordExportTransactionsReply
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "TransactionsAPIService.TransactionServiceExportTransactions")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/rest/v1/transactions/export"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.currency != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "currency", r.currency, "", "")
	}
	if r.direction != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "direction", r.direction, "", "")
	}
	if r.query != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "query", r.query, "", "")
	}
	if r.limit != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "limit", r.limit, "", "")
	}
	if r.offset != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "offset", r.offset, "", "")
	}
	if r.from != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "from", r.from, "", "")
	}
	if r.to != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "to", r.to, "", "")
	}
	if r.transactionIds != nil {
		t := *r.transactionIds
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "transactionIds", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "transactionIds", t, "form", "multi")
		}
	}
	if r.format != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "format", r.format, "", "")
	}
	if r.type_ != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "type", r.type_, "", "")
	}
	if r.source != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "source", r.source, "", "")
	}
	if r.destination != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "destination", r.destination, "", "")
	}
	if r.ids != nil {
		t := *r.ids
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "ids", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "ids", t, "form", "multi")
		}
	}
	if r.blockchain != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "blockchain", r.blockchain, "", "")
	}
	if r.network != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "network", r.network, "", "")
	}
	if r.fromBlockNumber != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "fromBlockNumber", r.fromBlockNumber, "", "")
	}
	if r.toBlockNumber != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "toBlockNumber", r.toBlockNumber, "", "")
	}
	if r.amountAbove != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "amountAbove", r.amountAbove, "", "")
	}
	if r.excludeUnknownSourceDestination != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "excludeUnknownSourceDestination", r.excludeUnknownSourceDestination, "", "")
	}
	if r.hashes != nil {
		t := *r.hashes
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "hashes", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "hashes", t, "form", "multi")
		}
	}
	if r.address != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "address", r.address, "", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["ApiKeyTPV1"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v map[string]interface{}
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v map[string]interface{}
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v map[string]interface{}
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v map[string]interface{}
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v map[string]interface{}
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 503 {
			var v map[string]interface{}
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
			var v GooglerpcStatus
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiTransactionServiceGetTransactionsRequest struct {
	ctx context.Context
	ApiService *TransactionsAPIService
	currency *string
	direction *string
	query *string
	limit *string
	offset *string
	from *time.Time
	to *time.Time
	transactionIds *[]string
	type_ *string
	source *string
	destination *string
	ids *[]string
	blockchain *string
	network *string
	fromBlockNumber *string
	toBlockNumber *string
	hashes *[]string
	address *string
	amountAbove *string
	excludeUnknownSourceDestination *bool
	customerId *string
}

// Filter on ID or symbol of the currency
func (r ApiTransactionServiceGetTransactionsRequest) Currency(currency string) ApiTransactionServiceGetTransactionsRequest {
	r.currency = &currency
	return r
}

// The direction of the transaction (e.g. &#x60;incoming&#x60;, &#x60;outgoing&#x60;)
func (r ApiTransactionServiceGetTransactionsRequest) Direction(direction string) ApiTransactionServiceGetTransactionsRequest {
	r.direction = &direction
	return r
}

// Filter by query string in any of the fields address, customerid, transactionid, hash, type.
func (r ApiTransactionServiceGetTransactionsRequest) Query(query string) ApiTransactionServiceGetTransactionsRequest {
	r.query = &query
	return r
}

// The amount of transactions returned per request. Max 100.
func (r ApiTransactionServiceGetTransactionsRequest) Limit(limit string) ApiTransactionServiceGetTransactionsRequest {
	r.limit = &limit
	return r
}

// The offset from which to begin selection of transactions.
func (r ApiTransactionServiceGetTransactionsRequest) Offset(offset string) ApiTransactionServiceGetTransactionsRequest {
	r.offset = &offset
	return r
}

// Only return transactions from after this timestamp.
func (r ApiTransactionServiceGetTransactionsRequest) From(from time.Time) ApiTransactionServiceGetTransactionsRequest {
	r.from = &from
	return r
}

// Only return transactions from before this timestamp.
func (r ApiTransactionServiceGetTransactionsRequest) To(to time.Time) ApiTransactionServiceGetTransactionsRequest {
	r.to = &to
	return r
}

// Filter on Protect internal transactionID. This is purely internal and should rarely be used by clients
func (r ApiTransactionServiceGetTransactionsRequest) TransactionIds(transactionIds []string) ApiTransactionServiceGetTransactionsRequest {
	r.transactionIds = &transactionIds
	return r
}

// The type of transactions to fetch (e.g. &#x60;burn&#x60;).
func (r ApiTransactionServiceGetTransactionsRequest) Type_(type_ string) ApiTransactionServiceGetTransactionsRequest {
	r.type_ = &type_
	return r
}

// Returns only transaction that have this address as a source
func (r ApiTransactionServiceGetTransactionsRequest) Source(source string) ApiTransactionServiceGetTransactionsRequest {
	r.source = &source
	return r
}

// Returns only transaction that have this address as a destination
func (r ApiTransactionServiceGetTransactionsRequest) Destination(destination string) ApiTransactionServiceGetTransactionsRequest {
	r.destination = &destination
	return r
}

// Filter on Protect transaction ID, as visible in the transaction objects.
func (r ApiTransactionServiceGetTransactionsRequest) Ids(ids []string) ApiTransactionServiceGetTransactionsRequest {
	r.ids = &ids
	return r
}

// The blockchain associated with the transactions (e.g. &#x60;ETH&#x60;, &#x60;BTC&#x60;)
func (r ApiTransactionServiceGetTransactionsRequest) Blockchain(blockchain string) ApiTransactionServiceGetTransactionsRequest {
	r.blockchain = &blockchain
	return r
}

// The network the transaction took place in (e.g. &#x60;mainnet&#x60;, &#x60;testnet&#x60;).
func (r ApiTransactionServiceGetTransactionsRequest) Network(network string) ApiTransactionServiceGetTransactionsRequest {
	r.network = &network
	return r
}

// Only return transactions from after this block.
func (r ApiTransactionServiceGetTransactionsRequest) FromBlockNumber(fromBlockNumber string) ApiTransactionServiceGetTransactionsRequest {
	r.fromBlockNumber = &fromBlockNumber
	return r
}

// Only return transactions from before this block.
func (r ApiTransactionServiceGetTransactionsRequest) ToBlockNumber(toBlockNumber string) ApiTransactionServiceGetTransactionsRequest {
	r.toBlockNumber = &toBlockNumber
	return r
}

// Filter on transaction hash, as visible in the transaction objects.
func (r ApiTransactionServiceGetTransactionsRequest) Hashes(hashes []string) ApiTransactionServiceGetTransactionsRequest {
	r.hashes = &hashes
	return r
}

// Returns only transaction that have this address as either a source or a destination
func (r ApiTransactionServiceGetTransactionsRequest) Address(address string) ApiTransactionServiceGetTransactionsRequest {
	r.address = &address
	return r
}

// Returns only transactions with an amount strictly above the given amount
func (r ApiTransactionServiceGetTransactionsRequest) AmountAbove(amountAbove string) ApiTransactionServiceGetTransactionsRequest {
	r.amountAbove = &amountAbove
	return r
}

// Returns only transactions with a known source and destination, default false
func (r ApiTransactionServiceGetTransactionsRequest) ExcludeUnknownSourceDestination(excludeUnknownSourceDestination bool) ApiTransactionServiceGetTransactionsRequest {
	r.excludeUnknownSourceDestination = &excludeUnknownSourceDestination
	return r
}

// Returns only transactions with a specific customer id
func (r ApiTransactionServiceGetTransactionsRequest) CustomerId(customerId string) ApiTransactionServiceGetTransactionsRequest {
	r.customerId = &customerId
	return r
}

func (r ApiTransactionServiceGetTransactionsRequest) Execute() (*TgvalidatordGetTransactionsReply, *http.Response, error) {
	return r.ApiService.TransactionServiceGetTransactionsExecute(r)
}

/*
TransactionServiceGetTransactions List transactions

This endpoint returns a list of transactions based on the provided query parameters.

You must specify either a `currency` (by ID or symbol) or a combination of `blockchain` and `network`.

- If `currency` is provided, `blockchain` and `network` cannot be used.
- If `currency` is not provided, you may use `blockchain`, `network`, or both together.

Only one of these approaches is allowed per request.

The `currencyID` is unique across blockchains and networks, and can be identified by querying the `/currencies` endpoint. We recommend using `currencyID` whenever possible to avoid ambiguity.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiTransactionServiceGetTransactionsRequest
*/
func (a *TransactionsAPIService) TransactionServiceGetTransactions(ctx context.Context) ApiTransactionServiceGetTransactionsRequest {
	return ApiTransactionServiceGetTransactionsRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return TgvalidatordGetTransactionsReply
func (a *TransactionsAPIService) TransactionServiceGetTransactionsExecute(r ApiTransactionServiceGetTransactionsRequest) (*TgvalidatordGetTransactionsReply, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *TgvalidatordGetTransactionsReply
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "TransactionsAPIService.TransactionServiceGetTransactions")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/rest/v1/transactions"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.currency != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "currency", r.currency, "", "")
	}
	if r.direction != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "direction", r.direction, "", "")
	}
	if r.query != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "query", r.query, "", "")
	}
	if r.limit != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "limit", r.limit, "", "")
	}
	if r.offset != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "offset", r.offset, "", "")
	}
	if r.from != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "from", r.from, "", "")
	}
	if r.to != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "to", r.to, "", "")
	}
	if r.transactionIds != nil {
		t := *r.transactionIds
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "transactionIds", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "transactionIds", t, "form", "multi")
		}
	}
	if r.type_ != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "type", r.type_, "", "")
	}
	if r.source != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "source", r.source, "", "")
	}
	if r.destination != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "destination", r.destination, "", "")
	}
	if r.ids != nil {
		t := *r.ids
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "ids", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "ids", t, "form", "multi")
		}
	}
	if r.blockchain != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "blockchain", r.blockchain, "", "")
	}
	if r.network != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "network", r.network, "", "")
	}
	if r.fromBlockNumber != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "fromBlockNumber", r.fromBlockNumber, "", "")
	}
	if r.toBlockNumber != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "toBlockNumber", r.toBlockNumber, "", "")
	}
	if r.hashes != nil {
		t := *r.hashes
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "hashes", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "hashes", t, "form", "multi")
		}
	}
	if r.address != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "address", r.address, "", "")
	}
	if r.amountAbove != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "amountAbove", r.amountAbove, "", "")
	}
	if r.excludeUnknownSourceDestination != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "excludeUnknownSourceDestination", r.excludeUnknownSourceDestination, "", "")
	}
	if r.customerId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "customerId", r.customerId, "", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["ApiKeyTPV1"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v map[string]interface{}
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v map[string]interface{}
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v map[string]interface{}
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v map[string]interface{}
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v map[string]interface{}
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 503 {
			var v map[string]interface{}
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
			var v GooglerpcStatus
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}
