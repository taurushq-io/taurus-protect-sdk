// Code generated by protoc-gen-ts_proto. DO NOT EDIT.
// versions:
//   protoc-gen-ts_proto  v1.181.2
//   protoc               v6.33.4
// source: transaction.proto

/* eslint-disable */
import Long from "long";
import _m0 from "protobufjs/minimal";
import { Currency } from "./currency";
import { Timestamp } from "./google/protobuf/timestamp";
import { CompanyTravelRuleData, PersonTravelRuleData } from "./request";
import { TransactionScore } from "./score";
import { Asset } from "./wallet";

export const protobufPackage = "tgvalidatord";

export interface AddressInfo {
  address: string;
  label: string;
  container: string;
  customerId: string;
  amount: string;
  amountMainUnit: string;
  type: string;
  idx: number;
  internalAddressId: number;
  whitelistedAddressId: number;
  scores: TransactionScore[];
}

export interface Transaction {
  id: number;
  direction: string;
  currency: string;
  sources: AddressInfo[];
  destinations: AddressInfo[];
  amount: string;
  amountMainUnit: string;
  fee: string;
  feeMainUnit: string;
  hash: string;
  block: number;
  receptionDate: Date | undefined;
  confirmationDate: Date | undefined;
  transactionId: string;
  type: string;
  uniqueId: string;
  blockchain: string;
  arg1: string;
  arg2: string;
  currencyInfo: Currency | undefined;
  network: string;
  requestId: number;
  confirmationBlock: number;
  requestVisible: boolean;
  travelRule: TravelRule | undefined;
  status: string;
  platformFees: PlatformFee[];
  attributes: TransactionAttribute[];
  forkNumber: number;
  fees: TransactionFees[];
  isConfirmed: boolean;
}

export interface PlatformFee {
  /** The fee type. This can only be "exchange", but other types may be added in the future. */
  type: string;
  amount: string;
  amountMainUnit: string;
  symbol: string;
}

export interface TransactionFee {
  type: string;
  amount: string;
  amountMainUnit: string;
}

export interface TransactionFees {
  asset: Asset | undefined;
  fees: TransactionFee[];
}

export interface TransactionAttribute {
  id: string;
  key: string;
  value: string;
}

export interface TravelRule {
  originatorPersonTravelRuleData?: PersonTravelRuleData | undefined;
  originatorCompanyTravelRuleData?: CompanyTravelRuleData | undefined;
  beneficiaryCompanyTravelRuleData?: CompanyTravelRuleData | undefined;
  beneficiaryPersonTravelRuleData?: PersonTravelRuleData | undefined;
  currency: string;
  amount: string;
  amountMainUnit: string;
  transactionHash: string;
  originatorParticipant: string;
  beneficiaryParticipant: string;
  initiationDate: Date | undefined;
  confirmationDate: Date | undefined;
  blockchain: string;
  network: string;
}

function createBaseAddressInfo(): AddressInfo {
  return {
    address: "",
    label: "",
    container: "",
    customerId: "",
    amount: "",
    amountMainUnit: "",
    type: "",
    idx: 0,
    internalAddressId: 0,
    whitelistedAddressId: 0,
    scores: [],
  };
}

export const AddressInfo = {
  encode(message: AddressInfo, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.address !== "") {
      writer.uint32(10).string(message.address);
    }
    if (message.label !== "") {
      writer.uint32(18).string(message.label);
    }
    if (message.container !== "") {
      writer.uint32(26).string(message.container);
    }
    if (message.customerId !== "") {
      writer.uint32(34).string(message.customerId);
    }
    if (message.amount !== "") {
      writer.uint32(42).string(message.amount);
    }
    if (message.amountMainUnit !== "") {
      writer.uint32(50).string(message.amountMainUnit);
    }
    if (message.type !== "") {
      writer.uint32(58).string(message.type);
    }
    if (message.idx !== 0) {
      writer.uint32(64).uint64(message.idx);
    }
    if (message.internalAddressId !== 0) {
      writer.uint32(72).uint64(message.internalAddressId);
    }
    if (message.whitelistedAddressId !== 0) {
      writer.uint32(80).uint64(message.whitelistedAddressId);
    }
    for (const v of message.scores) {
      TransactionScore.encode(v!, writer.uint32(90).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): AddressInfo {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseAddressInfo();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.address = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.label = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.container = reader.string();
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.customerId = reader.string();
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.amount = reader.string();
          continue;
        case 6:
          if (tag !== 50) {
            break;
          }

          message.amountMainUnit = reader.string();
          continue;
        case 7:
          if (tag !== 58) {
            break;
          }

          message.type = reader.string();
          continue;
        case 8:
          if (tag !== 64) {
            break;
          }

          message.idx = longToNumber(reader.uint64() as Long);
          continue;
        case 9:
          if (tag !== 72) {
            break;
          }

          message.internalAddressId = longToNumber(reader.uint64() as Long);
          continue;
        case 10:
          if (tag !== 80) {
            break;
          }

          message.whitelistedAddressId = longToNumber(reader.uint64() as Long);
          continue;
        case 11:
          if (tag !== 90) {
            break;
          }

          message.scores.push(TransactionScore.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): AddressInfo {
    return {
      address: isSet(object.address) ? globalThis.String(object.address) : "",
      label: isSet(object.label) ? globalThis.String(object.label) : "",
      container: isSet(object.container) ? globalThis.String(object.container) : "",
      customerId: isSet(object.customerId) ? globalThis.String(object.customerId) : "",
      amount: isSet(object.amount) ? globalThis.String(object.amount) : "",
      amountMainUnit: isSet(object.amountMainUnit) ? globalThis.String(object.amountMainUnit) : "",
      type: isSet(object.type) ? globalThis.String(object.type) : "",
      idx: isSet(object.idx) ? globalThis.Number(object.idx) : 0,
      internalAddressId: isSet(object.internalAddressId) ? globalThis.Number(object.internalAddressId) : 0,
      whitelistedAddressId: isSet(object.whitelistedAddressId) ? globalThis.Number(object.whitelistedAddressId) : 0,
      scores: globalThis.Array.isArray(object?.scores)
        ? object.scores.map((e: any) => TransactionScore.fromJSON(e))
        : [],
    };
  },

  toJSON(message: AddressInfo): unknown {
    const obj: any = {};
    if (message.address !== "") {
      obj.address = message.address;
    }
    if (message.label !== "") {
      obj.label = message.label;
    }
    if (message.container !== "") {
      obj.container = message.container;
    }
    if (message.customerId !== "") {
      obj.customerId = message.customerId;
    }
    if (message.amount !== "") {
      obj.amount = message.amount;
    }
    if (message.amountMainUnit !== "") {
      obj.amountMainUnit = message.amountMainUnit;
    }
    if (message.type !== "") {
      obj.type = message.type;
    }
    if (message.idx !== 0) {
      obj.idx = Math.round(message.idx);
    }
    if (message.internalAddressId !== 0) {
      obj.internalAddressId = Math.round(message.internalAddressId);
    }
    if (message.whitelistedAddressId !== 0) {
      obj.whitelistedAddressId = Math.round(message.whitelistedAddressId);
    }
    if (message.scores?.length) {
      obj.scores = message.scores.map((e) => TransactionScore.toJSON(e));
    }
    return obj;
  },

  create(base?: DeepPartial<AddressInfo>): AddressInfo {
    return AddressInfo.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<AddressInfo>): AddressInfo {
    const message = createBaseAddressInfo();
    message.address = object.address ?? "";
    message.label = object.label ?? "";
    message.container = object.container ?? "";
    message.customerId = object.customerId ?? "";
    message.amount = object.amount ?? "";
    message.amountMainUnit = object.amountMainUnit ?? "";
    message.type = object.type ?? "";
    message.idx = object.idx ?? 0;
    message.internalAddressId = object.internalAddressId ?? 0;
    message.whitelistedAddressId = object.whitelistedAddressId ?? 0;
    message.scores = object.scores?.map((e) => TransactionScore.fromPartial(e)) || [];
    return message;
  },
};

function createBaseTransaction(): Transaction {
  return {
    id: 0,
    direction: "",
    currency: "",
    sources: [],
    destinations: [],
    amount: "",
    amountMainUnit: "",
    fee: "",
    feeMainUnit: "",
    hash: "",
    block: 0,
    receptionDate: undefined,
    confirmationDate: undefined,
    transactionId: "",
    type: "",
    uniqueId: "",
    blockchain: "",
    arg1: "",
    arg2: "",
    currencyInfo: undefined,
    network: "",
    requestId: 0,
    confirmationBlock: 0,
    requestVisible: false,
    travelRule: undefined,
    status: "",
    platformFees: [],
    attributes: [],
    forkNumber: 0,
    fees: [],
    isConfirmed: false,
  };
}

export const Transaction = {
  encode(message: Transaction, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.id !== 0) {
      writer.uint32(8).uint64(message.id);
    }
    if (message.direction !== "") {
      writer.uint32(18).string(message.direction);
    }
    if (message.currency !== "") {
      writer.uint32(26).string(message.currency);
    }
    for (const v of message.sources) {
      AddressInfo.encode(v!, writer.uint32(34).fork()).ldelim();
    }
    for (const v of message.destinations) {
      AddressInfo.encode(v!, writer.uint32(42).fork()).ldelim();
    }
    if (message.amount !== "") {
      writer.uint32(50).string(message.amount);
    }
    if (message.amountMainUnit !== "") {
      writer.uint32(58).string(message.amountMainUnit);
    }
    if (message.fee !== "") {
      writer.uint32(66).string(message.fee);
    }
    if (message.feeMainUnit !== "") {
      writer.uint32(74).string(message.feeMainUnit);
    }
    if (message.hash !== "") {
      writer.uint32(82).string(message.hash);
    }
    if (message.block !== 0) {
      writer.uint32(88).uint64(message.block);
    }
    if (message.receptionDate !== undefined) {
      Timestamp.encode(toTimestamp(message.receptionDate), writer.uint32(98).fork()).ldelim();
    }
    if (message.confirmationDate !== undefined) {
      Timestamp.encode(toTimestamp(message.confirmationDate), writer.uint32(106).fork()).ldelim();
    }
    if (message.transactionId !== "") {
      writer.uint32(114).string(message.transactionId);
    }
    if (message.type !== "") {
      writer.uint32(122).string(message.type);
    }
    if (message.uniqueId !== "") {
      writer.uint32(130).string(message.uniqueId);
    }
    if (message.blockchain !== "") {
      writer.uint32(138).string(message.blockchain);
    }
    if (message.arg1 !== "") {
      writer.uint32(146).string(message.arg1);
    }
    if (message.arg2 !== "") {
      writer.uint32(154).string(message.arg2);
    }
    if (message.currencyInfo !== undefined) {
      Currency.encode(message.currencyInfo, writer.uint32(162).fork()).ldelim();
    }
    if (message.network !== "") {
      writer.uint32(170).string(message.network);
    }
    if (message.requestId !== 0) {
      writer.uint32(176).uint64(message.requestId);
    }
    if (message.confirmationBlock !== 0) {
      writer.uint32(184).uint64(message.confirmationBlock);
    }
    if (message.requestVisible !== false) {
      writer.uint32(192).bool(message.requestVisible);
    }
    if (message.travelRule !== undefined) {
      TravelRule.encode(message.travelRule, writer.uint32(202).fork()).ldelim();
    }
    if (message.status !== "") {
      writer.uint32(210).string(message.status);
    }
    for (const v of message.platformFees) {
      PlatformFee.encode(v!, writer.uint32(218).fork()).ldelim();
    }
    for (const v of message.attributes) {
      TransactionAttribute.encode(v!, writer.uint32(226).fork()).ldelim();
    }
    if (message.forkNumber !== 0) {
      writer.uint32(232).uint64(message.forkNumber);
    }
    for (const v of message.fees) {
      TransactionFees.encode(v!, writer.uint32(242).fork()).ldelim();
    }
    if (message.isConfirmed !== false) {
      writer.uint32(248).bool(message.isConfirmed);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): Transaction {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseTransaction();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.id = longToNumber(reader.uint64() as Long);
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.direction = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.currency = reader.string();
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.sources.push(AddressInfo.decode(reader, reader.uint32()));
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.destinations.push(AddressInfo.decode(reader, reader.uint32()));
          continue;
        case 6:
          if (tag !== 50) {
            break;
          }

          message.amount = reader.string();
          continue;
        case 7:
          if (tag !== 58) {
            break;
          }

          message.amountMainUnit = reader.string();
          continue;
        case 8:
          if (tag !== 66) {
            break;
          }

          message.fee = reader.string();
          continue;
        case 9:
          if (tag !== 74) {
            break;
          }

          message.feeMainUnit = reader.string();
          continue;
        case 10:
          if (tag !== 82) {
            break;
          }

          message.hash = reader.string();
          continue;
        case 11:
          if (tag !== 88) {
            break;
          }

          message.block = longToNumber(reader.uint64() as Long);
          continue;
        case 12:
          if (tag !== 98) {
            break;
          }

          message.receptionDate = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        case 13:
          if (tag !== 106) {
            break;
          }

          message.confirmationDate = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        case 14:
          if (tag !== 114) {
            break;
          }

          message.transactionId = reader.string();
          continue;
        case 15:
          if (tag !== 122) {
            break;
          }

          message.type = reader.string();
          continue;
        case 16:
          if (tag !== 130) {
            break;
          }

          message.uniqueId = reader.string();
          continue;
        case 17:
          if (tag !== 138) {
            break;
          }

          message.blockchain = reader.string();
          continue;
        case 18:
          if (tag !== 146) {
            break;
          }

          message.arg1 = reader.string();
          continue;
        case 19:
          if (tag !== 154) {
            break;
          }

          message.arg2 = reader.string();
          continue;
        case 20:
          if (tag !== 162) {
            break;
          }

          message.currencyInfo = Currency.decode(reader, reader.uint32());
          continue;
        case 21:
          if (tag !== 170) {
            break;
          }

          message.network = reader.string();
          continue;
        case 22:
          if (tag !== 176) {
            break;
          }

          message.requestId = longToNumber(reader.uint64() as Long);
          continue;
        case 23:
          if (tag !== 184) {
            break;
          }

          message.confirmationBlock = longToNumber(reader.uint64() as Long);
          continue;
        case 24:
          if (tag !== 192) {
            break;
          }

          message.requestVisible = reader.bool();
          continue;
        case 25:
          if (tag !== 202) {
            break;
          }

          message.travelRule = TravelRule.decode(reader, reader.uint32());
          continue;
        case 26:
          if (tag !== 210) {
            break;
          }

          message.status = reader.string();
          continue;
        case 27:
          if (tag !== 218) {
            break;
          }

          message.platformFees.push(PlatformFee.decode(reader, reader.uint32()));
          continue;
        case 28:
          if (tag !== 226) {
            break;
          }

          message.attributes.push(TransactionAttribute.decode(reader, reader.uint32()));
          continue;
        case 29:
          if (tag !== 232) {
            break;
          }

          message.forkNumber = longToNumber(reader.uint64() as Long);
          continue;
        case 30:
          if (tag !== 242) {
            break;
          }

          message.fees.push(TransactionFees.decode(reader, reader.uint32()));
          continue;
        case 31:
          if (tag !== 248) {
            break;
          }

          message.isConfirmed = reader.bool();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Transaction {
    return {
      id: isSet(object.id) ? globalThis.Number(object.id) : 0,
      direction: isSet(object.direction) ? globalThis.String(object.direction) : "",
      currency: isSet(object.currency) ? globalThis.String(object.currency) : "",
      sources: globalThis.Array.isArray(object?.sources) ? object.sources.map((e: any) => AddressInfo.fromJSON(e)) : [],
      destinations: globalThis.Array.isArray(object?.destinations)
        ? object.destinations.map((e: any) => AddressInfo.fromJSON(e))
        : [],
      amount: isSet(object.amount) ? globalThis.String(object.amount) : "",
      amountMainUnit: isSet(object.amountMainUnit) ? globalThis.String(object.amountMainUnit) : "",
      fee: isSet(object.fee) ? globalThis.String(object.fee) : "",
      feeMainUnit: isSet(object.feeMainUnit) ? globalThis.String(object.feeMainUnit) : "",
      hash: isSet(object.hash) ? globalThis.String(object.hash) : "",
      block: isSet(object.block) ? globalThis.Number(object.block) : 0,
      receptionDate: isSet(object.receptionDate) ? fromJsonTimestamp(object.receptionDate) : undefined,
      confirmationDate: isSet(object.confirmationDate) ? fromJsonTimestamp(object.confirmationDate) : undefined,
      transactionId: isSet(object.transactionId) ? globalThis.String(object.transactionId) : "",
      type: isSet(object.type) ? globalThis.String(object.type) : "",
      uniqueId: isSet(object.uniqueId) ? globalThis.String(object.uniqueId) : "",
      blockchain: isSet(object.blockchain) ? globalThis.String(object.blockchain) : "",
      arg1: isSet(object.arg1) ? globalThis.String(object.arg1) : "",
      arg2: isSet(object.arg2) ? globalThis.String(object.arg2) : "",
      currencyInfo: isSet(object.currencyInfo) ? Currency.fromJSON(object.currencyInfo) : undefined,
      network: isSet(object.network) ? globalThis.String(object.network) : "",
      requestId: isSet(object.requestId) ? globalThis.Number(object.requestId) : 0,
      confirmationBlock: isSet(object.confirmationBlock) ? globalThis.Number(object.confirmationBlock) : 0,
      requestVisible: isSet(object.requestVisible) ? globalThis.Boolean(object.requestVisible) : false,
      travelRule: isSet(object.travelRule) ? TravelRule.fromJSON(object.travelRule) : undefined,
      status: isSet(object.status) ? globalThis.String(object.status) : "",
      platformFees: globalThis.Array.isArray(object?.platformFees)
        ? object.platformFees.map((e: any) => PlatformFee.fromJSON(e))
        : [],
      attributes: globalThis.Array.isArray(object?.attributes)
        ? object.attributes.map((e: any) => TransactionAttribute.fromJSON(e))
        : [],
      forkNumber: isSet(object.forkNumber) ? globalThis.Number(object.forkNumber) : 0,
      fees: globalThis.Array.isArray(object?.fees) ? object.fees.map((e: any) => TransactionFees.fromJSON(e)) : [],
      isConfirmed: isSet(object.isConfirmed) ? globalThis.Boolean(object.isConfirmed) : false,
    };
  },

  toJSON(message: Transaction): unknown {
    const obj: any = {};
    if (message.id !== 0) {
      obj.id = Math.round(message.id);
    }
    if (message.direction !== "") {
      obj.direction = message.direction;
    }
    if (message.currency !== "") {
      obj.currency = message.currency;
    }
    if (message.sources?.length) {
      obj.sources = message.sources.map((e) => AddressInfo.toJSON(e));
    }
    if (message.destinations?.length) {
      obj.destinations = message.destinations.map((e) => AddressInfo.toJSON(e));
    }
    if (message.amount !== "") {
      obj.amount = message.amount;
    }
    if (message.amountMainUnit !== "") {
      obj.amountMainUnit = message.amountMainUnit;
    }
    if (message.fee !== "") {
      obj.fee = message.fee;
    }
    if (message.feeMainUnit !== "") {
      obj.feeMainUnit = message.feeMainUnit;
    }
    if (message.hash !== "") {
      obj.hash = message.hash;
    }
    if (message.block !== 0) {
      obj.block = Math.round(message.block);
    }
    if (message.receptionDate !== undefined) {
      obj.receptionDate = message.receptionDate.toISOString();
    }
    if (message.confirmationDate !== undefined) {
      obj.confirmationDate = message.confirmationDate.toISOString();
    }
    if (message.transactionId !== "") {
      obj.transactionId = message.transactionId;
    }
    if (message.type !== "") {
      obj.type = message.type;
    }
    if (message.uniqueId !== "") {
      obj.uniqueId = message.uniqueId;
    }
    if (message.blockchain !== "") {
      obj.blockchain = message.blockchain;
    }
    if (message.arg1 !== "") {
      obj.arg1 = message.arg1;
    }
    if (message.arg2 !== "") {
      obj.arg2 = message.arg2;
    }
    if (message.currencyInfo !== undefined) {
      obj.currencyInfo = Currency.toJSON(message.currencyInfo);
    }
    if (message.network !== "") {
      obj.network = message.network;
    }
    if (message.requestId !== 0) {
      obj.requestId = Math.round(message.requestId);
    }
    if (message.confirmationBlock !== 0) {
      obj.confirmationBlock = Math.round(message.confirmationBlock);
    }
    if (message.requestVisible !== false) {
      obj.requestVisible = message.requestVisible;
    }
    if (message.travelRule !== undefined) {
      obj.travelRule = TravelRule.toJSON(message.travelRule);
    }
    if (message.status !== "") {
      obj.status = message.status;
    }
    if (message.platformFees?.length) {
      obj.platformFees = message.platformFees.map((e) => PlatformFee.toJSON(e));
    }
    if (message.attributes?.length) {
      obj.attributes = message.attributes.map((e) => TransactionAttribute.toJSON(e));
    }
    if (message.forkNumber !== 0) {
      obj.forkNumber = Math.round(message.forkNumber);
    }
    if (message.fees?.length) {
      obj.fees = message.fees.map((e) => TransactionFees.toJSON(e));
    }
    if (message.isConfirmed !== false) {
      obj.isConfirmed = message.isConfirmed;
    }
    return obj;
  },

  create(base?: DeepPartial<Transaction>): Transaction {
    return Transaction.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<Transaction>): Transaction {
    const message = createBaseTransaction();
    message.id = object.id ?? 0;
    message.direction = object.direction ?? "";
    message.currency = object.currency ?? "";
    message.sources = object.sources?.map((e) => AddressInfo.fromPartial(e)) || [];
    message.destinations = object.destinations?.map((e) => AddressInfo.fromPartial(e)) || [];
    message.amount = object.amount ?? "";
    message.amountMainUnit = object.amountMainUnit ?? "";
    message.fee = object.fee ?? "";
    message.feeMainUnit = object.feeMainUnit ?? "";
    message.hash = object.hash ?? "";
    message.block = object.block ?? 0;
    message.receptionDate = object.receptionDate ?? undefined;
    message.confirmationDate = object.confirmationDate ?? undefined;
    message.transactionId = object.transactionId ?? "";
    message.type = object.type ?? "";
    message.uniqueId = object.uniqueId ?? "";
    message.blockchain = object.blockchain ?? "";
    message.arg1 = object.arg1 ?? "";
    message.arg2 = object.arg2 ?? "";
    message.currencyInfo = (object.currencyInfo !== undefined && object.currencyInfo !== null)
      ? Currency.fromPartial(object.currencyInfo)
      : undefined;
    message.network = object.network ?? "";
    message.requestId = object.requestId ?? 0;
    message.confirmationBlock = object.confirmationBlock ?? 0;
    message.requestVisible = object.requestVisible ?? false;
    message.travelRule = (object.travelRule !== undefined && object.travelRule !== null)
      ? TravelRule.fromPartial(object.travelRule)
      : undefined;
    message.status = object.status ?? "";
    message.platformFees = object.platformFees?.map((e) => PlatformFee.fromPartial(e)) || [];
    message.attributes = object.attributes?.map((e) => TransactionAttribute.fromPartial(e)) || [];
    message.forkNumber = object.forkNumber ?? 0;
    message.fees = object.fees?.map((e) => TransactionFees.fromPartial(e)) || [];
    message.isConfirmed = object.isConfirmed ?? false;
    return message;
  },
};

function createBasePlatformFee(): PlatformFee {
  return { type: "", amount: "", amountMainUnit: "", symbol: "" };
}

export const PlatformFee = {
  encode(message: PlatformFee, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.type !== "") {
      writer.uint32(10).string(message.type);
    }
    if (message.amount !== "") {
      writer.uint32(18).string(message.amount);
    }
    if (message.amountMainUnit !== "") {
      writer.uint32(26).string(message.amountMainUnit);
    }
    if (message.symbol !== "") {
      writer.uint32(34).string(message.symbol);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): PlatformFee {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBasePlatformFee();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.type = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.amount = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.amountMainUnit = reader.string();
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.symbol = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): PlatformFee {
    return {
      type: isSet(object.type) ? globalThis.String(object.type) : "",
      amount: isSet(object.amount) ? globalThis.String(object.amount) : "",
      amountMainUnit: isSet(object.amountMainUnit) ? globalThis.String(object.amountMainUnit) : "",
      symbol: isSet(object.symbol) ? globalThis.String(object.symbol) : "",
    };
  },

  toJSON(message: PlatformFee): unknown {
    const obj: any = {};
    if (message.type !== "") {
      obj.type = message.type;
    }
    if (message.amount !== "") {
      obj.amount = message.amount;
    }
    if (message.amountMainUnit !== "") {
      obj.amountMainUnit = message.amountMainUnit;
    }
    if (message.symbol !== "") {
      obj.symbol = message.symbol;
    }
    return obj;
  },

  create(base?: DeepPartial<PlatformFee>): PlatformFee {
    return PlatformFee.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<PlatformFee>): PlatformFee {
    const message = createBasePlatformFee();
    message.type = object.type ?? "";
    message.amount = object.amount ?? "";
    message.amountMainUnit = object.amountMainUnit ?? "";
    message.symbol = object.symbol ?? "";
    return message;
  },
};

function createBaseTransactionFee(): TransactionFee {
  return { type: "", amount: "", amountMainUnit: "" };
}

export const TransactionFee = {
  encode(message: TransactionFee, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.type !== "") {
      writer.uint32(10).string(message.type);
    }
    if (message.amount !== "") {
      writer.uint32(18).string(message.amount);
    }
    if (message.amountMainUnit !== "") {
      writer.uint32(26).string(message.amountMainUnit);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): TransactionFee {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseTransactionFee();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.type = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.amount = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.amountMainUnit = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): TransactionFee {
    return {
      type: isSet(object.type) ? globalThis.String(object.type) : "",
      amount: isSet(object.amount) ? globalThis.String(object.amount) : "",
      amountMainUnit: isSet(object.amountMainUnit) ? globalThis.String(object.amountMainUnit) : "",
    };
  },

  toJSON(message: TransactionFee): unknown {
    const obj: any = {};
    if (message.type !== "") {
      obj.type = message.type;
    }
    if (message.amount !== "") {
      obj.amount = message.amount;
    }
    if (message.amountMainUnit !== "") {
      obj.amountMainUnit = message.amountMainUnit;
    }
    return obj;
  },

  create(base?: DeepPartial<TransactionFee>): TransactionFee {
    return TransactionFee.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<TransactionFee>): TransactionFee {
    const message = createBaseTransactionFee();
    message.type = object.type ?? "";
    message.amount = object.amount ?? "";
    message.amountMainUnit = object.amountMainUnit ?? "";
    return message;
  },
};

function createBaseTransactionFees(): TransactionFees {
  return { asset: undefined, fees: [] };
}

export const TransactionFees = {
  encode(message: TransactionFees, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.asset !== undefined) {
      Asset.encode(message.asset, writer.uint32(10).fork()).ldelim();
    }
    for (const v of message.fees) {
      TransactionFee.encode(v!, writer.uint32(18).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): TransactionFees {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseTransactionFees();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.asset = Asset.decode(reader, reader.uint32());
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.fees.push(TransactionFee.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): TransactionFees {
    return {
      asset: isSet(object.asset) ? Asset.fromJSON(object.asset) : undefined,
      fees: globalThis.Array.isArray(object?.fees) ? object.fees.map((e: any) => TransactionFee.fromJSON(e)) : [],
    };
  },

  toJSON(message: TransactionFees): unknown {
    const obj: any = {};
    if (message.asset !== undefined) {
      obj.asset = Asset.toJSON(message.asset);
    }
    if (message.fees?.length) {
      obj.fees = message.fees.map((e) => TransactionFee.toJSON(e));
    }
    return obj;
  },

  create(base?: DeepPartial<TransactionFees>): TransactionFees {
    return TransactionFees.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<TransactionFees>): TransactionFees {
    const message = createBaseTransactionFees();
    message.asset = (object.asset !== undefined && object.asset !== null) ? Asset.fromPartial(object.asset) : undefined;
    message.fees = object.fees?.map((e) => TransactionFee.fromPartial(e)) || [];
    return message;
  },
};

function createBaseTransactionAttribute(): TransactionAttribute {
  return { id: "", key: "", value: "" };
}

export const TransactionAttribute = {
  encode(message: TransactionAttribute, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.id !== "") {
      writer.uint32(10).string(message.id);
    }
    if (message.key !== "") {
      writer.uint32(26).string(message.key);
    }
    if (message.value !== "") {
      writer.uint32(34).string(message.value);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): TransactionAttribute {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseTransactionAttribute();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.id = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.key = reader.string();
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.value = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): TransactionAttribute {
    return {
      id: isSet(object.id) ? globalThis.String(object.id) : "",
      key: isSet(object.key) ? globalThis.String(object.key) : "",
      value: isSet(object.value) ? globalThis.String(object.value) : "",
    };
  },

  toJSON(message: TransactionAttribute): unknown {
    const obj: any = {};
    if (message.id !== "") {
      obj.id = message.id;
    }
    if (message.key !== "") {
      obj.key = message.key;
    }
    if (message.value !== "") {
      obj.value = message.value;
    }
    return obj;
  },

  create(base?: DeepPartial<TransactionAttribute>): TransactionAttribute {
    return TransactionAttribute.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<TransactionAttribute>): TransactionAttribute {
    const message = createBaseTransactionAttribute();
    message.id = object.id ?? "";
    message.key = object.key ?? "";
    message.value = object.value ?? "";
    return message;
  },
};

function createBaseTravelRule(): TravelRule {
  return {
    originatorPersonTravelRuleData: undefined,
    originatorCompanyTravelRuleData: undefined,
    beneficiaryCompanyTravelRuleData: undefined,
    beneficiaryPersonTravelRuleData: undefined,
    currency: "",
    amount: "",
    amountMainUnit: "",
    transactionHash: "",
    originatorParticipant: "",
    beneficiaryParticipant: "",
    initiationDate: undefined,
    confirmationDate: undefined,
    blockchain: "",
    network: "",
  };
}

export const TravelRule = {
  encode(message: TravelRule, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.originatorPersonTravelRuleData !== undefined) {
      PersonTravelRuleData.encode(message.originatorPersonTravelRuleData, writer.uint32(10).fork()).ldelim();
    }
    if (message.originatorCompanyTravelRuleData !== undefined) {
      CompanyTravelRuleData.encode(message.originatorCompanyTravelRuleData, writer.uint32(18).fork()).ldelim();
    }
    if (message.beneficiaryCompanyTravelRuleData !== undefined) {
      CompanyTravelRuleData.encode(message.beneficiaryCompanyTravelRuleData, writer.uint32(26).fork()).ldelim();
    }
    if (message.beneficiaryPersonTravelRuleData !== undefined) {
      PersonTravelRuleData.encode(message.beneficiaryPersonTravelRuleData, writer.uint32(34).fork()).ldelim();
    }
    if (message.currency !== "") {
      writer.uint32(42).string(message.currency);
    }
    if (message.amount !== "") {
      writer.uint32(50).string(message.amount);
    }
    if (message.amountMainUnit !== "") {
      writer.uint32(58).string(message.amountMainUnit);
    }
    if (message.transactionHash !== "") {
      writer.uint32(66).string(message.transactionHash);
    }
    if (message.originatorParticipant !== "") {
      writer.uint32(74).string(message.originatorParticipant);
    }
    if (message.beneficiaryParticipant !== "") {
      writer.uint32(82).string(message.beneficiaryParticipant);
    }
    if (message.initiationDate !== undefined) {
      Timestamp.encode(toTimestamp(message.initiationDate), writer.uint32(90).fork()).ldelim();
    }
    if (message.confirmationDate !== undefined) {
      Timestamp.encode(toTimestamp(message.confirmationDate), writer.uint32(98).fork()).ldelim();
    }
    if (message.blockchain !== "") {
      writer.uint32(106).string(message.blockchain);
    }
    if (message.network !== "") {
      writer.uint32(114).string(message.network);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): TravelRule {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseTravelRule();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.originatorPersonTravelRuleData = PersonTravelRuleData.decode(reader, reader.uint32());
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.originatorCompanyTravelRuleData = CompanyTravelRuleData.decode(reader, reader.uint32());
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.beneficiaryCompanyTravelRuleData = CompanyTravelRuleData.decode(reader, reader.uint32());
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.beneficiaryPersonTravelRuleData = PersonTravelRuleData.decode(reader, reader.uint32());
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.currency = reader.string();
          continue;
        case 6:
          if (tag !== 50) {
            break;
          }

          message.amount = reader.string();
          continue;
        case 7:
          if (tag !== 58) {
            break;
          }

          message.amountMainUnit = reader.string();
          continue;
        case 8:
          if (tag !== 66) {
            break;
          }

          message.transactionHash = reader.string();
          continue;
        case 9:
          if (tag !== 74) {
            break;
          }

          message.originatorParticipant = reader.string();
          continue;
        case 10:
          if (tag !== 82) {
            break;
          }

          message.beneficiaryParticipant = reader.string();
          continue;
        case 11:
          if (tag !== 90) {
            break;
          }

          message.initiationDate = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        case 12:
          if (tag !== 98) {
            break;
          }

          message.confirmationDate = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        case 13:
          if (tag !== 106) {
            break;
          }

          message.blockchain = reader.string();
          continue;
        case 14:
          if (tag !== 114) {
            break;
          }

          message.network = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): TravelRule {
    return {
      originatorPersonTravelRuleData: isSet(object.originatorPersonTravelRuleData)
        ? PersonTravelRuleData.fromJSON(object.originatorPersonTravelRuleData)
        : undefined,
      originatorCompanyTravelRuleData: isSet(object.originatorCompanyTravelRuleData)
        ? CompanyTravelRuleData.fromJSON(object.originatorCompanyTravelRuleData)
        : undefined,
      beneficiaryCompanyTravelRuleData: isSet(object.beneficiaryCompanyTravelRuleData)
        ? CompanyTravelRuleData.fromJSON(object.beneficiaryCompanyTravelRuleData)
        : undefined,
      beneficiaryPersonTravelRuleData: isSet(object.beneficiaryPersonTravelRuleData)
        ? PersonTravelRuleData.fromJSON(object.beneficiaryPersonTravelRuleData)
        : undefined,
      currency: isSet(object.currency) ? globalThis.String(object.currency) : "",
      amount: isSet(object.amount) ? globalThis.String(object.amount) : "",
      amountMainUnit: isSet(object.amountMainUnit) ? globalThis.String(object.amountMainUnit) : "",
      transactionHash: isSet(object.transactionHash) ? globalThis.String(object.transactionHash) : "",
      originatorParticipant: isSet(object.originatorParticipant) ? globalThis.String(object.originatorParticipant) : "",
      beneficiaryParticipant: isSet(object.beneficiaryParticipant)
        ? globalThis.String(object.beneficiaryParticipant)
        : "",
      initiationDate: isSet(object.initiationDate) ? fromJsonTimestamp(object.initiationDate) : undefined,
      confirmationDate: isSet(object.confirmationDate) ? fromJsonTimestamp(object.confirmationDate) : undefined,
      blockchain: isSet(object.blockchain) ? globalThis.String(object.blockchain) : "",
      network: isSet(object.network) ? globalThis.String(object.network) : "",
    };
  },

  toJSON(message: TravelRule): unknown {
    const obj: any = {};
    if (message.originatorPersonTravelRuleData !== undefined) {
      obj.originatorPersonTravelRuleData = PersonTravelRuleData.toJSON(message.originatorPersonTravelRuleData);
    }
    if (message.originatorCompanyTravelRuleData !== undefined) {
      obj.originatorCompanyTravelRuleData = CompanyTravelRuleData.toJSON(message.originatorCompanyTravelRuleData);
    }
    if (message.beneficiaryCompanyTravelRuleData !== undefined) {
      obj.beneficiaryCompanyTravelRuleData = CompanyTravelRuleData.toJSON(message.beneficiaryCompanyTravelRuleData);
    }
    if (message.beneficiaryPersonTravelRuleData !== undefined) {
      obj.beneficiaryPersonTravelRuleData = PersonTravelRuleData.toJSON(message.beneficiaryPersonTravelRuleData);
    }
    if (message.currency !== "") {
      obj.currency = message.currency;
    }
    if (message.amount !== "") {
      obj.amount = message.amount;
    }
    if (message.amountMainUnit !== "") {
      obj.amountMainUnit = message.amountMainUnit;
    }
    if (message.transactionHash !== "") {
      obj.transactionHash = message.transactionHash;
    }
    if (message.originatorParticipant !== "") {
      obj.originatorParticipant = message.originatorParticipant;
    }
    if (message.beneficiaryParticipant !== "") {
      obj.beneficiaryParticipant = message.beneficiaryParticipant;
    }
    if (message.initiationDate !== undefined) {
      obj.initiationDate = message.initiationDate.toISOString();
    }
    if (message.confirmationDate !== undefined) {
      obj.confirmationDate = message.confirmationDate.toISOString();
    }
    if (message.blockchain !== "") {
      obj.blockchain = message.blockchain;
    }
    if (message.network !== "") {
      obj.network = message.network;
    }
    return obj;
  },

  create(base?: DeepPartial<TravelRule>): TravelRule {
    return TravelRule.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<TravelRule>): TravelRule {
    const message = createBaseTravelRule();
    message.originatorPersonTravelRuleData =
      (object.originatorPersonTravelRuleData !== undefined && object.originatorPersonTravelRuleData !== null)
        ? PersonTravelRuleData.fromPartial(object.originatorPersonTravelRuleData)
        : undefined;
    message.originatorCompanyTravelRuleData =
      (object.originatorCompanyTravelRuleData !== undefined && object.originatorCompanyTravelRuleData !== null)
        ? CompanyTravelRuleData.fromPartial(object.originatorCompanyTravelRuleData)
        : undefined;
    message.beneficiaryCompanyTravelRuleData =
      (object.beneficiaryCompanyTravelRuleData !== undefined && object.beneficiaryCompanyTravelRuleData !== null)
        ? CompanyTravelRuleData.fromPartial(object.beneficiaryCompanyTravelRuleData)
        : undefined;
    message.beneficiaryPersonTravelRuleData =
      (object.beneficiaryPersonTravelRuleData !== undefined && object.beneficiaryPersonTravelRuleData !== null)
        ? PersonTravelRuleData.fromPartial(object.beneficiaryPersonTravelRuleData)
        : undefined;
    message.currency = object.currency ?? "";
    message.amount = object.amount ?? "";
    message.amountMainUnit = object.amountMainUnit ?? "";
    message.transactionHash = object.transactionHash ?? "";
    message.originatorParticipant = object.originatorParticipant ?? "";
    message.beneficiaryParticipant = object.beneficiaryParticipant ?? "";
    message.initiationDate = object.initiationDate ?? undefined;
    message.confirmationDate = object.confirmationDate ?? undefined;
    message.blockchain = object.blockchain ?? "";
    message.network = object.network ?? "";
    return message;
  },
};

type Builtin = Date | Function | Uint8Array | string | number | boolean | undefined;

export type DeepPartial<T> = T extends Builtin ? T
  : T extends globalThis.Array<infer U> ? globalThis.Array<DeepPartial<U>>
  : T extends ReadonlyArray<infer U> ? ReadonlyArray<DeepPartial<U>>
  : T extends {} ? { [K in keyof T]?: DeepPartial<T[K]> }
  : Partial<T>;

function toTimestamp(date: Date): Timestamp {
  const seconds = Math.trunc(date.getTime() / 1_000);
  const nanos = (date.getTime() % 1_000) * 1_000_000;
  return { seconds, nanos };
}

function fromTimestamp(t: Timestamp): Date {
  let millis = (t.seconds || 0) * 1_000;
  millis += (t.nanos || 0) / 1_000_000;
  return new globalThis.Date(millis);
}

function fromJsonTimestamp(o: any): Date {
  if (o instanceof globalThis.Date) {
    return o;
  } else if (typeof o === "string") {
    return new globalThis.Date(o);
  } else {
    return fromTimestamp(Timestamp.fromJSON(o));
  }
}

function longToNumber(long: Long): number {
  if (long.gt(globalThis.Number.MAX_SAFE_INTEGER)) {
    throw new globalThis.Error("Value is larger than Number.MAX_SAFE_INTEGER");
  }
  if (long.lt(globalThis.Number.MIN_SAFE_INTEGER)) {
    throw new globalThis.Error("Value is smaller than Number.MIN_SAFE_INTEGER");
  }
  return long.toNumber();
}

if (_m0.util.Long !== Long) {
  _m0.util.Long = Long as any;
  _m0.configure();
}

function isSet(value: any): boolean {
  return value !== null && value !== undefined;
}
