/*
Taurus-PROTECT APIs

Taurus-PROTECT APIs description

API version: 1.0
*/

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package openapi

import (
	"bytes"
	"context"
	"io"
	"net/http"
	"net/url"
	"strings"
	"time"
	"reflect"
)


// AddressesAPIService AddressesAPI service
type AddressesAPIService service

type ApiReportServiceSwiftMT535BalanceReportRequest struct {
	ctx context.Context
	ApiService *AddressesAPIService
	blockchain *string
	blockchainaddress *string
	forDate *time.Time
	network *string
}

func (r ApiReportServiceSwiftMT535BalanceReportRequest) Blockchain(blockchain string) ApiReportServiceSwiftMT535BalanceReportRequest {
	r.blockchain = &blockchain
	return r
}

func (r ApiReportServiceSwiftMT535BalanceReportRequest) Blockchainaddress(blockchainaddress string) ApiReportServiceSwiftMT535BalanceReportRequest {
	r.blockchainaddress = &blockchainaddress
	return r
}

func (r ApiReportServiceSwiftMT535BalanceReportRequest) ForDate(forDate time.Time) ApiReportServiceSwiftMT535BalanceReportRequest {
	r.forDate = &forDate
	return r
}

func (r ApiReportServiceSwiftMT535BalanceReportRequest) Network(network string) ApiReportServiceSwiftMT535BalanceReportRequest {
	r.network = &network
	return r
}

func (r ApiReportServiceSwiftMT535BalanceReportRequest) Execute() (*ApiHttpBody, *http.Response, error) {
	return r.ApiService.ReportServiceSwiftMT535BalanceReportExecute(r)
}

/*
ReportServiceSwiftMT535BalanceReport Get the balance of the address

Returns the MT535 statement of holdings for the address.
By default, the response is a JSON, with the swift content formatted in base64. To get the plain swift as a response, use the request header **'Accept: text/plain'**.
A date can be passed to get the balance at a particular date. If no date is given, the last closing date is used.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiReportServiceSwiftMT535BalanceReportRequest
*/
func (a *AddressesAPIService) ReportServiceSwiftMT535BalanceReport(ctx context.Context) ApiReportServiceSwiftMT535BalanceReportRequest {
	return ApiReportServiceSwiftMT535BalanceReportRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return ApiHttpBody
func (a *AddressesAPIService) ReportServiceSwiftMT535BalanceReportExecute(r ApiReportServiceSwiftMT535BalanceReportRequest) (*ApiHttpBody, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ApiHttpBody
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AddressesAPIService.ReportServiceSwiftMT535BalanceReport")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/rest/v1/reports/mt535"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.blockchain != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "blockchain", r.blockchain, "", "")
	}
	if r.blockchainaddress != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "blockchainaddress", r.blockchainaddress, "", "")
	}
	if r.forDate != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "forDate", r.forDate, "", "")
	}
	if r.network != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "network", r.network, "", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["ApiKeyTPV1"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v map[string]interface{}
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v map[string]interface{}
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v map[string]interface{}
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v map[string]interface{}
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v map[string]interface{}
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 503 {
			var v map[string]interface{}
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
			var v GooglerpcStatus
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiReportServiceSwiftMT536TransactionsReportRequest struct {
	ctx context.Context
	ApiService *AddressesAPIService
	blockchain *string
	blockchainaddress *string
	forDate *time.Time
	network *string
}

func (r ApiReportServiceSwiftMT536TransactionsReportRequest) Blockchain(blockchain string) ApiReportServiceSwiftMT536TransactionsReportRequest {
	r.blockchain = &blockchain
	return r
}

func (r ApiReportServiceSwiftMT536TransactionsReportRequest) Blockchainaddress(blockchainaddress string) ApiReportServiceSwiftMT536TransactionsReportRequest {
	r.blockchainaddress = &blockchainaddress
	return r
}

func (r ApiReportServiceSwiftMT536TransactionsReportRequest) ForDate(forDate time.Time) ApiReportServiceSwiftMT536TransactionsReportRequest {
	r.forDate = &forDate
	return r
}

func (r ApiReportServiceSwiftMT536TransactionsReportRequest) Network(network string) ApiReportServiceSwiftMT536TransactionsReportRequest {
	r.network = &network
	return r
}

func (r ApiReportServiceSwiftMT536TransactionsReportRequest) Execute() (*ApiHttpBody, *http.Response, error) {
	return r.ApiService.ReportServiceSwiftMT536TransactionsReportExecute(r)
}

/*
ReportServiceSwiftMT536TransactionsReport Get the daily transactions of the address

Returns the MT536 statement of transactions for the address.
By default, the response is a JSON, with the swift content formatted in base64. To get the plain swift as a response, use the request header **'Accept: text/plain'**.
A date can be passed to get the transactions of a particular day. If no date is given, the last day is used.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiReportServiceSwiftMT536TransactionsReportRequest
*/
func (a *AddressesAPIService) ReportServiceSwiftMT536TransactionsReport(ctx context.Context) ApiReportServiceSwiftMT536TransactionsReportRequest {
	return ApiReportServiceSwiftMT536TransactionsReportRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return ApiHttpBody
func (a *AddressesAPIService) ReportServiceSwiftMT536TransactionsReportExecute(r ApiReportServiceSwiftMT536TransactionsReportRequest) (*ApiHttpBody, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ApiHttpBody
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AddressesAPIService.ReportServiceSwiftMT536TransactionsReport")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/rest/v1/reports/mt536"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.blockchain != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "blockchain", r.blockchain, "", "")
	}
	if r.blockchainaddress != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "blockchainaddress", r.blockchainaddress, "", "")
	}
	if r.forDate != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "forDate", r.forDate, "", "")
	}
	if r.network != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "network", r.network, "", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["ApiKeyTPV1"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v map[string]interface{}
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v map[string]interface{}
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v map[string]interface{}
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v map[string]interface{}
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v map[string]interface{}
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 503 {
			var v map[string]interface{}
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
			var v GooglerpcStatus
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiWalletServiceBTCSignMessageRequest struct {
	ctx context.Context
	ApiService *AddressesAPIService
	addressId string
	message *string
}

func (r ApiWalletServiceBTCSignMessageRequest) Message(message string) ApiWalletServiceBTCSignMessageRequest {
	r.message = &message
	return r
}

func (r ApiWalletServiceBTCSignMessageRequest) Execute() (*TgvalidatordBTCSignMessageReply, *http.Response, error) {
	return r.ApiService.WalletServiceBTCSignMessageExecute(r)
}

/*
WalletServiceBTCSignMessage Calculate a BTC specific signature of a message

This endpoint returns a BTC specific signature from a given message and address as input.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param addressId
 @return ApiWalletServiceBTCSignMessageRequest
*/
func (a *AddressesAPIService) WalletServiceBTCSignMessage(ctx context.Context, addressId string) ApiWalletServiceBTCSignMessageRequest {
	return ApiWalletServiceBTCSignMessageRequest{
		ApiService: a,
		ctx: ctx,
		addressId: addressId,
	}
}

// Execute executes the request
//  @return TgvalidatordBTCSignMessageReply
func (a *AddressesAPIService) WalletServiceBTCSignMessageExecute(r ApiWalletServiceBTCSignMessageRequest) (*TgvalidatordBTCSignMessageReply, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *TgvalidatordBTCSignMessageReply
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AddressesAPIService.WalletServiceBTCSignMessage")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/rest/v1/addresses/{addressId}/btc_sign"
	localVarPath = strings.Replace(localVarPath, "{"+"addressId"+"}", url.PathEscape(parameterValueToString(r.addressId, "addressId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.message != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "message", r.message, "", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["ApiKeyTPV1"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v map[string]interface{}
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v map[string]interface{}
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v map[string]interface{}
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v map[string]interface{}
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v map[string]interface{}
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 503 {
			var v map[string]interface{}
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
			var v GooglerpcStatus
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiWalletServiceComputeAddressesSignatureRequest struct {
	ctx context.Context
	ApiService *AddressesAPIService
	body *TgvalidatordComputeAddressesSignatureRequest
}

func (r ApiWalletServiceComputeAddressesSignatureRequest) Body(body TgvalidatordComputeAddressesSignatureRequest) ApiWalletServiceComputeAddressesSignatureRequest {
	r.body = &body
	return r
}

func (r ApiWalletServiceComputeAddressesSignatureRequest) Execute() (*TgvalidatordComputeAddressesSignatureReply, *http.Response, error) {
	return r.ApiService.WalletServiceComputeAddressesSignatureExecute(r)
}

/*
WalletServiceComputeAddressesSignature Recompute addresses signatures

This endpoint forces a recompute of all addresses signatures.
 Required role: **Admin**.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiWalletServiceComputeAddressesSignatureRequest
*/
func (a *AddressesAPIService) WalletServiceComputeAddressesSignature(ctx context.Context) ApiWalletServiceComputeAddressesSignatureRequest {
	return ApiWalletServiceComputeAddressesSignatureRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return TgvalidatordComputeAddressesSignatureReply
func (a *AddressesAPIService) WalletServiceComputeAddressesSignatureExecute(r ApiWalletServiceComputeAddressesSignatureRequest) (*TgvalidatordComputeAddressesSignatureReply, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *TgvalidatordComputeAddressesSignatureReply
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AddressesAPIService.WalletServiceComputeAddressesSignature")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/rest/v1/addresses/signature/compute"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.body == nil {
		return localVarReturnValue, nil, reportError("body is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["ApiKeyTPV1"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v map[string]interface{}
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v map[string]interface{}
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v map[string]interface{}
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v map[string]interface{}
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v map[string]interface{}
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 503 {
			var v map[string]interface{}
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
			var v GooglerpcStatus
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiWalletServiceCreateAddressRequest struct {
	ctx context.Context
	ApiService *AddressesAPIService
	body *TgvalidatordCreateAddressRequest
}

func (r ApiWalletServiceCreateAddressRequest) Body(body TgvalidatordCreateAddressRequest) ApiWalletServiceCreateAddressRequest {
	r.body = &body
	return r
}

func (r ApiWalletServiceCreateAddressRequest) Execute() (*TgvalidatordCreateAddressReply, *http.Response, error) {
	return r.ApiService.WalletServiceCreateAddressExecute(r)
}

/*
WalletServiceCreateAddress Create an address

This endpoint creates a new address within a specified Wallet. All addresses _must_ be associated with a parent wallet. Addresses created with this endpoint are internal to Protect. To create an external address, you need to create a [whitelisted address request](https://docs.taurushq.com/protect-capital/reference/whitelistservice_createwhitelistedaddress).

For more information about whitelisted assets, see our [user guides](https://docs.taurushq.com/user-and-technical-guides/docs/smart-contracts).

Address creation requires HSM signature, which makes it synchronous. Therefore, address creation can be slow, and failures may occur if the HSM is either unavailable or takes too long to process. If this happens, the API can be safely called again.

**Required role:** AccountCreator.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiWalletServiceCreateAddressRequest
*/
func (a *AddressesAPIService) WalletServiceCreateAddress(ctx context.Context) ApiWalletServiceCreateAddressRequest {
	return ApiWalletServiceCreateAddressRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return TgvalidatordCreateAddressReply
func (a *AddressesAPIService) WalletServiceCreateAddressExecute(r ApiWalletServiceCreateAddressRequest) (*TgvalidatordCreateAddressReply, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *TgvalidatordCreateAddressReply
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AddressesAPIService.WalletServiceCreateAddress")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/rest/v1/addresses"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.body == nil {
		return localVarReturnValue, nil, reportError("body is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["ApiKeyTPV1"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v map[string]interface{}
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v map[string]interface{}
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v map[string]interface{}
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v map[string]interface{}
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v map[string]interface{}
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 503 {
			var v map[string]interface{}
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
			var v GooglerpcStatus
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiWalletServiceCreateAddressAttributesRequest struct {
	ctx context.Context
	ApiService *AddressesAPIService
	addressId string
	body *WalletServiceCreateAddressAttributesBody
}

func (r ApiWalletServiceCreateAddressAttributesRequest) Body(body WalletServiceCreateAddressAttributesBody) ApiWalletServiceCreateAddressAttributesRequest {
	r.body = &body
	return r
}

func (r ApiWalletServiceCreateAddressAttributesRequest) Execute() (*TgvalidatordCreateAddressAttributesReply, *http.Response, error) {
	return r.ApiService.WalletServiceCreateAddressAttributesExecute(r)
}

/*
WalletServiceCreateAddressAttributes Create attributes

This endpoint creates attributes for a given address. 
 Required role: **AccountCreator**.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param addressId
 @return ApiWalletServiceCreateAddressAttributesRequest
*/
func (a *AddressesAPIService) WalletServiceCreateAddressAttributes(ctx context.Context, addressId string) ApiWalletServiceCreateAddressAttributesRequest {
	return ApiWalletServiceCreateAddressAttributesRequest{
		ApiService: a,
		ctx: ctx,
		addressId: addressId,
	}
}

// Execute executes the request
//  @return TgvalidatordCreateAddressAttributesReply
func (a *AddressesAPIService) WalletServiceCreateAddressAttributesExecute(r ApiWalletServiceCreateAddressAttributesRequest) (*TgvalidatordCreateAddressAttributesReply, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *TgvalidatordCreateAddressAttributesReply
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AddressesAPIService.WalletServiceCreateAddressAttributes")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/rest/v1/addresses/{addressId}/attributes"
	localVarPath = strings.Replace(localVarPath, "{"+"addressId"+"}", url.PathEscape(parameterValueToString(r.addressId, "addressId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.body == nil {
		return localVarReturnValue, nil, reportError("body is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["ApiKeyTPV1"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v map[string]interface{}
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v map[string]interface{}
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v map[string]interface{}
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v map[string]interface{}
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v map[string]interface{}
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 503 {
			var v map[string]interface{}
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
			var v GooglerpcStatus
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiWalletServiceCreateAddressesBatchRequest struct {
	ctx context.Context
	ApiService *AddressesAPIService
	body *TgvalidatordCreateAddressesRequest
}

func (r ApiWalletServiceCreateAddressesBatchRequest) Body(body TgvalidatordCreateAddressesRequest) ApiWalletServiceCreateAddressesBatchRequest {
	r.body = &body
	return r
}

func (r ApiWalletServiceCreateAddressesBatchRequest) Execute() (*TgvalidatordCreateAddressesReply, *http.Response, error) {
	return r.ApiService.WalletServiceCreateAddressesBatchExecute(r)
}

/*
WalletServiceCreateAddressesBatch Create a batch of addresses

Required role: **AccountCreator**. 
 This endpoint creates a batch of addresses. 
 Address created from this endpoint will start with a **created** and will not be ready to use until the HSM process them. 

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiWalletServiceCreateAddressesBatchRequest
*/
func (a *AddressesAPIService) WalletServiceCreateAddressesBatch(ctx context.Context) ApiWalletServiceCreateAddressesBatchRequest {
	return ApiWalletServiceCreateAddressesBatchRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return TgvalidatordCreateAddressesReply
func (a *AddressesAPIService) WalletServiceCreateAddressesBatchExecute(r ApiWalletServiceCreateAddressesBatchRequest) (*TgvalidatordCreateAddressesReply, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *TgvalidatordCreateAddressesReply
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AddressesAPIService.WalletServiceCreateAddressesBatch")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/rest/v1/addresses/batch"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.body == nil {
		return localVarReturnValue, nil, reportError("body is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["ApiKeyTPV1"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v map[string]interface{}
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v map[string]interface{}
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v map[string]interface{}
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v map[string]interface{}
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v map[string]interface{}
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 503 {
			var v map[string]interface{}
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
			var v GooglerpcStatus
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiWalletServiceDeleteAddressAttributeRequest struct {
	ctx context.Context
	ApiService *AddressesAPIService
	addressId string
	id string
}

func (r ApiWalletServiceDeleteAddressAttributeRequest) Execute() (map[string]interface{}, *http.Response, error) {
	return r.ApiService.WalletServiceDeleteAddressAttributeExecute(r)
}

/*
WalletServiceDeleteAddressAttribute Delete an attribute

This endpoint deletes an attribute of a given address. 
 Required role: **AccountCreator**.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param addressId
 @param id
 @return ApiWalletServiceDeleteAddressAttributeRequest
*/
func (a *AddressesAPIService) WalletServiceDeleteAddressAttribute(ctx context.Context, addressId string, id string) ApiWalletServiceDeleteAddressAttributeRequest {
	return ApiWalletServiceDeleteAddressAttributeRequest{
		ApiService: a,
		ctx: ctx,
		addressId: addressId,
		id: id,
	}
}

// Execute executes the request
//  @return map[string]interface{}
func (a *AddressesAPIService) WalletServiceDeleteAddressAttributeExecute(r ApiWalletServiceDeleteAddressAttributeRequest) (map[string]interface{}, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  map[string]interface{}
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AddressesAPIService.WalletServiceDeleteAddressAttribute")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/rest/v1/addresses/{addressId}/attributes/{id}"
	localVarPath = strings.Replace(localVarPath, "{"+"addressId"+"}", url.PathEscape(parameterValueToString(r.addressId, "addressId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["ApiKeyTPV1"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v map[string]interface{}
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v map[string]interface{}
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v map[string]interface{}
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v map[string]interface{}
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v map[string]interface{}
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 503 {
			var v map[string]interface{}
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
			var v GooglerpcStatus
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiWalletServiceETHSignMessageRequest struct {
	ctx context.Context
	ApiService *AddressesAPIService
	addressId string
	message *string
}

func (r ApiWalletServiceETHSignMessageRequest) Message(message string) ApiWalletServiceETHSignMessageRequest {
	r.message = &message
	return r
}

func (r ApiWalletServiceETHSignMessageRequest) Execute() (*TgvalidatordETHSignMessageReply, *http.Response, error) {
	return r.ApiService.WalletServiceETHSignMessageExecute(r)
}

/*
WalletServiceETHSignMessage Calculate an ETH specific signature of a message

This endpoint returns an ETH specific signature from a given message and address as input.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param addressId
 @return ApiWalletServiceETHSignMessageRequest
*/
func (a *AddressesAPIService) WalletServiceETHSignMessage(ctx context.Context, addressId string) ApiWalletServiceETHSignMessageRequest {
	return ApiWalletServiceETHSignMessageRequest{
		ApiService: a,
		ctx: ctx,
		addressId: addressId,
	}
}

// Execute executes the request
//  @return TgvalidatordETHSignMessageReply
func (a *AddressesAPIService) WalletServiceETHSignMessageExecute(r ApiWalletServiceETHSignMessageRequest) (*TgvalidatordETHSignMessageReply, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *TgvalidatordETHSignMessageReply
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AddressesAPIService.WalletServiceETHSignMessage")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/rest/v1/addresses/{addressId}/eth_sign"
	localVarPath = strings.Replace(localVarPath, "{"+"addressId"+"}", url.PathEscape(parameterValueToString(r.addressId, "addressId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.message != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "message", r.message, "", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["ApiKeyTPV1"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v map[string]interface{}
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v map[string]interface{}
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v map[string]interface{}
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v map[string]interface{}
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v map[string]interface{}
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 503 {
			var v map[string]interface{}
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
			var v GooglerpcStatus
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiWalletServiceExportAddressBalanceHistoryRequest struct {
	ctx context.Context
	ApiService *AddressesAPIService
	id string
	intervalHours *string
	format *string
}

func (r ApiWalletServiceExportAddressBalanceHistoryRequest) IntervalHours(intervalHours string) ApiWalletServiceExportAddressBalanceHistoryRequest {
	r.intervalHours = &intervalHours
	return r
}

// Desired file format, can be csv or json.
func (r ApiWalletServiceExportAddressBalanceHistoryRequest) Format(format string) ApiWalletServiceExportAddressBalanceHistoryRequest {
	r.format = &format
	return r
}

func (r ApiWalletServiceExportAddressBalanceHistoryRequest) Execute() (*TgvalidatordExportAddressBalanceHistoryReply, *http.Response, error) {
	return r.ApiService.WalletServiceExportAddressBalanceHistoryExecute(r)
}

/*
WalletServiceExportAddressBalanceHistory Export address' balances history

This endpoint exports a list of address' balances history

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id Desired address ID
 @return ApiWalletServiceExportAddressBalanceHistoryRequest
*/
func (a *AddressesAPIService) WalletServiceExportAddressBalanceHistory(ctx context.Context, id string) ApiWalletServiceExportAddressBalanceHistoryRequest {
	return ApiWalletServiceExportAddressBalanceHistoryRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
//  @return TgvalidatordExportAddressBalanceHistoryReply
func (a *AddressesAPIService) WalletServiceExportAddressBalanceHistoryExecute(r ApiWalletServiceExportAddressBalanceHistoryRequest) (*TgvalidatordExportAddressBalanceHistoryReply, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *TgvalidatordExportAddressBalanceHistoryReply
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AddressesAPIService.WalletServiceExportAddressBalanceHistory")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/rest/v1/addresses/{id}/balances/history/export"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.intervalHours != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "intervalHours", r.intervalHours, "", "")
	}
	if r.format != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "format", r.format, "", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["ApiKeyTPV1"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v map[string]interface{}
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v map[string]interface{}
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v map[string]interface{}
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v map[string]interface{}
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v map[string]interface{}
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 503 {
			var v map[string]interface{}
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
			var v GooglerpcStatus
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiWalletServiceExportAddressesRequest struct {
	ctx context.Context
	ApiService *AddressesAPIService
	walletId *string
	currency *string
	format *string
	query *string
	scoreProvider *string
	scoreInBelow *string
	scoreOutBelow *string
	scoreExclusive *bool
	customerId *string
	coinfirmScoreGreater *string
	chainalysisScoreGreater *string
	scoreFilterScoreProvider *string
	scoreFilterScorechainFiltersScoreInBelow *string
	scoreFilterScorechainFiltersScoreOutBelow *string
	scoreFilterScorechainFiltersScoreExclusive *bool
	scoreFilterCoinfirmFiltersScoreGreater *string
	scoreFilterChainalysisFiltersScoreGreater *string
	scoreFilterEllipticFiltersScoreGreater *string
	scoreFilterTrmlabsFiltersScoreGreater *string
	blockchain *string
	network *string
}

func (r ApiWalletServiceExportAddressesRequest) WalletId(walletId string) ApiWalletServiceExportAddressesRequest {
	r.walletId = &walletId
	return r
}

// Filter on ID or symbol of the currency
func (r ApiWalletServiceExportAddressesRequest) Currency(currency string) ApiWalletServiceExportAddressesRequest {
	r.currency = &currency
	return r
}

// Desired file format, can be csv or json.
func (r ApiWalletServiceExportAddressesRequest) Format(format string) ApiWalletServiceExportAddressesRequest {
	r.format = &format
	return r
}

func (r ApiWalletServiceExportAddressesRequest) Query(query string) ApiWalletServiceExportAddressesRequest {
	r.query = &query
	return r
}

// Deprecated. Use scoreFilter instead.
func (r ApiWalletServiceExportAddressesRequest) ScoreProvider(scoreProvider string) ApiWalletServiceExportAddressesRequest {
	r.scoreProvider = &scoreProvider
	return r
}

// Deprecated. Use scoreFilter instead.
func (r ApiWalletServiceExportAddressesRequest) ScoreInBelow(scoreInBelow string) ApiWalletServiceExportAddressesRequest {
	r.scoreInBelow = &scoreInBelow
	return r
}

// Deprecated. Use scoreFilter instead.
func (r ApiWalletServiceExportAddressesRequest) ScoreOutBelow(scoreOutBelow string) ApiWalletServiceExportAddressesRequest {
	r.scoreOutBelow = &scoreOutBelow
	return r
}

// Deprecated. Use scoreFilter instead.
func (r ApiWalletServiceExportAddressesRequest) ScoreExclusive(scoreExclusive bool) ApiWalletServiceExportAddressesRequest {
	r.scoreExclusive = &scoreExclusive
	return r
}

func (r ApiWalletServiceExportAddressesRequest) CustomerId(customerId string) ApiWalletServiceExportAddressesRequest {
	r.customerId = &customerId
	return r
}

// Deprecated. Use scoreFilter instead.
func (r ApiWalletServiceExportAddressesRequest) CoinfirmScoreGreater(coinfirmScoreGreater string) ApiWalletServiceExportAddressesRequest {
	r.coinfirmScoreGreater = &coinfirmScoreGreater
	return r
}

// Deprecated. Use scoreFilter instead.
func (r ApiWalletServiceExportAddressesRequest) ChainalysisScoreGreater(chainalysisScoreGreater string) ApiWalletServiceExportAddressesRequest {
	r.chainalysisScoreGreater = &chainalysisScoreGreater
	return r
}

// Specify the score provider to filter on, or empty.Each provider has associated filter parameters that can be set.Supported values: &#x60;scorechain&#x60;, &#x60;coinfirm&#x60;, &#x60;chainalysis&#x60;, &#x60;elliptic&#x60;, &#x60;trmlabs&#x60;
func (r ApiWalletServiceExportAddressesRequest) ScoreFilterScoreProvider(scoreFilterScoreProvider string) ApiWalletServiceExportAddressesRequest {
	r.scoreFilterScoreProvider = &scoreFilterScoreProvider
	return r
}

// Filter addresses under a Scorechain incoming score threshold.
func (r ApiWalletServiceExportAddressesRequest) ScoreFilterScorechainFiltersScoreInBelow(scoreFilterScorechainFiltersScoreInBelow string) ApiWalletServiceExportAddressesRequest {
	r.scoreFilterScorechainFiltersScoreInBelow = &scoreFilterScorechainFiltersScoreInBelow
	return r
}

// Filter addresses under a Scorechain outgoing score threshold.
func (r ApiWalletServiceExportAddressesRequest) ScoreFilterScorechainFiltersScoreOutBelow(scoreFilterScorechainFiltersScoreOutBelow string) ApiWalletServiceExportAddressesRequest {
	r.scoreFilterScorechainFiltersScoreOutBelow = &scoreFilterScorechainFiltersScoreOutBelow
	return r
}

// By default when both Scorechain scores scoreInBelow and scoreOutBelow are provided, it returns the addresses matching (scoreInBelow AND scoreOutBelow). When scoreExclusive is set to true, it will return the addresses matching (scoreInBelow OR scoreOutBelow).
func (r ApiWalletServiceExportAddressesRequest) ScoreFilterScorechainFiltersScoreExclusive(scoreFilterScorechainFiltersScoreExclusive bool) ApiWalletServiceExportAddressesRequest {
	r.scoreFilterScorechainFiltersScoreExclusive = &scoreFilterScorechainFiltersScoreExclusive
	return r
}

// Filter addresses with a Coinfirm C-score above threshold.
func (r ApiWalletServiceExportAddressesRequest) ScoreFilterCoinfirmFiltersScoreGreater(scoreFilterCoinfirmFiltersScoreGreater string) ApiWalletServiceExportAddressesRequest {
	r.scoreFilterCoinfirmFiltersScoreGreater = &scoreFilterCoinfirmFiltersScoreGreater
	return r
}

// Filter addresses with a Chainalysis risk score above threshold.
func (r ApiWalletServiceExportAddressesRequest) ScoreFilterChainalysisFiltersScoreGreater(scoreFilterChainalysisFiltersScoreGreater string) ApiWalletServiceExportAddressesRequest {
	r.scoreFilterChainalysisFiltersScoreGreater = &scoreFilterChainalysisFiltersScoreGreater
	return r
}

// Filter addresses with an Elliptic risk score above threshold.
func (r ApiWalletServiceExportAddressesRequest) ScoreFilterEllipticFiltersScoreGreater(scoreFilterEllipticFiltersScoreGreater string) ApiWalletServiceExportAddressesRequest {
	r.scoreFilterEllipticFiltersScoreGreater = &scoreFilterEllipticFiltersScoreGreater
	return r
}

// Filter addresses with an TRM Labs risk score above threshold.
func (r ApiWalletServiceExportAddressesRequest) ScoreFilterTrmlabsFiltersScoreGreater(scoreFilterTrmlabsFiltersScoreGreater string) ApiWalletServiceExportAddressesRequest {
	r.scoreFilterTrmlabsFiltersScoreGreater = &scoreFilterTrmlabsFiltersScoreGreater
	return r
}

func (r ApiWalletServiceExportAddressesRequest) Blockchain(blockchain string) ApiWalletServiceExportAddressesRequest {
	r.blockchain = &blockchain
	return r
}

func (r ApiWalletServiceExportAddressesRequest) Network(network string) ApiWalletServiceExportAddressesRequest {
	r.network = &network
	return r
}

func (r ApiWalletServiceExportAddressesRequest) Execute() (*TgvalidatordExportAddressesReply, *http.Response, error) {
	return r.ApiService.WalletServiceExportAddressesExecute(r)
}

/*
WalletServiceExportAddresses Export addresses

This endpoint exports a list of addresses

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiWalletServiceExportAddressesRequest
*/
func (a *AddressesAPIService) WalletServiceExportAddresses(ctx context.Context) ApiWalletServiceExportAddressesRequest {
	return ApiWalletServiceExportAddressesRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return TgvalidatordExportAddressesReply
func (a *AddressesAPIService) WalletServiceExportAddressesExecute(r ApiWalletServiceExportAddressesRequest) (*TgvalidatordExportAddressesReply, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *TgvalidatordExportAddressesReply
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AddressesAPIService.WalletServiceExportAddresses")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/rest/v1/addresses/export"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.walletId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "walletId", r.walletId, "", "")
	}
	if r.currency != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "currency", r.currency, "", "")
	}
	if r.format != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "format", r.format, "", "")
	}
	if r.query != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "query", r.query, "", "")
	}
	if r.scoreProvider != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "scoreProvider", r.scoreProvider, "", "")
	}
	if r.scoreInBelow != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "scoreInBelow", r.scoreInBelow, "", "")
	}
	if r.scoreOutBelow != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "scoreOutBelow", r.scoreOutBelow, "", "")
	}
	if r.scoreExclusive != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "scoreExclusive", r.scoreExclusive, "", "")
	}
	if r.customerId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "customerId", r.customerId, "", "")
	}
	if r.coinfirmScoreGreater != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "coinfirmScoreGreater", r.coinfirmScoreGreater, "", "")
	}
	if r.chainalysisScoreGreater != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "chainalysisScoreGreater", r.chainalysisScoreGreater, "", "")
	}
	if r.scoreFilterScoreProvider != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "scoreFilter.scoreProvider", r.scoreFilterScoreProvider, "", "")
	}
	if r.scoreFilterScorechainFiltersScoreInBelow != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "scoreFilter.scorechainFilters.scoreInBelow", r.scoreFilterScorechainFiltersScoreInBelow, "", "")
	}
	if r.scoreFilterScorechainFiltersScoreOutBelow != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "scoreFilter.scorechainFilters.scoreOutBelow", r.scoreFilterScorechainFiltersScoreOutBelow, "", "")
	}
	if r.scoreFilterScorechainFiltersScoreExclusive != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "scoreFilter.scorechainFilters.scoreExclusive", r.scoreFilterScorechainFiltersScoreExclusive, "", "")
	}
	if r.scoreFilterCoinfirmFiltersScoreGreater != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "scoreFilter.coinfirmFilters.scoreGreater", r.scoreFilterCoinfirmFiltersScoreGreater, "", "")
	}
	if r.scoreFilterChainalysisFiltersScoreGreater != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "scoreFilter.chainalysisFilters.scoreGreater", r.scoreFilterChainalysisFiltersScoreGreater, "", "")
	}
	if r.scoreFilterEllipticFiltersScoreGreater != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "scoreFilter.ellipticFilters.scoreGreater", r.scoreFilterEllipticFiltersScoreGreater, "", "")
	}
	if r.scoreFilterTrmlabsFiltersScoreGreater != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "scoreFilter.trmlabsFilters.scoreGreater", r.scoreFilterTrmlabsFiltersScoreGreater, "", "")
	}
	if r.blockchain != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "blockchain", r.blockchain, "", "")
	}
	if r.network != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "network", r.network, "", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["ApiKeyTPV1"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v map[string]interface{}
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v map[string]interface{}
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v map[string]interface{}
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v map[string]interface{}
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v map[string]interface{}
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 503 {
			var v map[string]interface{}
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
			var v GooglerpcStatus
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiWalletServiceGetAddressRequest struct {
	ctx context.Context
	ApiService *AddressesAPIService
	id string
}

func (r ApiWalletServiceGetAddressRequest) Execute() (*TgvalidatordGetAddressReply, *http.Response, error) {
	return r.ApiService.WalletServiceGetAddressExecute(r)
}

/*
WalletServiceGetAddress Get an address

This endpoint accepts a unique address ID and returns the address alongside related information including:

* additional risk score data (if applicable).
* information about the related wallet and currency.
* related whitelisted address IDs.

To search across all addresses with query parameters, use the [List Addresses](https://docs.taurushq.com/protect-capital/reference/walletservice_getaddresses) endpoint.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id
 @return ApiWalletServiceGetAddressRequest
*/
func (a *AddressesAPIService) WalletServiceGetAddress(ctx context.Context, id string) ApiWalletServiceGetAddressRequest {
	return ApiWalletServiceGetAddressRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
//  @return TgvalidatordGetAddressReply
func (a *AddressesAPIService) WalletServiceGetAddressExecute(r ApiWalletServiceGetAddressRequest) (*TgvalidatordGetAddressReply, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *TgvalidatordGetAddressReply
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AddressesAPIService.WalletServiceGetAddress")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/rest/v1/addresses/{id}"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["ApiKeyTPV1"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v map[string]interface{}
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v map[string]interface{}
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v map[string]interface{}
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v map[string]interface{}
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v map[string]interface{}
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 503 {
			var v map[string]interface{}
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
			var v GooglerpcStatus
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiWalletServiceGetAddressBalanceHistoryRequest struct {
	ctx context.Context
	ApiService *AddressesAPIService
	id string
	intervalHours *string
}

func (r ApiWalletServiceGetAddressBalanceHistoryRequest) IntervalHours(intervalHours string) ApiWalletServiceGetAddressBalanceHistoryRequest {
	r.intervalHours = &intervalHours
	return r
}

func (r ApiWalletServiceGetAddressBalanceHistoryRequest) Execute() (*TgvalidatordGetAddressBalanceHistoryReply, *http.Response, error) {
	return r.ApiService.WalletServiceGetAddressBalanceHistoryExecute(r)
}

/*
WalletServiceGetAddressBalanceHistory List address' balances history

This endpoint returns the balances history of a given address

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id
 @return ApiWalletServiceGetAddressBalanceHistoryRequest
*/
func (a *AddressesAPIService) WalletServiceGetAddressBalanceHistory(ctx context.Context, id string) ApiWalletServiceGetAddressBalanceHistoryRequest {
	return ApiWalletServiceGetAddressBalanceHistoryRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
//  @return TgvalidatordGetAddressBalanceHistoryReply
func (a *AddressesAPIService) WalletServiceGetAddressBalanceHistoryExecute(r ApiWalletServiceGetAddressBalanceHistoryRequest) (*TgvalidatordGetAddressBalanceHistoryReply, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *TgvalidatordGetAddressBalanceHistoryReply
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AddressesAPIService.WalletServiceGetAddressBalanceHistory")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/rest/v1/addresses/{id}/balances/history"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.intervalHours != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "intervalHours", r.intervalHours, "", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["ApiKeyTPV1"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v map[string]interface{}
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v map[string]interface{}
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v map[string]interface{}
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v map[string]interface{}
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v map[string]interface{}
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 503 {
			var v map[string]interface{}
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
			var v GooglerpcStatus
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiWalletServiceGetAddressProofOfReserveRequest struct {
	ctx context.Context
	ApiService *AddressesAPIService
	id string
	challenge *string
}

func (r ApiWalletServiceGetAddressProofOfReserveRequest) Challenge(challenge string) ApiWalletServiceGetAddressProofOfReserveRequest {
	r.challenge = &challenge
	return r
}

func (r ApiWalletServiceGetAddressProofOfReserveRequest) Execute() (*TgvalidatordGetAddressProofOfReserveReply, *http.Response, error) {
	return r.ApiService.WalletServiceGetAddressProofOfReserveExecute(r)
}

/*
WalletServiceGetAddressProofOfReserve Get the proof of reserve of an address

This endpoint returns the proof of reserve of an address. The relevance of response fields is specific to the request type.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id
 @return ApiWalletServiceGetAddressProofOfReserveRequest
*/
func (a *AddressesAPIService) WalletServiceGetAddressProofOfReserve(ctx context.Context, id string) ApiWalletServiceGetAddressProofOfReserveRequest {
	return ApiWalletServiceGetAddressProofOfReserveRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
//  @return TgvalidatordGetAddressProofOfReserveReply
func (a *AddressesAPIService) WalletServiceGetAddressProofOfReserveExecute(r ApiWalletServiceGetAddressProofOfReserveRequest) (*TgvalidatordGetAddressProofOfReserveReply, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *TgvalidatordGetAddressProofOfReserveReply
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AddressesAPIService.WalletServiceGetAddressProofOfReserve")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/rest/v1/addresses/{id}/proofofreserve"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.challenge != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "challenge", r.challenge, "", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["ApiKeyTPV1"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v map[string]interface{}
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v map[string]interface{}
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v map[string]interface{}
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v map[string]interface{}
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v map[string]interface{}
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 503 {
			var v map[string]interface{}
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
			var v GooglerpcStatus
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiWalletServiceGetAddressTokensRequest struct {
	ctx context.Context
	ApiService *AddressesAPIService
	id string
	limit *string
	cursor *string
}

func (r ApiWalletServiceGetAddressTokensRequest) Limit(limit string) ApiWalletServiceGetAddressTokensRequest {
	r.limit = &limit
	return r
}

func (r ApiWalletServiceGetAddressTokensRequest) Cursor(cursor string) ApiWalletServiceGetAddressTokensRequest {
	r.cursor = &cursor
	return r
}

func (r ApiWalletServiceGetAddressTokensRequest) Execute() (*TgvalidatordGetAddressTokensReply, *http.Response, error) {
	return r.ApiService.WalletServiceGetAddressTokensExecute(r)
}

/*
WalletServiceGetAddressTokens Get the list of tokens for an address

This endpoint returns the list of tokens with their balances held by a given address.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id
 @return ApiWalletServiceGetAddressTokensRequest
*/
func (a *AddressesAPIService) WalletServiceGetAddressTokens(ctx context.Context, id string) ApiWalletServiceGetAddressTokensRequest {
	return ApiWalletServiceGetAddressTokensRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
//  @return TgvalidatordGetAddressTokensReply
func (a *AddressesAPIService) WalletServiceGetAddressTokensExecute(r ApiWalletServiceGetAddressTokensRequest) (*TgvalidatordGetAddressTokensReply, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *TgvalidatordGetAddressTokensReply
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AddressesAPIService.WalletServiceGetAddressTokens")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/rest/v1/addresses/{id}/tokens"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.limit != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "limit", r.limit, "", "")
	}
	if r.cursor != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "cursor", r.cursor, "", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["ApiKeyTPV1"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v map[string]interface{}
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v map[string]interface{}
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v map[string]interface{}
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v map[string]interface{}
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v map[string]interface{}
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 503 {
			var v map[string]interface{}
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
			var v GooglerpcStatus
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiWalletServiceGetAddressUTXOsRequest struct {
	ctx context.Context
	ApiService *AddressesAPIService
	id string
}

func (r ApiWalletServiceGetAddressUTXOsRequest) Execute() (*TgvalidatordGetAddressUTXOsReply, *http.Response, error) {
	return r.ApiService.WalletServiceGetAddressUTXOsExecute(r)
}

/*
WalletServiceGetAddressUTXOs List UTXOs of an address

This endpoint returns a list of UTXOs of a given address. In the case of the ADA blockchain, the value returned is the one from the native currency. Result is sorted by (address, id) DESC.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id
 @return ApiWalletServiceGetAddressUTXOsRequest
*/
func (a *AddressesAPIService) WalletServiceGetAddressUTXOs(ctx context.Context, id string) ApiWalletServiceGetAddressUTXOsRequest {
	return ApiWalletServiceGetAddressUTXOsRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
//  @return TgvalidatordGetAddressUTXOsReply
func (a *AddressesAPIService) WalletServiceGetAddressUTXOsExecute(r ApiWalletServiceGetAddressUTXOsRequest) (*TgvalidatordGetAddressUTXOsReply, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *TgvalidatordGetAddressUTXOsReply
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AddressesAPIService.WalletServiceGetAddressUTXOs")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/rest/v1/addresses/{id}/utxos"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["ApiKeyTPV1"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v map[string]interface{}
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v map[string]interface{}
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v map[string]interface{}
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v map[string]interface{}
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v map[string]interface{}
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 503 {
			var v map[string]interface{}
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
			var v GooglerpcStatus
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiWalletServiceGetAddressesRequest struct {
	ctx context.Context
	ApiService *AddressesAPIService
	currency *string
	query *string
	limit *string
	offset *string
	scoreProvider *string
	scoreInBelow *string
	scoreOutBelow *string
	scoreExclusive *bool
	onlyPositiveBalance *bool
	sortBy *string
	sortOrder *string
	balanceBelow *string
	balanceAbove *string
	walletId *string
	customerId *string
	coinfirmScoreGreater *string
	chainalysisScoreGreater *string
	tagIDs *[]string
	blockchain *string
	network *string
	addressIds *[]string
	nfts *string
	addresses *[]string
	scoreFilterScoreProvider *string
	scoreFilterScorechainFiltersScoreInBelow *string
	scoreFilterScorechainFiltersScoreOutBelow *string
	scoreFilterScorechainFiltersScoreExclusive *bool
	scoreFilterCoinfirmFiltersScoreGreater *string
	scoreFilterChainalysisFiltersScoreGreater *string
	scoreFilterEllipticFiltersScoreGreater *string
	scoreFilterTrmlabsFiltersScoreGreater *string
	attributeFiltersJson *string
	attributeFiltersOperator *string
}

// Filter on IDs or symbols of the currency
func (r ApiWalletServiceGetAddressesRequest) Currency(currency string) ApiWalletServiceGetAddressesRequest {
	r.currency = &currency
	return r
}

func (r ApiWalletServiceGetAddressesRequest) Query(query string) ApiWalletServiceGetAddressesRequest {
	r.query = &query
	return r
}

func (r ApiWalletServiceGetAddressesRequest) Limit(limit string) ApiWalletServiceGetAddressesRequest {
	r.limit = &limit
	return r
}

func (r ApiWalletServiceGetAddressesRequest) Offset(offset string) ApiWalletServiceGetAddressesRequest {
	r.offset = &offset
	return r
}

// Deprecated. Use scoreFilter instead.
func (r ApiWalletServiceGetAddressesRequest) ScoreProvider(scoreProvider string) ApiWalletServiceGetAddressesRequest {
	r.scoreProvider = &scoreProvider
	return r
}

// Deprecated. Use scoreFilter instead.
func (r ApiWalletServiceGetAddressesRequest) ScoreInBelow(scoreInBelow string) ApiWalletServiceGetAddressesRequest {
	r.scoreInBelow = &scoreInBelow
	return r
}

// Deprecated. Use scoreFilter instead.
func (r ApiWalletServiceGetAddressesRequest) ScoreOutBelow(scoreOutBelow string) ApiWalletServiceGetAddressesRequest {
	r.scoreOutBelow = &scoreOutBelow
	return r
}

// Deprecated. Use scoreFilter instead.
func (r ApiWalletServiceGetAddressesRequest) ScoreExclusive(scoreExclusive bool) ApiWalletServiceGetAddressesRequest {
	r.scoreExclusive = &scoreExclusive
	return r
}

// Set this parameter to true to get only addresses with a positive unconfirmed balance
func (r ApiWalletServiceGetAddressesRequest) OnlyPositiveBalance(onlyPositiveBalance bool) ApiWalletServiceGetAddressesRequest {
	r.onlyPositiveBalance = &onlyPositiveBalance
	return r
}

// Set this parameter to select the type on which you want to sort.The types accepted yet are: BALANCE and ADDRESSID
func (r ApiWalletServiceGetAddressesRequest) SortBy(sortBy string) ApiWalletServiceGetAddressesRequest {
	r.sortBy = &sortBy
	return r
}

// Set this parameter to ASC to get the addresses sorted in ascending order or DESC to get them in descending order.
func (r ApiWalletServiceGetAddressesRequest) SortOrder(sortOrder string) ApiWalletServiceGetAddressesRequest {
	r.sortOrder = &sortOrder
	return r
}

// Filter addresses and keep only addresses with a balance below the threshold.
func (r ApiWalletServiceGetAddressesRequest) BalanceBelow(balanceBelow string) ApiWalletServiceGetAddressesRequest {
	r.balanceBelow = &balanceBelow
	return r
}

// Filter addresses and keep only addresses with a balance above the threshold.
func (r ApiWalletServiceGetAddressesRequest) BalanceAbove(balanceAbove string) ApiWalletServiceGetAddressesRequest {
	r.balanceAbove = &balanceAbove
	return r
}

func (r ApiWalletServiceGetAddressesRequest) WalletId(walletId string) ApiWalletServiceGetAddressesRequest {
	r.walletId = &walletId
	return r
}

func (r ApiWalletServiceGetAddressesRequest) CustomerId(customerId string) ApiWalletServiceGetAddressesRequest {
	r.customerId = &customerId
	return r
}

// Deprecated. Use scoreFilter instead.
func (r ApiWalletServiceGetAddressesRequest) CoinfirmScoreGreater(coinfirmScoreGreater string) ApiWalletServiceGetAddressesRequest {
	r.coinfirmScoreGreater = &coinfirmScoreGreater
	return r
}

// Deprecated. Use scoreFilter instead.
func (r ApiWalletServiceGetAddressesRequest) ChainalysisScoreGreater(chainalysisScoreGreater string) ApiWalletServiceGetAddressesRequest {
	r.chainalysisScoreGreater = &chainalysisScoreGreater
	return r
}

// Filter addresses with a &#39;OR&#39; combination of tag IDs
func (r ApiWalletServiceGetAddressesRequest) TagIDs(tagIDs []string) ApiWalletServiceGetAddressesRequest {
	r.tagIDs = &tagIDs
	return r
}

func (r ApiWalletServiceGetAddressesRequest) Blockchain(blockchain string) ApiWalletServiceGetAddressesRequest {
	r.blockchain = &blockchain
	return r
}

func (r ApiWalletServiceGetAddressesRequest) Network(network string) ApiWalletServiceGetAddressesRequest {
	r.network = &network
	return r
}

// Filter addresses with a list of address IDs.
func (r ApiWalletServiceGetAddressesRequest) AddressIds(addressIds []string) ApiWalletServiceGetAddressesRequest {
	r.addressIds = &addressIds
	return r
}

// One of include / exclude / only depending on whether you want to include addresses of type NFTs (or you want only those)
func (r ApiWalletServiceGetAddressesRequest) Nfts(nfts string) ApiWalletServiceGetAddressesRequest {
	r.nfts = &nfts
	return r
}

// Filter addresses with a list of blockchain addresses (hashes).The blockchain needs to be specified when using this filter.
func (r ApiWalletServiceGetAddressesRequest) Addresses(addresses []string) ApiWalletServiceGetAddressesRequest {
	r.addresses = &addresses
	return r
}

// Specify the score provider to filter on, or empty.Each provider has associated filter parameters that can be set.Supported values: &#x60;scorechain&#x60;, &#x60;coinfirm&#x60;, &#x60;chainalysis&#x60;, &#x60;elliptic&#x60;, &#x60;trmlabs&#x60;
func (r ApiWalletServiceGetAddressesRequest) ScoreFilterScoreProvider(scoreFilterScoreProvider string) ApiWalletServiceGetAddressesRequest {
	r.scoreFilterScoreProvider = &scoreFilterScoreProvider
	return r
}

// Filter addresses under a Scorechain incoming score threshold.
func (r ApiWalletServiceGetAddressesRequest) ScoreFilterScorechainFiltersScoreInBelow(scoreFilterScorechainFiltersScoreInBelow string) ApiWalletServiceGetAddressesRequest {
	r.scoreFilterScorechainFiltersScoreInBelow = &scoreFilterScorechainFiltersScoreInBelow
	return r
}

// Filter addresses under a Scorechain outgoing score threshold.
func (r ApiWalletServiceGetAddressesRequest) ScoreFilterScorechainFiltersScoreOutBelow(scoreFilterScorechainFiltersScoreOutBelow string) ApiWalletServiceGetAddressesRequest {
	r.scoreFilterScorechainFiltersScoreOutBelow = &scoreFilterScorechainFiltersScoreOutBelow
	return r
}

// By default when both Scorechain scores scoreInBelow and scoreOutBelow are provided, it returns the addresses matching (scoreInBelow AND scoreOutBelow). When scoreExclusive is set to true, it will return the addresses matching (scoreInBelow OR scoreOutBelow).
func (r ApiWalletServiceGetAddressesRequest) ScoreFilterScorechainFiltersScoreExclusive(scoreFilterScorechainFiltersScoreExclusive bool) ApiWalletServiceGetAddressesRequest {
	r.scoreFilterScorechainFiltersScoreExclusive = &scoreFilterScorechainFiltersScoreExclusive
	return r
}

// Filter addresses with a Coinfirm C-score above threshold.
func (r ApiWalletServiceGetAddressesRequest) ScoreFilterCoinfirmFiltersScoreGreater(scoreFilterCoinfirmFiltersScoreGreater string) ApiWalletServiceGetAddressesRequest {
	r.scoreFilterCoinfirmFiltersScoreGreater = &scoreFilterCoinfirmFiltersScoreGreater
	return r
}

// Filter addresses with a Chainalysis risk score above threshold.
func (r ApiWalletServiceGetAddressesRequest) ScoreFilterChainalysisFiltersScoreGreater(scoreFilterChainalysisFiltersScoreGreater string) ApiWalletServiceGetAddressesRequest {
	r.scoreFilterChainalysisFiltersScoreGreater = &scoreFilterChainalysisFiltersScoreGreater
	return r
}

// Filter addresses with an Elliptic risk score above threshold.
func (r ApiWalletServiceGetAddressesRequest) ScoreFilterEllipticFiltersScoreGreater(scoreFilterEllipticFiltersScoreGreater string) ApiWalletServiceGetAddressesRequest {
	r.scoreFilterEllipticFiltersScoreGreater = &scoreFilterEllipticFiltersScoreGreater
	return r
}

// Filter addresses with an TRM Labs risk score above threshold.
func (r ApiWalletServiceGetAddressesRequest) ScoreFilterTrmlabsFiltersScoreGreater(scoreFilterTrmlabsFiltersScoreGreater string) ApiWalletServiceGetAddressesRequest {
	r.scoreFilterTrmlabsFiltersScoreGreater = &scoreFilterTrmlabsFiltersScoreGreater
	return r
}

// A JSON representation of a list of AttributeFilter objects. The filters are combined with an attributeFiltersOperator (&#39;OR&#39; by default). Each AttributeFilter can use different comparison operators: &#x60;&#x3D;&#x60; (default if not specified), &#x60;&lt;&gt;&#x60; (not equal), &#x60;&gt;&#x60; (greater than), &#x60;&gt;&#x3D;&#x60; (greater than or equal), &#x60;&lt;&#x60; (less than), &#x60;&lt;&#x3D;&#x60; (less than or equal)
func (r ApiWalletServiceGetAddressesRequest) AttributeFiltersJson(attributeFiltersJson string) ApiWalletServiceGetAddressesRequest {
	r.attributeFiltersJson = &attributeFiltersJson
	return r
}

// Specifies how attribute filters are combined. Accepted values: &#39;OR&#39; (default), &#39;AND&#39;.
func (r ApiWalletServiceGetAddressesRequest) AttributeFiltersOperator(attributeFiltersOperator string) ApiWalletServiceGetAddressesRequest {
	r.attributeFiltersOperator = &attributeFiltersOperator
	return r
}

func (r ApiWalletServiceGetAddressesRequest) Execute() (*TgvalidatordGetAddressesReply, *http.Response, error) {
	return r.ApiService.WalletServiceGetAddressesExecute(r)
}

/*
WalletServiceGetAddresses List addresses

This endpoint returns a list of addresses

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiWalletServiceGetAddressesRequest
*/
func (a *AddressesAPIService) WalletServiceGetAddresses(ctx context.Context) ApiWalletServiceGetAddressesRequest {
	return ApiWalletServiceGetAddressesRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return TgvalidatordGetAddressesReply
func (a *AddressesAPIService) WalletServiceGetAddressesExecute(r ApiWalletServiceGetAddressesRequest) (*TgvalidatordGetAddressesReply, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *TgvalidatordGetAddressesReply
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AddressesAPIService.WalletServiceGetAddresses")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/rest/v1/addresses"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.currency != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "currency", r.currency, "", "")
	}
	if r.query != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "query", r.query, "", "")
	}
	if r.limit != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "limit", r.limit, "", "")
	}
	if r.offset != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "offset", r.offset, "", "")
	}
	if r.scoreProvider != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "scoreProvider", r.scoreProvider, "", "")
	}
	if r.scoreInBelow != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "scoreInBelow", r.scoreInBelow, "", "")
	}
	if r.scoreOutBelow != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "scoreOutBelow", r.scoreOutBelow, "", "")
	}
	if r.scoreExclusive != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "scoreExclusive", r.scoreExclusive, "", "")
	}
	if r.onlyPositiveBalance != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "onlyPositiveBalance", r.onlyPositiveBalance, "", "")
	}
	if r.sortBy != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "sortBy", r.sortBy, "", "")
	}
	if r.sortOrder != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "sortOrder", r.sortOrder, "", "")
	}
	if r.balanceBelow != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "balanceBelow", r.balanceBelow, "", "")
	}
	if r.balanceAbove != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "balanceAbove", r.balanceAbove, "", "")
	}
	if r.walletId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "walletId", r.walletId, "", "")
	}
	if r.customerId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "customerId", r.customerId, "", "")
	}
	if r.coinfirmScoreGreater != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "coinfirmScoreGreater", r.coinfirmScoreGreater, "", "")
	}
	if r.chainalysisScoreGreater != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "chainalysisScoreGreater", r.chainalysisScoreGreater, "", "")
	}
	if r.tagIDs != nil {
		t := *r.tagIDs
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "tagIDs", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "tagIDs", t, "form", "multi")
		}
	}
	if r.blockchain != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "blockchain", r.blockchain, "", "")
	}
	if r.network != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "network", r.network, "", "")
	}
	if r.addressIds != nil {
		t := *r.addressIds
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "addressIds", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "addressIds", t, "form", "multi")
		}
	}
	if r.nfts != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "nfts", r.nfts, "", "")
	}
	if r.addresses != nil {
		t := *r.addresses
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "addresses", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "addresses", t, "form", "multi")
		}
	}
	if r.scoreFilterScoreProvider != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "scoreFilter.scoreProvider", r.scoreFilterScoreProvider, "", "")
	}
	if r.scoreFilterScorechainFiltersScoreInBelow != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "scoreFilter.scorechainFilters.scoreInBelow", r.scoreFilterScorechainFiltersScoreInBelow, "", "")
	}
	if r.scoreFilterScorechainFiltersScoreOutBelow != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "scoreFilter.scorechainFilters.scoreOutBelow", r.scoreFilterScorechainFiltersScoreOutBelow, "", "")
	}
	if r.scoreFilterScorechainFiltersScoreExclusive != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "scoreFilter.scorechainFilters.scoreExclusive", r.scoreFilterScorechainFiltersScoreExclusive, "", "")
	}
	if r.scoreFilterCoinfirmFiltersScoreGreater != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "scoreFilter.coinfirmFilters.scoreGreater", r.scoreFilterCoinfirmFiltersScoreGreater, "", "")
	}
	if r.scoreFilterChainalysisFiltersScoreGreater != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "scoreFilter.chainalysisFilters.scoreGreater", r.scoreFilterChainalysisFiltersScoreGreater, "", "")
	}
	if r.scoreFilterEllipticFiltersScoreGreater != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "scoreFilter.ellipticFilters.scoreGreater", r.scoreFilterEllipticFiltersScoreGreater, "", "")
	}
	if r.scoreFilterTrmlabsFiltersScoreGreater != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "scoreFilter.trmlabsFilters.scoreGreater", r.scoreFilterTrmlabsFiltersScoreGreater, "", "")
	}
	if r.attributeFiltersJson != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "attributeFiltersJson", r.attributeFiltersJson, "", "")
	}
	if r.attributeFiltersOperator != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "attributeFiltersOperator", r.attributeFiltersOperator, "", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["ApiKeyTPV1"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v map[string]interface{}
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v map[string]interface{}
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v map[string]interface{}
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v map[string]interface{}
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v map[string]interface{}
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 503 {
			var v map[string]interface{}
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
			var v GooglerpcStatus
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiWalletServiceGetAddressesProofOfReserveRequest struct {
	ctx context.Context
	ApiService *AddressesAPIService
	blockchain string
	addresses *[]string
	challenge *string
	network *string
}

func (r ApiWalletServiceGetAddressesProofOfReserveRequest) Addresses(addresses []string) ApiWalletServiceGetAddressesProofOfReserveRequest {
	r.addresses = &addresses
	return r
}

func (r ApiWalletServiceGetAddressesProofOfReserveRequest) Challenge(challenge string) ApiWalletServiceGetAddressesProofOfReserveRequest {
	r.challenge = &challenge
	return r
}

func (r ApiWalletServiceGetAddressesProofOfReserveRequest) Network(network string) ApiWalletServiceGetAddressesProofOfReserveRequest {
	r.network = &network
	return r
}

func (r ApiWalletServiceGetAddressesProofOfReserveRequest) Execute() (*TgvalidatordGetAddressesProofOfReserveReply, *http.Response, error) {
	return r.ApiService.WalletServiceGetAddressesProofOfReserveExecute(r)
}

/*
WalletServiceGetAddressesProofOfReserve Get the proof of reserve of a list of addresses

This endpoint returns the proof of reserve for a list of addresses.  The relevance of response fields is specific to the request type.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param blockchain
 @return ApiWalletServiceGetAddressesProofOfReserveRequest
*/
func (a *AddressesAPIService) WalletServiceGetAddressesProofOfReserve(ctx context.Context, blockchain string) ApiWalletServiceGetAddressesProofOfReserveRequest {
	return ApiWalletServiceGetAddressesProofOfReserveRequest{
		ApiService: a,
		ctx: ctx,
		blockchain: blockchain,
	}
}

// Execute executes the request
//  @return TgvalidatordGetAddressesProofOfReserveReply
func (a *AddressesAPIService) WalletServiceGetAddressesProofOfReserveExecute(r ApiWalletServiceGetAddressesProofOfReserveRequest) (*TgvalidatordGetAddressesProofOfReserveReply, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *TgvalidatordGetAddressesProofOfReserveReply
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AddressesAPIService.WalletServiceGetAddressesProofOfReserve")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/rest/v1/{blockchain}/addresses/proofofreserve"
	localVarPath = strings.Replace(localVarPath, "{"+"blockchain"+"}", url.PathEscape(parameterValueToString(r.blockchain, "blockchain")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.addresses != nil {
		t := *r.addresses
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "addresses", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "addresses", t, "form", "multi")
		}
	}
	if r.challenge != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "challenge", r.challenge, "", "")
	}
	if r.network != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "network", r.network, "", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["ApiKeyTPV1"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v map[string]interface{}
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v map[string]interface{}
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v map[string]interface{}
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v map[string]interface{}
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v map[string]interface{}
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 503 {
			var v map[string]interface{}
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
			var v GooglerpcStatus
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiWalletServiceGetAddressesStatusRequest struct {
	ctx context.Context
	ApiService *AddressesAPIService
	walletIds *[]string
	addressIds *[]string
	currencyIds *[]string
	sortingSortOrder *string
	cursorCurrentPage *string
	cursorPageRequest *string
	cursorPageSize *string
}

func (r ApiWalletServiceGetAddressesStatusRequest) WalletIds(walletIds []string) ApiWalletServiceGetAddressesStatusRequest {
	r.walletIds = &walletIds
	return r
}

func (r ApiWalletServiceGetAddressesStatusRequest) AddressIds(addressIds []string) ApiWalletServiceGetAddressesStatusRequest {
	r.addressIds = &addressIds
	return r
}

func (r ApiWalletServiceGetAddressesStatusRequest) CurrencyIds(currencyIds []string) ApiWalletServiceGetAddressesStatusRequest {
	r.currencyIds = &currencyIds
	return r
}

func (r ApiWalletServiceGetAddressesStatusRequest) SortingSortOrder(sortingSortOrder string) ApiWalletServiceGetAddressesStatusRequest {
	r.sortingSortOrder = &sortingSortOrder
	return r
}

// Base64-encoded string representing the current window of data
func (r ApiWalletServiceGetAddressesStatusRequest) CursorCurrentPage(cursorCurrentPage string) ApiWalletServiceGetAddressesStatusRequest {
	r.cursorCurrentPage = &cursorCurrentPage
	return r
}

// The page to request, w.r.t the current page. Can be one of &#x60;FIRST&#x60;, &#x60;PREVIOUS&#x60;, &#x60;NEXT&#x60;, &#x60;LAST&#x60;
func (r ApiWalletServiceGetAddressesStatusRequest) CursorPageRequest(cursorPageRequest string) ApiWalletServiceGetAddressesStatusRequest {
	r.cursorPageRequest = &cursorPageRequest
	return r
}

// The size of the page requested. The handling service should impose a hard limit on this
func (r ApiWalletServiceGetAddressesStatusRequest) CursorPageSize(cursorPageSize string) ApiWalletServiceGetAddressesStatusRequest {
	r.cursorPageSize = &cursorPageSize
	return r
}

func (r ApiWalletServiceGetAddressesStatusRequest) Execute() (*TgvalidatordGetAddressesStatusReply, *http.Response, error) {
	return r.ApiService.WalletServiceGetAddressesStatusExecute(r)
}

/*
WalletServiceGetAddressesStatus List addresses's status

This endpoint returns a list of addresses with their status

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiWalletServiceGetAddressesStatusRequest
*/
func (a *AddressesAPIService) WalletServiceGetAddressesStatus(ctx context.Context) ApiWalletServiceGetAddressesStatusRequest {
	return ApiWalletServiceGetAddressesStatusRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return TgvalidatordGetAddressesStatusReply
func (a *AddressesAPIService) WalletServiceGetAddressesStatusExecute(r ApiWalletServiceGetAddressesStatusRequest) (*TgvalidatordGetAddressesStatusReply, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *TgvalidatordGetAddressesStatusReply
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AddressesAPIService.WalletServiceGetAddressesStatus")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/rest/v1/addresses/status"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.walletIds != nil {
		t := *r.walletIds
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "walletIds", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "walletIds", t, "form", "multi")
		}
	}
	if r.addressIds != nil {
		t := *r.addressIds
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "addressIds", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "addressIds", t, "form", "multi")
		}
	}
	if r.currencyIds != nil {
		t := *r.currencyIds
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "currencyIds", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "currencyIds", t, "form", "multi")
		}
	}
	if r.sortingSortOrder != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "sorting.sortOrder", r.sortingSortOrder, "", "")
	}
	if r.cursorCurrentPage != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "cursor.currentPage", r.cursorCurrentPage, "", "")
	}
	if r.cursorPageRequest != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "cursor.pageRequest", r.cursorPageRequest, "", "")
	}
	if r.cursorPageSize != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "cursor.pageSize", r.cursorPageSize, "", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["ApiKeyTPV1"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v map[string]interface{}
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v map[string]interface{}
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v map[string]interface{}
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v map[string]interface{}
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v map[string]interface{}
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 503 {
			var v map[string]interface{}
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
			var v GooglerpcStatus
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiWalletServiceGetLightAddressesRequest struct {
	ctx context.Context
	ApiService *AddressesAPIService
	uniqueCurrencyFilterBlockchain *string
	uniqueCurrencyFilterNetwork *string
	currencyID *string
	uniqueCurrencyFilterTokenContractAddress *string
	uniqueCurrencyFilterTokenID *string
	addresses *[]string
}

// Required: The Blockchain to filter by (e.g. ETH, BTC). Can be found using the blockchain endpoint &#x60;/api/rest/v1/blockchains&#x60;
func (r ApiWalletServiceGetLightAddressesRequest) UniqueCurrencyFilterBlockchain(uniqueCurrencyFilterBlockchain string) ApiWalletServiceGetLightAddressesRequest {
	r.uniqueCurrencyFilterBlockchain = &uniqueCurrencyFilterBlockchain
	return r
}

// Required: Network or environment the currency is used on (e.g. &#39;mainnet&#39;, &#39;testnet&#39;).
func (r ApiWalletServiceGetLightAddressesRequest) UniqueCurrencyFilterNetwork(uniqueCurrencyFilterNetwork string) ApiWalletServiceGetLightAddressesRequest {
	r.uniqueCurrencyFilterNetwork = &uniqueCurrencyFilterNetwork
	return r
}

// One of the currencyID or uniqueCurrencyFilter fields must be provided
func (r ApiWalletServiceGetLightAddressesRequest) CurrencyID(currencyID string) ApiWalletServiceGetLightAddressesRequest {
	r.currencyID = &currencyID
	return r
}

// If this parameter is set, the currency returned will be a token with the specified contract address. If not set, the currency returned will be the native currency of the blockchain.
func (r ApiWalletServiceGetLightAddressesRequest) UniqueCurrencyFilterTokenContractAddress(uniqueCurrencyFilterTokenContractAddress string) ApiWalletServiceGetLightAddressesRequest {
	r.uniqueCurrencyFilterTokenContractAddress = &uniqueCurrencyFilterTokenContractAddress
	return r
}

// For some blockchains (ex. ALGO, XTZ) a tokenContractAddress might contain multiple assets. The tokenID is used to differentiate between those assets. If not set, the currency returned won&#39;t have any tokenID defined.
func (r ApiWalletServiceGetLightAddressesRequest) UniqueCurrencyFilterTokenID(uniqueCurrencyFilterTokenID string) ApiWalletServiceGetLightAddressesRequest {
	r.uniqueCurrencyFilterTokenID = &uniqueCurrencyFilterTokenID
	return r
}

func (r ApiWalletServiceGetLightAddressesRequest) Addresses(addresses []string) ApiWalletServiceGetLightAddressesRequest {
	r.addresses = &addresses
	return r
}

func (r ApiWalletServiceGetLightAddressesRequest) Execute() (*TgvalidatordGetLightAddressesReply, *http.Response, error) {
	return r.ApiService.WalletServiceGetLightAddressesExecute(r)
}

/*
WalletServiceGetLightAddresses List light addresses

This endpoint returns a list of addresses with light information filtered by a unique currency and a list of addresses. The light address information mainly contains the identifiers. There is no balance, risk score or attributes.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiWalletServiceGetLightAddressesRequest
*/
func (a *AddressesAPIService) WalletServiceGetLightAddresses(ctx context.Context) ApiWalletServiceGetLightAddressesRequest {
	return ApiWalletServiceGetLightAddressesRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return TgvalidatordGetLightAddressesReply
func (a *AddressesAPIService) WalletServiceGetLightAddressesExecute(r ApiWalletServiceGetLightAddressesRequest) (*TgvalidatordGetLightAddressesReply, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *TgvalidatordGetLightAddressesReply
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AddressesAPIService.WalletServiceGetLightAddresses")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/rest/v1/addresses/light"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.uniqueCurrencyFilterBlockchain == nil {
		return localVarReturnValue, nil, reportError("uniqueCurrencyFilterBlockchain is required and must be specified")
	}
	if r.uniqueCurrencyFilterNetwork == nil {
		return localVarReturnValue, nil, reportError("uniqueCurrencyFilterNetwork is required and must be specified")
	}

	if r.currencyID != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "currencyID", r.currencyID, "", "")
	}
	parameterAddToHeaderOrQuery(localVarQueryParams, "uniqueCurrencyFilter.blockchain", r.uniqueCurrencyFilterBlockchain, "", "")
	parameterAddToHeaderOrQuery(localVarQueryParams, "uniqueCurrencyFilter.network", r.uniqueCurrencyFilterNetwork, "", "")
	if r.uniqueCurrencyFilterTokenContractAddress != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "uniqueCurrencyFilter.tokenContractAddress", r.uniqueCurrencyFilterTokenContractAddress, "", "")
	}
	if r.uniqueCurrencyFilterTokenID != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "uniqueCurrencyFilter.tokenID", r.uniqueCurrencyFilterTokenID, "", "")
	}
	if r.addresses != nil {
		t := *r.addresses
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "addresses", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "addresses", t, "form", "multi")
		}
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["ApiKeyTPV1"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v map[string]interface{}
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v map[string]interface{}
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v map[string]interface{}
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v map[string]interface{}
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v map[string]interface{}
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 503 {
			var v map[string]interface{}
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
			var v GooglerpcStatus
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}
