// Code generated by protoc-gen-ts_proto. DO NOT EDIT.
// versions:
//   protoc-gen-ts_proto  v1.181.2
//   protoc               v6.33.4
// source: exchange-service.proto

/* eslint-disable */
import Long from "long";
import _m0 from "protobufjs/minimal";
import { RequestCursor, ResponseCursor } from "./cursor";
import { Exchange, ExchangeCounterparty } from "./exchange";
import { Empty } from "./google/protobuf/empty";

export const protobufPackage = "tgvalidatord";

export interface GetExchangesRequest {
  currencyID: string;
  includeBaseCurrencyValuation: boolean;
  exchangeLabel: string;
  sortOrder: string;
  cursor: RequestCursor | undefined;
  status: string;
  onlyPositiveBalance: boolean;
}

export interface GetExchangesReply {
  result: Exchange[];
  cursor: ResponseCursor | undefined;
}

export interface GetExchangeRequest {
  id: number;
}

export interface GetExchangeReply {
  result: Exchange | undefined;
}

export interface ExportExchangesRequest {
  format: string;
}

export interface ExportExchangesReply {
  result: string;
  totalItems: number;
}

export interface GetExchangeWithdrawalFeeRequest {
  id: number;
  toAddressId: number;
  amount: string;
}

export interface GetExchangeWithdrawalFeeReply {
  result: string;
}

export interface GetExchangeCounterpartiesReply {
  exchangesTotalValuation: string;
  exchanges: ExchangeCounterparty[];
}

function createBaseGetExchangesRequest(): GetExchangesRequest {
  return {
    currencyID: "",
    includeBaseCurrencyValuation: false,
    exchangeLabel: "",
    sortOrder: "",
    cursor: undefined,
    status: "",
    onlyPositiveBalance: false,
  };
}

export const GetExchangesRequest = {
  encode(message: GetExchangesRequest, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.currencyID !== "") {
      writer.uint32(10).string(message.currencyID);
    }
    if (message.includeBaseCurrencyValuation !== false) {
      writer.uint32(16).bool(message.includeBaseCurrencyValuation);
    }
    if (message.exchangeLabel !== "") {
      writer.uint32(26).string(message.exchangeLabel);
    }
    if (message.sortOrder !== "") {
      writer.uint32(34).string(message.sortOrder);
    }
    if (message.cursor !== undefined) {
      RequestCursor.encode(message.cursor, writer.uint32(42).fork()).ldelim();
    }
    if (message.status !== "") {
      writer.uint32(50).string(message.status);
    }
    if (message.onlyPositiveBalance !== false) {
      writer.uint32(56).bool(message.onlyPositiveBalance);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): GetExchangesRequest {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetExchangesRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.currencyID = reader.string();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.includeBaseCurrencyValuation = reader.bool();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.exchangeLabel = reader.string();
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.sortOrder = reader.string();
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.cursor = RequestCursor.decode(reader, reader.uint32());
          continue;
        case 6:
          if (tag !== 50) {
            break;
          }

          message.status = reader.string();
          continue;
        case 7:
          if (tag !== 56) {
            break;
          }

          message.onlyPositiveBalance = reader.bool();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetExchangesRequest {
    return {
      currencyID: isSet(object.currencyID) ? globalThis.String(object.currencyID) : "",
      includeBaseCurrencyValuation: isSet(object.includeBaseCurrencyValuation)
        ? globalThis.Boolean(object.includeBaseCurrencyValuation)
        : false,
      exchangeLabel: isSet(object.exchangeLabel) ? globalThis.String(object.exchangeLabel) : "",
      sortOrder: isSet(object.sortOrder) ? globalThis.String(object.sortOrder) : "",
      cursor: isSet(object.cursor) ? RequestCursor.fromJSON(object.cursor) : undefined,
      status: isSet(object.status) ? globalThis.String(object.status) : "",
      onlyPositiveBalance: isSet(object.onlyPositiveBalance) ? globalThis.Boolean(object.onlyPositiveBalance) : false,
    };
  },

  toJSON(message: GetExchangesRequest): unknown {
    const obj: any = {};
    if (message.currencyID !== "") {
      obj.currencyID = message.currencyID;
    }
    if (message.includeBaseCurrencyValuation !== false) {
      obj.includeBaseCurrencyValuation = message.includeBaseCurrencyValuation;
    }
    if (message.exchangeLabel !== "") {
      obj.exchangeLabel = message.exchangeLabel;
    }
    if (message.sortOrder !== "") {
      obj.sortOrder = message.sortOrder;
    }
    if (message.cursor !== undefined) {
      obj.cursor = RequestCursor.toJSON(message.cursor);
    }
    if (message.status !== "") {
      obj.status = message.status;
    }
    if (message.onlyPositiveBalance !== false) {
      obj.onlyPositiveBalance = message.onlyPositiveBalance;
    }
    return obj;
  },

  create(base?: DeepPartial<GetExchangesRequest>): GetExchangesRequest {
    return GetExchangesRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<GetExchangesRequest>): GetExchangesRequest {
    const message = createBaseGetExchangesRequest();
    message.currencyID = object.currencyID ?? "";
    message.includeBaseCurrencyValuation = object.includeBaseCurrencyValuation ?? false;
    message.exchangeLabel = object.exchangeLabel ?? "";
    message.sortOrder = object.sortOrder ?? "";
    message.cursor = (object.cursor !== undefined && object.cursor !== null)
      ? RequestCursor.fromPartial(object.cursor)
      : undefined;
    message.status = object.status ?? "";
    message.onlyPositiveBalance = object.onlyPositiveBalance ?? false;
    return message;
  },
};

function createBaseGetExchangesReply(): GetExchangesReply {
  return { result: [], cursor: undefined };
}

export const GetExchangesReply = {
  encode(message: GetExchangesReply, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    for (const v of message.result) {
      Exchange.encode(v!, writer.uint32(10).fork()).ldelim();
    }
    if (message.cursor !== undefined) {
      ResponseCursor.encode(message.cursor, writer.uint32(18).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): GetExchangesReply {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetExchangesReply();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.result.push(Exchange.decode(reader, reader.uint32()));
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.cursor = ResponseCursor.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetExchangesReply {
    return {
      result: globalThis.Array.isArray(object?.result) ? object.result.map((e: any) => Exchange.fromJSON(e)) : [],
      cursor: isSet(object.cursor) ? ResponseCursor.fromJSON(object.cursor) : undefined,
    };
  },

  toJSON(message: GetExchangesReply): unknown {
    const obj: any = {};
    if (message.result?.length) {
      obj.result = message.result.map((e) => Exchange.toJSON(e));
    }
    if (message.cursor !== undefined) {
      obj.cursor = ResponseCursor.toJSON(message.cursor);
    }
    return obj;
  },

  create(base?: DeepPartial<GetExchangesReply>): GetExchangesReply {
    return GetExchangesReply.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<GetExchangesReply>): GetExchangesReply {
    const message = createBaseGetExchangesReply();
    message.result = object.result?.map((e) => Exchange.fromPartial(e)) || [];
    message.cursor = (object.cursor !== undefined && object.cursor !== null)
      ? ResponseCursor.fromPartial(object.cursor)
      : undefined;
    return message;
  },
};

function createBaseGetExchangeRequest(): GetExchangeRequest {
  return { id: 0 };
}

export const GetExchangeRequest = {
  encode(message: GetExchangeRequest, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.id !== 0) {
      writer.uint32(8).uint64(message.id);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): GetExchangeRequest {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetExchangeRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.id = longToNumber(reader.uint64() as Long);
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetExchangeRequest {
    return { id: isSet(object.id) ? globalThis.Number(object.id) : 0 };
  },

  toJSON(message: GetExchangeRequest): unknown {
    const obj: any = {};
    if (message.id !== 0) {
      obj.id = Math.round(message.id);
    }
    return obj;
  },

  create(base?: DeepPartial<GetExchangeRequest>): GetExchangeRequest {
    return GetExchangeRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<GetExchangeRequest>): GetExchangeRequest {
    const message = createBaseGetExchangeRequest();
    message.id = object.id ?? 0;
    return message;
  },
};

function createBaseGetExchangeReply(): GetExchangeReply {
  return { result: undefined };
}

export const GetExchangeReply = {
  encode(message: GetExchangeReply, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.result !== undefined) {
      Exchange.encode(message.result, writer.uint32(10).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): GetExchangeReply {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetExchangeReply();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.result = Exchange.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetExchangeReply {
    return { result: isSet(object.result) ? Exchange.fromJSON(object.result) : undefined };
  },

  toJSON(message: GetExchangeReply): unknown {
    const obj: any = {};
    if (message.result !== undefined) {
      obj.result = Exchange.toJSON(message.result);
    }
    return obj;
  },

  create(base?: DeepPartial<GetExchangeReply>): GetExchangeReply {
    return GetExchangeReply.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<GetExchangeReply>): GetExchangeReply {
    const message = createBaseGetExchangeReply();
    message.result = (object.result !== undefined && object.result !== null)
      ? Exchange.fromPartial(object.result)
      : undefined;
    return message;
  },
};

function createBaseExportExchangesRequest(): ExportExchangesRequest {
  return { format: "" };
}

export const ExportExchangesRequest = {
  encode(message: ExportExchangesRequest, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.format !== "") {
      writer.uint32(10).string(message.format);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): ExportExchangesRequest {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseExportExchangesRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.format = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ExportExchangesRequest {
    return { format: isSet(object.format) ? globalThis.String(object.format) : "" };
  },

  toJSON(message: ExportExchangesRequest): unknown {
    const obj: any = {};
    if (message.format !== "") {
      obj.format = message.format;
    }
    return obj;
  },

  create(base?: DeepPartial<ExportExchangesRequest>): ExportExchangesRequest {
    return ExportExchangesRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ExportExchangesRequest>): ExportExchangesRequest {
    const message = createBaseExportExchangesRequest();
    message.format = object.format ?? "";
    return message;
  },
};

function createBaseExportExchangesReply(): ExportExchangesReply {
  return { result: "", totalItems: 0 };
}

export const ExportExchangesReply = {
  encode(message: ExportExchangesReply, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.result !== "") {
      writer.uint32(10).string(message.result);
    }
    if (message.totalItems !== 0) {
      writer.uint32(16).uint64(message.totalItems);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): ExportExchangesReply {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseExportExchangesReply();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.result = reader.string();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.totalItems = longToNumber(reader.uint64() as Long);
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ExportExchangesReply {
    return {
      result: isSet(object.result) ? globalThis.String(object.result) : "",
      totalItems: isSet(object.totalItems) ? globalThis.Number(object.totalItems) : 0,
    };
  },

  toJSON(message: ExportExchangesReply): unknown {
    const obj: any = {};
    if (message.result !== "") {
      obj.result = message.result;
    }
    if (message.totalItems !== 0) {
      obj.totalItems = Math.round(message.totalItems);
    }
    return obj;
  },

  create(base?: DeepPartial<ExportExchangesReply>): ExportExchangesReply {
    return ExportExchangesReply.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ExportExchangesReply>): ExportExchangesReply {
    const message = createBaseExportExchangesReply();
    message.result = object.result ?? "";
    message.totalItems = object.totalItems ?? 0;
    return message;
  },
};

function createBaseGetExchangeWithdrawalFeeRequest(): GetExchangeWithdrawalFeeRequest {
  return { id: 0, toAddressId: 0, amount: "" };
}

export const GetExchangeWithdrawalFeeRequest = {
  encode(message: GetExchangeWithdrawalFeeRequest, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.id !== 0) {
      writer.uint32(8).uint64(message.id);
    }
    if (message.toAddressId !== 0) {
      writer.uint32(16).uint64(message.toAddressId);
    }
    if (message.amount !== "") {
      writer.uint32(26).string(message.amount);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): GetExchangeWithdrawalFeeRequest {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetExchangeWithdrawalFeeRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.id = longToNumber(reader.uint64() as Long);
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.toAddressId = longToNumber(reader.uint64() as Long);
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.amount = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetExchangeWithdrawalFeeRequest {
    return {
      id: isSet(object.id) ? globalThis.Number(object.id) : 0,
      toAddressId: isSet(object.toAddressId) ? globalThis.Number(object.toAddressId) : 0,
      amount: isSet(object.amount) ? globalThis.String(object.amount) : "",
    };
  },

  toJSON(message: GetExchangeWithdrawalFeeRequest): unknown {
    const obj: any = {};
    if (message.id !== 0) {
      obj.id = Math.round(message.id);
    }
    if (message.toAddressId !== 0) {
      obj.toAddressId = Math.round(message.toAddressId);
    }
    if (message.amount !== "") {
      obj.amount = message.amount;
    }
    return obj;
  },

  create(base?: DeepPartial<GetExchangeWithdrawalFeeRequest>): GetExchangeWithdrawalFeeRequest {
    return GetExchangeWithdrawalFeeRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<GetExchangeWithdrawalFeeRequest>): GetExchangeWithdrawalFeeRequest {
    const message = createBaseGetExchangeWithdrawalFeeRequest();
    message.id = object.id ?? 0;
    message.toAddressId = object.toAddressId ?? 0;
    message.amount = object.amount ?? "";
    return message;
  },
};

function createBaseGetExchangeWithdrawalFeeReply(): GetExchangeWithdrawalFeeReply {
  return { result: "" };
}

export const GetExchangeWithdrawalFeeReply = {
  encode(message: GetExchangeWithdrawalFeeReply, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.result !== "") {
      writer.uint32(10).string(message.result);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): GetExchangeWithdrawalFeeReply {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetExchangeWithdrawalFeeReply();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.result = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetExchangeWithdrawalFeeReply {
    return { result: isSet(object.result) ? globalThis.String(object.result) : "" };
  },

  toJSON(message: GetExchangeWithdrawalFeeReply): unknown {
    const obj: any = {};
    if (message.result !== "") {
      obj.result = message.result;
    }
    return obj;
  },

  create(base?: DeepPartial<GetExchangeWithdrawalFeeReply>): GetExchangeWithdrawalFeeReply {
    return GetExchangeWithdrawalFeeReply.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<GetExchangeWithdrawalFeeReply>): GetExchangeWithdrawalFeeReply {
    const message = createBaseGetExchangeWithdrawalFeeReply();
    message.result = object.result ?? "";
    return message;
  },
};

function createBaseGetExchangeCounterpartiesReply(): GetExchangeCounterpartiesReply {
  return { exchangesTotalValuation: "", exchanges: [] };
}

export const GetExchangeCounterpartiesReply = {
  encode(message: GetExchangeCounterpartiesReply, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.exchangesTotalValuation !== "") {
      writer.uint32(10).string(message.exchangesTotalValuation);
    }
    for (const v of message.exchanges) {
      ExchangeCounterparty.encode(v!, writer.uint32(18).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): GetExchangeCounterpartiesReply {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetExchangeCounterpartiesReply();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.exchangesTotalValuation = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.exchanges.push(ExchangeCounterparty.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetExchangeCounterpartiesReply {
    return {
      exchangesTotalValuation: isSet(object.exchangesTotalValuation)
        ? globalThis.String(object.exchangesTotalValuation)
        : "",
      exchanges: globalThis.Array.isArray(object?.exchanges)
        ? object.exchanges.map((e: any) => ExchangeCounterparty.fromJSON(e))
        : [],
    };
  },

  toJSON(message: GetExchangeCounterpartiesReply): unknown {
    const obj: any = {};
    if (message.exchangesTotalValuation !== "") {
      obj.exchangesTotalValuation = message.exchangesTotalValuation;
    }
    if (message.exchanges?.length) {
      obj.exchanges = message.exchanges.map((e) => ExchangeCounterparty.toJSON(e));
    }
    return obj;
  },

  create(base?: DeepPartial<GetExchangeCounterpartiesReply>): GetExchangeCounterpartiesReply {
    return GetExchangeCounterpartiesReply.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<GetExchangeCounterpartiesReply>): GetExchangeCounterpartiesReply {
    const message = createBaseGetExchangeCounterpartiesReply();
    message.exchangesTotalValuation = object.exchangesTotalValuation ?? "";
    message.exchanges = object.exchanges?.map((e) => ExchangeCounterparty.fromPartial(e)) || [];
    return message;
  },
};

export interface ExchangeService {
  GetExchanges(request: GetExchangesRequest): Promise<GetExchangesReply>;
  GetExchange(request: GetExchangeRequest): Promise<GetExchangeReply>;
  GetExchangeWithdrawalFee(request: GetExchangeWithdrawalFeeRequest): Promise<GetExchangeWithdrawalFeeReply>;
  ExportExchanges(request: ExportExchangesRequest): Promise<ExportExchangesReply>;
  GetExchangeCounterparties(request: Empty): Promise<GetExchangeCounterpartiesReply>;
}

export const ExchangeServiceServiceName = "tgvalidatord.ExchangeService";
export class ExchangeServiceClientImpl implements ExchangeService {
  private readonly rpc: Rpc;
  private readonly service: string;
  constructor(rpc: Rpc, opts?: { service?: string }) {
    this.service = opts?.service || ExchangeServiceServiceName;
    this.rpc = rpc;
    this.GetExchanges = this.GetExchanges.bind(this);
    this.GetExchange = this.GetExchange.bind(this);
    this.GetExchangeWithdrawalFee = this.GetExchangeWithdrawalFee.bind(this);
    this.ExportExchanges = this.ExportExchanges.bind(this);
    this.GetExchangeCounterparties = this.GetExchangeCounterparties.bind(this);
  }
  GetExchanges(request: GetExchangesRequest): Promise<GetExchangesReply> {
    const data = GetExchangesRequest.encode(request).finish();
    const promise = this.rpc.request(this.service, "GetExchanges", data);
    return promise.then((data) => GetExchangesReply.decode(_m0.Reader.create(data)));
  }

  GetExchange(request: GetExchangeRequest): Promise<GetExchangeReply> {
    const data = GetExchangeRequest.encode(request).finish();
    const promise = this.rpc.request(this.service, "GetExchange", data);
    return promise.then((data) => GetExchangeReply.decode(_m0.Reader.create(data)));
  }

  GetExchangeWithdrawalFee(request: GetExchangeWithdrawalFeeRequest): Promise<GetExchangeWithdrawalFeeReply> {
    const data = GetExchangeWithdrawalFeeRequest.encode(request).finish();
    const promise = this.rpc.request(this.service, "GetExchangeWithdrawalFee", data);
    return promise.then((data) => GetExchangeWithdrawalFeeReply.decode(_m0.Reader.create(data)));
  }

  ExportExchanges(request: ExportExchangesRequest): Promise<ExportExchangesReply> {
    const data = ExportExchangesRequest.encode(request).finish();
    const promise = this.rpc.request(this.service, "ExportExchanges", data);
    return promise.then((data) => ExportExchangesReply.decode(_m0.Reader.create(data)));
  }

  GetExchangeCounterparties(request: Empty): Promise<GetExchangeCounterpartiesReply> {
    const data = Empty.encode(request).finish();
    const promise = this.rpc.request(this.service, "GetExchangeCounterparties", data);
    return promise.then((data) => GetExchangeCounterpartiesReply.decode(_m0.Reader.create(data)));
  }
}

interface Rpc {
  request(service: string, method: string, data: Uint8Array): Promise<Uint8Array>;
}

type Builtin = Date | Function | Uint8Array | string | number | boolean | undefined;

export type DeepPartial<T> = T extends Builtin ? T
  : T extends globalThis.Array<infer U> ? globalThis.Array<DeepPartial<U>>
  : T extends ReadonlyArray<infer U> ? ReadonlyArray<DeepPartial<U>>
  : T extends {} ? { [K in keyof T]?: DeepPartial<T[K]> }
  : Partial<T>;

function longToNumber(long: Long): number {
  if (long.gt(globalThis.Number.MAX_SAFE_INTEGER)) {
    throw new globalThis.Error("Value is larger than Number.MAX_SAFE_INTEGER");
  }
  if (long.lt(globalThis.Number.MIN_SAFE_INTEGER)) {
    throw new globalThis.Error("Value is smaller than Number.MIN_SAFE_INTEGER");
  }
  return long.toNumber();
}

if (_m0.util.Long !== Long) {
  _m0.util.Long = Long as any;
  _m0.configure();
}

function isSet(value: any): boolean {
  return value !== null && value !== undefined;
}
