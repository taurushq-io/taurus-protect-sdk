# coding: utf-8

"""
    Taurus-PROTECT APIs

    Taurus-PROTECT APIs description

    The version of the OpenAPI document: 1.0
    Generated by OpenAPI Generator (https://openapi-generator.tech)

    Do not edit the class manually.
"""  # noqa: E501

import warnings
from pydantic import validate_call, Field, StrictFloat, StrictStr, StrictInt
from typing import Any, Dict, List, Optional, Tuple, Union
from typing_extensions import Annotated

from pydantic import Field, StrictStr
from typing import Any, Dict, List, Optional
from typing_extensions import Annotated
from taurus_protect._internal.openapi.models.tgvalidatord_get_shared_addresses_reply import TgvalidatordGetSharedAddressesReply
from taurus_protect._internal.openapi.models.tgvalidatord_get_shared_assets_reply import TgvalidatordGetSharedAssetsReply
from taurus_protect._internal.openapi.models.tgvalidatord_share_address_request import TgvalidatordShareAddressRequest
from taurus_protect._internal.openapi.models.tgvalidatord_share_whitelisted_asset_request import TgvalidatordShareWhitelistedAssetRequest

from taurus_protect._internal.openapi.api_client import ApiClient, RequestSerialized
from taurus_protect._internal.openapi.api_response import ApiResponse
from taurus_protect._internal.openapi.rest import RESTResponseType


class TaurusNetworkSharedAddressAssetApi:
    """NOTE: This class is auto generated by OpenAPI Generator
    Ref: https://openapi-generator.tech

    Do not edit the class manually.
    """

    def __init__(self, api_client=None) -> None:
        if api_client is None:
            api_client = ApiClient.get_default()
        self.api_client = api_client


    @validate_call
    def taurus_network_service_get_shared_addresses(
        self,
        participant_id: Annotated[Optional[StrictStr], Field(description="Get all the shared addresses where the participantID is either the owner or the target of the shared address.")] = None,
        owner_participant_id: Annotated[Optional[StrictStr], Field(description="Filter shared addresses by specifying who is the owner of the shared addresses (your participant or the counterparty)")] = None,
        target_participant_id: Annotated[Optional[StrictStr], Field(description="Filter shared addresses by specifying who is the target of the shared addresses (your participant or the counterparty)")] = None,
        blockchain: Annotated[Optional[StrictStr], Field(description="Filter shared addresses by specifying the blockchain of the shared addresses")] = None,
        network: Annotated[Optional[StrictStr], Field(description="Filter shared addresses by specifying the network of the shared addresses. It must be used in combination with the blockchain filter.")] = None,
        ids: Annotated[Optional[List[StrictStr]], Field(description="Filter shared addresses by specifying the shared address IDs")] = None,
        sort_order: Annotated[Optional[StrictStr], Field(description="Set this parameter to ASC to get the id sorted in ASC order or DESC to get them in descending order. By default, the order is DESC.")] = None,
        cursor_current_page: Annotated[Optional[StrictStr], Field(description="Base64-encoded string representing the current window of data")] = None,
        cursor_page_request: Annotated[Optional[StrictStr], Field(description="The page to request, w.r.t the current page. Can be one of `FIRST`, `PREVIOUS`, `NEXT`, `LAST`")] = None,
        cursor_page_size: Annotated[Optional[StrictStr], Field(description="The size of the page requested. The handling service should impose a hard limit on this")] = None,
        statuses: Annotated[Optional[List[StrictStr]], Field(description="Filter shared addresses by specifying a list of statuses. Accepted status values:  'new', 'pending', 'rejected', 'accepted', 'unshared'")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> TgvalidatordGetSharedAddressesReply:
        """List shared addresses

        This endpoint returns a list of addresses that you shared or that are shared to you via Taurus-NETWORK. You can filter the results by specifying the owner or the target of the shared addresses.

        :param participant_id: Get all the shared addresses where the participantID is either the owner or the target of the shared address.
        :type participant_id: str
        :param owner_participant_id: Filter shared addresses by specifying who is the owner of the shared addresses (your participant or the counterparty)
        :type owner_participant_id: str
        :param target_participant_id: Filter shared addresses by specifying who is the target of the shared addresses (your participant or the counterparty)
        :type target_participant_id: str
        :param blockchain: Filter shared addresses by specifying the blockchain of the shared addresses
        :type blockchain: str
        :param network: Filter shared addresses by specifying the network of the shared addresses. It must be used in combination with the blockchain filter.
        :type network: str
        :param ids: Filter shared addresses by specifying the shared address IDs
        :type ids: List[str]
        :param sort_order: Set this parameter to ASC to get the id sorted in ASC order or DESC to get them in descending order. By default, the order is DESC.
        :type sort_order: str
        :param cursor_current_page: Base64-encoded string representing the current window of data
        :type cursor_current_page: str
        :param cursor_page_request: The page to request, w.r.t the current page. Can be one of `FIRST`, `PREVIOUS`, `NEXT`, `LAST`
        :type cursor_page_request: str
        :param cursor_page_size: The size of the page requested. The handling service should impose a hard limit on this
        :type cursor_page_size: str
        :param statuses: Filter shared addresses by specifying a list of statuses. Accepted status values:  'new', 'pending', 'rejected', 'accepted', 'unshared'
        :type statuses: List[str]
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._taurus_network_service_get_shared_addresses_serialize(
            participant_id=participant_id,
            owner_participant_id=owner_participant_id,
            target_participant_id=target_participant_id,
            blockchain=blockchain,
            network=network,
            ids=ids,
            sort_order=sort_order,
            cursor_current_page=cursor_current_page,
            cursor_page_request=cursor_page_request,
            cursor_page_size=cursor_page_size,
            statuses=statuses,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "TgvalidatordGetSharedAddressesReply",
            '400': "object",
            '401': "object",
            '403': "object",
            '404': "object",
            '500': "object",
            '503': "object",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def taurus_network_service_get_shared_addresses_with_http_info(
        self,
        participant_id: Annotated[Optional[StrictStr], Field(description="Get all the shared addresses where the participantID is either the owner or the target of the shared address.")] = None,
        owner_participant_id: Annotated[Optional[StrictStr], Field(description="Filter shared addresses by specifying who is the owner of the shared addresses (your participant or the counterparty)")] = None,
        target_participant_id: Annotated[Optional[StrictStr], Field(description="Filter shared addresses by specifying who is the target of the shared addresses (your participant or the counterparty)")] = None,
        blockchain: Annotated[Optional[StrictStr], Field(description="Filter shared addresses by specifying the blockchain of the shared addresses")] = None,
        network: Annotated[Optional[StrictStr], Field(description="Filter shared addresses by specifying the network of the shared addresses. It must be used in combination with the blockchain filter.")] = None,
        ids: Annotated[Optional[List[StrictStr]], Field(description="Filter shared addresses by specifying the shared address IDs")] = None,
        sort_order: Annotated[Optional[StrictStr], Field(description="Set this parameter to ASC to get the id sorted in ASC order or DESC to get them in descending order. By default, the order is DESC.")] = None,
        cursor_current_page: Annotated[Optional[StrictStr], Field(description="Base64-encoded string representing the current window of data")] = None,
        cursor_page_request: Annotated[Optional[StrictStr], Field(description="The page to request, w.r.t the current page. Can be one of `FIRST`, `PREVIOUS`, `NEXT`, `LAST`")] = None,
        cursor_page_size: Annotated[Optional[StrictStr], Field(description="The size of the page requested. The handling service should impose a hard limit on this")] = None,
        statuses: Annotated[Optional[List[StrictStr]], Field(description="Filter shared addresses by specifying a list of statuses. Accepted status values:  'new', 'pending', 'rejected', 'accepted', 'unshared'")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[TgvalidatordGetSharedAddressesReply]:
        """List shared addresses

        This endpoint returns a list of addresses that you shared or that are shared to you via Taurus-NETWORK. You can filter the results by specifying the owner or the target of the shared addresses.

        :param participant_id: Get all the shared addresses where the participantID is either the owner or the target of the shared address.
        :type participant_id: str
        :param owner_participant_id: Filter shared addresses by specifying who is the owner of the shared addresses (your participant or the counterparty)
        :type owner_participant_id: str
        :param target_participant_id: Filter shared addresses by specifying who is the target of the shared addresses (your participant or the counterparty)
        :type target_participant_id: str
        :param blockchain: Filter shared addresses by specifying the blockchain of the shared addresses
        :type blockchain: str
        :param network: Filter shared addresses by specifying the network of the shared addresses. It must be used in combination with the blockchain filter.
        :type network: str
        :param ids: Filter shared addresses by specifying the shared address IDs
        :type ids: List[str]
        :param sort_order: Set this parameter to ASC to get the id sorted in ASC order or DESC to get them in descending order. By default, the order is DESC.
        :type sort_order: str
        :param cursor_current_page: Base64-encoded string representing the current window of data
        :type cursor_current_page: str
        :param cursor_page_request: The page to request, w.r.t the current page. Can be one of `FIRST`, `PREVIOUS`, `NEXT`, `LAST`
        :type cursor_page_request: str
        :param cursor_page_size: The size of the page requested. The handling service should impose a hard limit on this
        :type cursor_page_size: str
        :param statuses: Filter shared addresses by specifying a list of statuses. Accepted status values:  'new', 'pending', 'rejected', 'accepted', 'unshared'
        :type statuses: List[str]
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._taurus_network_service_get_shared_addresses_serialize(
            participant_id=participant_id,
            owner_participant_id=owner_participant_id,
            target_participant_id=target_participant_id,
            blockchain=blockchain,
            network=network,
            ids=ids,
            sort_order=sort_order,
            cursor_current_page=cursor_current_page,
            cursor_page_request=cursor_page_request,
            cursor_page_size=cursor_page_size,
            statuses=statuses,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "TgvalidatordGetSharedAddressesReply",
            '400': "object",
            '401': "object",
            '403': "object",
            '404': "object",
            '500': "object",
            '503': "object",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def taurus_network_service_get_shared_addresses_without_preload_content(
        self,
        participant_id: Annotated[Optional[StrictStr], Field(description="Get all the shared addresses where the participantID is either the owner or the target of the shared address.")] = None,
        owner_participant_id: Annotated[Optional[StrictStr], Field(description="Filter shared addresses by specifying who is the owner of the shared addresses (your participant or the counterparty)")] = None,
        target_participant_id: Annotated[Optional[StrictStr], Field(description="Filter shared addresses by specifying who is the target of the shared addresses (your participant or the counterparty)")] = None,
        blockchain: Annotated[Optional[StrictStr], Field(description="Filter shared addresses by specifying the blockchain of the shared addresses")] = None,
        network: Annotated[Optional[StrictStr], Field(description="Filter shared addresses by specifying the network of the shared addresses. It must be used in combination with the blockchain filter.")] = None,
        ids: Annotated[Optional[List[StrictStr]], Field(description="Filter shared addresses by specifying the shared address IDs")] = None,
        sort_order: Annotated[Optional[StrictStr], Field(description="Set this parameter to ASC to get the id sorted in ASC order or DESC to get them in descending order. By default, the order is DESC.")] = None,
        cursor_current_page: Annotated[Optional[StrictStr], Field(description="Base64-encoded string representing the current window of data")] = None,
        cursor_page_request: Annotated[Optional[StrictStr], Field(description="The page to request, w.r.t the current page. Can be one of `FIRST`, `PREVIOUS`, `NEXT`, `LAST`")] = None,
        cursor_page_size: Annotated[Optional[StrictStr], Field(description="The size of the page requested. The handling service should impose a hard limit on this")] = None,
        statuses: Annotated[Optional[List[StrictStr]], Field(description="Filter shared addresses by specifying a list of statuses. Accepted status values:  'new', 'pending', 'rejected', 'accepted', 'unshared'")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """List shared addresses

        This endpoint returns a list of addresses that you shared or that are shared to you via Taurus-NETWORK. You can filter the results by specifying the owner or the target of the shared addresses.

        :param participant_id: Get all the shared addresses where the participantID is either the owner or the target of the shared address.
        :type participant_id: str
        :param owner_participant_id: Filter shared addresses by specifying who is the owner of the shared addresses (your participant or the counterparty)
        :type owner_participant_id: str
        :param target_participant_id: Filter shared addresses by specifying who is the target of the shared addresses (your participant or the counterparty)
        :type target_participant_id: str
        :param blockchain: Filter shared addresses by specifying the blockchain of the shared addresses
        :type blockchain: str
        :param network: Filter shared addresses by specifying the network of the shared addresses. It must be used in combination with the blockchain filter.
        :type network: str
        :param ids: Filter shared addresses by specifying the shared address IDs
        :type ids: List[str]
        :param sort_order: Set this parameter to ASC to get the id sorted in ASC order or DESC to get them in descending order. By default, the order is DESC.
        :type sort_order: str
        :param cursor_current_page: Base64-encoded string representing the current window of data
        :type cursor_current_page: str
        :param cursor_page_request: The page to request, w.r.t the current page. Can be one of `FIRST`, `PREVIOUS`, `NEXT`, `LAST`
        :type cursor_page_request: str
        :param cursor_page_size: The size of the page requested. The handling service should impose a hard limit on this
        :type cursor_page_size: str
        :param statuses: Filter shared addresses by specifying a list of statuses. Accepted status values:  'new', 'pending', 'rejected', 'accepted', 'unshared'
        :type statuses: List[str]
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._taurus_network_service_get_shared_addresses_serialize(
            participant_id=participant_id,
            owner_participant_id=owner_participant_id,
            target_participant_id=target_participant_id,
            blockchain=blockchain,
            network=network,
            ids=ids,
            sort_order=sort_order,
            cursor_current_page=cursor_current_page,
            cursor_page_request=cursor_page_request,
            cursor_page_size=cursor_page_size,
            statuses=statuses,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "TgvalidatordGetSharedAddressesReply",
            '400': "object",
            '401': "object",
            '403': "object",
            '404': "object",
            '500': "object",
            '503': "object",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _taurus_network_service_get_shared_addresses_serialize(
        self,
        participant_id,
        owner_participant_id,
        target_participant_id,
        blockchain,
        network,
        ids,
        sort_order,
        cursor_current_page,
        cursor_page_request,
        cursor_page_size,
        statuses,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
            'ids': 'multi',
            'statuses': 'multi',
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        # process the query parameters
        if participant_id is not None:
            
            _query_params.append(('participantID', participant_id))
            
        if owner_participant_id is not None:
            
            _query_params.append(('ownerParticipantID', owner_participant_id))
            
        if target_participant_id is not None:
            
            _query_params.append(('targetParticipantID', target_participant_id))
            
        if blockchain is not None:
            
            _query_params.append(('blockchain', blockchain))
            
        if network is not None:
            
            _query_params.append(('network', network))
            
        if ids is not None:
            
            _query_params.append(('ids', ids))
            
        if sort_order is not None:
            
            _query_params.append(('sortOrder', sort_order))
            
        if cursor_current_page is not None:
            
            _query_params.append(('cursor.currentPage', cursor_current_page))
            
        if cursor_page_request is not None:
            
            _query_params.append(('cursor.pageRequest', cursor_page_request))
            
        if cursor_page_size is not None:
            
            _query_params.append(('cursor.pageSize', cursor_page_size))
            
        if statuses is not None:
            
            _query_params.append(('statuses', statuses))
            
        # process the header parameters
        # process the form parameters
        # process the body parameter


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json'
                ]
            )


        # authentication setting
        _auth_settings: List[str] = [
            'ApiKeyTPV1'
        ]

        return self.api_client.param_serialize(
            method='GET',
            resource_path='/api/rest/v1/tn/shared_addresses',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def taurus_network_service_get_shared_assets(
        self,
        participant_id: Annotated[Optional[StrictStr], Field(description="Get all the shared assets where the participantID is either the owner or the target of the shared assets.")] = None,
        owner_participant_id: Annotated[Optional[StrictStr], Field(description="Filter shared assets by specifying who is the owner of the shared assets (your participant or the counterparty)")] = None,
        target_participant_id: Annotated[Optional[StrictStr], Field(description="Filter shared assets by specifying who is the target of the shared assets (your participant or the counterparty)")] = None,
        blockchain: Annotated[Optional[StrictStr], Field(description="Filter shared assets by specifying the blockchain of the shared assets")] = None,
        network: Annotated[Optional[StrictStr], Field(description="Filter shared assets by specifying the network of the shared assets. It must be used in combination with the blockchain filter.")] = None,
        ids: Annotated[Optional[List[StrictStr]], Field(description="Filter shared addresses by specifying the shared asset IDs")] = None,
        sort_order: Annotated[Optional[StrictStr], Field(description="Set this parameter to ASC to get the id sorted in ASC order or DESC to get them in descending order. By default, the order is DESC.")] = None,
        cursor_current_page: Annotated[Optional[StrictStr], Field(description="Base64-encoded string representing the current window of data")] = None,
        cursor_page_request: Annotated[Optional[StrictStr], Field(description="The page to request, w.r.t the current page. Can be one of `FIRST`, `PREVIOUS`, `NEXT`, `LAST`")] = None,
        cursor_page_size: Annotated[Optional[StrictStr], Field(description="The size of the page requested. The handling service should impose a hard limit on this")] = None,
        statuses: Annotated[Optional[List[StrictStr]], Field(description="Filter shared assets by specifying a list of statuses. Accepted status values:  'new', 'pending', 'rejected', 'accepted', 'unshared'")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> TgvalidatordGetSharedAssetsReply:
        """List shared assets

        This endpoint returns a list of whitelisted assets that you shared or that are shared to you via Taurus-NETWORK. You can filter the results by specifying the owner or the target of the shared assets.

        :param participant_id: Get all the shared assets where the participantID is either the owner or the target of the shared assets.
        :type participant_id: str
        :param owner_participant_id: Filter shared assets by specifying who is the owner of the shared assets (your participant or the counterparty)
        :type owner_participant_id: str
        :param target_participant_id: Filter shared assets by specifying who is the target of the shared assets (your participant or the counterparty)
        :type target_participant_id: str
        :param blockchain: Filter shared assets by specifying the blockchain of the shared assets
        :type blockchain: str
        :param network: Filter shared assets by specifying the network of the shared assets. It must be used in combination with the blockchain filter.
        :type network: str
        :param ids: Filter shared addresses by specifying the shared asset IDs
        :type ids: List[str]
        :param sort_order: Set this parameter to ASC to get the id sorted in ASC order or DESC to get them in descending order. By default, the order is DESC.
        :type sort_order: str
        :param cursor_current_page: Base64-encoded string representing the current window of data
        :type cursor_current_page: str
        :param cursor_page_request: The page to request, w.r.t the current page. Can be one of `FIRST`, `PREVIOUS`, `NEXT`, `LAST`
        :type cursor_page_request: str
        :param cursor_page_size: The size of the page requested. The handling service should impose a hard limit on this
        :type cursor_page_size: str
        :param statuses: Filter shared assets by specifying a list of statuses. Accepted status values:  'new', 'pending', 'rejected', 'accepted', 'unshared'
        :type statuses: List[str]
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._taurus_network_service_get_shared_assets_serialize(
            participant_id=participant_id,
            owner_participant_id=owner_participant_id,
            target_participant_id=target_participant_id,
            blockchain=blockchain,
            network=network,
            ids=ids,
            sort_order=sort_order,
            cursor_current_page=cursor_current_page,
            cursor_page_request=cursor_page_request,
            cursor_page_size=cursor_page_size,
            statuses=statuses,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "TgvalidatordGetSharedAssetsReply",
            '400': "object",
            '401': "object",
            '403': "object",
            '404': "object",
            '500': "object",
            '503': "object",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def taurus_network_service_get_shared_assets_with_http_info(
        self,
        participant_id: Annotated[Optional[StrictStr], Field(description="Get all the shared assets where the participantID is either the owner or the target of the shared assets.")] = None,
        owner_participant_id: Annotated[Optional[StrictStr], Field(description="Filter shared assets by specifying who is the owner of the shared assets (your participant or the counterparty)")] = None,
        target_participant_id: Annotated[Optional[StrictStr], Field(description="Filter shared assets by specifying who is the target of the shared assets (your participant or the counterparty)")] = None,
        blockchain: Annotated[Optional[StrictStr], Field(description="Filter shared assets by specifying the blockchain of the shared assets")] = None,
        network: Annotated[Optional[StrictStr], Field(description="Filter shared assets by specifying the network of the shared assets. It must be used in combination with the blockchain filter.")] = None,
        ids: Annotated[Optional[List[StrictStr]], Field(description="Filter shared addresses by specifying the shared asset IDs")] = None,
        sort_order: Annotated[Optional[StrictStr], Field(description="Set this parameter to ASC to get the id sorted in ASC order or DESC to get them in descending order. By default, the order is DESC.")] = None,
        cursor_current_page: Annotated[Optional[StrictStr], Field(description="Base64-encoded string representing the current window of data")] = None,
        cursor_page_request: Annotated[Optional[StrictStr], Field(description="The page to request, w.r.t the current page. Can be one of `FIRST`, `PREVIOUS`, `NEXT`, `LAST`")] = None,
        cursor_page_size: Annotated[Optional[StrictStr], Field(description="The size of the page requested. The handling service should impose a hard limit on this")] = None,
        statuses: Annotated[Optional[List[StrictStr]], Field(description="Filter shared assets by specifying a list of statuses. Accepted status values:  'new', 'pending', 'rejected', 'accepted', 'unshared'")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[TgvalidatordGetSharedAssetsReply]:
        """List shared assets

        This endpoint returns a list of whitelisted assets that you shared or that are shared to you via Taurus-NETWORK. You can filter the results by specifying the owner or the target of the shared assets.

        :param participant_id: Get all the shared assets where the participantID is either the owner or the target of the shared assets.
        :type participant_id: str
        :param owner_participant_id: Filter shared assets by specifying who is the owner of the shared assets (your participant or the counterparty)
        :type owner_participant_id: str
        :param target_participant_id: Filter shared assets by specifying who is the target of the shared assets (your participant or the counterparty)
        :type target_participant_id: str
        :param blockchain: Filter shared assets by specifying the blockchain of the shared assets
        :type blockchain: str
        :param network: Filter shared assets by specifying the network of the shared assets. It must be used in combination with the blockchain filter.
        :type network: str
        :param ids: Filter shared addresses by specifying the shared asset IDs
        :type ids: List[str]
        :param sort_order: Set this parameter to ASC to get the id sorted in ASC order or DESC to get them in descending order. By default, the order is DESC.
        :type sort_order: str
        :param cursor_current_page: Base64-encoded string representing the current window of data
        :type cursor_current_page: str
        :param cursor_page_request: The page to request, w.r.t the current page. Can be one of `FIRST`, `PREVIOUS`, `NEXT`, `LAST`
        :type cursor_page_request: str
        :param cursor_page_size: The size of the page requested. The handling service should impose a hard limit on this
        :type cursor_page_size: str
        :param statuses: Filter shared assets by specifying a list of statuses. Accepted status values:  'new', 'pending', 'rejected', 'accepted', 'unshared'
        :type statuses: List[str]
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._taurus_network_service_get_shared_assets_serialize(
            participant_id=participant_id,
            owner_participant_id=owner_participant_id,
            target_participant_id=target_participant_id,
            blockchain=blockchain,
            network=network,
            ids=ids,
            sort_order=sort_order,
            cursor_current_page=cursor_current_page,
            cursor_page_request=cursor_page_request,
            cursor_page_size=cursor_page_size,
            statuses=statuses,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "TgvalidatordGetSharedAssetsReply",
            '400': "object",
            '401': "object",
            '403': "object",
            '404': "object",
            '500': "object",
            '503': "object",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def taurus_network_service_get_shared_assets_without_preload_content(
        self,
        participant_id: Annotated[Optional[StrictStr], Field(description="Get all the shared assets where the participantID is either the owner or the target of the shared assets.")] = None,
        owner_participant_id: Annotated[Optional[StrictStr], Field(description="Filter shared assets by specifying who is the owner of the shared assets (your participant or the counterparty)")] = None,
        target_participant_id: Annotated[Optional[StrictStr], Field(description="Filter shared assets by specifying who is the target of the shared assets (your participant or the counterparty)")] = None,
        blockchain: Annotated[Optional[StrictStr], Field(description="Filter shared assets by specifying the blockchain of the shared assets")] = None,
        network: Annotated[Optional[StrictStr], Field(description="Filter shared assets by specifying the network of the shared assets. It must be used in combination with the blockchain filter.")] = None,
        ids: Annotated[Optional[List[StrictStr]], Field(description="Filter shared addresses by specifying the shared asset IDs")] = None,
        sort_order: Annotated[Optional[StrictStr], Field(description="Set this parameter to ASC to get the id sorted in ASC order or DESC to get them in descending order. By default, the order is DESC.")] = None,
        cursor_current_page: Annotated[Optional[StrictStr], Field(description="Base64-encoded string representing the current window of data")] = None,
        cursor_page_request: Annotated[Optional[StrictStr], Field(description="The page to request, w.r.t the current page. Can be one of `FIRST`, `PREVIOUS`, `NEXT`, `LAST`")] = None,
        cursor_page_size: Annotated[Optional[StrictStr], Field(description="The size of the page requested. The handling service should impose a hard limit on this")] = None,
        statuses: Annotated[Optional[List[StrictStr]], Field(description="Filter shared assets by specifying a list of statuses. Accepted status values:  'new', 'pending', 'rejected', 'accepted', 'unshared'")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """List shared assets

        This endpoint returns a list of whitelisted assets that you shared or that are shared to you via Taurus-NETWORK. You can filter the results by specifying the owner or the target of the shared assets.

        :param participant_id: Get all the shared assets where the participantID is either the owner or the target of the shared assets.
        :type participant_id: str
        :param owner_participant_id: Filter shared assets by specifying who is the owner of the shared assets (your participant or the counterparty)
        :type owner_participant_id: str
        :param target_participant_id: Filter shared assets by specifying who is the target of the shared assets (your participant or the counterparty)
        :type target_participant_id: str
        :param blockchain: Filter shared assets by specifying the blockchain of the shared assets
        :type blockchain: str
        :param network: Filter shared assets by specifying the network of the shared assets. It must be used in combination with the blockchain filter.
        :type network: str
        :param ids: Filter shared addresses by specifying the shared asset IDs
        :type ids: List[str]
        :param sort_order: Set this parameter to ASC to get the id sorted in ASC order or DESC to get them in descending order. By default, the order is DESC.
        :type sort_order: str
        :param cursor_current_page: Base64-encoded string representing the current window of data
        :type cursor_current_page: str
        :param cursor_page_request: The page to request, w.r.t the current page. Can be one of `FIRST`, `PREVIOUS`, `NEXT`, `LAST`
        :type cursor_page_request: str
        :param cursor_page_size: The size of the page requested. The handling service should impose a hard limit on this
        :type cursor_page_size: str
        :param statuses: Filter shared assets by specifying a list of statuses. Accepted status values:  'new', 'pending', 'rejected', 'accepted', 'unshared'
        :type statuses: List[str]
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._taurus_network_service_get_shared_assets_serialize(
            participant_id=participant_id,
            owner_participant_id=owner_participant_id,
            target_participant_id=target_participant_id,
            blockchain=blockchain,
            network=network,
            ids=ids,
            sort_order=sort_order,
            cursor_current_page=cursor_current_page,
            cursor_page_request=cursor_page_request,
            cursor_page_size=cursor_page_size,
            statuses=statuses,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "TgvalidatordGetSharedAssetsReply",
            '400': "object",
            '401': "object",
            '403': "object",
            '404': "object",
            '500': "object",
            '503': "object",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _taurus_network_service_get_shared_assets_serialize(
        self,
        participant_id,
        owner_participant_id,
        target_participant_id,
        blockchain,
        network,
        ids,
        sort_order,
        cursor_current_page,
        cursor_page_request,
        cursor_page_size,
        statuses,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
            'ids': 'multi',
            'statuses': 'multi',
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        # process the query parameters
        if participant_id is not None:
            
            _query_params.append(('participantID', participant_id))
            
        if owner_participant_id is not None:
            
            _query_params.append(('ownerParticipantID', owner_participant_id))
            
        if target_participant_id is not None:
            
            _query_params.append(('targetParticipantID', target_participant_id))
            
        if blockchain is not None:
            
            _query_params.append(('blockchain', blockchain))
            
        if network is not None:
            
            _query_params.append(('network', network))
            
        if ids is not None:
            
            _query_params.append(('ids', ids))
            
        if sort_order is not None:
            
            _query_params.append(('sortOrder', sort_order))
            
        if cursor_current_page is not None:
            
            _query_params.append(('cursor.currentPage', cursor_current_page))
            
        if cursor_page_request is not None:
            
            _query_params.append(('cursor.pageRequest', cursor_page_request))
            
        if cursor_page_size is not None:
            
            _query_params.append(('cursor.pageSize', cursor_page_size))
            
        if statuses is not None:
            
            _query_params.append(('statuses', statuses))
            
        # process the header parameters
        # process the form parameters
        # process the body parameter


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json'
                ]
            )


        # authentication setting
        _auth_settings: List[str] = [
            'ApiKeyTPV1'
        ]

        return self.api_client.param_serialize(
            method='GET',
            resource_path='/api/rest/v1/tn/shared_assets',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def taurus_network_service_share_address(
        self,
        body: TgvalidatordShareAddressRequest,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> object:
        """Share an address

        This endpoint shares an internal address with a Taurus-NETWORK participant. It will automatically create a whitelisted address to be approved/rejected on the target participant side.

        :param body: (required)
        :type body: TgvalidatordShareAddressRequest
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._taurus_network_service_share_address_serialize(
            body=body,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "object",
            '400': "object",
            '401': "object",
            '403': "object",
            '404': "object",
            '500': "object",
            '503': "object",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def taurus_network_service_share_address_with_http_info(
        self,
        body: TgvalidatordShareAddressRequest,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[object]:
        """Share an address

        This endpoint shares an internal address with a Taurus-NETWORK participant. It will automatically create a whitelisted address to be approved/rejected on the target participant side.

        :param body: (required)
        :type body: TgvalidatordShareAddressRequest
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._taurus_network_service_share_address_serialize(
            body=body,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "object",
            '400': "object",
            '401': "object",
            '403': "object",
            '404': "object",
            '500': "object",
            '503': "object",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def taurus_network_service_share_address_without_preload_content(
        self,
        body: TgvalidatordShareAddressRequest,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """Share an address

        This endpoint shares an internal address with a Taurus-NETWORK participant. It will automatically create a whitelisted address to be approved/rejected on the target participant side.

        :param body: (required)
        :type body: TgvalidatordShareAddressRequest
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._taurus_network_service_share_address_serialize(
            body=body,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "object",
            '400': "object",
            '401': "object",
            '403': "object",
            '404': "object",
            '500': "object",
            '503': "object",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _taurus_network_service_share_address_serialize(
        self,
        body,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        # process the query parameters
        # process the header parameters
        # process the form parameters
        # process the body parameter
        if body is not None:
            _body_params = body


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json'
                ]
            )

        # set the HTTP header `Content-Type`
        if _content_type:
            _header_params['Content-Type'] = _content_type
        else:
            _default_content_type = (
                self.api_client.select_header_content_type(
                    [
                        'application/json'
                    ]
                )
            )
            if _default_content_type is not None:
                _header_params['Content-Type'] = _default_content_type

        # authentication setting
        _auth_settings: List[str] = [
            'ApiKeyTPV1'
        ]

        return self.api_client.param_serialize(
            method='POST',
            resource_path='/api/rest/v1/tn/shared_addresses',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def taurus_network_service_share_whitelisted_asset(
        self,
        body: TgvalidatordShareWhitelistedAssetRequest,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> object:
        """Share an asset

        This endpoint shares an asset with a Taurus-NETWORK participant. It will automatically create a whitelisted asset to be approved/rejected on the target participant side.

        :param body: (required)
        :type body: TgvalidatordShareWhitelistedAssetRequest
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._taurus_network_service_share_whitelisted_asset_serialize(
            body=body,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "object",
            '400': "object",
            '401': "object",
            '403': "object",
            '404': "object",
            '500': "object",
            '503': "object",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def taurus_network_service_share_whitelisted_asset_with_http_info(
        self,
        body: TgvalidatordShareWhitelistedAssetRequest,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[object]:
        """Share an asset

        This endpoint shares an asset with a Taurus-NETWORK participant. It will automatically create a whitelisted asset to be approved/rejected on the target participant side.

        :param body: (required)
        :type body: TgvalidatordShareWhitelistedAssetRequest
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._taurus_network_service_share_whitelisted_asset_serialize(
            body=body,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "object",
            '400': "object",
            '401': "object",
            '403': "object",
            '404': "object",
            '500': "object",
            '503': "object",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def taurus_network_service_share_whitelisted_asset_without_preload_content(
        self,
        body: TgvalidatordShareWhitelistedAssetRequest,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """Share an asset

        This endpoint shares an asset with a Taurus-NETWORK participant. It will automatically create a whitelisted asset to be approved/rejected on the target participant side.

        :param body: (required)
        :type body: TgvalidatordShareWhitelistedAssetRequest
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._taurus_network_service_share_whitelisted_asset_serialize(
            body=body,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "object",
            '400': "object",
            '401': "object",
            '403': "object",
            '404': "object",
            '500': "object",
            '503': "object",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _taurus_network_service_share_whitelisted_asset_serialize(
        self,
        body,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        # process the query parameters
        # process the header parameters
        # process the form parameters
        # process the body parameter
        if body is not None:
            _body_params = body


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json'
                ]
            )

        # set the HTTP header `Content-Type`
        if _content_type:
            _header_params['Content-Type'] = _content_type
        else:
            _default_content_type = (
                self.api_client.select_header_content_type(
                    [
                        'application/json'
                    ]
                )
            )
            if _default_content_type is not None:
                _header_params['Content-Type'] = _default_content_type

        # authentication setting
        _auth_settings: List[str] = [
            'ApiKeyTPV1'
        ]

        return self.api_client.param_serialize(
            method='POST',
            resource_path='/api/rest/v1/tn/shared_assets',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def taurus_network_service_unshare_address(
        self,
        tn_shared_address_id: Annotated[StrictStr, Field(description="The ID of the shared address to unshare.")],
        body: Dict[str, Any],
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> object:
        """Unshare an address

        This endpoint unshares an address with a Taurus-NETWORK participant. The address must be shared with the participant to be unshared. Unsharing an address will not delete shared address in the participant registry, it will update the status of the shared address.

        :param tn_shared_address_id: The ID of the shared address to unshare. (required)
        :type tn_shared_address_id: str
        :param body: (required)
        :type body: object
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._taurus_network_service_unshare_address_serialize(
            tn_shared_address_id=tn_shared_address_id,
            body=body,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "object",
            '400': "object",
            '401': "object",
            '403': "object",
            '404': "object",
            '500': "object",
            '503': "object",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def taurus_network_service_unshare_address_with_http_info(
        self,
        tn_shared_address_id: Annotated[StrictStr, Field(description="The ID of the shared address to unshare.")],
        body: Dict[str, Any],
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[object]:
        """Unshare an address

        This endpoint unshares an address with a Taurus-NETWORK participant. The address must be shared with the participant to be unshared. Unsharing an address will not delete shared address in the participant registry, it will update the status of the shared address.

        :param tn_shared_address_id: The ID of the shared address to unshare. (required)
        :type tn_shared_address_id: str
        :param body: (required)
        :type body: object
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._taurus_network_service_unshare_address_serialize(
            tn_shared_address_id=tn_shared_address_id,
            body=body,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "object",
            '400': "object",
            '401': "object",
            '403': "object",
            '404': "object",
            '500': "object",
            '503': "object",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def taurus_network_service_unshare_address_without_preload_content(
        self,
        tn_shared_address_id: Annotated[StrictStr, Field(description="The ID of the shared address to unshare.")],
        body: Dict[str, Any],
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """Unshare an address

        This endpoint unshares an address with a Taurus-NETWORK participant. The address must be shared with the participant to be unshared. Unsharing an address will not delete shared address in the participant registry, it will update the status of the shared address.

        :param tn_shared_address_id: The ID of the shared address to unshare. (required)
        :type tn_shared_address_id: str
        :param body: (required)
        :type body: object
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._taurus_network_service_unshare_address_serialize(
            tn_shared_address_id=tn_shared_address_id,
            body=body,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "object",
            '400': "object",
            '401': "object",
            '403': "object",
            '404': "object",
            '500': "object",
            '503': "object",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _taurus_network_service_unshare_address_serialize(
        self,
        tn_shared_address_id,
        body,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        if tn_shared_address_id is not None:
            _path_params['tnSharedAddressID'] = tn_shared_address_id
        # process the query parameters
        # process the header parameters
        # process the form parameters
        # process the body parameter
        if body is not None:
            _body_params = body


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json'
                ]
            )

        # set the HTTP header `Content-Type`
        if _content_type:
            _header_params['Content-Type'] = _content_type
        else:
            _default_content_type = (
                self.api_client.select_header_content_type(
                    [
                        'application/json'
                    ]
                )
            )
            if _default_content_type is not None:
                _header_params['Content-Type'] = _default_content_type

        # authentication setting
        _auth_settings: List[str] = [
            'ApiKeyTPV1'
        ]

        return self.api_client.param_serialize(
            method='POST',
            resource_path='/api/rest/v1/tn/shared_addresses/{tnSharedAddressID}/unshare',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def taurus_network_service_unshare_whitelisted_asset(
        self,
        tn_shared_asset_id: StrictStr,
        body: Dict[str, Any],
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> object:
        """Unshare an asset

        This endpoint unshares an asset with a Taurus-NETWORK participant. The asset must be shared with the participant to be unshared. Unsharing an asset will not delete shared asset in the participant registry, it will update the status of the shared address.

        :param tn_shared_asset_id: (required)
        :type tn_shared_asset_id: str
        :param body: (required)
        :type body: object
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._taurus_network_service_unshare_whitelisted_asset_serialize(
            tn_shared_asset_id=tn_shared_asset_id,
            body=body,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "object",
            '400': "object",
            '401': "object",
            '403': "object",
            '404': "object",
            '500': "object",
            '503': "object",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def taurus_network_service_unshare_whitelisted_asset_with_http_info(
        self,
        tn_shared_asset_id: StrictStr,
        body: Dict[str, Any],
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[object]:
        """Unshare an asset

        This endpoint unshares an asset with a Taurus-NETWORK participant. The asset must be shared with the participant to be unshared. Unsharing an asset will not delete shared asset in the participant registry, it will update the status of the shared address.

        :param tn_shared_asset_id: (required)
        :type tn_shared_asset_id: str
        :param body: (required)
        :type body: object
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._taurus_network_service_unshare_whitelisted_asset_serialize(
            tn_shared_asset_id=tn_shared_asset_id,
            body=body,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "object",
            '400': "object",
            '401': "object",
            '403': "object",
            '404': "object",
            '500': "object",
            '503': "object",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def taurus_network_service_unshare_whitelisted_asset_without_preload_content(
        self,
        tn_shared_asset_id: StrictStr,
        body: Dict[str, Any],
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """Unshare an asset

        This endpoint unshares an asset with a Taurus-NETWORK participant. The asset must be shared with the participant to be unshared. Unsharing an asset will not delete shared asset in the participant registry, it will update the status of the shared address.

        :param tn_shared_asset_id: (required)
        :type tn_shared_asset_id: str
        :param body: (required)
        :type body: object
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._taurus_network_service_unshare_whitelisted_asset_serialize(
            tn_shared_asset_id=tn_shared_asset_id,
            body=body,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "object",
            '400': "object",
            '401': "object",
            '403': "object",
            '404': "object",
            '500': "object",
            '503': "object",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _taurus_network_service_unshare_whitelisted_asset_serialize(
        self,
        tn_shared_asset_id,
        body,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        if tn_shared_asset_id is not None:
            _path_params['tnSharedAssetID'] = tn_shared_asset_id
        # process the query parameters
        # process the header parameters
        # process the form parameters
        # process the body parameter
        if body is not None:
            _body_params = body


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json'
                ]
            )

        # set the HTTP header `Content-Type`
        if _content_type:
            _header_params['Content-Type'] = _content_type
        else:
            _default_content_type = (
                self.api_client.select_header_content_type(
                    [
                        'application/json'
                    ]
                )
            )
            if _default_content_type is not None:
                _header_params['Content-Type'] = _default_content_type

        # authentication setting
        _auth_settings: List[str] = [
            'ApiKeyTPV1'
        ]

        return self.api_client.param_serialize(
            method='POST',
            resource_path='/api/rest/v1/tn/shared_assets/{tnSharedAssetID}/unshare',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )


