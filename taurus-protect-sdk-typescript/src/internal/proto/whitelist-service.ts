// Code generated by protoc-gen-ts_proto. DO NOT EDIT.
// versions:
//   protoc-gen-ts_proto  v1.181.2
//   protoc               v6.33.4
// source: whitelist-service.proto

/* eslint-disable */
import Long from "long";
import _m0 from "protobufjs/minimal";
import { Empty } from "./google/protobuf/empty";
import { Timestamp } from "./google/protobuf/timestamp";
import { ScoreFilter } from "./score";
import {
  SignedWhitelistedAddressEnvelope,
  SignedWhitelistedContractAddressEnvelope,
  WhitelistedAddressAttribute,
  WhitelistedAddressBatchSignature,
  WhitelistedContractAddressAttribute,
} from "./whitelist";

export const protobufPackage = "tgvalidatord";

export interface GetSignedWhitelistedAddressEnvelopeRequest {
  id: number;
}

export interface GetSignedWhitelistedAddressEnvelopeReply {
  result: SignedWhitelistedAddressEnvelope | undefined;
}

export interface GetSignedWhitelistedAddressEnvelopesRequest {
  limit: number;
  offset: number;
  /** @deprecated */
  exchangeAccountId: number;
  addressType: string;
  query: string;
  /** @deprecated */
  currency: string;
  /** @deprecated */
  scoreProvider: string;
  /** @deprecated */
  scoreInBelow: string;
  /** @deprecated */
  scoreOutBelow: string;
  /** @deprecated */
  scoreExclusive: boolean;
  rulesContainerNormalized: boolean;
  exchangeAccountIds: number[];
  /** @deprecated */
  coinfirmScoreGreater: string;
  tagIDs: string[];
  /** @deprecated */
  chainalysisScoreGreater: string;
  /** @deprecated */
  contractType: string;
  allowedForAddressId: number;
  allowedForWalletId: number;
  blockchain: string;
  includeForApproval: boolean;
  addresses: string[];
  network: string;
  ids: number[];
  tnParticipantID: string;
  scoreFilter: ScoreFilter | undefined;
  lastIncomingTxFromWhitelistedAddress: Date | undefined;
  contractTypes: string[];
  attributeFiltersJson: string;
  attributeFiltersOperator: string;
}

export interface AttributeFilter {
  key: string;
  value: string;
  type: string;
  operator: string;
}

export interface HashRulesContainer {
  hash: string;
  rulesContainer: string;
  rulesSignatures: string;
}

export interface GetSignedWhitelistedAddressEnvelopesReply {
  result: SignedWhitelistedAddressEnvelope[];
  totalItems: number;
  rulesContainers: HashRulesContainer[];
}

export interface ExportWhitelistedAddressesRequest {
  format: string;
  /** @deprecated */
  exchangeAccountId: number;
  addressType: string;
  query: string;
  /** @deprecated */
  currency: string;
  /** @deprecated */
  scoreProvider: string;
  /** @deprecated */
  scoreInBelow: string;
  /** @deprecated */
  scoreOutBelow: string;
  /** @deprecated */
  scoreExclusive: boolean;
  exchangeAccountIds: number[];
  /** @deprecated */
  coinfirmScoreGreater: string;
  tags: string[];
  /** @deprecated */
  chainalysisScoreGreater: string;
  blockchain: string;
  addresses: string[];
  network: string;
  scoreFilter: ScoreFilter | undefined;
}

export interface ExportWhitelistedAddressesReply {
  result: string;
  totalItems: number;
}

export interface GetWhitelistedAddressesForApprovalRequest {
  limit: number;
  offset: number;
  ids: number[];
  blockchain: string;
  addressType: string;
  query: string;
  network: string;
  includeAlreadySignedByUser: boolean;
}

export interface CreateWhitelistedAddressRequest {
  address: string;
  memo: string;
  label: string;
  exchangeAccountId: number;
  customerId: string;
  linkedInternalAddressIds: number[];
  addressType: string;
  contractType: string;
  linkedWalletIds: number[];
  blockchain: string;
  network: string;
  visibilityGroupID: string;
  /** @deprecated */
  currency: string;
}

export interface ApproveWhitelistedAddressRequest {
  signature: string;
  comment: string;
  /** @deprecated */
  whitelistedAddressIds: number[];
  ids: number[];
  async: boolean;
}

export interface ApproveWhitelistingReply {
  signatures: number;
  asyncSignature: WhitelistedAddressBatchSignature | undefined;
}

export interface GetAsyncWhitelistedAddressApprovalsRequest {
  ids: number[];
  includeDetails: boolean;
}

export interface GetAsyncWhitelistedAddressApprovalsReply {
  result: WhitelistedAddressBatchSignature[];
}

export interface RejectWhitelistedAddressRequest {
  /** @deprecated */
  id: number;
  comment: string;
  ids: number[];
}

export interface DeleteWhitelistedAddressRequest {
  id: number;
  comment: string;
}

export interface GetWhitelistedAddressAttributeRequest {
  whitelistedAddressId: number;
  id: number;
}

export interface GetWhitelistedAddressAttributeReply {
  result: WhitelistedAddressAttribute | undefined;
}

export interface CreateWhitelistedAddressAttributesRequest {
  whitelistedAddressId: number;
  attributes: CreateWhitelistedAddressAttributeRequest[];
}

export interface CreateWhitelistedAddressAttributesReply {
  result: WhitelistedAddressAttribute[];
}

export interface CreateWhitelistedAddressAttributeRequest {
  key: string;
  value: string;
  contentType: string;
  type: string;
  subtype: string;
  isfile: boolean;
}

export interface DeleteWhitelistedAddressAttributeRequest {
  whitelistedAddressId: number;
  id: number;
}

export interface GetSignedWhitelistedContractAddressEnvelopeRequest {
  id: number;
}

export interface GetSignedWhitelistedContractAddressEnvelopeReply {
  result: SignedWhitelistedContractAddressEnvelope | undefined;
}

export interface GetSignedWhitelistedContractAddressEnvelopesRequest {
  limit: number;
  offset: number;
  query: string;
  blockchain: string;
  includeForApproval: boolean;
  network: string;
  /** @deprecated */
  isNFT: boolean;
  whitelistedContractAddressIds: number[];
  kindTypes: string[];
}

export interface GetSignedWhitelistedContractAddressEnvelopesReply {
  result: SignedWhitelistedContractAddressEnvelope[];
  totalItems: number;
}

export interface GetWhitelistedContractAddressesForApprovalRequest {
  limit: number;
  offset: number;
  ids: number[];
}

export interface CreateWhitelistedContractAddressRequest {
  blockchain: string;
  contractAddress: string;
  symbol: string;
  name: string;
  decimals: number;
  tokenId: string;
  kind: string;
  network: string;
}

export interface UpdateWhitelistedContractAddressRequest {
  id: number;
  symbol: string;
  name: string;
  decimals: number;
}

export interface UpdateWhitelistedContractAddressResult {
  updatedContractTemporaryId: number;
}

export interface UpdateWhitelistedContractAddressReply {
  result: UpdateWhitelistedContractAddressResult | undefined;
}

export interface RejectWhitelistedContractAddressRequest {
  /** @deprecated */
  id: number;
  comment: string;
  ids: number[];
}

export interface DeleteWhitelistedContractAddressRequest {
  id: number;
  comment: string;
}

export interface ApproveWhitelistedContractAddressRequest {
  signature: string;
  comment: string;
  /** @deprecated */
  whitelistedContractAddressIds: number[];
  ids: number[];
}

export interface GetWhitelistedContractAddressAttributeRequest {
  whitelistedContractAddressId: number;
  id: number;
}

export interface GetWhitelistedContractAddressAttributeReply {
  result: WhitelistedContractAddressAttribute | undefined;
}

export interface CreateWhitelistedContractAddressAttributesRequest {
  whitelistedContractAddressId: number;
  attributes: CreateWhitelistedContractAddressAttributeRequest[];
}

export interface CreateWhitelistedContractAddressAttributeRequest {
  key: string;
  value: string;
  contentType: string;
  type: string;
  subtype: string;
  isfile: boolean;
}

export interface CreateWhitelistedContractAddressAttributesReply {
  result: WhitelistedContractAddressAttribute[];
}

export interface DeleteWhitelistedContractAddressAttributeRequest {
  whitelistedContractAddressId: number;
  id: number;
}

export interface IDResult {
  id: number;
}

export interface CreateReply {
  result: IDResult | undefined;
}

function createBaseGetSignedWhitelistedAddressEnvelopeRequest(): GetSignedWhitelistedAddressEnvelopeRequest {
  return { id: 0 };
}

export const GetSignedWhitelistedAddressEnvelopeRequest = {
  encode(message: GetSignedWhitelistedAddressEnvelopeRequest, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.id !== 0) {
      writer.uint32(8).uint64(message.id);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): GetSignedWhitelistedAddressEnvelopeRequest {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetSignedWhitelistedAddressEnvelopeRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.id = longToNumber(reader.uint64() as Long);
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetSignedWhitelistedAddressEnvelopeRequest {
    return { id: isSet(object.id) ? globalThis.Number(object.id) : 0 };
  },

  toJSON(message: GetSignedWhitelistedAddressEnvelopeRequest): unknown {
    const obj: any = {};
    if (message.id !== 0) {
      obj.id = Math.round(message.id);
    }
    return obj;
  },

  create(base?: DeepPartial<GetSignedWhitelistedAddressEnvelopeRequest>): GetSignedWhitelistedAddressEnvelopeRequest {
    return GetSignedWhitelistedAddressEnvelopeRequest.fromPartial(base ?? {});
  },
  fromPartial(
    object: DeepPartial<GetSignedWhitelistedAddressEnvelopeRequest>,
  ): GetSignedWhitelistedAddressEnvelopeRequest {
    const message = createBaseGetSignedWhitelistedAddressEnvelopeRequest();
    message.id = object.id ?? 0;
    return message;
  },
};

function createBaseGetSignedWhitelistedAddressEnvelopeReply(): GetSignedWhitelistedAddressEnvelopeReply {
  return { result: undefined };
}

export const GetSignedWhitelistedAddressEnvelopeReply = {
  encode(message: GetSignedWhitelistedAddressEnvelopeReply, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.result !== undefined) {
      SignedWhitelistedAddressEnvelope.encode(message.result, writer.uint32(10).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): GetSignedWhitelistedAddressEnvelopeReply {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetSignedWhitelistedAddressEnvelopeReply();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.result = SignedWhitelistedAddressEnvelope.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetSignedWhitelistedAddressEnvelopeReply {
    return { result: isSet(object.result) ? SignedWhitelistedAddressEnvelope.fromJSON(object.result) : undefined };
  },

  toJSON(message: GetSignedWhitelistedAddressEnvelopeReply): unknown {
    const obj: any = {};
    if (message.result !== undefined) {
      obj.result = SignedWhitelistedAddressEnvelope.toJSON(message.result);
    }
    return obj;
  },

  create(base?: DeepPartial<GetSignedWhitelistedAddressEnvelopeReply>): GetSignedWhitelistedAddressEnvelopeReply {
    return GetSignedWhitelistedAddressEnvelopeReply.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<GetSignedWhitelistedAddressEnvelopeReply>): GetSignedWhitelistedAddressEnvelopeReply {
    const message = createBaseGetSignedWhitelistedAddressEnvelopeReply();
    message.result = (object.result !== undefined && object.result !== null)
      ? SignedWhitelistedAddressEnvelope.fromPartial(object.result)
      : undefined;
    return message;
  },
};

function createBaseGetSignedWhitelistedAddressEnvelopesRequest(): GetSignedWhitelistedAddressEnvelopesRequest {
  return {
    limit: 0,
    offset: 0,
    exchangeAccountId: 0,
    addressType: "",
    query: "",
    currency: "",
    scoreProvider: "",
    scoreInBelow: "",
    scoreOutBelow: "",
    scoreExclusive: false,
    rulesContainerNormalized: false,
    exchangeAccountIds: [],
    coinfirmScoreGreater: "",
    tagIDs: [],
    chainalysisScoreGreater: "",
    contractType: "",
    allowedForAddressId: 0,
    allowedForWalletId: 0,
    blockchain: "",
    includeForApproval: false,
    addresses: [],
    network: "",
    ids: [],
    tnParticipantID: "",
    scoreFilter: undefined,
    lastIncomingTxFromWhitelistedAddress: undefined,
    contractTypes: [],
    attributeFiltersJson: "",
    attributeFiltersOperator: "",
  };
}

export const GetSignedWhitelistedAddressEnvelopesRequest = {
  encode(message: GetSignedWhitelistedAddressEnvelopesRequest, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.limit !== 0) {
      writer.uint32(8).uint64(message.limit);
    }
    if (message.offset !== 0) {
      writer.uint32(16).uint64(message.offset);
    }
    if (message.exchangeAccountId !== 0) {
      writer.uint32(24).uint64(message.exchangeAccountId);
    }
    if (message.addressType !== "") {
      writer.uint32(34).string(message.addressType);
    }
    if (message.query !== "") {
      writer.uint32(42).string(message.query);
    }
    if (message.currency !== "") {
      writer.uint32(50).string(message.currency);
    }
    if (message.scoreProvider !== "") {
      writer.uint32(58).string(message.scoreProvider);
    }
    if (message.scoreInBelow !== "") {
      writer.uint32(66).string(message.scoreInBelow);
    }
    if (message.scoreOutBelow !== "") {
      writer.uint32(74).string(message.scoreOutBelow);
    }
    if (message.scoreExclusive !== false) {
      writer.uint32(80).bool(message.scoreExclusive);
    }
    if (message.rulesContainerNormalized !== false) {
      writer.uint32(88).bool(message.rulesContainerNormalized);
    }
    writer.uint32(98).fork();
    for (const v of message.exchangeAccountIds) {
      writer.uint64(v);
    }
    writer.ldelim();
    if (message.coinfirmScoreGreater !== "") {
      writer.uint32(106).string(message.coinfirmScoreGreater);
    }
    for (const v of message.tagIDs) {
      writer.uint32(114).string(v!);
    }
    if (message.chainalysisScoreGreater !== "") {
      writer.uint32(122).string(message.chainalysisScoreGreater);
    }
    if (message.contractType !== "") {
      writer.uint32(130).string(message.contractType);
    }
    if (message.allowedForAddressId !== 0) {
      writer.uint32(136).uint64(message.allowedForAddressId);
    }
    if (message.allowedForWalletId !== 0) {
      writer.uint32(144).uint64(message.allowedForWalletId);
    }
    if (message.blockchain !== "") {
      writer.uint32(154).string(message.blockchain);
    }
    if (message.includeForApproval !== false) {
      writer.uint32(160).bool(message.includeForApproval);
    }
    for (const v of message.addresses) {
      writer.uint32(170).string(v!);
    }
    if (message.network !== "") {
      writer.uint32(178).string(message.network);
    }
    writer.uint32(186).fork();
    for (const v of message.ids) {
      writer.uint64(v);
    }
    writer.ldelim();
    if (message.tnParticipantID !== "") {
      writer.uint32(194).string(message.tnParticipantID);
    }
    if (message.scoreFilter !== undefined) {
      ScoreFilter.encode(message.scoreFilter, writer.uint32(202).fork()).ldelim();
    }
    if (message.lastIncomingTxFromWhitelistedAddress !== undefined) {
      Timestamp.encode(toTimestamp(message.lastIncomingTxFromWhitelistedAddress), writer.uint32(210).fork()).ldelim();
    }
    for (const v of message.contractTypes) {
      writer.uint32(218).string(v!);
    }
    if (message.attributeFiltersJson !== "") {
      writer.uint32(226).string(message.attributeFiltersJson);
    }
    if (message.attributeFiltersOperator !== "") {
      writer.uint32(234).string(message.attributeFiltersOperator);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): GetSignedWhitelistedAddressEnvelopesRequest {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetSignedWhitelistedAddressEnvelopesRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.limit = longToNumber(reader.uint64() as Long);
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.offset = longToNumber(reader.uint64() as Long);
          continue;
        case 3:
          if (tag !== 24) {
            break;
          }

          message.exchangeAccountId = longToNumber(reader.uint64() as Long);
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.addressType = reader.string();
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.query = reader.string();
          continue;
        case 6:
          if (tag !== 50) {
            break;
          }

          message.currency = reader.string();
          continue;
        case 7:
          if (tag !== 58) {
            break;
          }

          message.scoreProvider = reader.string();
          continue;
        case 8:
          if (tag !== 66) {
            break;
          }

          message.scoreInBelow = reader.string();
          continue;
        case 9:
          if (tag !== 74) {
            break;
          }

          message.scoreOutBelow = reader.string();
          continue;
        case 10:
          if (tag !== 80) {
            break;
          }

          message.scoreExclusive = reader.bool();
          continue;
        case 11:
          if (tag !== 88) {
            break;
          }

          message.rulesContainerNormalized = reader.bool();
          continue;
        case 12:
          if (tag === 96) {
            message.exchangeAccountIds.push(longToNumber(reader.uint64() as Long));

            continue;
          }

          if (tag === 98) {
            const end2 = reader.uint32() + reader.pos;
            while (reader.pos < end2) {
              message.exchangeAccountIds.push(longToNumber(reader.uint64() as Long));
            }

            continue;
          }

          break;
        case 13:
          if (tag !== 106) {
            break;
          }

          message.coinfirmScoreGreater = reader.string();
          continue;
        case 14:
          if (tag !== 114) {
            break;
          }

          message.tagIDs.push(reader.string());
          continue;
        case 15:
          if (tag !== 122) {
            break;
          }

          message.chainalysisScoreGreater = reader.string();
          continue;
        case 16:
          if (tag !== 130) {
            break;
          }

          message.contractType = reader.string();
          continue;
        case 17:
          if (tag !== 136) {
            break;
          }

          message.allowedForAddressId = longToNumber(reader.uint64() as Long);
          continue;
        case 18:
          if (tag !== 144) {
            break;
          }

          message.allowedForWalletId = longToNumber(reader.uint64() as Long);
          continue;
        case 19:
          if (tag !== 154) {
            break;
          }

          message.blockchain = reader.string();
          continue;
        case 20:
          if (tag !== 160) {
            break;
          }

          message.includeForApproval = reader.bool();
          continue;
        case 21:
          if (tag !== 170) {
            break;
          }

          message.addresses.push(reader.string());
          continue;
        case 22:
          if (tag !== 178) {
            break;
          }

          message.network = reader.string();
          continue;
        case 23:
          if (tag === 184) {
            message.ids.push(longToNumber(reader.uint64() as Long));

            continue;
          }

          if (tag === 186) {
            const end2 = reader.uint32() + reader.pos;
            while (reader.pos < end2) {
              message.ids.push(longToNumber(reader.uint64() as Long));
            }

            continue;
          }

          break;
        case 24:
          if (tag !== 194) {
            break;
          }

          message.tnParticipantID = reader.string();
          continue;
        case 25:
          if (tag !== 202) {
            break;
          }

          message.scoreFilter = ScoreFilter.decode(reader, reader.uint32());
          continue;
        case 26:
          if (tag !== 210) {
            break;
          }

          message.lastIncomingTxFromWhitelistedAddress = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        case 27:
          if (tag !== 218) {
            break;
          }

          message.contractTypes.push(reader.string());
          continue;
        case 28:
          if (tag !== 226) {
            break;
          }

          message.attributeFiltersJson = reader.string();
          continue;
        case 29:
          if (tag !== 234) {
            break;
          }

          message.attributeFiltersOperator = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetSignedWhitelistedAddressEnvelopesRequest {
    return {
      limit: isSet(object.limit) ? globalThis.Number(object.limit) : 0,
      offset: isSet(object.offset) ? globalThis.Number(object.offset) : 0,
      exchangeAccountId: isSet(object.exchangeAccountId) ? globalThis.Number(object.exchangeAccountId) : 0,
      addressType: isSet(object.addressType) ? globalThis.String(object.addressType) : "",
      query: isSet(object.query) ? globalThis.String(object.query) : "",
      currency: isSet(object.currency) ? globalThis.String(object.currency) : "",
      scoreProvider: isSet(object.scoreProvider) ? globalThis.String(object.scoreProvider) : "",
      scoreInBelow: isSet(object.scoreInBelow) ? globalThis.String(object.scoreInBelow) : "",
      scoreOutBelow: isSet(object.scoreOutBelow) ? globalThis.String(object.scoreOutBelow) : "",
      scoreExclusive: isSet(object.scoreExclusive) ? globalThis.Boolean(object.scoreExclusive) : false,
      rulesContainerNormalized: isSet(object.rulesContainerNormalized)
        ? globalThis.Boolean(object.rulesContainerNormalized)
        : false,
      exchangeAccountIds: globalThis.Array.isArray(object?.exchangeAccountIds)
        ? object.exchangeAccountIds.map((e: any) => globalThis.Number(e))
        : [],
      coinfirmScoreGreater: isSet(object.coinfirmScoreGreater) ? globalThis.String(object.coinfirmScoreGreater) : "",
      tagIDs: globalThis.Array.isArray(object?.tagIDs) ? object.tagIDs.map((e: any) => globalThis.String(e)) : [],
      chainalysisScoreGreater: isSet(object.chainalysisScoreGreater)
        ? globalThis.String(object.chainalysisScoreGreater)
        : "",
      contractType: isSet(object.contractType) ? globalThis.String(object.contractType) : "",
      allowedForAddressId: isSet(object.allowedForAddressId) ? globalThis.Number(object.allowedForAddressId) : 0,
      allowedForWalletId: isSet(object.allowedForWalletId) ? globalThis.Number(object.allowedForWalletId) : 0,
      blockchain: isSet(object.blockchain) ? globalThis.String(object.blockchain) : "",
      includeForApproval: isSet(object.includeForApproval) ? globalThis.Boolean(object.includeForApproval) : false,
      addresses: globalThis.Array.isArray(object?.addresses)
        ? object.addresses.map((e: any) => globalThis.String(e))
        : [],
      network: isSet(object.network) ? globalThis.String(object.network) : "",
      ids: globalThis.Array.isArray(object?.ids) ? object.ids.map((e: any) => globalThis.Number(e)) : [],
      tnParticipantID: isSet(object.tnParticipantID) ? globalThis.String(object.tnParticipantID) : "",
      scoreFilter: isSet(object.scoreFilter) ? ScoreFilter.fromJSON(object.scoreFilter) : undefined,
      lastIncomingTxFromWhitelistedAddress: isSet(object.lastIncomingTxFromWhitelistedAddress)
        ? fromJsonTimestamp(object.lastIncomingTxFromWhitelistedAddress)
        : undefined,
      contractTypes: globalThis.Array.isArray(object?.contractTypes)
        ? object.contractTypes.map((e: any) => globalThis.String(e))
        : [],
      attributeFiltersJson: isSet(object.attributeFiltersJson) ? globalThis.String(object.attributeFiltersJson) : "",
      attributeFiltersOperator: isSet(object.attributeFiltersOperator)
        ? globalThis.String(object.attributeFiltersOperator)
        : "",
    };
  },

  toJSON(message: GetSignedWhitelistedAddressEnvelopesRequest): unknown {
    const obj: any = {};
    if (message.limit !== 0) {
      obj.limit = Math.round(message.limit);
    }
    if (message.offset !== 0) {
      obj.offset = Math.round(message.offset);
    }
    if (message.exchangeAccountId !== 0) {
      obj.exchangeAccountId = Math.round(message.exchangeAccountId);
    }
    if (message.addressType !== "") {
      obj.addressType = message.addressType;
    }
    if (message.query !== "") {
      obj.query = message.query;
    }
    if (message.currency !== "") {
      obj.currency = message.currency;
    }
    if (message.scoreProvider !== "") {
      obj.scoreProvider = message.scoreProvider;
    }
    if (message.scoreInBelow !== "") {
      obj.scoreInBelow = message.scoreInBelow;
    }
    if (message.scoreOutBelow !== "") {
      obj.scoreOutBelow = message.scoreOutBelow;
    }
    if (message.scoreExclusive !== false) {
      obj.scoreExclusive = message.scoreExclusive;
    }
    if (message.rulesContainerNormalized !== false) {
      obj.rulesContainerNormalized = message.rulesContainerNormalized;
    }
    if (message.exchangeAccountIds?.length) {
      obj.exchangeAccountIds = message.exchangeAccountIds.map((e) => Math.round(e));
    }
    if (message.coinfirmScoreGreater !== "") {
      obj.coinfirmScoreGreater = message.coinfirmScoreGreater;
    }
    if (message.tagIDs?.length) {
      obj.tagIDs = message.tagIDs;
    }
    if (message.chainalysisScoreGreater !== "") {
      obj.chainalysisScoreGreater = message.chainalysisScoreGreater;
    }
    if (message.contractType !== "") {
      obj.contractType = message.contractType;
    }
    if (message.allowedForAddressId !== 0) {
      obj.allowedForAddressId = Math.round(message.allowedForAddressId);
    }
    if (message.allowedForWalletId !== 0) {
      obj.allowedForWalletId = Math.round(message.allowedForWalletId);
    }
    if (message.blockchain !== "") {
      obj.blockchain = message.blockchain;
    }
    if (message.includeForApproval !== false) {
      obj.includeForApproval = message.includeForApproval;
    }
    if (message.addresses?.length) {
      obj.addresses = message.addresses;
    }
    if (message.network !== "") {
      obj.network = message.network;
    }
    if (message.ids?.length) {
      obj.ids = message.ids.map((e) => Math.round(e));
    }
    if (message.tnParticipantID !== "") {
      obj.tnParticipantID = message.tnParticipantID;
    }
    if (message.scoreFilter !== undefined) {
      obj.scoreFilter = ScoreFilter.toJSON(message.scoreFilter);
    }
    if (message.lastIncomingTxFromWhitelistedAddress !== undefined) {
      obj.lastIncomingTxFromWhitelistedAddress = message.lastIncomingTxFromWhitelistedAddress.toISOString();
    }
    if (message.contractTypes?.length) {
      obj.contractTypes = message.contractTypes;
    }
    if (message.attributeFiltersJson !== "") {
      obj.attributeFiltersJson = message.attributeFiltersJson;
    }
    if (message.attributeFiltersOperator !== "") {
      obj.attributeFiltersOperator = message.attributeFiltersOperator;
    }
    return obj;
  },

  create(base?: DeepPartial<GetSignedWhitelistedAddressEnvelopesRequest>): GetSignedWhitelistedAddressEnvelopesRequest {
    return GetSignedWhitelistedAddressEnvelopesRequest.fromPartial(base ?? {});
  },
  fromPartial(
    object: DeepPartial<GetSignedWhitelistedAddressEnvelopesRequest>,
  ): GetSignedWhitelistedAddressEnvelopesRequest {
    const message = createBaseGetSignedWhitelistedAddressEnvelopesRequest();
    message.limit = object.limit ?? 0;
    message.offset = object.offset ?? 0;
    message.exchangeAccountId = object.exchangeAccountId ?? 0;
    message.addressType = object.addressType ?? "";
    message.query = object.query ?? "";
    message.currency = object.currency ?? "";
    message.scoreProvider = object.scoreProvider ?? "";
    message.scoreInBelow = object.scoreInBelow ?? "";
    message.scoreOutBelow = object.scoreOutBelow ?? "";
    message.scoreExclusive = object.scoreExclusive ?? false;
    message.rulesContainerNormalized = object.rulesContainerNormalized ?? false;
    message.exchangeAccountIds = object.exchangeAccountIds?.map((e) => e) || [];
    message.coinfirmScoreGreater = object.coinfirmScoreGreater ?? "";
    message.tagIDs = object.tagIDs?.map((e) => e) || [];
    message.chainalysisScoreGreater = object.chainalysisScoreGreater ?? "";
    message.contractType = object.contractType ?? "";
    message.allowedForAddressId = object.allowedForAddressId ?? 0;
    message.allowedForWalletId = object.allowedForWalletId ?? 0;
    message.blockchain = object.blockchain ?? "";
    message.includeForApproval = object.includeForApproval ?? false;
    message.addresses = object.addresses?.map((e) => e) || [];
    message.network = object.network ?? "";
    message.ids = object.ids?.map((e) => e) || [];
    message.tnParticipantID = object.tnParticipantID ?? "";
    message.scoreFilter = (object.scoreFilter !== undefined && object.scoreFilter !== null)
      ? ScoreFilter.fromPartial(object.scoreFilter)
      : undefined;
    message.lastIncomingTxFromWhitelistedAddress = object.lastIncomingTxFromWhitelistedAddress ?? undefined;
    message.contractTypes = object.contractTypes?.map((e) => e) || [];
    message.attributeFiltersJson = object.attributeFiltersJson ?? "";
    message.attributeFiltersOperator = object.attributeFiltersOperator ?? "";
    return message;
  },
};

function createBaseAttributeFilter(): AttributeFilter {
  return { key: "", value: "", type: "", operator: "" };
}

export const AttributeFilter = {
  encode(message: AttributeFilter, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.key !== "") {
      writer.uint32(10).string(message.key);
    }
    if (message.value !== "") {
      writer.uint32(18).string(message.value);
    }
    if (message.type !== "") {
      writer.uint32(26).string(message.type);
    }
    if (message.operator !== "") {
      writer.uint32(34).string(message.operator);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): AttributeFilter {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseAttributeFilter();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.key = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.value = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.type = reader.string();
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.operator = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): AttributeFilter {
    return {
      key: isSet(object.key) ? globalThis.String(object.key) : "",
      value: isSet(object.value) ? globalThis.String(object.value) : "",
      type: isSet(object.type) ? globalThis.String(object.type) : "",
      operator: isSet(object.operator) ? globalThis.String(object.operator) : "",
    };
  },

  toJSON(message: AttributeFilter): unknown {
    const obj: any = {};
    if (message.key !== "") {
      obj.key = message.key;
    }
    if (message.value !== "") {
      obj.value = message.value;
    }
    if (message.type !== "") {
      obj.type = message.type;
    }
    if (message.operator !== "") {
      obj.operator = message.operator;
    }
    return obj;
  },

  create(base?: DeepPartial<AttributeFilter>): AttributeFilter {
    return AttributeFilter.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<AttributeFilter>): AttributeFilter {
    const message = createBaseAttributeFilter();
    message.key = object.key ?? "";
    message.value = object.value ?? "";
    message.type = object.type ?? "";
    message.operator = object.operator ?? "";
    return message;
  },
};

function createBaseHashRulesContainer(): HashRulesContainer {
  return { hash: "", rulesContainer: "", rulesSignatures: "" };
}

export const HashRulesContainer = {
  encode(message: HashRulesContainer, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.hash !== "") {
      writer.uint32(10).string(message.hash);
    }
    if (message.rulesContainer !== "") {
      writer.uint32(18).string(message.rulesContainer);
    }
    if (message.rulesSignatures !== "") {
      writer.uint32(26).string(message.rulesSignatures);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): HashRulesContainer {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseHashRulesContainer();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.hash = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.rulesContainer = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.rulesSignatures = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): HashRulesContainer {
    return {
      hash: isSet(object.hash) ? globalThis.String(object.hash) : "",
      rulesContainer: isSet(object.rulesContainer) ? globalThis.String(object.rulesContainer) : "",
      rulesSignatures: isSet(object.rulesSignatures) ? globalThis.String(object.rulesSignatures) : "",
    };
  },

  toJSON(message: HashRulesContainer): unknown {
    const obj: any = {};
    if (message.hash !== "") {
      obj.hash = message.hash;
    }
    if (message.rulesContainer !== "") {
      obj.rulesContainer = message.rulesContainer;
    }
    if (message.rulesSignatures !== "") {
      obj.rulesSignatures = message.rulesSignatures;
    }
    return obj;
  },

  create(base?: DeepPartial<HashRulesContainer>): HashRulesContainer {
    return HashRulesContainer.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<HashRulesContainer>): HashRulesContainer {
    const message = createBaseHashRulesContainer();
    message.hash = object.hash ?? "";
    message.rulesContainer = object.rulesContainer ?? "";
    message.rulesSignatures = object.rulesSignatures ?? "";
    return message;
  },
};

function createBaseGetSignedWhitelistedAddressEnvelopesReply(): GetSignedWhitelistedAddressEnvelopesReply {
  return { result: [], totalItems: 0, rulesContainers: [] };
}

export const GetSignedWhitelistedAddressEnvelopesReply = {
  encode(message: GetSignedWhitelistedAddressEnvelopesReply, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    for (const v of message.result) {
      SignedWhitelistedAddressEnvelope.encode(v!, writer.uint32(10).fork()).ldelim();
    }
    if (message.totalItems !== 0) {
      writer.uint32(16).uint64(message.totalItems);
    }
    for (const v of message.rulesContainers) {
      HashRulesContainer.encode(v!, writer.uint32(26).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): GetSignedWhitelistedAddressEnvelopesReply {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetSignedWhitelistedAddressEnvelopesReply();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.result.push(SignedWhitelistedAddressEnvelope.decode(reader, reader.uint32()));
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.totalItems = longToNumber(reader.uint64() as Long);
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.rulesContainers.push(HashRulesContainer.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetSignedWhitelistedAddressEnvelopesReply {
    return {
      result: globalThis.Array.isArray(object?.result)
        ? object.result.map((e: any) => SignedWhitelistedAddressEnvelope.fromJSON(e))
        : [],
      totalItems: isSet(object.totalItems) ? globalThis.Number(object.totalItems) : 0,
      rulesContainers: globalThis.Array.isArray(object?.rulesContainers)
        ? object.rulesContainers.map((e: any) => HashRulesContainer.fromJSON(e))
        : [],
    };
  },

  toJSON(message: GetSignedWhitelistedAddressEnvelopesReply): unknown {
    const obj: any = {};
    if (message.result?.length) {
      obj.result = message.result.map((e) => SignedWhitelistedAddressEnvelope.toJSON(e));
    }
    if (message.totalItems !== 0) {
      obj.totalItems = Math.round(message.totalItems);
    }
    if (message.rulesContainers?.length) {
      obj.rulesContainers = message.rulesContainers.map((e) => HashRulesContainer.toJSON(e));
    }
    return obj;
  },

  create(base?: DeepPartial<GetSignedWhitelistedAddressEnvelopesReply>): GetSignedWhitelistedAddressEnvelopesReply {
    return GetSignedWhitelistedAddressEnvelopesReply.fromPartial(base ?? {});
  },
  fromPartial(
    object: DeepPartial<GetSignedWhitelistedAddressEnvelopesReply>,
  ): GetSignedWhitelistedAddressEnvelopesReply {
    const message = createBaseGetSignedWhitelistedAddressEnvelopesReply();
    message.result = object.result?.map((e) => SignedWhitelistedAddressEnvelope.fromPartial(e)) || [];
    message.totalItems = object.totalItems ?? 0;
    message.rulesContainers = object.rulesContainers?.map((e) => HashRulesContainer.fromPartial(e)) || [];
    return message;
  },
};

function createBaseExportWhitelistedAddressesRequest(): ExportWhitelistedAddressesRequest {
  return {
    format: "",
    exchangeAccountId: 0,
    addressType: "",
    query: "",
    currency: "",
    scoreProvider: "",
    scoreInBelow: "",
    scoreOutBelow: "",
    scoreExclusive: false,
    exchangeAccountIds: [],
    coinfirmScoreGreater: "",
    tags: [],
    chainalysisScoreGreater: "",
    blockchain: "",
    addresses: [],
    network: "",
    scoreFilter: undefined,
  };
}

export const ExportWhitelistedAddressesRequest = {
  encode(message: ExportWhitelistedAddressesRequest, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.format !== "") {
      writer.uint32(10).string(message.format);
    }
    if (message.exchangeAccountId !== 0) {
      writer.uint32(16).uint64(message.exchangeAccountId);
    }
    if (message.addressType !== "") {
      writer.uint32(26).string(message.addressType);
    }
    if (message.query !== "") {
      writer.uint32(34).string(message.query);
    }
    if (message.currency !== "") {
      writer.uint32(42).string(message.currency);
    }
    if (message.scoreProvider !== "") {
      writer.uint32(50).string(message.scoreProvider);
    }
    if (message.scoreInBelow !== "") {
      writer.uint32(58).string(message.scoreInBelow);
    }
    if (message.scoreOutBelow !== "") {
      writer.uint32(66).string(message.scoreOutBelow);
    }
    if (message.scoreExclusive !== false) {
      writer.uint32(72).bool(message.scoreExclusive);
    }
    writer.uint32(82).fork();
    for (const v of message.exchangeAccountIds) {
      writer.uint64(v);
    }
    writer.ldelim();
    if (message.coinfirmScoreGreater !== "") {
      writer.uint32(90).string(message.coinfirmScoreGreater);
    }
    for (const v of message.tags) {
      writer.uint32(98).string(v!);
    }
    if (message.chainalysisScoreGreater !== "") {
      writer.uint32(106).string(message.chainalysisScoreGreater);
    }
    if (message.blockchain !== "") {
      writer.uint32(114).string(message.blockchain);
    }
    for (const v of message.addresses) {
      writer.uint32(122).string(v!);
    }
    if (message.network !== "") {
      writer.uint32(130).string(message.network);
    }
    if (message.scoreFilter !== undefined) {
      ScoreFilter.encode(message.scoreFilter, writer.uint32(138).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): ExportWhitelistedAddressesRequest {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseExportWhitelistedAddressesRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.format = reader.string();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.exchangeAccountId = longToNumber(reader.uint64() as Long);
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.addressType = reader.string();
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.query = reader.string();
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.currency = reader.string();
          continue;
        case 6:
          if (tag !== 50) {
            break;
          }

          message.scoreProvider = reader.string();
          continue;
        case 7:
          if (tag !== 58) {
            break;
          }

          message.scoreInBelow = reader.string();
          continue;
        case 8:
          if (tag !== 66) {
            break;
          }

          message.scoreOutBelow = reader.string();
          continue;
        case 9:
          if (tag !== 72) {
            break;
          }

          message.scoreExclusive = reader.bool();
          continue;
        case 10:
          if (tag === 80) {
            message.exchangeAccountIds.push(longToNumber(reader.uint64() as Long));

            continue;
          }

          if (tag === 82) {
            const end2 = reader.uint32() + reader.pos;
            while (reader.pos < end2) {
              message.exchangeAccountIds.push(longToNumber(reader.uint64() as Long));
            }

            continue;
          }

          break;
        case 11:
          if (tag !== 90) {
            break;
          }

          message.coinfirmScoreGreater = reader.string();
          continue;
        case 12:
          if (tag !== 98) {
            break;
          }

          message.tags.push(reader.string());
          continue;
        case 13:
          if (tag !== 106) {
            break;
          }

          message.chainalysisScoreGreater = reader.string();
          continue;
        case 14:
          if (tag !== 114) {
            break;
          }

          message.blockchain = reader.string();
          continue;
        case 15:
          if (tag !== 122) {
            break;
          }

          message.addresses.push(reader.string());
          continue;
        case 16:
          if (tag !== 130) {
            break;
          }

          message.network = reader.string();
          continue;
        case 17:
          if (tag !== 138) {
            break;
          }

          message.scoreFilter = ScoreFilter.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ExportWhitelistedAddressesRequest {
    return {
      format: isSet(object.format) ? globalThis.String(object.format) : "",
      exchangeAccountId: isSet(object.exchangeAccountId) ? globalThis.Number(object.exchangeAccountId) : 0,
      addressType: isSet(object.addressType) ? globalThis.String(object.addressType) : "",
      query: isSet(object.query) ? globalThis.String(object.query) : "",
      currency: isSet(object.currency) ? globalThis.String(object.currency) : "",
      scoreProvider: isSet(object.scoreProvider) ? globalThis.String(object.scoreProvider) : "",
      scoreInBelow: isSet(object.scoreInBelow) ? globalThis.String(object.scoreInBelow) : "",
      scoreOutBelow: isSet(object.scoreOutBelow) ? globalThis.String(object.scoreOutBelow) : "",
      scoreExclusive: isSet(object.scoreExclusive) ? globalThis.Boolean(object.scoreExclusive) : false,
      exchangeAccountIds: globalThis.Array.isArray(object?.exchangeAccountIds)
        ? object.exchangeAccountIds.map((e: any) => globalThis.Number(e))
        : [],
      coinfirmScoreGreater: isSet(object.coinfirmScoreGreater) ? globalThis.String(object.coinfirmScoreGreater) : "",
      tags: globalThis.Array.isArray(object?.tags) ? object.tags.map((e: any) => globalThis.String(e)) : [],
      chainalysisScoreGreater: isSet(object.chainalysisScoreGreater)
        ? globalThis.String(object.chainalysisScoreGreater)
        : "",
      blockchain: isSet(object.blockchain) ? globalThis.String(object.blockchain) : "",
      addresses: globalThis.Array.isArray(object?.addresses)
        ? object.addresses.map((e: any) => globalThis.String(e))
        : [],
      network: isSet(object.network) ? globalThis.String(object.network) : "",
      scoreFilter: isSet(object.scoreFilter) ? ScoreFilter.fromJSON(object.scoreFilter) : undefined,
    };
  },

  toJSON(message: ExportWhitelistedAddressesRequest): unknown {
    const obj: any = {};
    if (message.format !== "") {
      obj.format = message.format;
    }
    if (message.exchangeAccountId !== 0) {
      obj.exchangeAccountId = Math.round(message.exchangeAccountId);
    }
    if (message.addressType !== "") {
      obj.addressType = message.addressType;
    }
    if (message.query !== "") {
      obj.query = message.query;
    }
    if (message.currency !== "") {
      obj.currency = message.currency;
    }
    if (message.scoreProvider !== "") {
      obj.scoreProvider = message.scoreProvider;
    }
    if (message.scoreInBelow !== "") {
      obj.scoreInBelow = message.scoreInBelow;
    }
    if (message.scoreOutBelow !== "") {
      obj.scoreOutBelow = message.scoreOutBelow;
    }
    if (message.scoreExclusive !== false) {
      obj.scoreExclusive = message.scoreExclusive;
    }
    if (message.exchangeAccountIds?.length) {
      obj.exchangeAccountIds = message.exchangeAccountIds.map((e) => Math.round(e));
    }
    if (message.coinfirmScoreGreater !== "") {
      obj.coinfirmScoreGreater = message.coinfirmScoreGreater;
    }
    if (message.tags?.length) {
      obj.tags = message.tags;
    }
    if (message.chainalysisScoreGreater !== "") {
      obj.chainalysisScoreGreater = message.chainalysisScoreGreater;
    }
    if (message.blockchain !== "") {
      obj.blockchain = message.blockchain;
    }
    if (message.addresses?.length) {
      obj.addresses = message.addresses;
    }
    if (message.network !== "") {
      obj.network = message.network;
    }
    if (message.scoreFilter !== undefined) {
      obj.scoreFilter = ScoreFilter.toJSON(message.scoreFilter);
    }
    return obj;
  },

  create(base?: DeepPartial<ExportWhitelistedAddressesRequest>): ExportWhitelistedAddressesRequest {
    return ExportWhitelistedAddressesRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ExportWhitelistedAddressesRequest>): ExportWhitelistedAddressesRequest {
    const message = createBaseExportWhitelistedAddressesRequest();
    message.format = object.format ?? "";
    message.exchangeAccountId = object.exchangeAccountId ?? 0;
    message.addressType = object.addressType ?? "";
    message.query = object.query ?? "";
    message.currency = object.currency ?? "";
    message.scoreProvider = object.scoreProvider ?? "";
    message.scoreInBelow = object.scoreInBelow ?? "";
    message.scoreOutBelow = object.scoreOutBelow ?? "";
    message.scoreExclusive = object.scoreExclusive ?? false;
    message.exchangeAccountIds = object.exchangeAccountIds?.map((e) => e) || [];
    message.coinfirmScoreGreater = object.coinfirmScoreGreater ?? "";
    message.tags = object.tags?.map((e) => e) || [];
    message.chainalysisScoreGreater = object.chainalysisScoreGreater ?? "";
    message.blockchain = object.blockchain ?? "";
    message.addresses = object.addresses?.map((e) => e) || [];
    message.network = object.network ?? "";
    message.scoreFilter = (object.scoreFilter !== undefined && object.scoreFilter !== null)
      ? ScoreFilter.fromPartial(object.scoreFilter)
      : undefined;
    return message;
  },
};

function createBaseExportWhitelistedAddressesReply(): ExportWhitelistedAddressesReply {
  return { result: "", totalItems: 0 };
}

export const ExportWhitelistedAddressesReply = {
  encode(message: ExportWhitelistedAddressesReply, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.result !== "") {
      writer.uint32(10).string(message.result);
    }
    if (message.totalItems !== 0) {
      writer.uint32(16).uint64(message.totalItems);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): ExportWhitelistedAddressesReply {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseExportWhitelistedAddressesReply();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.result = reader.string();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.totalItems = longToNumber(reader.uint64() as Long);
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ExportWhitelistedAddressesReply {
    return {
      result: isSet(object.result) ? globalThis.String(object.result) : "",
      totalItems: isSet(object.totalItems) ? globalThis.Number(object.totalItems) : 0,
    };
  },

  toJSON(message: ExportWhitelistedAddressesReply): unknown {
    const obj: any = {};
    if (message.result !== "") {
      obj.result = message.result;
    }
    if (message.totalItems !== 0) {
      obj.totalItems = Math.round(message.totalItems);
    }
    return obj;
  },

  create(base?: DeepPartial<ExportWhitelistedAddressesReply>): ExportWhitelistedAddressesReply {
    return ExportWhitelistedAddressesReply.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ExportWhitelistedAddressesReply>): ExportWhitelistedAddressesReply {
    const message = createBaseExportWhitelistedAddressesReply();
    message.result = object.result ?? "";
    message.totalItems = object.totalItems ?? 0;
    return message;
  },
};

function createBaseGetWhitelistedAddressesForApprovalRequest(): GetWhitelistedAddressesForApprovalRequest {
  return {
    limit: 0,
    offset: 0,
    ids: [],
    blockchain: "",
    addressType: "",
    query: "",
    network: "",
    includeAlreadySignedByUser: false,
  };
}

export const GetWhitelistedAddressesForApprovalRequest = {
  encode(message: GetWhitelistedAddressesForApprovalRequest, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.limit !== 0) {
      writer.uint32(8).uint64(message.limit);
    }
    if (message.offset !== 0) {
      writer.uint32(16).uint64(message.offset);
    }
    writer.uint32(26).fork();
    for (const v of message.ids) {
      writer.uint64(v);
    }
    writer.ldelim();
    if (message.blockchain !== "") {
      writer.uint32(34).string(message.blockchain);
    }
    if (message.addressType !== "") {
      writer.uint32(42).string(message.addressType);
    }
    if (message.query !== "") {
      writer.uint32(50).string(message.query);
    }
    if (message.network !== "") {
      writer.uint32(58).string(message.network);
    }
    if (message.includeAlreadySignedByUser !== false) {
      writer.uint32(64).bool(message.includeAlreadySignedByUser);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): GetWhitelistedAddressesForApprovalRequest {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetWhitelistedAddressesForApprovalRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.limit = longToNumber(reader.uint64() as Long);
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.offset = longToNumber(reader.uint64() as Long);
          continue;
        case 3:
          if (tag === 24) {
            message.ids.push(longToNumber(reader.uint64() as Long));

            continue;
          }

          if (tag === 26) {
            const end2 = reader.uint32() + reader.pos;
            while (reader.pos < end2) {
              message.ids.push(longToNumber(reader.uint64() as Long));
            }

            continue;
          }

          break;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.blockchain = reader.string();
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.addressType = reader.string();
          continue;
        case 6:
          if (tag !== 50) {
            break;
          }

          message.query = reader.string();
          continue;
        case 7:
          if (tag !== 58) {
            break;
          }

          message.network = reader.string();
          continue;
        case 8:
          if (tag !== 64) {
            break;
          }

          message.includeAlreadySignedByUser = reader.bool();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetWhitelistedAddressesForApprovalRequest {
    return {
      limit: isSet(object.limit) ? globalThis.Number(object.limit) : 0,
      offset: isSet(object.offset) ? globalThis.Number(object.offset) : 0,
      ids: globalThis.Array.isArray(object?.ids) ? object.ids.map((e: any) => globalThis.Number(e)) : [],
      blockchain: isSet(object.blockchain) ? globalThis.String(object.blockchain) : "",
      addressType: isSet(object.addressType) ? globalThis.String(object.addressType) : "",
      query: isSet(object.query) ? globalThis.String(object.query) : "",
      network: isSet(object.network) ? globalThis.String(object.network) : "",
      includeAlreadySignedByUser: isSet(object.includeAlreadySignedByUser)
        ? globalThis.Boolean(object.includeAlreadySignedByUser)
        : false,
    };
  },

  toJSON(message: GetWhitelistedAddressesForApprovalRequest): unknown {
    const obj: any = {};
    if (message.limit !== 0) {
      obj.limit = Math.round(message.limit);
    }
    if (message.offset !== 0) {
      obj.offset = Math.round(message.offset);
    }
    if (message.ids?.length) {
      obj.ids = message.ids.map((e) => Math.round(e));
    }
    if (message.blockchain !== "") {
      obj.blockchain = message.blockchain;
    }
    if (message.addressType !== "") {
      obj.addressType = message.addressType;
    }
    if (message.query !== "") {
      obj.query = message.query;
    }
    if (message.network !== "") {
      obj.network = message.network;
    }
    if (message.includeAlreadySignedByUser !== false) {
      obj.includeAlreadySignedByUser = message.includeAlreadySignedByUser;
    }
    return obj;
  },

  create(base?: DeepPartial<GetWhitelistedAddressesForApprovalRequest>): GetWhitelistedAddressesForApprovalRequest {
    return GetWhitelistedAddressesForApprovalRequest.fromPartial(base ?? {});
  },
  fromPartial(
    object: DeepPartial<GetWhitelistedAddressesForApprovalRequest>,
  ): GetWhitelistedAddressesForApprovalRequest {
    const message = createBaseGetWhitelistedAddressesForApprovalRequest();
    message.limit = object.limit ?? 0;
    message.offset = object.offset ?? 0;
    message.ids = object.ids?.map((e) => e) || [];
    message.blockchain = object.blockchain ?? "";
    message.addressType = object.addressType ?? "";
    message.query = object.query ?? "";
    message.network = object.network ?? "";
    message.includeAlreadySignedByUser = object.includeAlreadySignedByUser ?? false;
    return message;
  },
};

function createBaseCreateWhitelistedAddressRequest(): CreateWhitelistedAddressRequest {
  return {
    address: "",
    memo: "",
    label: "",
    exchangeAccountId: 0,
    customerId: "",
    linkedInternalAddressIds: [],
    addressType: "",
    contractType: "",
    linkedWalletIds: [],
    blockchain: "",
    network: "",
    visibilityGroupID: "",
    currency: "",
  };
}

export const CreateWhitelistedAddressRequest = {
  encode(message: CreateWhitelistedAddressRequest, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.address !== "") {
      writer.uint32(18).string(message.address);
    }
    if (message.memo !== "") {
      writer.uint32(26).string(message.memo);
    }
    if (message.label !== "") {
      writer.uint32(34).string(message.label);
    }
    if (message.exchangeAccountId !== 0) {
      writer.uint32(40).uint64(message.exchangeAccountId);
    }
    if (message.customerId !== "") {
      writer.uint32(50).string(message.customerId);
    }
    writer.uint32(58).fork();
    for (const v of message.linkedInternalAddressIds) {
      writer.uint64(v);
    }
    writer.ldelim();
    if (message.addressType !== "") {
      writer.uint32(66).string(message.addressType);
    }
    if (message.contractType !== "") {
      writer.uint32(74).string(message.contractType);
    }
    writer.uint32(82).fork();
    for (const v of message.linkedWalletIds) {
      writer.uint64(v);
    }
    writer.ldelim();
    if (message.blockchain !== "") {
      writer.uint32(90).string(message.blockchain);
    }
    if (message.network !== "") {
      writer.uint32(98).string(message.network);
    }
    if (message.visibilityGroupID !== "") {
      writer.uint32(106).string(message.visibilityGroupID);
    }
    if (message.currency !== "") {
      writer.uint32(10).string(message.currency);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CreateWhitelistedAddressRequest {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCreateWhitelistedAddressRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 2:
          if (tag !== 18) {
            break;
          }

          message.address = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.memo = reader.string();
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.label = reader.string();
          continue;
        case 5:
          if (tag !== 40) {
            break;
          }

          message.exchangeAccountId = longToNumber(reader.uint64() as Long);
          continue;
        case 6:
          if (tag !== 50) {
            break;
          }

          message.customerId = reader.string();
          continue;
        case 7:
          if (tag === 56) {
            message.linkedInternalAddressIds.push(longToNumber(reader.uint64() as Long));

            continue;
          }

          if (tag === 58) {
            const end2 = reader.uint32() + reader.pos;
            while (reader.pos < end2) {
              message.linkedInternalAddressIds.push(longToNumber(reader.uint64() as Long));
            }

            continue;
          }

          break;
        case 8:
          if (tag !== 66) {
            break;
          }

          message.addressType = reader.string();
          continue;
        case 9:
          if (tag !== 74) {
            break;
          }

          message.contractType = reader.string();
          continue;
        case 10:
          if (tag === 80) {
            message.linkedWalletIds.push(longToNumber(reader.uint64() as Long));

            continue;
          }

          if (tag === 82) {
            const end2 = reader.uint32() + reader.pos;
            while (reader.pos < end2) {
              message.linkedWalletIds.push(longToNumber(reader.uint64() as Long));
            }

            continue;
          }

          break;
        case 11:
          if (tag !== 90) {
            break;
          }

          message.blockchain = reader.string();
          continue;
        case 12:
          if (tag !== 98) {
            break;
          }

          message.network = reader.string();
          continue;
        case 13:
          if (tag !== 106) {
            break;
          }

          message.visibilityGroupID = reader.string();
          continue;
        case 1:
          if (tag !== 10) {
            break;
          }

          message.currency = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CreateWhitelistedAddressRequest {
    return {
      address: isSet(object.address) ? globalThis.String(object.address) : "",
      memo: isSet(object.memo) ? globalThis.String(object.memo) : "",
      label: isSet(object.label) ? globalThis.String(object.label) : "",
      exchangeAccountId: isSet(object.exchangeAccountId) ? globalThis.Number(object.exchangeAccountId) : 0,
      customerId: isSet(object.customerId) ? globalThis.String(object.customerId) : "",
      linkedInternalAddressIds: globalThis.Array.isArray(object?.linkedInternalAddressIds)
        ? object.linkedInternalAddressIds.map((e: any) => globalThis.Number(e))
        : [],
      addressType: isSet(object.addressType) ? globalThis.String(object.addressType) : "",
      contractType: isSet(object.contractType) ? globalThis.String(object.contractType) : "",
      linkedWalletIds: globalThis.Array.isArray(object?.linkedWalletIds)
        ? object.linkedWalletIds.map((e: any) => globalThis.Number(e))
        : [],
      blockchain: isSet(object.blockchain) ? globalThis.String(object.blockchain) : "",
      network: isSet(object.network) ? globalThis.String(object.network) : "",
      visibilityGroupID: isSet(object.visibilityGroupID) ? globalThis.String(object.visibilityGroupID) : "",
      currency: isSet(object.currency) ? globalThis.String(object.currency) : "",
    };
  },

  toJSON(message: CreateWhitelistedAddressRequest): unknown {
    const obj: any = {};
    if (message.address !== "") {
      obj.address = message.address;
    }
    if (message.memo !== "") {
      obj.memo = message.memo;
    }
    if (message.label !== "") {
      obj.label = message.label;
    }
    if (message.exchangeAccountId !== 0) {
      obj.exchangeAccountId = Math.round(message.exchangeAccountId);
    }
    if (message.customerId !== "") {
      obj.customerId = message.customerId;
    }
    if (message.linkedInternalAddressIds?.length) {
      obj.linkedInternalAddressIds = message.linkedInternalAddressIds.map((e) => Math.round(e));
    }
    if (message.addressType !== "") {
      obj.addressType = message.addressType;
    }
    if (message.contractType !== "") {
      obj.contractType = message.contractType;
    }
    if (message.linkedWalletIds?.length) {
      obj.linkedWalletIds = message.linkedWalletIds.map((e) => Math.round(e));
    }
    if (message.blockchain !== "") {
      obj.blockchain = message.blockchain;
    }
    if (message.network !== "") {
      obj.network = message.network;
    }
    if (message.visibilityGroupID !== "") {
      obj.visibilityGroupID = message.visibilityGroupID;
    }
    if (message.currency !== "") {
      obj.currency = message.currency;
    }
    return obj;
  },

  create(base?: DeepPartial<CreateWhitelistedAddressRequest>): CreateWhitelistedAddressRequest {
    return CreateWhitelistedAddressRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CreateWhitelistedAddressRequest>): CreateWhitelistedAddressRequest {
    const message = createBaseCreateWhitelistedAddressRequest();
    message.address = object.address ?? "";
    message.memo = object.memo ?? "";
    message.label = object.label ?? "";
    message.exchangeAccountId = object.exchangeAccountId ?? 0;
    message.customerId = object.customerId ?? "";
    message.linkedInternalAddressIds = object.linkedInternalAddressIds?.map((e) => e) || [];
    message.addressType = object.addressType ?? "";
    message.contractType = object.contractType ?? "";
    message.linkedWalletIds = object.linkedWalletIds?.map((e) => e) || [];
    message.blockchain = object.blockchain ?? "";
    message.network = object.network ?? "";
    message.visibilityGroupID = object.visibilityGroupID ?? "";
    message.currency = object.currency ?? "";
    return message;
  },
};

function createBaseApproveWhitelistedAddressRequest(): ApproveWhitelistedAddressRequest {
  return { signature: "", comment: "", whitelistedAddressIds: [], ids: [], async: false };
}

export const ApproveWhitelistedAddressRequest = {
  encode(message: ApproveWhitelistedAddressRequest, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.signature !== "") {
      writer.uint32(10).string(message.signature);
    }
    if (message.comment !== "") {
      writer.uint32(18).string(message.comment);
    }
    writer.uint32(26).fork();
    for (const v of message.whitelistedAddressIds) {
      writer.uint64(v);
    }
    writer.ldelim();
    writer.uint32(34).fork();
    for (const v of message.ids) {
      writer.uint64(v);
    }
    writer.ldelim();
    if (message.async !== false) {
      writer.uint32(40).bool(message.async);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): ApproveWhitelistedAddressRequest {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseApproveWhitelistedAddressRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.signature = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.comment = reader.string();
          continue;
        case 3:
          if (tag === 24) {
            message.whitelistedAddressIds.push(longToNumber(reader.uint64() as Long));

            continue;
          }

          if (tag === 26) {
            const end2 = reader.uint32() + reader.pos;
            while (reader.pos < end2) {
              message.whitelistedAddressIds.push(longToNumber(reader.uint64() as Long));
            }

            continue;
          }

          break;
        case 4:
          if (tag === 32) {
            message.ids.push(longToNumber(reader.uint64() as Long));

            continue;
          }

          if (tag === 34) {
            const end2 = reader.uint32() + reader.pos;
            while (reader.pos < end2) {
              message.ids.push(longToNumber(reader.uint64() as Long));
            }

            continue;
          }

          break;
        case 5:
          if (tag !== 40) {
            break;
          }

          message.async = reader.bool();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ApproveWhitelistedAddressRequest {
    return {
      signature: isSet(object.signature) ? globalThis.String(object.signature) : "",
      comment: isSet(object.comment) ? globalThis.String(object.comment) : "",
      whitelistedAddressIds: globalThis.Array.isArray(object?.whitelistedAddressIds)
        ? object.whitelistedAddressIds.map((e: any) => globalThis.Number(e))
        : [],
      ids: globalThis.Array.isArray(object?.ids) ? object.ids.map((e: any) => globalThis.Number(e)) : [],
      async: isSet(object.async) ? globalThis.Boolean(object.async) : false,
    };
  },

  toJSON(message: ApproveWhitelistedAddressRequest): unknown {
    const obj: any = {};
    if (message.signature !== "") {
      obj.signature = message.signature;
    }
    if (message.comment !== "") {
      obj.comment = message.comment;
    }
    if (message.whitelistedAddressIds?.length) {
      obj.whitelistedAddressIds = message.whitelistedAddressIds.map((e) => Math.round(e));
    }
    if (message.ids?.length) {
      obj.ids = message.ids.map((e) => Math.round(e));
    }
    if (message.async !== false) {
      obj.async = message.async;
    }
    return obj;
  },

  create(base?: DeepPartial<ApproveWhitelistedAddressRequest>): ApproveWhitelistedAddressRequest {
    return ApproveWhitelistedAddressRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ApproveWhitelistedAddressRequest>): ApproveWhitelistedAddressRequest {
    const message = createBaseApproveWhitelistedAddressRequest();
    message.signature = object.signature ?? "";
    message.comment = object.comment ?? "";
    message.whitelistedAddressIds = object.whitelistedAddressIds?.map((e) => e) || [];
    message.ids = object.ids?.map((e) => e) || [];
    message.async = object.async ?? false;
    return message;
  },
};

function createBaseApproveWhitelistingReply(): ApproveWhitelistingReply {
  return { signatures: 0, asyncSignature: undefined };
}

export const ApproveWhitelistingReply = {
  encode(message: ApproveWhitelistingReply, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.signatures !== 0) {
      writer.uint32(8).uint64(message.signatures);
    }
    if (message.asyncSignature !== undefined) {
      WhitelistedAddressBatchSignature.encode(message.asyncSignature, writer.uint32(26).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): ApproveWhitelistingReply {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseApproveWhitelistingReply();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.signatures = longToNumber(reader.uint64() as Long);
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.asyncSignature = WhitelistedAddressBatchSignature.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ApproveWhitelistingReply {
    return {
      signatures: isSet(object.signatures) ? globalThis.Number(object.signatures) : 0,
      asyncSignature: isSet(object.asyncSignature)
        ? WhitelistedAddressBatchSignature.fromJSON(object.asyncSignature)
        : undefined,
    };
  },

  toJSON(message: ApproveWhitelistingReply): unknown {
    const obj: any = {};
    if (message.signatures !== 0) {
      obj.signatures = Math.round(message.signatures);
    }
    if (message.asyncSignature !== undefined) {
      obj.asyncSignature = WhitelistedAddressBatchSignature.toJSON(message.asyncSignature);
    }
    return obj;
  },

  create(base?: DeepPartial<ApproveWhitelistingReply>): ApproveWhitelistingReply {
    return ApproveWhitelistingReply.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ApproveWhitelistingReply>): ApproveWhitelistingReply {
    const message = createBaseApproveWhitelistingReply();
    message.signatures = object.signatures ?? 0;
    message.asyncSignature = (object.asyncSignature !== undefined && object.asyncSignature !== null)
      ? WhitelistedAddressBatchSignature.fromPartial(object.asyncSignature)
      : undefined;
    return message;
  },
};

function createBaseGetAsyncWhitelistedAddressApprovalsRequest(): GetAsyncWhitelistedAddressApprovalsRequest {
  return { ids: [], includeDetails: false };
}

export const GetAsyncWhitelistedAddressApprovalsRequest = {
  encode(message: GetAsyncWhitelistedAddressApprovalsRequest, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    writer.uint32(10).fork();
    for (const v of message.ids) {
      writer.uint64(v);
    }
    writer.ldelim();
    if (message.includeDetails !== false) {
      writer.uint32(16).bool(message.includeDetails);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): GetAsyncWhitelistedAddressApprovalsRequest {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetAsyncWhitelistedAddressApprovalsRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag === 8) {
            message.ids.push(longToNumber(reader.uint64() as Long));

            continue;
          }

          if (tag === 10) {
            const end2 = reader.uint32() + reader.pos;
            while (reader.pos < end2) {
              message.ids.push(longToNumber(reader.uint64() as Long));
            }

            continue;
          }

          break;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.includeDetails = reader.bool();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetAsyncWhitelistedAddressApprovalsRequest {
    return {
      ids: globalThis.Array.isArray(object?.ids) ? object.ids.map((e: any) => globalThis.Number(e)) : [],
      includeDetails: isSet(object.includeDetails) ? globalThis.Boolean(object.includeDetails) : false,
    };
  },

  toJSON(message: GetAsyncWhitelistedAddressApprovalsRequest): unknown {
    const obj: any = {};
    if (message.ids?.length) {
      obj.ids = message.ids.map((e) => Math.round(e));
    }
    if (message.includeDetails !== false) {
      obj.includeDetails = message.includeDetails;
    }
    return obj;
  },

  create(base?: DeepPartial<GetAsyncWhitelistedAddressApprovalsRequest>): GetAsyncWhitelistedAddressApprovalsRequest {
    return GetAsyncWhitelistedAddressApprovalsRequest.fromPartial(base ?? {});
  },
  fromPartial(
    object: DeepPartial<GetAsyncWhitelistedAddressApprovalsRequest>,
  ): GetAsyncWhitelistedAddressApprovalsRequest {
    const message = createBaseGetAsyncWhitelistedAddressApprovalsRequest();
    message.ids = object.ids?.map((e) => e) || [];
    message.includeDetails = object.includeDetails ?? false;
    return message;
  },
};

function createBaseGetAsyncWhitelistedAddressApprovalsReply(): GetAsyncWhitelistedAddressApprovalsReply {
  return { result: [] };
}

export const GetAsyncWhitelistedAddressApprovalsReply = {
  encode(message: GetAsyncWhitelistedAddressApprovalsReply, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    for (const v of message.result) {
      WhitelistedAddressBatchSignature.encode(v!, writer.uint32(10).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): GetAsyncWhitelistedAddressApprovalsReply {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetAsyncWhitelistedAddressApprovalsReply();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.result.push(WhitelistedAddressBatchSignature.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetAsyncWhitelistedAddressApprovalsReply {
    return {
      result: globalThis.Array.isArray(object?.result)
        ? object.result.map((e: any) => WhitelistedAddressBatchSignature.fromJSON(e))
        : [],
    };
  },

  toJSON(message: GetAsyncWhitelistedAddressApprovalsReply): unknown {
    const obj: any = {};
    if (message.result?.length) {
      obj.result = message.result.map((e) => WhitelistedAddressBatchSignature.toJSON(e));
    }
    return obj;
  },

  create(base?: DeepPartial<GetAsyncWhitelistedAddressApprovalsReply>): GetAsyncWhitelistedAddressApprovalsReply {
    return GetAsyncWhitelistedAddressApprovalsReply.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<GetAsyncWhitelistedAddressApprovalsReply>): GetAsyncWhitelistedAddressApprovalsReply {
    const message = createBaseGetAsyncWhitelistedAddressApprovalsReply();
    message.result = object.result?.map((e) => WhitelistedAddressBatchSignature.fromPartial(e)) || [];
    return message;
  },
};

function createBaseRejectWhitelistedAddressRequest(): RejectWhitelistedAddressRequest {
  return { id: 0, comment: "", ids: [] };
}

export const RejectWhitelistedAddressRequest = {
  encode(message: RejectWhitelistedAddressRequest, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.id !== 0) {
      writer.uint32(8).uint64(message.id);
    }
    if (message.comment !== "") {
      writer.uint32(18).string(message.comment);
    }
    writer.uint32(26).fork();
    for (const v of message.ids) {
      writer.uint64(v);
    }
    writer.ldelim();
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): RejectWhitelistedAddressRequest {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseRejectWhitelistedAddressRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.id = longToNumber(reader.uint64() as Long);
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.comment = reader.string();
          continue;
        case 3:
          if (tag === 24) {
            message.ids.push(longToNumber(reader.uint64() as Long));

            continue;
          }

          if (tag === 26) {
            const end2 = reader.uint32() + reader.pos;
            while (reader.pos < end2) {
              message.ids.push(longToNumber(reader.uint64() as Long));
            }

            continue;
          }

          break;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): RejectWhitelistedAddressRequest {
    return {
      id: isSet(object.id) ? globalThis.Number(object.id) : 0,
      comment: isSet(object.comment) ? globalThis.String(object.comment) : "",
      ids: globalThis.Array.isArray(object?.ids) ? object.ids.map((e: any) => globalThis.Number(e)) : [],
    };
  },

  toJSON(message: RejectWhitelistedAddressRequest): unknown {
    const obj: any = {};
    if (message.id !== 0) {
      obj.id = Math.round(message.id);
    }
    if (message.comment !== "") {
      obj.comment = message.comment;
    }
    if (message.ids?.length) {
      obj.ids = message.ids.map((e) => Math.round(e));
    }
    return obj;
  },

  create(base?: DeepPartial<RejectWhitelistedAddressRequest>): RejectWhitelistedAddressRequest {
    return RejectWhitelistedAddressRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<RejectWhitelistedAddressRequest>): RejectWhitelistedAddressRequest {
    const message = createBaseRejectWhitelistedAddressRequest();
    message.id = object.id ?? 0;
    message.comment = object.comment ?? "";
    message.ids = object.ids?.map((e) => e) || [];
    return message;
  },
};

function createBaseDeleteWhitelistedAddressRequest(): DeleteWhitelistedAddressRequest {
  return { id: 0, comment: "" };
}

export const DeleteWhitelistedAddressRequest = {
  encode(message: DeleteWhitelistedAddressRequest, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.id !== 0) {
      writer.uint32(8).uint64(message.id);
    }
    if (message.comment !== "") {
      writer.uint32(18).string(message.comment);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): DeleteWhitelistedAddressRequest {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseDeleteWhitelistedAddressRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.id = longToNumber(reader.uint64() as Long);
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.comment = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): DeleteWhitelistedAddressRequest {
    return {
      id: isSet(object.id) ? globalThis.Number(object.id) : 0,
      comment: isSet(object.comment) ? globalThis.String(object.comment) : "",
    };
  },

  toJSON(message: DeleteWhitelistedAddressRequest): unknown {
    const obj: any = {};
    if (message.id !== 0) {
      obj.id = Math.round(message.id);
    }
    if (message.comment !== "") {
      obj.comment = message.comment;
    }
    return obj;
  },

  create(base?: DeepPartial<DeleteWhitelistedAddressRequest>): DeleteWhitelistedAddressRequest {
    return DeleteWhitelistedAddressRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<DeleteWhitelistedAddressRequest>): DeleteWhitelistedAddressRequest {
    const message = createBaseDeleteWhitelistedAddressRequest();
    message.id = object.id ?? 0;
    message.comment = object.comment ?? "";
    return message;
  },
};

function createBaseGetWhitelistedAddressAttributeRequest(): GetWhitelistedAddressAttributeRequest {
  return { whitelistedAddressId: 0, id: 0 };
}

export const GetWhitelistedAddressAttributeRequest = {
  encode(message: GetWhitelistedAddressAttributeRequest, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.whitelistedAddressId !== 0) {
      writer.uint32(8).uint64(message.whitelistedAddressId);
    }
    if (message.id !== 0) {
      writer.uint32(16).uint64(message.id);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): GetWhitelistedAddressAttributeRequest {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetWhitelistedAddressAttributeRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.whitelistedAddressId = longToNumber(reader.uint64() as Long);
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.id = longToNumber(reader.uint64() as Long);
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetWhitelistedAddressAttributeRequest {
    return {
      whitelistedAddressId: isSet(object.whitelistedAddressId) ? globalThis.Number(object.whitelistedAddressId) : 0,
      id: isSet(object.id) ? globalThis.Number(object.id) : 0,
    };
  },

  toJSON(message: GetWhitelistedAddressAttributeRequest): unknown {
    const obj: any = {};
    if (message.whitelistedAddressId !== 0) {
      obj.whitelistedAddressId = Math.round(message.whitelistedAddressId);
    }
    if (message.id !== 0) {
      obj.id = Math.round(message.id);
    }
    return obj;
  },

  create(base?: DeepPartial<GetWhitelistedAddressAttributeRequest>): GetWhitelistedAddressAttributeRequest {
    return GetWhitelistedAddressAttributeRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<GetWhitelistedAddressAttributeRequest>): GetWhitelistedAddressAttributeRequest {
    const message = createBaseGetWhitelistedAddressAttributeRequest();
    message.whitelistedAddressId = object.whitelistedAddressId ?? 0;
    message.id = object.id ?? 0;
    return message;
  },
};

function createBaseGetWhitelistedAddressAttributeReply(): GetWhitelistedAddressAttributeReply {
  return { result: undefined };
}

export const GetWhitelistedAddressAttributeReply = {
  encode(message: GetWhitelistedAddressAttributeReply, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.result !== undefined) {
      WhitelistedAddressAttribute.encode(message.result, writer.uint32(10).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): GetWhitelistedAddressAttributeReply {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetWhitelistedAddressAttributeReply();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.result = WhitelistedAddressAttribute.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetWhitelistedAddressAttributeReply {
    return { result: isSet(object.result) ? WhitelistedAddressAttribute.fromJSON(object.result) : undefined };
  },

  toJSON(message: GetWhitelistedAddressAttributeReply): unknown {
    const obj: any = {};
    if (message.result !== undefined) {
      obj.result = WhitelistedAddressAttribute.toJSON(message.result);
    }
    return obj;
  },

  create(base?: DeepPartial<GetWhitelistedAddressAttributeReply>): GetWhitelistedAddressAttributeReply {
    return GetWhitelistedAddressAttributeReply.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<GetWhitelistedAddressAttributeReply>): GetWhitelistedAddressAttributeReply {
    const message = createBaseGetWhitelistedAddressAttributeReply();
    message.result = (object.result !== undefined && object.result !== null)
      ? WhitelistedAddressAttribute.fromPartial(object.result)
      : undefined;
    return message;
  },
};

function createBaseCreateWhitelistedAddressAttributesRequest(): CreateWhitelistedAddressAttributesRequest {
  return { whitelistedAddressId: 0, attributes: [] };
}

export const CreateWhitelistedAddressAttributesRequest = {
  encode(message: CreateWhitelistedAddressAttributesRequest, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.whitelistedAddressId !== 0) {
      writer.uint32(8).uint64(message.whitelistedAddressId);
    }
    for (const v of message.attributes) {
      CreateWhitelistedAddressAttributeRequest.encode(v!, writer.uint32(18).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CreateWhitelistedAddressAttributesRequest {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCreateWhitelistedAddressAttributesRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.whitelistedAddressId = longToNumber(reader.uint64() as Long);
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.attributes.push(CreateWhitelistedAddressAttributeRequest.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CreateWhitelistedAddressAttributesRequest {
    return {
      whitelistedAddressId: isSet(object.whitelistedAddressId) ? globalThis.Number(object.whitelistedAddressId) : 0,
      attributes: globalThis.Array.isArray(object?.attributes)
        ? object.attributes.map((e: any) => CreateWhitelistedAddressAttributeRequest.fromJSON(e))
        : [],
    };
  },

  toJSON(message: CreateWhitelistedAddressAttributesRequest): unknown {
    const obj: any = {};
    if (message.whitelistedAddressId !== 0) {
      obj.whitelistedAddressId = Math.round(message.whitelistedAddressId);
    }
    if (message.attributes?.length) {
      obj.attributes = message.attributes.map((e) => CreateWhitelistedAddressAttributeRequest.toJSON(e));
    }
    return obj;
  },

  create(base?: DeepPartial<CreateWhitelistedAddressAttributesRequest>): CreateWhitelistedAddressAttributesRequest {
    return CreateWhitelistedAddressAttributesRequest.fromPartial(base ?? {});
  },
  fromPartial(
    object: DeepPartial<CreateWhitelistedAddressAttributesRequest>,
  ): CreateWhitelistedAddressAttributesRequest {
    const message = createBaseCreateWhitelistedAddressAttributesRequest();
    message.whitelistedAddressId = object.whitelistedAddressId ?? 0;
    message.attributes = object.attributes?.map((e) => CreateWhitelistedAddressAttributeRequest.fromPartial(e)) || [];
    return message;
  },
};

function createBaseCreateWhitelistedAddressAttributesReply(): CreateWhitelistedAddressAttributesReply {
  return { result: [] };
}

export const CreateWhitelistedAddressAttributesReply = {
  encode(message: CreateWhitelistedAddressAttributesReply, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    for (const v of message.result) {
      WhitelistedAddressAttribute.encode(v!, writer.uint32(10).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CreateWhitelistedAddressAttributesReply {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCreateWhitelistedAddressAttributesReply();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.result.push(WhitelistedAddressAttribute.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CreateWhitelistedAddressAttributesReply {
    return {
      result: globalThis.Array.isArray(object?.result)
        ? object.result.map((e: any) => WhitelistedAddressAttribute.fromJSON(e))
        : [],
    };
  },

  toJSON(message: CreateWhitelistedAddressAttributesReply): unknown {
    const obj: any = {};
    if (message.result?.length) {
      obj.result = message.result.map((e) => WhitelistedAddressAttribute.toJSON(e));
    }
    return obj;
  },

  create(base?: DeepPartial<CreateWhitelistedAddressAttributesReply>): CreateWhitelistedAddressAttributesReply {
    return CreateWhitelistedAddressAttributesReply.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CreateWhitelistedAddressAttributesReply>): CreateWhitelistedAddressAttributesReply {
    const message = createBaseCreateWhitelistedAddressAttributesReply();
    message.result = object.result?.map((e) => WhitelistedAddressAttribute.fromPartial(e)) || [];
    return message;
  },
};

function createBaseCreateWhitelistedAddressAttributeRequest(): CreateWhitelistedAddressAttributeRequest {
  return { key: "", value: "", contentType: "", type: "", subtype: "", isfile: false };
}

export const CreateWhitelistedAddressAttributeRequest = {
  encode(message: CreateWhitelistedAddressAttributeRequest, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.key !== "") {
      writer.uint32(10).string(message.key);
    }
    if (message.value !== "") {
      writer.uint32(18).string(message.value);
    }
    if (message.contentType !== "") {
      writer.uint32(26).string(message.contentType);
    }
    if (message.type !== "") {
      writer.uint32(34).string(message.type);
    }
    if (message.subtype !== "") {
      writer.uint32(42).string(message.subtype);
    }
    if (message.isfile !== false) {
      writer.uint32(48).bool(message.isfile);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CreateWhitelistedAddressAttributeRequest {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCreateWhitelistedAddressAttributeRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.key = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.value = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.contentType = reader.string();
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.type = reader.string();
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.subtype = reader.string();
          continue;
        case 6:
          if (tag !== 48) {
            break;
          }

          message.isfile = reader.bool();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CreateWhitelistedAddressAttributeRequest {
    return {
      key: isSet(object.key) ? globalThis.String(object.key) : "",
      value: isSet(object.value) ? globalThis.String(object.value) : "",
      contentType: isSet(object.contentType) ? globalThis.String(object.contentType) : "",
      type: isSet(object.type) ? globalThis.String(object.type) : "",
      subtype: isSet(object.subtype) ? globalThis.String(object.subtype) : "",
      isfile: isSet(object.isfile) ? globalThis.Boolean(object.isfile) : false,
    };
  },

  toJSON(message: CreateWhitelistedAddressAttributeRequest): unknown {
    const obj: any = {};
    if (message.key !== "") {
      obj.key = message.key;
    }
    if (message.value !== "") {
      obj.value = message.value;
    }
    if (message.contentType !== "") {
      obj.contentType = message.contentType;
    }
    if (message.type !== "") {
      obj.type = message.type;
    }
    if (message.subtype !== "") {
      obj.subtype = message.subtype;
    }
    if (message.isfile !== false) {
      obj.isfile = message.isfile;
    }
    return obj;
  },

  create(base?: DeepPartial<CreateWhitelistedAddressAttributeRequest>): CreateWhitelistedAddressAttributeRequest {
    return CreateWhitelistedAddressAttributeRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CreateWhitelistedAddressAttributeRequest>): CreateWhitelistedAddressAttributeRequest {
    const message = createBaseCreateWhitelistedAddressAttributeRequest();
    message.key = object.key ?? "";
    message.value = object.value ?? "";
    message.contentType = object.contentType ?? "";
    message.type = object.type ?? "";
    message.subtype = object.subtype ?? "";
    message.isfile = object.isfile ?? false;
    return message;
  },
};

function createBaseDeleteWhitelistedAddressAttributeRequest(): DeleteWhitelistedAddressAttributeRequest {
  return { whitelistedAddressId: 0, id: 0 };
}

export const DeleteWhitelistedAddressAttributeRequest = {
  encode(message: DeleteWhitelistedAddressAttributeRequest, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.whitelistedAddressId !== 0) {
      writer.uint32(8).uint64(message.whitelistedAddressId);
    }
    if (message.id !== 0) {
      writer.uint32(16).uint64(message.id);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): DeleteWhitelistedAddressAttributeRequest {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseDeleteWhitelistedAddressAttributeRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.whitelistedAddressId = longToNumber(reader.uint64() as Long);
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.id = longToNumber(reader.uint64() as Long);
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): DeleteWhitelistedAddressAttributeRequest {
    return {
      whitelistedAddressId: isSet(object.whitelistedAddressId) ? globalThis.Number(object.whitelistedAddressId) : 0,
      id: isSet(object.id) ? globalThis.Number(object.id) : 0,
    };
  },

  toJSON(message: DeleteWhitelistedAddressAttributeRequest): unknown {
    const obj: any = {};
    if (message.whitelistedAddressId !== 0) {
      obj.whitelistedAddressId = Math.round(message.whitelistedAddressId);
    }
    if (message.id !== 0) {
      obj.id = Math.round(message.id);
    }
    return obj;
  },

  create(base?: DeepPartial<DeleteWhitelistedAddressAttributeRequest>): DeleteWhitelistedAddressAttributeRequest {
    return DeleteWhitelistedAddressAttributeRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<DeleteWhitelistedAddressAttributeRequest>): DeleteWhitelistedAddressAttributeRequest {
    const message = createBaseDeleteWhitelistedAddressAttributeRequest();
    message.whitelistedAddressId = object.whitelistedAddressId ?? 0;
    message.id = object.id ?? 0;
    return message;
  },
};

function createBaseGetSignedWhitelistedContractAddressEnvelopeRequest(): GetSignedWhitelistedContractAddressEnvelopeRequest {
  return { id: 0 };
}

export const GetSignedWhitelistedContractAddressEnvelopeRequest = {
  encode(
    message: GetSignedWhitelistedContractAddressEnvelopeRequest,
    writer: _m0.Writer = _m0.Writer.create(),
  ): _m0.Writer {
    if (message.id !== 0) {
      writer.uint32(8).uint64(message.id);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): GetSignedWhitelistedContractAddressEnvelopeRequest {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetSignedWhitelistedContractAddressEnvelopeRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.id = longToNumber(reader.uint64() as Long);
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetSignedWhitelistedContractAddressEnvelopeRequest {
    return { id: isSet(object.id) ? globalThis.Number(object.id) : 0 };
  },

  toJSON(message: GetSignedWhitelistedContractAddressEnvelopeRequest): unknown {
    const obj: any = {};
    if (message.id !== 0) {
      obj.id = Math.round(message.id);
    }
    return obj;
  },

  create(
    base?: DeepPartial<GetSignedWhitelistedContractAddressEnvelopeRequest>,
  ): GetSignedWhitelistedContractAddressEnvelopeRequest {
    return GetSignedWhitelistedContractAddressEnvelopeRequest.fromPartial(base ?? {});
  },
  fromPartial(
    object: DeepPartial<GetSignedWhitelistedContractAddressEnvelopeRequest>,
  ): GetSignedWhitelistedContractAddressEnvelopeRequest {
    const message = createBaseGetSignedWhitelistedContractAddressEnvelopeRequest();
    message.id = object.id ?? 0;
    return message;
  },
};

function createBaseGetSignedWhitelistedContractAddressEnvelopeReply(): GetSignedWhitelistedContractAddressEnvelopeReply {
  return { result: undefined };
}

export const GetSignedWhitelistedContractAddressEnvelopeReply = {
  encode(
    message: GetSignedWhitelistedContractAddressEnvelopeReply,
    writer: _m0.Writer = _m0.Writer.create(),
  ): _m0.Writer {
    if (message.result !== undefined) {
      SignedWhitelistedContractAddressEnvelope.encode(message.result, writer.uint32(10).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): GetSignedWhitelistedContractAddressEnvelopeReply {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetSignedWhitelistedContractAddressEnvelopeReply();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.result = SignedWhitelistedContractAddressEnvelope.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetSignedWhitelistedContractAddressEnvelopeReply {
    return {
      result: isSet(object.result) ? SignedWhitelistedContractAddressEnvelope.fromJSON(object.result) : undefined,
    };
  },

  toJSON(message: GetSignedWhitelistedContractAddressEnvelopeReply): unknown {
    const obj: any = {};
    if (message.result !== undefined) {
      obj.result = SignedWhitelistedContractAddressEnvelope.toJSON(message.result);
    }
    return obj;
  },

  create(
    base?: DeepPartial<GetSignedWhitelistedContractAddressEnvelopeReply>,
  ): GetSignedWhitelistedContractAddressEnvelopeReply {
    return GetSignedWhitelistedContractAddressEnvelopeReply.fromPartial(base ?? {});
  },
  fromPartial(
    object: DeepPartial<GetSignedWhitelistedContractAddressEnvelopeReply>,
  ): GetSignedWhitelistedContractAddressEnvelopeReply {
    const message = createBaseGetSignedWhitelistedContractAddressEnvelopeReply();
    message.result = (object.result !== undefined && object.result !== null)
      ? SignedWhitelistedContractAddressEnvelope.fromPartial(object.result)
      : undefined;
    return message;
  },
};

function createBaseGetSignedWhitelistedContractAddressEnvelopesRequest(): GetSignedWhitelistedContractAddressEnvelopesRequest {
  return {
    limit: 0,
    offset: 0,
    query: "",
    blockchain: "",
    includeForApproval: false,
    network: "",
    isNFT: false,
    whitelistedContractAddressIds: [],
    kindTypes: [],
  };
}

export const GetSignedWhitelistedContractAddressEnvelopesRequest = {
  encode(
    message: GetSignedWhitelistedContractAddressEnvelopesRequest,
    writer: _m0.Writer = _m0.Writer.create(),
  ): _m0.Writer {
    if (message.limit !== 0) {
      writer.uint32(8).uint64(message.limit);
    }
    if (message.offset !== 0) {
      writer.uint32(16).uint64(message.offset);
    }
    if (message.query !== "") {
      writer.uint32(26).string(message.query);
    }
    if (message.blockchain !== "") {
      writer.uint32(34).string(message.blockchain);
    }
    if (message.includeForApproval !== false) {
      writer.uint32(40).bool(message.includeForApproval);
    }
    if (message.network !== "") {
      writer.uint32(50).string(message.network);
    }
    if (message.isNFT !== false) {
      writer.uint32(56).bool(message.isNFT);
    }
    writer.uint32(66).fork();
    for (const v of message.whitelistedContractAddressIds) {
      writer.uint64(v);
    }
    writer.ldelim();
    for (const v of message.kindTypes) {
      writer.uint32(74).string(v!);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): GetSignedWhitelistedContractAddressEnvelopesRequest {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetSignedWhitelistedContractAddressEnvelopesRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.limit = longToNumber(reader.uint64() as Long);
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.offset = longToNumber(reader.uint64() as Long);
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.query = reader.string();
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.blockchain = reader.string();
          continue;
        case 5:
          if (tag !== 40) {
            break;
          }

          message.includeForApproval = reader.bool();
          continue;
        case 6:
          if (tag !== 50) {
            break;
          }

          message.network = reader.string();
          continue;
        case 7:
          if (tag !== 56) {
            break;
          }

          message.isNFT = reader.bool();
          continue;
        case 8:
          if (tag === 64) {
            message.whitelistedContractAddressIds.push(longToNumber(reader.uint64() as Long));

            continue;
          }

          if (tag === 66) {
            const end2 = reader.uint32() + reader.pos;
            while (reader.pos < end2) {
              message.whitelistedContractAddressIds.push(longToNumber(reader.uint64() as Long));
            }

            continue;
          }

          break;
        case 9:
          if (tag !== 74) {
            break;
          }

          message.kindTypes.push(reader.string());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetSignedWhitelistedContractAddressEnvelopesRequest {
    return {
      limit: isSet(object.limit) ? globalThis.Number(object.limit) : 0,
      offset: isSet(object.offset) ? globalThis.Number(object.offset) : 0,
      query: isSet(object.query) ? globalThis.String(object.query) : "",
      blockchain: isSet(object.blockchain) ? globalThis.String(object.blockchain) : "",
      includeForApproval: isSet(object.includeForApproval) ? globalThis.Boolean(object.includeForApproval) : false,
      network: isSet(object.network) ? globalThis.String(object.network) : "",
      isNFT: isSet(object.isNFT) ? globalThis.Boolean(object.isNFT) : false,
      whitelistedContractAddressIds: globalThis.Array.isArray(object?.whitelistedContractAddressIds)
        ? object.whitelistedContractAddressIds.map((e: any) => globalThis.Number(e))
        : [],
      kindTypes: globalThis.Array.isArray(object?.kindTypes)
        ? object.kindTypes.map((e: any) => globalThis.String(e))
        : [],
    };
  },

  toJSON(message: GetSignedWhitelistedContractAddressEnvelopesRequest): unknown {
    const obj: any = {};
    if (message.limit !== 0) {
      obj.limit = Math.round(message.limit);
    }
    if (message.offset !== 0) {
      obj.offset = Math.round(message.offset);
    }
    if (message.query !== "") {
      obj.query = message.query;
    }
    if (message.blockchain !== "") {
      obj.blockchain = message.blockchain;
    }
    if (message.includeForApproval !== false) {
      obj.includeForApproval = message.includeForApproval;
    }
    if (message.network !== "") {
      obj.network = message.network;
    }
    if (message.isNFT !== false) {
      obj.isNFT = message.isNFT;
    }
    if (message.whitelistedContractAddressIds?.length) {
      obj.whitelistedContractAddressIds = message.whitelistedContractAddressIds.map((e) => Math.round(e));
    }
    if (message.kindTypes?.length) {
      obj.kindTypes = message.kindTypes;
    }
    return obj;
  },

  create(
    base?: DeepPartial<GetSignedWhitelistedContractAddressEnvelopesRequest>,
  ): GetSignedWhitelistedContractAddressEnvelopesRequest {
    return GetSignedWhitelistedContractAddressEnvelopesRequest.fromPartial(base ?? {});
  },
  fromPartial(
    object: DeepPartial<GetSignedWhitelistedContractAddressEnvelopesRequest>,
  ): GetSignedWhitelistedContractAddressEnvelopesRequest {
    const message = createBaseGetSignedWhitelistedContractAddressEnvelopesRequest();
    message.limit = object.limit ?? 0;
    message.offset = object.offset ?? 0;
    message.query = object.query ?? "";
    message.blockchain = object.blockchain ?? "";
    message.includeForApproval = object.includeForApproval ?? false;
    message.network = object.network ?? "";
    message.isNFT = object.isNFT ?? false;
    message.whitelistedContractAddressIds = object.whitelistedContractAddressIds?.map((e) => e) || [];
    message.kindTypes = object.kindTypes?.map((e) => e) || [];
    return message;
  },
};

function createBaseGetSignedWhitelistedContractAddressEnvelopesReply(): GetSignedWhitelistedContractAddressEnvelopesReply {
  return { result: [], totalItems: 0 };
}

export const GetSignedWhitelistedContractAddressEnvelopesReply = {
  encode(
    message: GetSignedWhitelistedContractAddressEnvelopesReply,
    writer: _m0.Writer = _m0.Writer.create(),
  ): _m0.Writer {
    for (const v of message.result) {
      SignedWhitelistedContractAddressEnvelope.encode(v!, writer.uint32(10).fork()).ldelim();
    }
    if (message.totalItems !== 0) {
      writer.uint32(16).uint64(message.totalItems);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): GetSignedWhitelistedContractAddressEnvelopesReply {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetSignedWhitelistedContractAddressEnvelopesReply();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.result.push(SignedWhitelistedContractAddressEnvelope.decode(reader, reader.uint32()));
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.totalItems = longToNumber(reader.uint64() as Long);
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetSignedWhitelistedContractAddressEnvelopesReply {
    return {
      result: globalThis.Array.isArray(object?.result)
        ? object.result.map((e: any) => SignedWhitelistedContractAddressEnvelope.fromJSON(e))
        : [],
      totalItems: isSet(object.totalItems) ? globalThis.Number(object.totalItems) : 0,
    };
  },

  toJSON(message: GetSignedWhitelistedContractAddressEnvelopesReply): unknown {
    const obj: any = {};
    if (message.result?.length) {
      obj.result = message.result.map((e) => SignedWhitelistedContractAddressEnvelope.toJSON(e));
    }
    if (message.totalItems !== 0) {
      obj.totalItems = Math.round(message.totalItems);
    }
    return obj;
  },

  create(
    base?: DeepPartial<GetSignedWhitelistedContractAddressEnvelopesReply>,
  ): GetSignedWhitelistedContractAddressEnvelopesReply {
    return GetSignedWhitelistedContractAddressEnvelopesReply.fromPartial(base ?? {});
  },
  fromPartial(
    object: DeepPartial<GetSignedWhitelistedContractAddressEnvelopesReply>,
  ): GetSignedWhitelistedContractAddressEnvelopesReply {
    const message = createBaseGetSignedWhitelistedContractAddressEnvelopesReply();
    message.result = object.result?.map((e) => SignedWhitelistedContractAddressEnvelope.fromPartial(e)) || [];
    message.totalItems = object.totalItems ?? 0;
    return message;
  },
};

function createBaseGetWhitelistedContractAddressesForApprovalRequest(): GetWhitelistedContractAddressesForApprovalRequest {
  return { limit: 0, offset: 0, ids: [] };
}

export const GetWhitelistedContractAddressesForApprovalRequest = {
  encode(
    message: GetWhitelistedContractAddressesForApprovalRequest,
    writer: _m0.Writer = _m0.Writer.create(),
  ): _m0.Writer {
    if (message.limit !== 0) {
      writer.uint32(8).uint64(message.limit);
    }
    if (message.offset !== 0) {
      writer.uint32(16).uint64(message.offset);
    }
    writer.uint32(26).fork();
    for (const v of message.ids) {
      writer.uint64(v);
    }
    writer.ldelim();
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): GetWhitelistedContractAddressesForApprovalRequest {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetWhitelistedContractAddressesForApprovalRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.limit = longToNumber(reader.uint64() as Long);
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.offset = longToNumber(reader.uint64() as Long);
          continue;
        case 3:
          if (tag === 24) {
            message.ids.push(longToNumber(reader.uint64() as Long));

            continue;
          }

          if (tag === 26) {
            const end2 = reader.uint32() + reader.pos;
            while (reader.pos < end2) {
              message.ids.push(longToNumber(reader.uint64() as Long));
            }

            continue;
          }

          break;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetWhitelistedContractAddressesForApprovalRequest {
    return {
      limit: isSet(object.limit) ? globalThis.Number(object.limit) : 0,
      offset: isSet(object.offset) ? globalThis.Number(object.offset) : 0,
      ids: globalThis.Array.isArray(object?.ids) ? object.ids.map((e: any) => globalThis.Number(e)) : [],
    };
  },

  toJSON(message: GetWhitelistedContractAddressesForApprovalRequest): unknown {
    const obj: any = {};
    if (message.limit !== 0) {
      obj.limit = Math.round(message.limit);
    }
    if (message.offset !== 0) {
      obj.offset = Math.round(message.offset);
    }
    if (message.ids?.length) {
      obj.ids = message.ids.map((e) => Math.round(e));
    }
    return obj;
  },

  create(
    base?: DeepPartial<GetWhitelistedContractAddressesForApprovalRequest>,
  ): GetWhitelistedContractAddressesForApprovalRequest {
    return GetWhitelistedContractAddressesForApprovalRequest.fromPartial(base ?? {});
  },
  fromPartial(
    object: DeepPartial<GetWhitelistedContractAddressesForApprovalRequest>,
  ): GetWhitelistedContractAddressesForApprovalRequest {
    const message = createBaseGetWhitelistedContractAddressesForApprovalRequest();
    message.limit = object.limit ?? 0;
    message.offset = object.offset ?? 0;
    message.ids = object.ids?.map((e) => e) || [];
    return message;
  },
};

function createBaseCreateWhitelistedContractAddressRequest(): CreateWhitelistedContractAddressRequest {
  return { blockchain: "", contractAddress: "", symbol: "", name: "", decimals: 0, tokenId: "", kind: "", network: "" };
}

export const CreateWhitelistedContractAddressRequest = {
  encode(message: CreateWhitelistedContractAddressRequest, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.blockchain !== "") {
      writer.uint32(10).string(message.blockchain);
    }
    if (message.contractAddress !== "") {
      writer.uint32(18).string(message.contractAddress);
    }
    if (message.symbol !== "") {
      writer.uint32(26).string(message.symbol);
    }
    if (message.name !== "") {
      writer.uint32(34).string(message.name);
    }
    if (message.decimals !== 0) {
      writer.uint32(40).uint64(message.decimals);
    }
    if (message.tokenId !== "") {
      writer.uint32(50).string(message.tokenId);
    }
    if (message.kind !== "") {
      writer.uint32(58).string(message.kind);
    }
    if (message.network !== "") {
      writer.uint32(66).string(message.network);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CreateWhitelistedContractAddressRequest {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCreateWhitelistedContractAddressRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.blockchain = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.contractAddress = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.symbol = reader.string();
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.name = reader.string();
          continue;
        case 5:
          if (tag !== 40) {
            break;
          }

          message.decimals = longToNumber(reader.uint64() as Long);
          continue;
        case 6:
          if (tag !== 50) {
            break;
          }

          message.tokenId = reader.string();
          continue;
        case 7:
          if (tag !== 58) {
            break;
          }

          message.kind = reader.string();
          continue;
        case 8:
          if (tag !== 66) {
            break;
          }

          message.network = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CreateWhitelistedContractAddressRequest {
    return {
      blockchain: isSet(object.blockchain) ? globalThis.String(object.blockchain) : "",
      contractAddress: isSet(object.contractAddress) ? globalThis.String(object.contractAddress) : "",
      symbol: isSet(object.symbol) ? globalThis.String(object.symbol) : "",
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      decimals: isSet(object.decimals) ? globalThis.Number(object.decimals) : 0,
      tokenId: isSet(object.tokenId) ? globalThis.String(object.tokenId) : "",
      kind: isSet(object.kind) ? globalThis.String(object.kind) : "",
      network: isSet(object.network) ? globalThis.String(object.network) : "",
    };
  },

  toJSON(message: CreateWhitelistedContractAddressRequest): unknown {
    const obj: any = {};
    if (message.blockchain !== "") {
      obj.blockchain = message.blockchain;
    }
    if (message.contractAddress !== "") {
      obj.contractAddress = message.contractAddress;
    }
    if (message.symbol !== "") {
      obj.symbol = message.symbol;
    }
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.decimals !== 0) {
      obj.decimals = Math.round(message.decimals);
    }
    if (message.tokenId !== "") {
      obj.tokenId = message.tokenId;
    }
    if (message.kind !== "") {
      obj.kind = message.kind;
    }
    if (message.network !== "") {
      obj.network = message.network;
    }
    return obj;
  },

  create(base?: DeepPartial<CreateWhitelistedContractAddressRequest>): CreateWhitelistedContractAddressRequest {
    return CreateWhitelistedContractAddressRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CreateWhitelistedContractAddressRequest>): CreateWhitelistedContractAddressRequest {
    const message = createBaseCreateWhitelistedContractAddressRequest();
    message.blockchain = object.blockchain ?? "";
    message.contractAddress = object.contractAddress ?? "";
    message.symbol = object.symbol ?? "";
    message.name = object.name ?? "";
    message.decimals = object.decimals ?? 0;
    message.tokenId = object.tokenId ?? "";
    message.kind = object.kind ?? "";
    message.network = object.network ?? "";
    return message;
  },
};

function createBaseUpdateWhitelistedContractAddressRequest(): UpdateWhitelistedContractAddressRequest {
  return { id: 0, symbol: "", name: "", decimals: 0 };
}

export const UpdateWhitelistedContractAddressRequest = {
  encode(message: UpdateWhitelistedContractAddressRequest, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.id !== 0) {
      writer.uint32(8).uint64(message.id);
    }
    if (message.symbol !== "") {
      writer.uint32(18).string(message.symbol);
    }
    if (message.name !== "") {
      writer.uint32(26).string(message.name);
    }
    if (message.decimals !== 0) {
      writer.uint32(32).uint64(message.decimals);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): UpdateWhitelistedContractAddressRequest {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseUpdateWhitelistedContractAddressRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.id = longToNumber(reader.uint64() as Long);
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.symbol = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.name = reader.string();
          continue;
        case 4:
          if (tag !== 32) {
            break;
          }

          message.decimals = longToNumber(reader.uint64() as Long);
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): UpdateWhitelistedContractAddressRequest {
    return {
      id: isSet(object.id) ? globalThis.Number(object.id) : 0,
      symbol: isSet(object.symbol) ? globalThis.String(object.symbol) : "",
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      decimals: isSet(object.decimals) ? globalThis.Number(object.decimals) : 0,
    };
  },

  toJSON(message: UpdateWhitelistedContractAddressRequest): unknown {
    const obj: any = {};
    if (message.id !== 0) {
      obj.id = Math.round(message.id);
    }
    if (message.symbol !== "") {
      obj.symbol = message.symbol;
    }
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.decimals !== 0) {
      obj.decimals = Math.round(message.decimals);
    }
    return obj;
  },

  create(base?: DeepPartial<UpdateWhitelistedContractAddressRequest>): UpdateWhitelistedContractAddressRequest {
    return UpdateWhitelistedContractAddressRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<UpdateWhitelistedContractAddressRequest>): UpdateWhitelistedContractAddressRequest {
    const message = createBaseUpdateWhitelistedContractAddressRequest();
    message.id = object.id ?? 0;
    message.symbol = object.symbol ?? "";
    message.name = object.name ?? "";
    message.decimals = object.decimals ?? 0;
    return message;
  },
};

function createBaseUpdateWhitelistedContractAddressResult(): UpdateWhitelistedContractAddressResult {
  return { updatedContractTemporaryId: 0 };
}

export const UpdateWhitelistedContractAddressResult = {
  encode(message: UpdateWhitelistedContractAddressResult, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.updatedContractTemporaryId !== 0) {
      writer.uint32(8).uint64(message.updatedContractTemporaryId);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): UpdateWhitelistedContractAddressResult {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseUpdateWhitelistedContractAddressResult();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.updatedContractTemporaryId = longToNumber(reader.uint64() as Long);
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): UpdateWhitelistedContractAddressResult {
    return {
      updatedContractTemporaryId: isSet(object.updatedContractTemporaryId)
        ? globalThis.Number(object.updatedContractTemporaryId)
        : 0,
    };
  },

  toJSON(message: UpdateWhitelistedContractAddressResult): unknown {
    const obj: any = {};
    if (message.updatedContractTemporaryId !== 0) {
      obj.updatedContractTemporaryId = Math.round(message.updatedContractTemporaryId);
    }
    return obj;
  },

  create(base?: DeepPartial<UpdateWhitelistedContractAddressResult>): UpdateWhitelistedContractAddressResult {
    return UpdateWhitelistedContractAddressResult.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<UpdateWhitelistedContractAddressResult>): UpdateWhitelistedContractAddressResult {
    const message = createBaseUpdateWhitelistedContractAddressResult();
    message.updatedContractTemporaryId = object.updatedContractTemporaryId ?? 0;
    return message;
  },
};

function createBaseUpdateWhitelistedContractAddressReply(): UpdateWhitelistedContractAddressReply {
  return { result: undefined };
}

export const UpdateWhitelistedContractAddressReply = {
  encode(message: UpdateWhitelistedContractAddressReply, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.result !== undefined) {
      UpdateWhitelistedContractAddressResult.encode(message.result, writer.uint32(10).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): UpdateWhitelistedContractAddressReply {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseUpdateWhitelistedContractAddressReply();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.result = UpdateWhitelistedContractAddressResult.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): UpdateWhitelistedContractAddressReply {
    return {
      result: isSet(object.result) ? UpdateWhitelistedContractAddressResult.fromJSON(object.result) : undefined,
    };
  },

  toJSON(message: UpdateWhitelistedContractAddressReply): unknown {
    const obj: any = {};
    if (message.result !== undefined) {
      obj.result = UpdateWhitelistedContractAddressResult.toJSON(message.result);
    }
    return obj;
  },

  create(base?: DeepPartial<UpdateWhitelistedContractAddressReply>): UpdateWhitelistedContractAddressReply {
    return UpdateWhitelistedContractAddressReply.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<UpdateWhitelistedContractAddressReply>): UpdateWhitelistedContractAddressReply {
    const message = createBaseUpdateWhitelistedContractAddressReply();
    message.result = (object.result !== undefined && object.result !== null)
      ? UpdateWhitelistedContractAddressResult.fromPartial(object.result)
      : undefined;
    return message;
  },
};

function createBaseRejectWhitelistedContractAddressRequest(): RejectWhitelistedContractAddressRequest {
  return { id: 0, comment: "", ids: [] };
}

export const RejectWhitelistedContractAddressRequest = {
  encode(message: RejectWhitelistedContractAddressRequest, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.id !== 0) {
      writer.uint32(8).uint64(message.id);
    }
    if (message.comment !== "") {
      writer.uint32(18).string(message.comment);
    }
    writer.uint32(26).fork();
    for (const v of message.ids) {
      writer.uint64(v);
    }
    writer.ldelim();
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): RejectWhitelistedContractAddressRequest {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseRejectWhitelistedContractAddressRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.id = longToNumber(reader.uint64() as Long);
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.comment = reader.string();
          continue;
        case 3:
          if (tag === 24) {
            message.ids.push(longToNumber(reader.uint64() as Long));

            continue;
          }

          if (tag === 26) {
            const end2 = reader.uint32() + reader.pos;
            while (reader.pos < end2) {
              message.ids.push(longToNumber(reader.uint64() as Long));
            }

            continue;
          }

          break;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): RejectWhitelistedContractAddressRequest {
    return {
      id: isSet(object.id) ? globalThis.Number(object.id) : 0,
      comment: isSet(object.comment) ? globalThis.String(object.comment) : "",
      ids: globalThis.Array.isArray(object?.ids) ? object.ids.map((e: any) => globalThis.Number(e)) : [],
    };
  },

  toJSON(message: RejectWhitelistedContractAddressRequest): unknown {
    const obj: any = {};
    if (message.id !== 0) {
      obj.id = Math.round(message.id);
    }
    if (message.comment !== "") {
      obj.comment = message.comment;
    }
    if (message.ids?.length) {
      obj.ids = message.ids.map((e) => Math.round(e));
    }
    return obj;
  },

  create(base?: DeepPartial<RejectWhitelistedContractAddressRequest>): RejectWhitelistedContractAddressRequest {
    return RejectWhitelistedContractAddressRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<RejectWhitelistedContractAddressRequest>): RejectWhitelistedContractAddressRequest {
    const message = createBaseRejectWhitelistedContractAddressRequest();
    message.id = object.id ?? 0;
    message.comment = object.comment ?? "";
    message.ids = object.ids?.map((e) => e) || [];
    return message;
  },
};

function createBaseDeleteWhitelistedContractAddressRequest(): DeleteWhitelistedContractAddressRequest {
  return { id: 0, comment: "" };
}

export const DeleteWhitelistedContractAddressRequest = {
  encode(message: DeleteWhitelistedContractAddressRequest, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.id !== 0) {
      writer.uint32(8).uint64(message.id);
    }
    if (message.comment !== "") {
      writer.uint32(18).string(message.comment);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): DeleteWhitelistedContractAddressRequest {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseDeleteWhitelistedContractAddressRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.id = longToNumber(reader.uint64() as Long);
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.comment = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): DeleteWhitelistedContractAddressRequest {
    return {
      id: isSet(object.id) ? globalThis.Number(object.id) : 0,
      comment: isSet(object.comment) ? globalThis.String(object.comment) : "",
    };
  },

  toJSON(message: DeleteWhitelistedContractAddressRequest): unknown {
    const obj: any = {};
    if (message.id !== 0) {
      obj.id = Math.round(message.id);
    }
    if (message.comment !== "") {
      obj.comment = message.comment;
    }
    return obj;
  },

  create(base?: DeepPartial<DeleteWhitelistedContractAddressRequest>): DeleteWhitelistedContractAddressRequest {
    return DeleteWhitelistedContractAddressRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<DeleteWhitelistedContractAddressRequest>): DeleteWhitelistedContractAddressRequest {
    const message = createBaseDeleteWhitelistedContractAddressRequest();
    message.id = object.id ?? 0;
    message.comment = object.comment ?? "";
    return message;
  },
};

function createBaseApproveWhitelistedContractAddressRequest(): ApproveWhitelistedContractAddressRequest {
  return { signature: "", comment: "", whitelistedContractAddressIds: [], ids: [] };
}

export const ApproveWhitelistedContractAddressRequest = {
  encode(message: ApproveWhitelistedContractAddressRequest, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.signature !== "") {
      writer.uint32(10).string(message.signature);
    }
    if (message.comment !== "") {
      writer.uint32(18).string(message.comment);
    }
    writer.uint32(26).fork();
    for (const v of message.whitelistedContractAddressIds) {
      writer.uint64(v);
    }
    writer.ldelim();
    writer.uint32(34).fork();
    for (const v of message.ids) {
      writer.uint64(v);
    }
    writer.ldelim();
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): ApproveWhitelistedContractAddressRequest {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseApproveWhitelistedContractAddressRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.signature = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.comment = reader.string();
          continue;
        case 3:
          if (tag === 24) {
            message.whitelistedContractAddressIds.push(longToNumber(reader.uint64() as Long));

            continue;
          }

          if (tag === 26) {
            const end2 = reader.uint32() + reader.pos;
            while (reader.pos < end2) {
              message.whitelistedContractAddressIds.push(longToNumber(reader.uint64() as Long));
            }

            continue;
          }

          break;
        case 4:
          if (tag === 32) {
            message.ids.push(longToNumber(reader.uint64() as Long));

            continue;
          }

          if (tag === 34) {
            const end2 = reader.uint32() + reader.pos;
            while (reader.pos < end2) {
              message.ids.push(longToNumber(reader.uint64() as Long));
            }

            continue;
          }

          break;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ApproveWhitelistedContractAddressRequest {
    return {
      signature: isSet(object.signature) ? globalThis.String(object.signature) : "",
      comment: isSet(object.comment) ? globalThis.String(object.comment) : "",
      whitelistedContractAddressIds: globalThis.Array.isArray(object?.whitelistedContractAddressIds)
        ? object.whitelistedContractAddressIds.map((e: any) => globalThis.Number(e))
        : [],
      ids: globalThis.Array.isArray(object?.ids) ? object.ids.map((e: any) => globalThis.Number(e)) : [],
    };
  },

  toJSON(message: ApproveWhitelistedContractAddressRequest): unknown {
    const obj: any = {};
    if (message.signature !== "") {
      obj.signature = message.signature;
    }
    if (message.comment !== "") {
      obj.comment = message.comment;
    }
    if (message.whitelistedContractAddressIds?.length) {
      obj.whitelistedContractAddressIds = message.whitelistedContractAddressIds.map((e) => Math.round(e));
    }
    if (message.ids?.length) {
      obj.ids = message.ids.map((e) => Math.round(e));
    }
    return obj;
  },

  create(base?: DeepPartial<ApproveWhitelistedContractAddressRequest>): ApproveWhitelistedContractAddressRequest {
    return ApproveWhitelistedContractAddressRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ApproveWhitelistedContractAddressRequest>): ApproveWhitelistedContractAddressRequest {
    const message = createBaseApproveWhitelistedContractAddressRequest();
    message.signature = object.signature ?? "";
    message.comment = object.comment ?? "";
    message.whitelistedContractAddressIds = object.whitelistedContractAddressIds?.map((e) => e) || [];
    message.ids = object.ids?.map((e) => e) || [];
    return message;
  },
};

function createBaseGetWhitelistedContractAddressAttributeRequest(): GetWhitelistedContractAddressAttributeRequest {
  return { whitelistedContractAddressId: 0, id: 0 };
}

export const GetWhitelistedContractAddressAttributeRequest = {
  encode(message: GetWhitelistedContractAddressAttributeRequest, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.whitelistedContractAddressId !== 0) {
      writer.uint32(8).uint64(message.whitelistedContractAddressId);
    }
    if (message.id !== 0) {
      writer.uint32(16).uint64(message.id);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): GetWhitelistedContractAddressAttributeRequest {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetWhitelistedContractAddressAttributeRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.whitelistedContractAddressId = longToNumber(reader.uint64() as Long);
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.id = longToNumber(reader.uint64() as Long);
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetWhitelistedContractAddressAttributeRequest {
    return {
      whitelistedContractAddressId: isSet(object.whitelistedContractAddressId)
        ? globalThis.Number(object.whitelistedContractAddressId)
        : 0,
      id: isSet(object.id) ? globalThis.Number(object.id) : 0,
    };
  },

  toJSON(message: GetWhitelistedContractAddressAttributeRequest): unknown {
    const obj: any = {};
    if (message.whitelistedContractAddressId !== 0) {
      obj.whitelistedContractAddressId = Math.round(message.whitelistedContractAddressId);
    }
    if (message.id !== 0) {
      obj.id = Math.round(message.id);
    }
    return obj;
  },

  create(
    base?: DeepPartial<GetWhitelistedContractAddressAttributeRequest>,
  ): GetWhitelistedContractAddressAttributeRequest {
    return GetWhitelistedContractAddressAttributeRequest.fromPartial(base ?? {});
  },
  fromPartial(
    object: DeepPartial<GetWhitelistedContractAddressAttributeRequest>,
  ): GetWhitelistedContractAddressAttributeRequest {
    const message = createBaseGetWhitelistedContractAddressAttributeRequest();
    message.whitelistedContractAddressId = object.whitelistedContractAddressId ?? 0;
    message.id = object.id ?? 0;
    return message;
  },
};

function createBaseGetWhitelistedContractAddressAttributeReply(): GetWhitelistedContractAddressAttributeReply {
  return { result: undefined };
}

export const GetWhitelistedContractAddressAttributeReply = {
  encode(message: GetWhitelistedContractAddressAttributeReply, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.result !== undefined) {
      WhitelistedContractAddressAttribute.encode(message.result, writer.uint32(10).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): GetWhitelistedContractAddressAttributeReply {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetWhitelistedContractAddressAttributeReply();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.result = WhitelistedContractAddressAttribute.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetWhitelistedContractAddressAttributeReply {
    return { result: isSet(object.result) ? WhitelistedContractAddressAttribute.fromJSON(object.result) : undefined };
  },

  toJSON(message: GetWhitelistedContractAddressAttributeReply): unknown {
    const obj: any = {};
    if (message.result !== undefined) {
      obj.result = WhitelistedContractAddressAttribute.toJSON(message.result);
    }
    return obj;
  },

  create(base?: DeepPartial<GetWhitelistedContractAddressAttributeReply>): GetWhitelistedContractAddressAttributeReply {
    return GetWhitelistedContractAddressAttributeReply.fromPartial(base ?? {});
  },
  fromPartial(
    object: DeepPartial<GetWhitelistedContractAddressAttributeReply>,
  ): GetWhitelistedContractAddressAttributeReply {
    const message = createBaseGetWhitelistedContractAddressAttributeReply();
    message.result = (object.result !== undefined && object.result !== null)
      ? WhitelistedContractAddressAttribute.fromPartial(object.result)
      : undefined;
    return message;
  },
};

function createBaseCreateWhitelistedContractAddressAttributesRequest(): CreateWhitelistedContractAddressAttributesRequest {
  return { whitelistedContractAddressId: 0, attributes: [] };
}

export const CreateWhitelistedContractAddressAttributesRequest = {
  encode(
    message: CreateWhitelistedContractAddressAttributesRequest,
    writer: _m0.Writer = _m0.Writer.create(),
  ): _m0.Writer {
    if (message.whitelistedContractAddressId !== 0) {
      writer.uint32(8).uint64(message.whitelistedContractAddressId);
    }
    for (const v of message.attributes) {
      CreateWhitelistedContractAddressAttributeRequest.encode(v!, writer.uint32(18).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CreateWhitelistedContractAddressAttributesRequest {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCreateWhitelistedContractAddressAttributesRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.whitelistedContractAddressId = longToNumber(reader.uint64() as Long);
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.attributes.push(CreateWhitelistedContractAddressAttributeRequest.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CreateWhitelistedContractAddressAttributesRequest {
    return {
      whitelistedContractAddressId: isSet(object.whitelistedContractAddressId)
        ? globalThis.Number(object.whitelistedContractAddressId)
        : 0,
      attributes: globalThis.Array.isArray(object?.attributes)
        ? object.attributes.map((e: any) => CreateWhitelistedContractAddressAttributeRequest.fromJSON(e))
        : [],
    };
  },

  toJSON(message: CreateWhitelistedContractAddressAttributesRequest): unknown {
    const obj: any = {};
    if (message.whitelistedContractAddressId !== 0) {
      obj.whitelistedContractAddressId = Math.round(message.whitelistedContractAddressId);
    }
    if (message.attributes?.length) {
      obj.attributes = message.attributes.map((e) => CreateWhitelistedContractAddressAttributeRequest.toJSON(e));
    }
    return obj;
  },

  create(
    base?: DeepPartial<CreateWhitelistedContractAddressAttributesRequest>,
  ): CreateWhitelistedContractAddressAttributesRequest {
    return CreateWhitelistedContractAddressAttributesRequest.fromPartial(base ?? {});
  },
  fromPartial(
    object: DeepPartial<CreateWhitelistedContractAddressAttributesRequest>,
  ): CreateWhitelistedContractAddressAttributesRequest {
    const message = createBaseCreateWhitelistedContractAddressAttributesRequest();
    message.whitelistedContractAddressId = object.whitelistedContractAddressId ?? 0;
    message.attributes =
      object.attributes?.map((e) => CreateWhitelistedContractAddressAttributeRequest.fromPartial(e)) || [];
    return message;
  },
};

function createBaseCreateWhitelistedContractAddressAttributeRequest(): CreateWhitelistedContractAddressAttributeRequest {
  return { key: "", value: "", contentType: "", type: "", subtype: "", isfile: false };
}

export const CreateWhitelistedContractAddressAttributeRequest = {
  encode(
    message: CreateWhitelistedContractAddressAttributeRequest,
    writer: _m0.Writer = _m0.Writer.create(),
  ): _m0.Writer {
    if (message.key !== "") {
      writer.uint32(10).string(message.key);
    }
    if (message.value !== "") {
      writer.uint32(18).string(message.value);
    }
    if (message.contentType !== "") {
      writer.uint32(26).string(message.contentType);
    }
    if (message.type !== "") {
      writer.uint32(34).string(message.type);
    }
    if (message.subtype !== "") {
      writer.uint32(42).string(message.subtype);
    }
    if (message.isfile !== false) {
      writer.uint32(48).bool(message.isfile);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CreateWhitelistedContractAddressAttributeRequest {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCreateWhitelistedContractAddressAttributeRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.key = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.value = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.contentType = reader.string();
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.type = reader.string();
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.subtype = reader.string();
          continue;
        case 6:
          if (tag !== 48) {
            break;
          }

          message.isfile = reader.bool();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CreateWhitelistedContractAddressAttributeRequest {
    return {
      key: isSet(object.key) ? globalThis.String(object.key) : "",
      value: isSet(object.value) ? globalThis.String(object.value) : "",
      contentType: isSet(object.contentType) ? globalThis.String(object.contentType) : "",
      type: isSet(object.type) ? globalThis.String(object.type) : "",
      subtype: isSet(object.subtype) ? globalThis.String(object.subtype) : "",
      isfile: isSet(object.isfile) ? globalThis.Boolean(object.isfile) : false,
    };
  },

  toJSON(message: CreateWhitelistedContractAddressAttributeRequest): unknown {
    const obj: any = {};
    if (message.key !== "") {
      obj.key = message.key;
    }
    if (message.value !== "") {
      obj.value = message.value;
    }
    if (message.contentType !== "") {
      obj.contentType = message.contentType;
    }
    if (message.type !== "") {
      obj.type = message.type;
    }
    if (message.subtype !== "") {
      obj.subtype = message.subtype;
    }
    if (message.isfile !== false) {
      obj.isfile = message.isfile;
    }
    return obj;
  },

  create(
    base?: DeepPartial<CreateWhitelistedContractAddressAttributeRequest>,
  ): CreateWhitelistedContractAddressAttributeRequest {
    return CreateWhitelistedContractAddressAttributeRequest.fromPartial(base ?? {});
  },
  fromPartial(
    object: DeepPartial<CreateWhitelistedContractAddressAttributeRequest>,
  ): CreateWhitelistedContractAddressAttributeRequest {
    const message = createBaseCreateWhitelistedContractAddressAttributeRequest();
    message.key = object.key ?? "";
    message.value = object.value ?? "";
    message.contentType = object.contentType ?? "";
    message.type = object.type ?? "";
    message.subtype = object.subtype ?? "";
    message.isfile = object.isfile ?? false;
    return message;
  },
};

function createBaseCreateWhitelistedContractAddressAttributesReply(): CreateWhitelistedContractAddressAttributesReply {
  return { result: [] };
}

export const CreateWhitelistedContractAddressAttributesReply = {
  encode(
    message: CreateWhitelistedContractAddressAttributesReply,
    writer: _m0.Writer = _m0.Writer.create(),
  ): _m0.Writer {
    for (const v of message.result) {
      WhitelistedContractAddressAttribute.encode(v!, writer.uint32(10).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CreateWhitelistedContractAddressAttributesReply {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCreateWhitelistedContractAddressAttributesReply();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.result.push(WhitelistedContractAddressAttribute.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CreateWhitelistedContractAddressAttributesReply {
    return {
      result: globalThis.Array.isArray(object?.result)
        ? object.result.map((e: any) => WhitelistedContractAddressAttribute.fromJSON(e))
        : [],
    };
  },

  toJSON(message: CreateWhitelistedContractAddressAttributesReply): unknown {
    const obj: any = {};
    if (message.result?.length) {
      obj.result = message.result.map((e) => WhitelistedContractAddressAttribute.toJSON(e));
    }
    return obj;
  },

  create(
    base?: DeepPartial<CreateWhitelistedContractAddressAttributesReply>,
  ): CreateWhitelistedContractAddressAttributesReply {
    return CreateWhitelistedContractAddressAttributesReply.fromPartial(base ?? {});
  },
  fromPartial(
    object: DeepPartial<CreateWhitelistedContractAddressAttributesReply>,
  ): CreateWhitelistedContractAddressAttributesReply {
    const message = createBaseCreateWhitelistedContractAddressAttributesReply();
    message.result = object.result?.map((e) => WhitelistedContractAddressAttribute.fromPartial(e)) || [];
    return message;
  },
};

function createBaseDeleteWhitelistedContractAddressAttributeRequest(): DeleteWhitelistedContractAddressAttributeRequest {
  return { whitelistedContractAddressId: 0, id: 0 };
}

export const DeleteWhitelistedContractAddressAttributeRequest = {
  encode(
    message: DeleteWhitelistedContractAddressAttributeRequest,
    writer: _m0.Writer = _m0.Writer.create(),
  ): _m0.Writer {
    if (message.whitelistedContractAddressId !== 0) {
      writer.uint32(8).uint64(message.whitelistedContractAddressId);
    }
    if (message.id !== 0) {
      writer.uint32(16).uint64(message.id);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): DeleteWhitelistedContractAddressAttributeRequest {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseDeleteWhitelistedContractAddressAttributeRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.whitelistedContractAddressId = longToNumber(reader.uint64() as Long);
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.id = longToNumber(reader.uint64() as Long);
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): DeleteWhitelistedContractAddressAttributeRequest {
    return {
      whitelistedContractAddressId: isSet(object.whitelistedContractAddressId)
        ? globalThis.Number(object.whitelistedContractAddressId)
        : 0,
      id: isSet(object.id) ? globalThis.Number(object.id) : 0,
    };
  },

  toJSON(message: DeleteWhitelistedContractAddressAttributeRequest): unknown {
    const obj: any = {};
    if (message.whitelistedContractAddressId !== 0) {
      obj.whitelistedContractAddressId = Math.round(message.whitelistedContractAddressId);
    }
    if (message.id !== 0) {
      obj.id = Math.round(message.id);
    }
    return obj;
  },

  create(
    base?: DeepPartial<DeleteWhitelistedContractAddressAttributeRequest>,
  ): DeleteWhitelistedContractAddressAttributeRequest {
    return DeleteWhitelistedContractAddressAttributeRequest.fromPartial(base ?? {});
  },
  fromPartial(
    object: DeepPartial<DeleteWhitelistedContractAddressAttributeRequest>,
  ): DeleteWhitelistedContractAddressAttributeRequest {
    const message = createBaseDeleteWhitelistedContractAddressAttributeRequest();
    message.whitelistedContractAddressId = object.whitelistedContractAddressId ?? 0;
    message.id = object.id ?? 0;
    return message;
  },
};

function createBaseIDResult(): IDResult {
  return { id: 0 };
}

export const IDResult = {
  encode(message: IDResult, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.id !== 0) {
      writer.uint32(8).uint64(message.id);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): IDResult {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseIDResult();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.id = longToNumber(reader.uint64() as Long);
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): IDResult {
    return { id: isSet(object.id) ? globalThis.Number(object.id) : 0 };
  },

  toJSON(message: IDResult): unknown {
    const obj: any = {};
    if (message.id !== 0) {
      obj.id = Math.round(message.id);
    }
    return obj;
  },

  create(base?: DeepPartial<IDResult>): IDResult {
    return IDResult.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<IDResult>): IDResult {
    const message = createBaseIDResult();
    message.id = object.id ?? 0;
    return message;
  },
};

function createBaseCreateReply(): CreateReply {
  return { result: undefined };
}

export const CreateReply = {
  encode(message: CreateReply, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.result !== undefined) {
      IDResult.encode(message.result, writer.uint32(10).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CreateReply {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCreateReply();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.result = IDResult.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CreateReply {
    return { result: isSet(object.result) ? IDResult.fromJSON(object.result) : undefined };
  },

  toJSON(message: CreateReply): unknown {
    const obj: any = {};
    if (message.result !== undefined) {
      obj.result = IDResult.toJSON(message.result);
    }
    return obj;
  },

  create(base?: DeepPartial<CreateReply>): CreateReply {
    return CreateReply.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CreateReply>): CreateReply {
    const message = createBaseCreateReply();
    message.result = (object.result !== undefined && object.result !== null)
      ? IDResult.fromPartial(object.result)
      : undefined;
    return message;
  },
};

export interface WhitelistService {
  /**
   * ///////////////////////
   * / Address Whitelist ///
   * ///////////////////////
   */
  GetWhitelistedAddress(
    request: GetSignedWhitelistedAddressEnvelopeRequest,
  ): Promise<GetSignedWhitelistedAddressEnvelopeReply>;
  GetWhitelistedAddressAttribute(
    request: GetWhitelistedAddressAttributeRequest,
  ): Promise<GetWhitelistedAddressAttributeReply>;
  CreateWhitelistedAddressAttributes(
    request: CreateWhitelistedAddressAttributesRequest,
  ): Promise<CreateWhitelistedAddressAttributesReply>;
  DeleteWhitelistedAddressAttribute(request: DeleteWhitelistedAddressAttributeRequest): Promise<Empty>;
  CreateWhitelistedAddress(request: CreateWhitelistedAddressRequest): Promise<CreateReply>;
  DeleteWhitelistedAddress(request: DeleteWhitelistedAddressRequest): Promise<CreateReply>;
  ApproveWhitelistedAddress(request: ApproveWhitelistedAddressRequest): Promise<ApproveWhitelistingReply>;
  GetAsyncWhitelistedAddressApprovals(
    request: GetAsyncWhitelistedAddressApprovalsRequest,
  ): Promise<GetAsyncWhitelistedAddressApprovalsReply>;
  RejectWhitelistedAddress(request: RejectWhitelistedAddressRequest): Promise<Empty>;
  GetWhitelistedAddresses(
    request: GetSignedWhitelistedAddressEnvelopesRequest,
  ): Promise<GetSignedWhitelistedAddressEnvelopesReply>;
  ExportWhitelistedAddresses(request: ExportWhitelistedAddressesRequest): Promise<ExportWhitelistedAddressesReply>;
  GetWhitelistedAddressesForApproval(
    request: GetWhitelistedAddressesForApprovalRequest,
  ): Promise<GetSignedWhitelistedAddressEnvelopesReply>;
  /**
   * ///////////
   * / WLCA  ///
   * ///////////
   */
  GetWhitelistedContract(
    request: GetSignedWhitelistedContractAddressEnvelopeRequest,
  ): Promise<GetSignedWhitelistedContractAddressEnvelopeReply>;
  UpdateWhitelistedContract(
    request: UpdateWhitelistedContractAddressRequest,
  ): Promise<UpdateWhitelistedContractAddressReply>;
  GetWhitelistedContractAttribute(
    request: GetWhitelistedContractAddressAttributeRequest,
  ): Promise<GetWhitelistedContractAddressAttributeReply>;
  CreateWhitelistedContractAttributes(
    request: CreateWhitelistedContractAddressAttributesRequest,
  ): Promise<CreateWhitelistedContractAddressAttributesReply>;
  DeleteWhitelistedContractAttribute(request: DeleteWhitelistedContractAddressAttributeRequest): Promise<Empty>;
  CreateWhitelistedContract(request: CreateWhitelistedContractAddressRequest): Promise<CreateReply>;
  /** @deprecated */
  DeleteWhitelistedContract(request: DeleteWhitelistedContractAddressRequest): Promise<CreateReply>;
  RejectWhitelistedContract(request: RejectWhitelistedContractAddressRequest): Promise<Empty>;
  ApproveWhitelistedContract(request: ApproveWhitelistedContractAddressRequest): Promise<ApproveWhitelistingReply>;
  GetWhitelistedContracts(
    request: GetSignedWhitelistedContractAddressEnvelopesRequest,
  ): Promise<GetSignedWhitelistedContractAddressEnvelopesReply>;
  GetWhitelistedContractsForApproval(
    request: GetWhitelistedContractAddressesForApprovalRequest,
  ): Promise<GetSignedWhitelistedContractAddressEnvelopesReply>;
}

export const WhitelistServiceServiceName = "tgvalidatord.WhitelistService";
export class WhitelistServiceClientImpl implements WhitelistService {
  private readonly rpc: Rpc;
  private readonly service: string;
  constructor(rpc: Rpc, opts?: { service?: string }) {
    this.service = opts?.service || WhitelistServiceServiceName;
    this.rpc = rpc;
    this.GetWhitelistedAddress = this.GetWhitelistedAddress.bind(this);
    this.GetWhitelistedAddressAttribute = this.GetWhitelistedAddressAttribute.bind(this);
    this.CreateWhitelistedAddressAttributes = this.CreateWhitelistedAddressAttributes.bind(this);
    this.DeleteWhitelistedAddressAttribute = this.DeleteWhitelistedAddressAttribute.bind(this);
    this.CreateWhitelistedAddress = this.CreateWhitelistedAddress.bind(this);
    this.DeleteWhitelistedAddress = this.DeleteWhitelistedAddress.bind(this);
    this.ApproveWhitelistedAddress = this.ApproveWhitelistedAddress.bind(this);
    this.GetAsyncWhitelistedAddressApprovals = this.GetAsyncWhitelistedAddressApprovals.bind(this);
    this.RejectWhitelistedAddress = this.RejectWhitelistedAddress.bind(this);
    this.GetWhitelistedAddresses = this.GetWhitelistedAddresses.bind(this);
    this.ExportWhitelistedAddresses = this.ExportWhitelistedAddresses.bind(this);
    this.GetWhitelistedAddressesForApproval = this.GetWhitelistedAddressesForApproval.bind(this);
    this.GetWhitelistedContract = this.GetWhitelistedContract.bind(this);
    this.UpdateWhitelistedContract = this.UpdateWhitelistedContract.bind(this);
    this.GetWhitelistedContractAttribute = this.GetWhitelistedContractAttribute.bind(this);
    this.CreateWhitelistedContractAttributes = this.CreateWhitelistedContractAttributes.bind(this);
    this.DeleteWhitelistedContractAttribute = this.DeleteWhitelistedContractAttribute.bind(this);
    this.CreateWhitelistedContract = this.CreateWhitelistedContract.bind(this);
    this.DeleteWhitelistedContract = this.DeleteWhitelistedContract.bind(this);
    this.RejectWhitelistedContract = this.RejectWhitelistedContract.bind(this);
    this.ApproveWhitelistedContract = this.ApproveWhitelistedContract.bind(this);
    this.GetWhitelistedContracts = this.GetWhitelistedContracts.bind(this);
    this.GetWhitelistedContractsForApproval = this.GetWhitelistedContractsForApproval.bind(this);
  }
  GetWhitelistedAddress(
    request: GetSignedWhitelistedAddressEnvelopeRequest,
  ): Promise<GetSignedWhitelistedAddressEnvelopeReply> {
    const data = GetSignedWhitelistedAddressEnvelopeRequest.encode(request).finish();
    const promise = this.rpc.request(this.service, "GetWhitelistedAddress", data);
    return promise.then((data) => GetSignedWhitelistedAddressEnvelopeReply.decode(_m0.Reader.create(data)));
  }

  GetWhitelistedAddressAttribute(
    request: GetWhitelistedAddressAttributeRequest,
  ): Promise<GetWhitelistedAddressAttributeReply> {
    const data = GetWhitelistedAddressAttributeRequest.encode(request).finish();
    const promise = this.rpc.request(this.service, "GetWhitelistedAddressAttribute", data);
    return promise.then((data) => GetWhitelistedAddressAttributeReply.decode(_m0.Reader.create(data)));
  }

  CreateWhitelistedAddressAttributes(
    request: CreateWhitelistedAddressAttributesRequest,
  ): Promise<CreateWhitelistedAddressAttributesReply> {
    const data = CreateWhitelistedAddressAttributesRequest.encode(request).finish();
    const promise = this.rpc.request(this.service, "CreateWhitelistedAddressAttributes", data);
    return promise.then((data) => CreateWhitelistedAddressAttributesReply.decode(_m0.Reader.create(data)));
  }

  DeleteWhitelistedAddressAttribute(request: DeleteWhitelistedAddressAttributeRequest): Promise<Empty> {
    const data = DeleteWhitelistedAddressAttributeRequest.encode(request).finish();
    const promise = this.rpc.request(this.service, "DeleteWhitelistedAddressAttribute", data);
    return promise.then((data) => Empty.decode(_m0.Reader.create(data)));
  }

  CreateWhitelistedAddress(request: CreateWhitelistedAddressRequest): Promise<CreateReply> {
    const data = CreateWhitelistedAddressRequest.encode(request).finish();
    const promise = this.rpc.request(this.service, "CreateWhitelistedAddress", data);
    return promise.then((data) => CreateReply.decode(_m0.Reader.create(data)));
  }

  DeleteWhitelistedAddress(request: DeleteWhitelistedAddressRequest): Promise<CreateReply> {
    const data = DeleteWhitelistedAddressRequest.encode(request).finish();
    const promise = this.rpc.request(this.service, "DeleteWhitelistedAddress", data);
    return promise.then((data) => CreateReply.decode(_m0.Reader.create(data)));
  }

  ApproveWhitelistedAddress(request: ApproveWhitelistedAddressRequest): Promise<ApproveWhitelistingReply> {
    const data = ApproveWhitelistedAddressRequest.encode(request).finish();
    const promise = this.rpc.request(this.service, "ApproveWhitelistedAddress", data);
    return promise.then((data) => ApproveWhitelistingReply.decode(_m0.Reader.create(data)));
  }

  GetAsyncWhitelistedAddressApprovals(
    request: GetAsyncWhitelistedAddressApprovalsRequest,
  ): Promise<GetAsyncWhitelistedAddressApprovalsReply> {
    const data = GetAsyncWhitelistedAddressApprovalsRequest.encode(request).finish();
    const promise = this.rpc.request(this.service, "GetAsyncWhitelistedAddressApprovals", data);
    return promise.then((data) => GetAsyncWhitelistedAddressApprovalsReply.decode(_m0.Reader.create(data)));
  }

  RejectWhitelistedAddress(request: RejectWhitelistedAddressRequest): Promise<Empty> {
    const data = RejectWhitelistedAddressRequest.encode(request).finish();
    const promise = this.rpc.request(this.service, "RejectWhitelistedAddress", data);
    return promise.then((data) => Empty.decode(_m0.Reader.create(data)));
  }

  GetWhitelistedAddresses(
    request: GetSignedWhitelistedAddressEnvelopesRequest,
  ): Promise<GetSignedWhitelistedAddressEnvelopesReply> {
    const data = GetSignedWhitelistedAddressEnvelopesRequest.encode(request).finish();
    const promise = this.rpc.request(this.service, "GetWhitelistedAddresses", data);
    return promise.then((data) => GetSignedWhitelistedAddressEnvelopesReply.decode(_m0.Reader.create(data)));
  }

  ExportWhitelistedAddresses(request: ExportWhitelistedAddressesRequest): Promise<ExportWhitelistedAddressesReply> {
    const data = ExportWhitelistedAddressesRequest.encode(request).finish();
    const promise = this.rpc.request(this.service, "ExportWhitelistedAddresses", data);
    return promise.then((data) => ExportWhitelistedAddressesReply.decode(_m0.Reader.create(data)));
  }

  GetWhitelistedAddressesForApproval(
    request: GetWhitelistedAddressesForApprovalRequest,
  ): Promise<GetSignedWhitelistedAddressEnvelopesReply> {
    const data = GetWhitelistedAddressesForApprovalRequest.encode(request).finish();
    const promise = this.rpc.request(this.service, "GetWhitelistedAddressesForApproval", data);
    return promise.then((data) => GetSignedWhitelistedAddressEnvelopesReply.decode(_m0.Reader.create(data)));
  }

  GetWhitelistedContract(
    request: GetSignedWhitelistedContractAddressEnvelopeRequest,
  ): Promise<GetSignedWhitelistedContractAddressEnvelopeReply> {
    const data = GetSignedWhitelistedContractAddressEnvelopeRequest.encode(request).finish();
    const promise = this.rpc.request(this.service, "GetWhitelistedContract", data);
    return promise.then((data) => GetSignedWhitelistedContractAddressEnvelopeReply.decode(_m0.Reader.create(data)));
  }

  UpdateWhitelistedContract(
    request: UpdateWhitelistedContractAddressRequest,
  ): Promise<UpdateWhitelistedContractAddressReply> {
    const data = UpdateWhitelistedContractAddressRequest.encode(request).finish();
    const promise = this.rpc.request(this.service, "UpdateWhitelistedContract", data);
    return promise.then((data) => UpdateWhitelistedContractAddressReply.decode(_m0.Reader.create(data)));
  }

  GetWhitelistedContractAttribute(
    request: GetWhitelistedContractAddressAttributeRequest,
  ): Promise<GetWhitelistedContractAddressAttributeReply> {
    const data = GetWhitelistedContractAddressAttributeRequest.encode(request).finish();
    const promise = this.rpc.request(this.service, "GetWhitelistedContractAttribute", data);
    return promise.then((data) => GetWhitelistedContractAddressAttributeReply.decode(_m0.Reader.create(data)));
  }

  CreateWhitelistedContractAttributes(
    request: CreateWhitelistedContractAddressAttributesRequest,
  ): Promise<CreateWhitelistedContractAddressAttributesReply> {
    const data = CreateWhitelistedContractAddressAttributesRequest.encode(request).finish();
    const promise = this.rpc.request(this.service, "CreateWhitelistedContractAttributes", data);
    return promise.then((data) => CreateWhitelistedContractAddressAttributesReply.decode(_m0.Reader.create(data)));
  }

  DeleteWhitelistedContractAttribute(request: DeleteWhitelistedContractAddressAttributeRequest): Promise<Empty> {
    const data = DeleteWhitelistedContractAddressAttributeRequest.encode(request).finish();
    const promise = this.rpc.request(this.service, "DeleteWhitelistedContractAttribute", data);
    return promise.then((data) => Empty.decode(_m0.Reader.create(data)));
  }

  CreateWhitelistedContract(request: CreateWhitelistedContractAddressRequest): Promise<CreateReply> {
    const data = CreateWhitelistedContractAddressRequest.encode(request).finish();
    const promise = this.rpc.request(this.service, "CreateWhitelistedContract", data);
    return promise.then((data) => CreateReply.decode(_m0.Reader.create(data)));
  }

  DeleteWhitelistedContract(request: DeleteWhitelistedContractAddressRequest): Promise<CreateReply> {
    const data = DeleteWhitelistedContractAddressRequest.encode(request).finish();
    const promise = this.rpc.request(this.service, "DeleteWhitelistedContract", data);
    return promise.then((data) => CreateReply.decode(_m0.Reader.create(data)));
  }

  RejectWhitelistedContract(request: RejectWhitelistedContractAddressRequest): Promise<Empty> {
    const data = RejectWhitelistedContractAddressRequest.encode(request).finish();
    const promise = this.rpc.request(this.service, "RejectWhitelistedContract", data);
    return promise.then((data) => Empty.decode(_m0.Reader.create(data)));
  }

  ApproveWhitelistedContract(request: ApproveWhitelistedContractAddressRequest): Promise<ApproveWhitelistingReply> {
    const data = ApproveWhitelistedContractAddressRequest.encode(request).finish();
    const promise = this.rpc.request(this.service, "ApproveWhitelistedContract", data);
    return promise.then((data) => ApproveWhitelistingReply.decode(_m0.Reader.create(data)));
  }

  GetWhitelistedContracts(
    request: GetSignedWhitelistedContractAddressEnvelopesRequest,
  ): Promise<GetSignedWhitelistedContractAddressEnvelopesReply> {
    const data = GetSignedWhitelistedContractAddressEnvelopesRequest.encode(request).finish();
    const promise = this.rpc.request(this.service, "GetWhitelistedContracts", data);
    return promise.then((data) => GetSignedWhitelistedContractAddressEnvelopesReply.decode(_m0.Reader.create(data)));
  }

  GetWhitelistedContractsForApproval(
    request: GetWhitelistedContractAddressesForApprovalRequest,
  ): Promise<GetSignedWhitelistedContractAddressEnvelopesReply> {
    const data = GetWhitelistedContractAddressesForApprovalRequest.encode(request).finish();
    const promise = this.rpc.request(this.service, "GetWhitelistedContractsForApproval", data);
    return promise.then((data) => GetSignedWhitelistedContractAddressEnvelopesReply.decode(_m0.Reader.create(data)));
  }
}

interface Rpc {
  request(service: string, method: string, data: Uint8Array): Promise<Uint8Array>;
}

type Builtin = Date | Function | Uint8Array | string | number | boolean | undefined;

export type DeepPartial<T> = T extends Builtin ? T
  : T extends globalThis.Array<infer U> ? globalThis.Array<DeepPartial<U>>
  : T extends ReadonlyArray<infer U> ? ReadonlyArray<DeepPartial<U>>
  : T extends {} ? { [K in keyof T]?: DeepPartial<T[K]> }
  : Partial<T>;

function toTimestamp(date: Date): Timestamp {
  const seconds = Math.trunc(date.getTime() / 1_000);
  const nanos = (date.getTime() % 1_000) * 1_000_000;
  return { seconds, nanos };
}

function fromTimestamp(t: Timestamp): Date {
  let millis = (t.seconds || 0) * 1_000;
  millis += (t.nanos || 0) / 1_000_000;
  return new globalThis.Date(millis);
}

function fromJsonTimestamp(o: any): Date {
  if (o instanceof globalThis.Date) {
    return o;
  } else if (typeof o === "string") {
    return new globalThis.Date(o);
  } else {
    return fromTimestamp(Timestamp.fromJSON(o));
  }
}

function longToNumber(long: Long): number {
  if (long.gt(globalThis.Number.MAX_SAFE_INTEGER)) {
    throw new globalThis.Error("Value is larger than Number.MAX_SAFE_INTEGER");
  }
  if (long.lt(globalThis.Number.MIN_SAFE_INTEGER)) {
    throw new globalThis.Error("Value is smaller than Number.MIN_SAFE_INTEGER");
  }
  return long.toNumber();
}

if (_m0.util.Long !== Long) {
  _m0.util.Long = Long as any;
  _m0.configure();
}

function isSet(value: any): boolean {
  return value !== null && value !== undefined;
}
