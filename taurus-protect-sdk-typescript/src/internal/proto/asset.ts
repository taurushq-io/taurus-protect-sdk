// Code generated by protoc-gen-ts_proto. DO NOT EDIT.
// versions:
//   protoc-gen-ts_proto  v1.181.2
//   protoc               v6.33.4
// source: asset.proto

/* eslint-disable */
import Long from "long";
import _m0 from "protobufjs/minimal";
import { Duration } from "./google/protobuf/duration";
import { Timestamp } from "./google/protobuf/timestamp";
import { Asset } from "./wallet";

export const protobufPackage = "tgvalidatord";

export interface AssetParams {
  hederaNativeTokenParams?: HederaNativeTokenParams | undefined;
  solanaNativeTokenParams?: SolanaNativeTokenParams | undefined;
}

export interface HederaNativeTokenParams {
  name: string;
  symbol: string;
  initialSupply: number;
  freezeDefault: boolean;
  expiry: Date | undefined;
  autoRenewPeriod: string;
  memo: string;
  metadata: Uint8Array;
  tokenType: string;
  supplyType: string;
  maxSupply: number;
  customFee: Uint8Array;
  decimals: number;
  forceKYC: boolean;
}

export interface SolanaNativeTokenParams {
  decimals: number;
  /** on-chain metadata */
  name: string;
  symbol: string;
  uri: string;
  enableFreeze: boolean;
}

export interface BlockchainEvent {
  eventType: string;
  hederaNativeTokenTransaction?: HederaNativeTokenTransaction | undefined;
}

export interface HederaNativeTokenTransaction {
  transactionID: string;
  transactionType: string;
  sender: string;
  sources: HederaNativeTokenTransfer[];
  destinations: HederaNativeTokenTransfer[];
}

export interface HederaNativeTokenTransfer {
  address: string;
  amount: string;
  asset: Asset | undefined;
}

export interface AssetAttribute {
  key: string;
  value: string;
}

export interface AssetResource {
  id: string;
  tenantID: number;
  version: number;
  createdAt: Date | undefined;
  updatedAt: Date | undefined;
  label: string;
  assetType: string;
  asset: Asset | undefined;
  currencyID: string;
  assetAttributes: AssetAttribute[];
  status: string;
  blockchainAsset: BlockchainAsset | undefined;
}

export interface BlockchainAsset {
  hederaNativeTokenAsset?: HederaNativeTokenAsset | undefined;
  solanaNativeTokenAsset?: SolanaNativeTokenAsset | undefined;
}

export interface HederaNativeTokenAsset {
  address: string;
  state: HederaNativeTokenState | undefined;
}

export interface HederaNativeTokenState {
  name: string;
  symbol: string;
  memo: string;
  totalSupply: number;
  autoRenewPeriod: Duration | undefined;
  decimals: number;
  freezeDefault: boolean;
  initialSupply: number;
  treasuryAccountID: string;
  type: string;
  pauseStatus: boolean;
  deleted: boolean;
  createdTimestamp: Date | undefined;
  expiryTimestamp: Date | undefined;
  modificationTimestamp: Date | undefined;
  autoRenewAccount: string;
  customFees: string;
  adminKey: string;
  feeScheduleKey: string;
  freezeKey: string;
  kycKey: string;
  supplyKey: string;
  wipeKey: string;
  pauseKey: string;
}

export interface SolanaNativeTokenAsset {
  address: string;
  state: SolanaNativeTokenState | undefined;
}

export interface SolanaNativeTokenState {
  name: string;
  symbol: string;
  decimals: number;
  type: string;
  uri: string;
  owner: string;
  mintAuthority: string;
  freezeAuthority: string;
}

export interface AssetEvent {
  id: string;
  tenantID: number;
  hash: string;
  asset: Asset | undefined;
  blockchainEvent: BlockchainEvent | undefined;
  createdAt: Date | undefined;
  updatedAt: Date | undefined;
}

export interface InternalAddressDetails {
  address: string;
  blockchainAddressID: number;
}

export interface WhitelistedAddressDetails {
  address: string;
  whitelistedAddressID: number;
}

export interface ExternalAddressDetails {
  address: string;
}

export interface AssetHolder {
  id: string;
  tenantID: number;
  internalAddressDetails?: InternalAddressDetails | undefined;
  whitelistedAddressDetails?: WhitelistedAddressDetails | undefined;
  externalAddressDetails?: ExternalAddressDetails | undefined;
  asset: Asset | undefined;
  balance: string;
  createdAt: Date | undefined;
  updatedAt: Date | undefined;
}

function createBaseAssetParams(): AssetParams {
  return { hederaNativeTokenParams: undefined, solanaNativeTokenParams: undefined };
}

export const AssetParams = {
  encode(message: AssetParams, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.hederaNativeTokenParams !== undefined) {
      HederaNativeTokenParams.encode(message.hederaNativeTokenParams, writer.uint32(10).fork()).ldelim();
    }
    if (message.solanaNativeTokenParams !== undefined) {
      SolanaNativeTokenParams.encode(message.solanaNativeTokenParams, writer.uint32(18).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): AssetParams {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseAssetParams();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.hederaNativeTokenParams = HederaNativeTokenParams.decode(reader, reader.uint32());
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.solanaNativeTokenParams = SolanaNativeTokenParams.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): AssetParams {
    return {
      hederaNativeTokenParams: isSet(object.hederaNativeTokenParams)
        ? HederaNativeTokenParams.fromJSON(object.hederaNativeTokenParams)
        : undefined,
      solanaNativeTokenParams: isSet(object.solanaNativeTokenParams)
        ? SolanaNativeTokenParams.fromJSON(object.solanaNativeTokenParams)
        : undefined,
    };
  },

  toJSON(message: AssetParams): unknown {
    const obj: any = {};
    if (message.hederaNativeTokenParams !== undefined) {
      obj.hederaNativeTokenParams = HederaNativeTokenParams.toJSON(message.hederaNativeTokenParams);
    }
    if (message.solanaNativeTokenParams !== undefined) {
      obj.solanaNativeTokenParams = SolanaNativeTokenParams.toJSON(message.solanaNativeTokenParams);
    }
    return obj;
  },

  create(base?: DeepPartial<AssetParams>): AssetParams {
    return AssetParams.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<AssetParams>): AssetParams {
    const message = createBaseAssetParams();
    message.hederaNativeTokenParams =
      (object.hederaNativeTokenParams !== undefined && object.hederaNativeTokenParams !== null)
        ? HederaNativeTokenParams.fromPartial(object.hederaNativeTokenParams)
        : undefined;
    message.solanaNativeTokenParams =
      (object.solanaNativeTokenParams !== undefined && object.solanaNativeTokenParams !== null)
        ? SolanaNativeTokenParams.fromPartial(object.solanaNativeTokenParams)
        : undefined;
    return message;
  },
};

function createBaseHederaNativeTokenParams(): HederaNativeTokenParams {
  return {
    name: "",
    symbol: "",
    initialSupply: 0,
    freezeDefault: false,
    expiry: undefined,
    autoRenewPeriod: "",
    memo: "",
    metadata: new Uint8Array(0),
    tokenType: "",
    supplyType: "",
    maxSupply: 0,
    customFee: new Uint8Array(0),
    decimals: 0,
    forceKYC: false,
  };
}

export const HederaNativeTokenParams = {
  encode(message: HederaNativeTokenParams, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    if (message.symbol !== "") {
      writer.uint32(18).string(message.symbol);
    }
    if (message.initialSupply !== 0) {
      writer.uint32(24).uint64(message.initialSupply);
    }
    if (message.freezeDefault !== false) {
      writer.uint32(32).bool(message.freezeDefault);
    }
    if (message.expiry !== undefined) {
      Timestamp.encode(toTimestamp(message.expiry), writer.uint32(42).fork()).ldelim();
    }
    if (message.autoRenewPeriod !== "") {
      writer.uint32(50).string(message.autoRenewPeriod);
    }
    if (message.memo !== "") {
      writer.uint32(58).string(message.memo);
    }
    if (message.metadata.length !== 0) {
      writer.uint32(66).bytes(message.metadata);
    }
    if (message.tokenType !== "") {
      writer.uint32(74).string(message.tokenType);
    }
    if (message.supplyType !== "") {
      writer.uint32(82).string(message.supplyType);
    }
    if (message.maxSupply !== 0) {
      writer.uint32(88).uint64(message.maxSupply);
    }
    if (message.customFee.length !== 0) {
      writer.uint32(98).bytes(message.customFee);
    }
    if (message.decimals !== 0) {
      writer.uint32(104).uint64(message.decimals);
    }
    if (message.forceKYC !== false) {
      writer.uint32(112).bool(message.forceKYC);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): HederaNativeTokenParams {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseHederaNativeTokenParams();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.symbol = reader.string();
          continue;
        case 3:
          if (tag !== 24) {
            break;
          }

          message.initialSupply = longToNumber(reader.uint64() as Long);
          continue;
        case 4:
          if (tag !== 32) {
            break;
          }

          message.freezeDefault = reader.bool();
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.expiry = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        case 6:
          if (tag !== 50) {
            break;
          }

          message.autoRenewPeriod = reader.string();
          continue;
        case 7:
          if (tag !== 58) {
            break;
          }

          message.memo = reader.string();
          continue;
        case 8:
          if (tag !== 66) {
            break;
          }

          message.metadata = reader.bytes();
          continue;
        case 9:
          if (tag !== 74) {
            break;
          }

          message.tokenType = reader.string();
          continue;
        case 10:
          if (tag !== 82) {
            break;
          }

          message.supplyType = reader.string();
          continue;
        case 11:
          if (tag !== 88) {
            break;
          }

          message.maxSupply = longToNumber(reader.uint64() as Long);
          continue;
        case 12:
          if (tag !== 98) {
            break;
          }

          message.customFee = reader.bytes();
          continue;
        case 13:
          if (tag !== 104) {
            break;
          }

          message.decimals = longToNumber(reader.uint64() as Long);
          continue;
        case 14:
          if (tag !== 112) {
            break;
          }

          message.forceKYC = reader.bool();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): HederaNativeTokenParams {
    return {
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      symbol: isSet(object.symbol) ? globalThis.String(object.symbol) : "",
      initialSupply: isSet(object.initialSupply) ? globalThis.Number(object.initialSupply) : 0,
      freezeDefault: isSet(object.freezeDefault) ? globalThis.Boolean(object.freezeDefault) : false,
      expiry: isSet(object.expiry) ? fromJsonTimestamp(object.expiry) : undefined,
      autoRenewPeriod: isSet(object.autoRenewPeriod) ? globalThis.String(object.autoRenewPeriod) : "",
      memo: isSet(object.memo) ? globalThis.String(object.memo) : "",
      metadata: isSet(object.metadata) ? bytesFromBase64(object.metadata) : new Uint8Array(0),
      tokenType: isSet(object.tokenType) ? globalThis.String(object.tokenType) : "",
      supplyType: isSet(object.supplyType) ? globalThis.String(object.supplyType) : "",
      maxSupply: isSet(object.maxSupply) ? globalThis.Number(object.maxSupply) : 0,
      customFee: isSet(object.customFee) ? bytesFromBase64(object.customFee) : new Uint8Array(0),
      decimals: isSet(object.decimals) ? globalThis.Number(object.decimals) : 0,
      forceKYC: isSet(object.forceKYC) ? globalThis.Boolean(object.forceKYC) : false,
    };
  },

  toJSON(message: HederaNativeTokenParams): unknown {
    const obj: any = {};
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.symbol !== "") {
      obj.symbol = message.symbol;
    }
    if (message.initialSupply !== 0) {
      obj.initialSupply = Math.round(message.initialSupply);
    }
    if (message.freezeDefault !== false) {
      obj.freezeDefault = message.freezeDefault;
    }
    if (message.expiry !== undefined) {
      obj.expiry = message.expiry.toISOString();
    }
    if (message.autoRenewPeriod !== "") {
      obj.autoRenewPeriod = message.autoRenewPeriod;
    }
    if (message.memo !== "") {
      obj.memo = message.memo;
    }
    if (message.metadata.length !== 0) {
      obj.metadata = base64FromBytes(message.metadata);
    }
    if (message.tokenType !== "") {
      obj.tokenType = message.tokenType;
    }
    if (message.supplyType !== "") {
      obj.supplyType = message.supplyType;
    }
    if (message.maxSupply !== 0) {
      obj.maxSupply = Math.round(message.maxSupply);
    }
    if (message.customFee.length !== 0) {
      obj.customFee = base64FromBytes(message.customFee);
    }
    if (message.decimals !== 0) {
      obj.decimals = Math.round(message.decimals);
    }
    if (message.forceKYC !== false) {
      obj.forceKYC = message.forceKYC;
    }
    return obj;
  },

  create(base?: DeepPartial<HederaNativeTokenParams>): HederaNativeTokenParams {
    return HederaNativeTokenParams.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<HederaNativeTokenParams>): HederaNativeTokenParams {
    const message = createBaseHederaNativeTokenParams();
    message.name = object.name ?? "";
    message.symbol = object.symbol ?? "";
    message.initialSupply = object.initialSupply ?? 0;
    message.freezeDefault = object.freezeDefault ?? false;
    message.expiry = object.expiry ?? undefined;
    message.autoRenewPeriod = object.autoRenewPeriod ?? "";
    message.memo = object.memo ?? "";
    message.metadata = object.metadata ?? new Uint8Array(0);
    message.tokenType = object.tokenType ?? "";
    message.supplyType = object.supplyType ?? "";
    message.maxSupply = object.maxSupply ?? 0;
    message.customFee = object.customFee ?? new Uint8Array(0);
    message.decimals = object.decimals ?? 0;
    message.forceKYC = object.forceKYC ?? false;
    return message;
  },
};

function createBaseSolanaNativeTokenParams(): SolanaNativeTokenParams {
  return { decimals: 0, name: "", symbol: "", uri: "", enableFreeze: false };
}

export const SolanaNativeTokenParams = {
  encode(message: SolanaNativeTokenParams, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.decimals !== 0) {
      writer.uint32(8).uint64(message.decimals);
    }
    if (message.name !== "") {
      writer.uint32(18).string(message.name);
    }
    if (message.symbol !== "") {
      writer.uint32(26).string(message.symbol);
    }
    if (message.uri !== "") {
      writer.uint32(34).string(message.uri);
    }
    if (message.enableFreeze !== false) {
      writer.uint32(40).bool(message.enableFreeze);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): SolanaNativeTokenParams {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSolanaNativeTokenParams();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.decimals = longToNumber(reader.uint64() as Long);
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.name = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.symbol = reader.string();
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.uri = reader.string();
          continue;
        case 5:
          if (tag !== 40) {
            break;
          }

          message.enableFreeze = reader.bool();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): SolanaNativeTokenParams {
    return {
      decimals: isSet(object.decimals) ? globalThis.Number(object.decimals) : 0,
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      symbol: isSet(object.symbol) ? globalThis.String(object.symbol) : "",
      uri: isSet(object.uri) ? globalThis.String(object.uri) : "",
      enableFreeze: isSet(object.enableFreeze) ? globalThis.Boolean(object.enableFreeze) : false,
    };
  },

  toJSON(message: SolanaNativeTokenParams): unknown {
    const obj: any = {};
    if (message.decimals !== 0) {
      obj.decimals = Math.round(message.decimals);
    }
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.symbol !== "") {
      obj.symbol = message.symbol;
    }
    if (message.uri !== "") {
      obj.uri = message.uri;
    }
    if (message.enableFreeze !== false) {
      obj.enableFreeze = message.enableFreeze;
    }
    return obj;
  },

  create(base?: DeepPartial<SolanaNativeTokenParams>): SolanaNativeTokenParams {
    return SolanaNativeTokenParams.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<SolanaNativeTokenParams>): SolanaNativeTokenParams {
    const message = createBaseSolanaNativeTokenParams();
    message.decimals = object.decimals ?? 0;
    message.name = object.name ?? "";
    message.symbol = object.symbol ?? "";
    message.uri = object.uri ?? "";
    message.enableFreeze = object.enableFreeze ?? false;
    return message;
  },
};

function createBaseBlockchainEvent(): BlockchainEvent {
  return { eventType: "", hederaNativeTokenTransaction: undefined };
}

export const BlockchainEvent = {
  encode(message: BlockchainEvent, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.eventType !== "") {
      writer.uint32(10).string(message.eventType);
    }
    if (message.hederaNativeTokenTransaction !== undefined) {
      HederaNativeTokenTransaction.encode(message.hederaNativeTokenTransaction, writer.uint32(18).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): BlockchainEvent {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseBlockchainEvent();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.eventType = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.hederaNativeTokenTransaction = HederaNativeTokenTransaction.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): BlockchainEvent {
    return {
      eventType: isSet(object.eventType) ? globalThis.String(object.eventType) : "",
      hederaNativeTokenTransaction: isSet(object.hederaNativeTokenTransaction)
        ? HederaNativeTokenTransaction.fromJSON(object.hederaNativeTokenTransaction)
        : undefined,
    };
  },

  toJSON(message: BlockchainEvent): unknown {
    const obj: any = {};
    if (message.eventType !== "") {
      obj.eventType = message.eventType;
    }
    if (message.hederaNativeTokenTransaction !== undefined) {
      obj.hederaNativeTokenTransaction = HederaNativeTokenTransaction.toJSON(message.hederaNativeTokenTransaction);
    }
    return obj;
  },

  create(base?: DeepPartial<BlockchainEvent>): BlockchainEvent {
    return BlockchainEvent.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<BlockchainEvent>): BlockchainEvent {
    const message = createBaseBlockchainEvent();
    message.eventType = object.eventType ?? "";
    message.hederaNativeTokenTransaction =
      (object.hederaNativeTokenTransaction !== undefined && object.hederaNativeTokenTransaction !== null)
        ? HederaNativeTokenTransaction.fromPartial(object.hederaNativeTokenTransaction)
        : undefined;
    return message;
  },
};

function createBaseHederaNativeTokenTransaction(): HederaNativeTokenTransaction {
  return { transactionID: "", transactionType: "", sender: "", sources: [], destinations: [] };
}

export const HederaNativeTokenTransaction = {
  encode(message: HederaNativeTokenTransaction, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.transactionID !== "") {
      writer.uint32(10).string(message.transactionID);
    }
    if (message.transactionType !== "") {
      writer.uint32(18).string(message.transactionType);
    }
    if (message.sender !== "") {
      writer.uint32(26).string(message.sender);
    }
    for (const v of message.sources) {
      HederaNativeTokenTransfer.encode(v!, writer.uint32(34).fork()).ldelim();
    }
    for (const v of message.destinations) {
      HederaNativeTokenTransfer.encode(v!, writer.uint32(42).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): HederaNativeTokenTransaction {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseHederaNativeTokenTransaction();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.transactionID = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.transactionType = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.sender = reader.string();
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.sources.push(HederaNativeTokenTransfer.decode(reader, reader.uint32()));
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.destinations.push(HederaNativeTokenTransfer.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): HederaNativeTokenTransaction {
    return {
      transactionID: isSet(object.transactionID) ? globalThis.String(object.transactionID) : "",
      transactionType: isSet(object.transactionType) ? globalThis.String(object.transactionType) : "",
      sender: isSet(object.sender) ? globalThis.String(object.sender) : "",
      sources: globalThis.Array.isArray(object?.sources)
        ? object.sources.map((e: any) => HederaNativeTokenTransfer.fromJSON(e))
        : [],
      destinations: globalThis.Array.isArray(object?.destinations)
        ? object.destinations.map((e: any) => HederaNativeTokenTransfer.fromJSON(e))
        : [],
    };
  },

  toJSON(message: HederaNativeTokenTransaction): unknown {
    const obj: any = {};
    if (message.transactionID !== "") {
      obj.transactionID = message.transactionID;
    }
    if (message.transactionType !== "") {
      obj.transactionType = message.transactionType;
    }
    if (message.sender !== "") {
      obj.sender = message.sender;
    }
    if (message.sources?.length) {
      obj.sources = message.sources.map((e) => HederaNativeTokenTransfer.toJSON(e));
    }
    if (message.destinations?.length) {
      obj.destinations = message.destinations.map((e) => HederaNativeTokenTransfer.toJSON(e));
    }
    return obj;
  },

  create(base?: DeepPartial<HederaNativeTokenTransaction>): HederaNativeTokenTransaction {
    return HederaNativeTokenTransaction.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<HederaNativeTokenTransaction>): HederaNativeTokenTransaction {
    const message = createBaseHederaNativeTokenTransaction();
    message.transactionID = object.transactionID ?? "";
    message.transactionType = object.transactionType ?? "";
    message.sender = object.sender ?? "";
    message.sources = object.sources?.map((e) => HederaNativeTokenTransfer.fromPartial(e)) || [];
    message.destinations = object.destinations?.map((e) => HederaNativeTokenTransfer.fromPartial(e)) || [];
    return message;
  },
};

function createBaseHederaNativeTokenTransfer(): HederaNativeTokenTransfer {
  return { address: "", amount: "", asset: undefined };
}

export const HederaNativeTokenTransfer = {
  encode(message: HederaNativeTokenTransfer, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.address !== "") {
      writer.uint32(10).string(message.address);
    }
    if (message.amount !== "") {
      writer.uint32(18).string(message.amount);
    }
    if (message.asset !== undefined) {
      Asset.encode(message.asset, writer.uint32(26).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): HederaNativeTokenTransfer {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseHederaNativeTokenTransfer();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.address = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.amount = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.asset = Asset.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): HederaNativeTokenTransfer {
    return {
      address: isSet(object.address) ? globalThis.String(object.address) : "",
      amount: isSet(object.amount) ? globalThis.String(object.amount) : "",
      asset: isSet(object.asset) ? Asset.fromJSON(object.asset) : undefined,
    };
  },

  toJSON(message: HederaNativeTokenTransfer): unknown {
    const obj: any = {};
    if (message.address !== "") {
      obj.address = message.address;
    }
    if (message.amount !== "") {
      obj.amount = message.amount;
    }
    if (message.asset !== undefined) {
      obj.asset = Asset.toJSON(message.asset);
    }
    return obj;
  },

  create(base?: DeepPartial<HederaNativeTokenTransfer>): HederaNativeTokenTransfer {
    return HederaNativeTokenTransfer.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<HederaNativeTokenTransfer>): HederaNativeTokenTransfer {
    const message = createBaseHederaNativeTokenTransfer();
    message.address = object.address ?? "";
    message.amount = object.amount ?? "";
    message.asset = (object.asset !== undefined && object.asset !== null) ? Asset.fromPartial(object.asset) : undefined;
    return message;
  },
};

function createBaseAssetAttribute(): AssetAttribute {
  return { key: "", value: "" };
}

export const AssetAttribute = {
  encode(message: AssetAttribute, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.key !== "") {
      writer.uint32(10).string(message.key);
    }
    if (message.value !== "") {
      writer.uint32(18).string(message.value);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): AssetAttribute {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseAssetAttribute();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.key = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.value = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): AssetAttribute {
    return {
      key: isSet(object.key) ? globalThis.String(object.key) : "",
      value: isSet(object.value) ? globalThis.String(object.value) : "",
    };
  },

  toJSON(message: AssetAttribute): unknown {
    const obj: any = {};
    if (message.key !== "") {
      obj.key = message.key;
    }
    if (message.value !== "") {
      obj.value = message.value;
    }
    return obj;
  },

  create(base?: DeepPartial<AssetAttribute>): AssetAttribute {
    return AssetAttribute.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<AssetAttribute>): AssetAttribute {
    const message = createBaseAssetAttribute();
    message.key = object.key ?? "";
    message.value = object.value ?? "";
    return message;
  },
};

function createBaseAssetResource(): AssetResource {
  return {
    id: "",
    tenantID: 0,
    version: 0,
    createdAt: undefined,
    updatedAt: undefined,
    label: "",
    assetType: "",
    asset: undefined,
    currencyID: "",
    assetAttributes: [],
    status: "",
    blockchainAsset: undefined,
  };
}

export const AssetResource = {
  encode(message: AssetResource, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.id !== "") {
      writer.uint32(10).string(message.id);
    }
    if (message.tenantID !== 0) {
      writer.uint32(16).uint64(message.tenantID);
    }
    if (message.version !== 0) {
      writer.uint32(24).uint64(message.version);
    }
    if (message.createdAt !== undefined) {
      Timestamp.encode(toTimestamp(message.createdAt), writer.uint32(34).fork()).ldelim();
    }
    if (message.updatedAt !== undefined) {
      Timestamp.encode(toTimestamp(message.updatedAt), writer.uint32(42).fork()).ldelim();
    }
    if (message.label !== "") {
      writer.uint32(50).string(message.label);
    }
    if (message.assetType !== "") {
      writer.uint32(58).string(message.assetType);
    }
    if (message.asset !== undefined) {
      Asset.encode(message.asset, writer.uint32(66).fork()).ldelim();
    }
    if (message.currencyID !== "") {
      writer.uint32(74).string(message.currencyID);
    }
    for (const v of message.assetAttributes) {
      AssetAttribute.encode(v!, writer.uint32(82).fork()).ldelim();
    }
    if (message.status !== "") {
      writer.uint32(90).string(message.status);
    }
    if (message.blockchainAsset !== undefined) {
      BlockchainAsset.encode(message.blockchainAsset, writer.uint32(802).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): AssetResource {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseAssetResource();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.id = reader.string();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.tenantID = longToNumber(reader.uint64() as Long);
          continue;
        case 3:
          if (tag !== 24) {
            break;
          }

          message.version = longToNumber(reader.uint64() as Long);
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.createdAt = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.updatedAt = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        case 6:
          if (tag !== 50) {
            break;
          }

          message.label = reader.string();
          continue;
        case 7:
          if (tag !== 58) {
            break;
          }

          message.assetType = reader.string();
          continue;
        case 8:
          if (tag !== 66) {
            break;
          }

          message.asset = Asset.decode(reader, reader.uint32());
          continue;
        case 9:
          if (tag !== 74) {
            break;
          }

          message.currencyID = reader.string();
          continue;
        case 10:
          if (tag !== 82) {
            break;
          }

          message.assetAttributes.push(AssetAttribute.decode(reader, reader.uint32()));
          continue;
        case 11:
          if (tag !== 90) {
            break;
          }

          message.status = reader.string();
          continue;
        case 100:
          if (tag !== 802) {
            break;
          }

          message.blockchainAsset = BlockchainAsset.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): AssetResource {
    return {
      id: isSet(object.id) ? globalThis.String(object.id) : "",
      tenantID: isSet(object.tenantID) ? globalThis.Number(object.tenantID) : 0,
      version: isSet(object.version) ? globalThis.Number(object.version) : 0,
      createdAt: isSet(object.createdAt) ? fromJsonTimestamp(object.createdAt) : undefined,
      updatedAt: isSet(object.updatedAt) ? fromJsonTimestamp(object.updatedAt) : undefined,
      label: isSet(object.label) ? globalThis.String(object.label) : "",
      assetType: isSet(object.assetType) ? globalThis.String(object.assetType) : "",
      asset: isSet(object.asset) ? Asset.fromJSON(object.asset) : undefined,
      currencyID: isSet(object.currencyID) ? globalThis.String(object.currencyID) : "",
      assetAttributes: globalThis.Array.isArray(object?.assetAttributes)
        ? object.assetAttributes.map((e: any) => AssetAttribute.fromJSON(e))
        : [],
      status: isSet(object.status) ? globalThis.String(object.status) : "",
      blockchainAsset: isSet(object.blockchainAsset) ? BlockchainAsset.fromJSON(object.blockchainAsset) : undefined,
    };
  },

  toJSON(message: AssetResource): unknown {
    const obj: any = {};
    if (message.id !== "") {
      obj.id = message.id;
    }
    if (message.tenantID !== 0) {
      obj.tenantID = Math.round(message.tenantID);
    }
    if (message.version !== 0) {
      obj.version = Math.round(message.version);
    }
    if (message.createdAt !== undefined) {
      obj.createdAt = message.createdAt.toISOString();
    }
    if (message.updatedAt !== undefined) {
      obj.updatedAt = message.updatedAt.toISOString();
    }
    if (message.label !== "") {
      obj.label = message.label;
    }
    if (message.assetType !== "") {
      obj.assetType = message.assetType;
    }
    if (message.asset !== undefined) {
      obj.asset = Asset.toJSON(message.asset);
    }
    if (message.currencyID !== "") {
      obj.currencyID = message.currencyID;
    }
    if (message.assetAttributes?.length) {
      obj.assetAttributes = message.assetAttributes.map((e) => AssetAttribute.toJSON(e));
    }
    if (message.status !== "") {
      obj.status = message.status;
    }
    if (message.blockchainAsset !== undefined) {
      obj.blockchainAsset = BlockchainAsset.toJSON(message.blockchainAsset);
    }
    return obj;
  },

  create(base?: DeepPartial<AssetResource>): AssetResource {
    return AssetResource.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<AssetResource>): AssetResource {
    const message = createBaseAssetResource();
    message.id = object.id ?? "";
    message.tenantID = object.tenantID ?? 0;
    message.version = object.version ?? 0;
    message.createdAt = object.createdAt ?? undefined;
    message.updatedAt = object.updatedAt ?? undefined;
    message.label = object.label ?? "";
    message.assetType = object.assetType ?? "";
    message.asset = (object.asset !== undefined && object.asset !== null) ? Asset.fromPartial(object.asset) : undefined;
    message.currencyID = object.currencyID ?? "";
    message.assetAttributes = object.assetAttributes?.map((e) => AssetAttribute.fromPartial(e)) || [];
    message.status = object.status ?? "";
    message.blockchainAsset = (object.blockchainAsset !== undefined && object.blockchainAsset !== null)
      ? BlockchainAsset.fromPartial(object.blockchainAsset)
      : undefined;
    return message;
  },
};

function createBaseBlockchainAsset(): BlockchainAsset {
  return { hederaNativeTokenAsset: undefined, solanaNativeTokenAsset: undefined };
}

export const BlockchainAsset = {
  encode(message: BlockchainAsset, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.hederaNativeTokenAsset !== undefined) {
      HederaNativeTokenAsset.encode(message.hederaNativeTokenAsset, writer.uint32(10).fork()).ldelim();
    }
    if (message.solanaNativeTokenAsset !== undefined) {
      SolanaNativeTokenAsset.encode(message.solanaNativeTokenAsset, writer.uint32(18).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): BlockchainAsset {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseBlockchainAsset();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.hederaNativeTokenAsset = HederaNativeTokenAsset.decode(reader, reader.uint32());
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.solanaNativeTokenAsset = SolanaNativeTokenAsset.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): BlockchainAsset {
    return {
      hederaNativeTokenAsset: isSet(object.hederaNativeTokenAsset)
        ? HederaNativeTokenAsset.fromJSON(object.hederaNativeTokenAsset)
        : undefined,
      solanaNativeTokenAsset: isSet(object.solanaNativeTokenAsset)
        ? SolanaNativeTokenAsset.fromJSON(object.solanaNativeTokenAsset)
        : undefined,
    };
  },

  toJSON(message: BlockchainAsset): unknown {
    const obj: any = {};
    if (message.hederaNativeTokenAsset !== undefined) {
      obj.hederaNativeTokenAsset = HederaNativeTokenAsset.toJSON(message.hederaNativeTokenAsset);
    }
    if (message.solanaNativeTokenAsset !== undefined) {
      obj.solanaNativeTokenAsset = SolanaNativeTokenAsset.toJSON(message.solanaNativeTokenAsset);
    }
    return obj;
  },

  create(base?: DeepPartial<BlockchainAsset>): BlockchainAsset {
    return BlockchainAsset.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<BlockchainAsset>): BlockchainAsset {
    const message = createBaseBlockchainAsset();
    message.hederaNativeTokenAsset =
      (object.hederaNativeTokenAsset !== undefined && object.hederaNativeTokenAsset !== null)
        ? HederaNativeTokenAsset.fromPartial(object.hederaNativeTokenAsset)
        : undefined;
    message.solanaNativeTokenAsset =
      (object.solanaNativeTokenAsset !== undefined && object.solanaNativeTokenAsset !== null)
        ? SolanaNativeTokenAsset.fromPartial(object.solanaNativeTokenAsset)
        : undefined;
    return message;
  },
};

function createBaseHederaNativeTokenAsset(): HederaNativeTokenAsset {
  return { address: "", state: undefined };
}

export const HederaNativeTokenAsset = {
  encode(message: HederaNativeTokenAsset, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.address !== "") {
      writer.uint32(10).string(message.address);
    }
    if (message.state !== undefined) {
      HederaNativeTokenState.encode(message.state, writer.uint32(18).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): HederaNativeTokenAsset {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseHederaNativeTokenAsset();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.address = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.state = HederaNativeTokenState.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): HederaNativeTokenAsset {
    return {
      address: isSet(object.address) ? globalThis.String(object.address) : "",
      state: isSet(object.state) ? HederaNativeTokenState.fromJSON(object.state) : undefined,
    };
  },

  toJSON(message: HederaNativeTokenAsset): unknown {
    const obj: any = {};
    if (message.address !== "") {
      obj.address = message.address;
    }
    if (message.state !== undefined) {
      obj.state = HederaNativeTokenState.toJSON(message.state);
    }
    return obj;
  },

  create(base?: DeepPartial<HederaNativeTokenAsset>): HederaNativeTokenAsset {
    return HederaNativeTokenAsset.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<HederaNativeTokenAsset>): HederaNativeTokenAsset {
    const message = createBaseHederaNativeTokenAsset();
    message.address = object.address ?? "";
    message.state = (object.state !== undefined && object.state !== null)
      ? HederaNativeTokenState.fromPartial(object.state)
      : undefined;
    return message;
  },
};

function createBaseHederaNativeTokenState(): HederaNativeTokenState {
  return {
    name: "",
    symbol: "",
    memo: "",
    totalSupply: 0,
    autoRenewPeriod: undefined,
    decimals: 0,
    freezeDefault: false,
    initialSupply: 0,
    treasuryAccountID: "",
    type: "",
    pauseStatus: false,
    deleted: false,
    createdTimestamp: undefined,
    expiryTimestamp: undefined,
    modificationTimestamp: undefined,
    autoRenewAccount: "",
    customFees: "",
    adminKey: "",
    feeScheduleKey: "",
    freezeKey: "",
    kycKey: "",
    supplyKey: "",
    wipeKey: "",
    pauseKey: "",
  };
}

export const HederaNativeTokenState = {
  encode(message: HederaNativeTokenState, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    if (message.symbol !== "") {
      writer.uint32(18).string(message.symbol);
    }
    if (message.memo !== "") {
      writer.uint32(26).string(message.memo);
    }
    if (message.totalSupply !== 0) {
      writer.uint32(32).uint64(message.totalSupply);
    }
    if (message.autoRenewPeriod !== undefined) {
      Duration.encode(message.autoRenewPeriod, writer.uint32(42).fork()).ldelim();
    }
    if (message.decimals !== 0) {
      writer.uint32(48).uint64(message.decimals);
    }
    if (message.freezeDefault !== false) {
      writer.uint32(56).bool(message.freezeDefault);
    }
    if (message.initialSupply !== 0) {
      writer.uint32(64).uint64(message.initialSupply);
    }
    if (message.treasuryAccountID !== "") {
      writer.uint32(74).string(message.treasuryAccountID);
    }
    if (message.type !== "") {
      writer.uint32(82).string(message.type);
    }
    if (message.pauseStatus !== false) {
      writer.uint32(88).bool(message.pauseStatus);
    }
    if (message.deleted !== false) {
      writer.uint32(96).bool(message.deleted);
    }
    if (message.createdTimestamp !== undefined) {
      Timestamp.encode(toTimestamp(message.createdTimestamp), writer.uint32(106).fork()).ldelim();
    }
    if (message.expiryTimestamp !== undefined) {
      Timestamp.encode(toTimestamp(message.expiryTimestamp), writer.uint32(114).fork()).ldelim();
    }
    if (message.modificationTimestamp !== undefined) {
      Timestamp.encode(toTimestamp(message.modificationTimestamp), writer.uint32(122).fork()).ldelim();
    }
    if (message.autoRenewAccount !== "") {
      writer.uint32(130).string(message.autoRenewAccount);
    }
    if (message.customFees !== "") {
      writer.uint32(138).string(message.customFees);
    }
    if (message.adminKey !== "") {
      writer.uint32(146).string(message.adminKey);
    }
    if (message.feeScheduleKey !== "") {
      writer.uint32(154).string(message.feeScheduleKey);
    }
    if (message.freezeKey !== "") {
      writer.uint32(162).string(message.freezeKey);
    }
    if (message.kycKey !== "") {
      writer.uint32(170).string(message.kycKey);
    }
    if (message.supplyKey !== "") {
      writer.uint32(178).string(message.supplyKey);
    }
    if (message.wipeKey !== "") {
      writer.uint32(186).string(message.wipeKey);
    }
    if (message.pauseKey !== "") {
      writer.uint32(194).string(message.pauseKey);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): HederaNativeTokenState {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseHederaNativeTokenState();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.symbol = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.memo = reader.string();
          continue;
        case 4:
          if (tag !== 32) {
            break;
          }

          message.totalSupply = longToNumber(reader.uint64() as Long);
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.autoRenewPeriod = Duration.decode(reader, reader.uint32());
          continue;
        case 6:
          if (tag !== 48) {
            break;
          }

          message.decimals = longToNumber(reader.uint64() as Long);
          continue;
        case 7:
          if (tag !== 56) {
            break;
          }

          message.freezeDefault = reader.bool();
          continue;
        case 8:
          if (tag !== 64) {
            break;
          }

          message.initialSupply = longToNumber(reader.uint64() as Long);
          continue;
        case 9:
          if (tag !== 74) {
            break;
          }

          message.treasuryAccountID = reader.string();
          continue;
        case 10:
          if (tag !== 82) {
            break;
          }

          message.type = reader.string();
          continue;
        case 11:
          if (tag !== 88) {
            break;
          }

          message.pauseStatus = reader.bool();
          continue;
        case 12:
          if (tag !== 96) {
            break;
          }

          message.deleted = reader.bool();
          continue;
        case 13:
          if (tag !== 106) {
            break;
          }

          message.createdTimestamp = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        case 14:
          if (tag !== 114) {
            break;
          }

          message.expiryTimestamp = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        case 15:
          if (tag !== 122) {
            break;
          }

          message.modificationTimestamp = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        case 16:
          if (tag !== 130) {
            break;
          }

          message.autoRenewAccount = reader.string();
          continue;
        case 17:
          if (tag !== 138) {
            break;
          }

          message.customFees = reader.string();
          continue;
        case 18:
          if (tag !== 146) {
            break;
          }

          message.adminKey = reader.string();
          continue;
        case 19:
          if (tag !== 154) {
            break;
          }

          message.feeScheduleKey = reader.string();
          continue;
        case 20:
          if (tag !== 162) {
            break;
          }

          message.freezeKey = reader.string();
          continue;
        case 21:
          if (tag !== 170) {
            break;
          }

          message.kycKey = reader.string();
          continue;
        case 22:
          if (tag !== 178) {
            break;
          }

          message.supplyKey = reader.string();
          continue;
        case 23:
          if (tag !== 186) {
            break;
          }

          message.wipeKey = reader.string();
          continue;
        case 24:
          if (tag !== 194) {
            break;
          }

          message.pauseKey = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): HederaNativeTokenState {
    return {
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      symbol: isSet(object.symbol) ? globalThis.String(object.symbol) : "",
      memo: isSet(object.memo) ? globalThis.String(object.memo) : "",
      totalSupply: isSet(object.totalSupply) ? globalThis.Number(object.totalSupply) : 0,
      autoRenewPeriod: isSet(object.autoRenewPeriod) ? Duration.fromJSON(object.autoRenewPeriod) : undefined,
      decimals: isSet(object.decimals) ? globalThis.Number(object.decimals) : 0,
      freezeDefault: isSet(object.freezeDefault) ? globalThis.Boolean(object.freezeDefault) : false,
      initialSupply: isSet(object.initialSupply) ? globalThis.Number(object.initialSupply) : 0,
      treasuryAccountID: isSet(object.treasuryAccountID) ? globalThis.String(object.treasuryAccountID) : "",
      type: isSet(object.type) ? globalThis.String(object.type) : "",
      pauseStatus: isSet(object.pauseStatus) ? globalThis.Boolean(object.pauseStatus) : false,
      deleted: isSet(object.deleted) ? globalThis.Boolean(object.deleted) : false,
      createdTimestamp: isSet(object.createdTimestamp) ? fromJsonTimestamp(object.createdTimestamp) : undefined,
      expiryTimestamp: isSet(object.expiryTimestamp) ? fromJsonTimestamp(object.expiryTimestamp) : undefined,
      modificationTimestamp: isSet(object.modificationTimestamp)
        ? fromJsonTimestamp(object.modificationTimestamp)
        : undefined,
      autoRenewAccount: isSet(object.autoRenewAccount) ? globalThis.String(object.autoRenewAccount) : "",
      customFees: isSet(object.customFees) ? globalThis.String(object.customFees) : "",
      adminKey: isSet(object.adminKey) ? globalThis.String(object.adminKey) : "",
      feeScheduleKey: isSet(object.feeScheduleKey) ? globalThis.String(object.feeScheduleKey) : "",
      freezeKey: isSet(object.freezeKey) ? globalThis.String(object.freezeKey) : "",
      kycKey: isSet(object.kycKey) ? globalThis.String(object.kycKey) : "",
      supplyKey: isSet(object.supplyKey) ? globalThis.String(object.supplyKey) : "",
      wipeKey: isSet(object.wipeKey) ? globalThis.String(object.wipeKey) : "",
      pauseKey: isSet(object.pauseKey) ? globalThis.String(object.pauseKey) : "",
    };
  },

  toJSON(message: HederaNativeTokenState): unknown {
    const obj: any = {};
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.symbol !== "") {
      obj.symbol = message.symbol;
    }
    if (message.memo !== "") {
      obj.memo = message.memo;
    }
    if (message.totalSupply !== 0) {
      obj.totalSupply = Math.round(message.totalSupply);
    }
    if (message.autoRenewPeriod !== undefined) {
      obj.autoRenewPeriod = Duration.toJSON(message.autoRenewPeriod);
    }
    if (message.decimals !== 0) {
      obj.decimals = Math.round(message.decimals);
    }
    if (message.freezeDefault !== false) {
      obj.freezeDefault = message.freezeDefault;
    }
    if (message.initialSupply !== 0) {
      obj.initialSupply = Math.round(message.initialSupply);
    }
    if (message.treasuryAccountID !== "") {
      obj.treasuryAccountID = message.treasuryAccountID;
    }
    if (message.type !== "") {
      obj.type = message.type;
    }
    if (message.pauseStatus !== false) {
      obj.pauseStatus = message.pauseStatus;
    }
    if (message.deleted !== false) {
      obj.deleted = message.deleted;
    }
    if (message.createdTimestamp !== undefined) {
      obj.createdTimestamp = message.createdTimestamp.toISOString();
    }
    if (message.expiryTimestamp !== undefined) {
      obj.expiryTimestamp = message.expiryTimestamp.toISOString();
    }
    if (message.modificationTimestamp !== undefined) {
      obj.modificationTimestamp = message.modificationTimestamp.toISOString();
    }
    if (message.autoRenewAccount !== "") {
      obj.autoRenewAccount = message.autoRenewAccount;
    }
    if (message.customFees !== "") {
      obj.customFees = message.customFees;
    }
    if (message.adminKey !== "") {
      obj.adminKey = message.adminKey;
    }
    if (message.feeScheduleKey !== "") {
      obj.feeScheduleKey = message.feeScheduleKey;
    }
    if (message.freezeKey !== "") {
      obj.freezeKey = message.freezeKey;
    }
    if (message.kycKey !== "") {
      obj.kycKey = message.kycKey;
    }
    if (message.supplyKey !== "") {
      obj.supplyKey = message.supplyKey;
    }
    if (message.wipeKey !== "") {
      obj.wipeKey = message.wipeKey;
    }
    if (message.pauseKey !== "") {
      obj.pauseKey = message.pauseKey;
    }
    return obj;
  },

  create(base?: DeepPartial<HederaNativeTokenState>): HederaNativeTokenState {
    return HederaNativeTokenState.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<HederaNativeTokenState>): HederaNativeTokenState {
    const message = createBaseHederaNativeTokenState();
    message.name = object.name ?? "";
    message.symbol = object.symbol ?? "";
    message.memo = object.memo ?? "";
    message.totalSupply = object.totalSupply ?? 0;
    message.autoRenewPeriod = (object.autoRenewPeriod !== undefined && object.autoRenewPeriod !== null)
      ? Duration.fromPartial(object.autoRenewPeriod)
      : undefined;
    message.decimals = object.decimals ?? 0;
    message.freezeDefault = object.freezeDefault ?? false;
    message.initialSupply = object.initialSupply ?? 0;
    message.treasuryAccountID = object.treasuryAccountID ?? "";
    message.type = object.type ?? "";
    message.pauseStatus = object.pauseStatus ?? false;
    message.deleted = object.deleted ?? false;
    message.createdTimestamp = object.createdTimestamp ?? undefined;
    message.expiryTimestamp = object.expiryTimestamp ?? undefined;
    message.modificationTimestamp = object.modificationTimestamp ?? undefined;
    message.autoRenewAccount = object.autoRenewAccount ?? "";
    message.customFees = object.customFees ?? "";
    message.adminKey = object.adminKey ?? "";
    message.feeScheduleKey = object.feeScheduleKey ?? "";
    message.freezeKey = object.freezeKey ?? "";
    message.kycKey = object.kycKey ?? "";
    message.supplyKey = object.supplyKey ?? "";
    message.wipeKey = object.wipeKey ?? "";
    message.pauseKey = object.pauseKey ?? "";
    return message;
  },
};

function createBaseSolanaNativeTokenAsset(): SolanaNativeTokenAsset {
  return { address: "", state: undefined };
}

export const SolanaNativeTokenAsset = {
  encode(message: SolanaNativeTokenAsset, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.address !== "") {
      writer.uint32(10).string(message.address);
    }
    if (message.state !== undefined) {
      SolanaNativeTokenState.encode(message.state, writer.uint32(18).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): SolanaNativeTokenAsset {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSolanaNativeTokenAsset();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.address = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.state = SolanaNativeTokenState.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): SolanaNativeTokenAsset {
    return {
      address: isSet(object.address) ? globalThis.String(object.address) : "",
      state: isSet(object.state) ? SolanaNativeTokenState.fromJSON(object.state) : undefined,
    };
  },

  toJSON(message: SolanaNativeTokenAsset): unknown {
    const obj: any = {};
    if (message.address !== "") {
      obj.address = message.address;
    }
    if (message.state !== undefined) {
      obj.state = SolanaNativeTokenState.toJSON(message.state);
    }
    return obj;
  },

  create(base?: DeepPartial<SolanaNativeTokenAsset>): SolanaNativeTokenAsset {
    return SolanaNativeTokenAsset.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<SolanaNativeTokenAsset>): SolanaNativeTokenAsset {
    const message = createBaseSolanaNativeTokenAsset();
    message.address = object.address ?? "";
    message.state = (object.state !== undefined && object.state !== null)
      ? SolanaNativeTokenState.fromPartial(object.state)
      : undefined;
    return message;
  },
};

function createBaseSolanaNativeTokenState(): SolanaNativeTokenState {
  return { name: "", symbol: "", decimals: 0, type: "", uri: "", owner: "", mintAuthority: "", freezeAuthority: "" };
}

export const SolanaNativeTokenState = {
  encode(message: SolanaNativeTokenState, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    if (message.symbol !== "") {
      writer.uint32(18).string(message.symbol);
    }
    if (message.decimals !== 0) {
      writer.uint32(24).uint64(message.decimals);
    }
    if (message.type !== "") {
      writer.uint32(34).string(message.type);
    }
    if (message.uri !== "") {
      writer.uint32(42).string(message.uri);
    }
    if (message.owner !== "") {
      writer.uint32(50).string(message.owner);
    }
    if (message.mintAuthority !== "") {
      writer.uint32(58).string(message.mintAuthority);
    }
    if (message.freezeAuthority !== "") {
      writer.uint32(66).string(message.freezeAuthority);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): SolanaNativeTokenState {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSolanaNativeTokenState();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.symbol = reader.string();
          continue;
        case 3:
          if (tag !== 24) {
            break;
          }

          message.decimals = longToNumber(reader.uint64() as Long);
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.type = reader.string();
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.uri = reader.string();
          continue;
        case 6:
          if (tag !== 50) {
            break;
          }

          message.owner = reader.string();
          continue;
        case 7:
          if (tag !== 58) {
            break;
          }

          message.mintAuthority = reader.string();
          continue;
        case 8:
          if (tag !== 66) {
            break;
          }

          message.freezeAuthority = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): SolanaNativeTokenState {
    return {
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      symbol: isSet(object.symbol) ? globalThis.String(object.symbol) : "",
      decimals: isSet(object.decimals) ? globalThis.Number(object.decimals) : 0,
      type: isSet(object.type) ? globalThis.String(object.type) : "",
      uri: isSet(object.uri) ? globalThis.String(object.uri) : "",
      owner: isSet(object.owner) ? globalThis.String(object.owner) : "",
      mintAuthority: isSet(object.mintAuthority) ? globalThis.String(object.mintAuthority) : "",
      freezeAuthority: isSet(object.freezeAuthority) ? globalThis.String(object.freezeAuthority) : "",
    };
  },

  toJSON(message: SolanaNativeTokenState): unknown {
    const obj: any = {};
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.symbol !== "") {
      obj.symbol = message.symbol;
    }
    if (message.decimals !== 0) {
      obj.decimals = Math.round(message.decimals);
    }
    if (message.type !== "") {
      obj.type = message.type;
    }
    if (message.uri !== "") {
      obj.uri = message.uri;
    }
    if (message.owner !== "") {
      obj.owner = message.owner;
    }
    if (message.mintAuthority !== "") {
      obj.mintAuthority = message.mintAuthority;
    }
    if (message.freezeAuthority !== "") {
      obj.freezeAuthority = message.freezeAuthority;
    }
    return obj;
  },

  create(base?: DeepPartial<SolanaNativeTokenState>): SolanaNativeTokenState {
    return SolanaNativeTokenState.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<SolanaNativeTokenState>): SolanaNativeTokenState {
    const message = createBaseSolanaNativeTokenState();
    message.name = object.name ?? "";
    message.symbol = object.symbol ?? "";
    message.decimals = object.decimals ?? 0;
    message.type = object.type ?? "";
    message.uri = object.uri ?? "";
    message.owner = object.owner ?? "";
    message.mintAuthority = object.mintAuthority ?? "";
    message.freezeAuthority = object.freezeAuthority ?? "";
    return message;
  },
};

function createBaseAssetEvent(): AssetEvent {
  return {
    id: "",
    tenantID: 0,
    hash: "",
    asset: undefined,
    blockchainEvent: undefined,
    createdAt: undefined,
    updatedAt: undefined,
  };
}

export const AssetEvent = {
  encode(message: AssetEvent, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.id !== "") {
      writer.uint32(10).string(message.id);
    }
    if (message.tenantID !== 0) {
      writer.uint32(16).uint64(message.tenantID);
    }
    if (message.hash !== "") {
      writer.uint32(26).string(message.hash);
    }
    if (message.asset !== undefined) {
      Asset.encode(message.asset, writer.uint32(34).fork()).ldelim();
    }
    if (message.blockchainEvent !== undefined) {
      BlockchainEvent.encode(message.blockchainEvent, writer.uint32(42).fork()).ldelim();
    }
    if (message.createdAt !== undefined) {
      Timestamp.encode(toTimestamp(message.createdAt), writer.uint32(50).fork()).ldelim();
    }
    if (message.updatedAt !== undefined) {
      Timestamp.encode(toTimestamp(message.updatedAt), writer.uint32(58).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): AssetEvent {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseAssetEvent();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.id = reader.string();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.tenantID = longToNumber(reader.uint64() as Long);
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.hash = reader.string();
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.asset = Asset.decode(reader, reader.uint32());
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.blockchainEvent = BlockchainEvent.decode(reader, reader.uint32());
          continue;
        case 6:
          if (tag !== 50) {
            break;
          }

          message.createdAt = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        case 7:
          if (tag !== 58) {
            break;
          }

          message.updatedAt = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): AssetEvent {
    return {
      id: isSet(object.id) ? globalThis.String(object.id) : "",
      tenantID: isSet(object.tenantID) ? globalThis.Number(object.tenantID) : 0,
      hash: isSet(object.hash) ? globalThis.String(object.hash) : "",
      asset: isSet(object.asset) ? Asset.fromJSON(object.asset) : undefined,
      blockchainEvent: isSet(object.blockchainEvent) ? BlockchainEvent.fromJSON(object.blockchainEvent) : undefined,
      createdAt: isSet(object.createdAt) ? fromJsonTimestamp(object.createdAt) : undefined,
      updatedAt: isSet(object.updatedAt) ? fromJsonTimestamp(object.updatedAt) : undefined,
    };
  },

  toJSON(message: AssetEvent): unknown {
    const obj: any = {};
    if (message.id !== "") {
      obj.id = message.id;
    }
    if (message.tenantID !== 0) {
      obj.tenantID = Math.round(message.tenantID);
    }
    if (message.hash !== "") {
      obj.hash = message.hash;
    }
    if (message.asset !== undefined) {
      obj.asset = Asset.toJSON(message.asset);
    }
    if (message.blockchainEvent !== undefined) {
      obj.blockchainEvent = BlockchainEvent.toJSON(message.blockchainEvent);
    }
    if (message.createdAt !== undefined) {
      obj.createdAt = message.createdAt.toISOString();
    }
    if (message.updatedAt !== undefined) {
      obj.updatedAt = message.updatedAt.toISOString();
    }
    return obj;
  },

  create(base?: DeepPartial<AssetEvent>): AssetEvent {
    return AssetEvent.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<AssetEvent>): AssetEvent {
    const message = createBaseAssetEvent();
    message.id = object.id ?? "";
    message.tenantID = object.tenantID ?? 0;
    message.hash = object.hash ?? "";
    message.asset = (object.asset !== undefined && object.asset !== null) ? Asset.fromPartial(object.asset) : undefined;
    message.blockchainEvent = (object.blockchainEvent !== undefined && object.blockchainEvent !== null)
      ? BlockchainEvent.fromPartial(object.blockchainEvent)
      : undefined;
    message.createdAt = object.createdAt ?? undefined;
    message.updatedAt = object.updatedAt ?? undefined;
    return message;
  },
};

function createBaseInternalAddressDetails(): InternalAddressDetails {
  return { address: "", blockchainAddressID: 0 };
}

export const InternalAddressDetails = {
  encode(message: InternalAddressDetails, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.address !== "") {
      writer.uint32(10).string(message.address);
    }
    if (message.blockchainAddressID !== 0) {
      writer.uint32(16).uint64(message.blockchainAddressID);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): InternalAddressDetails {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseInternalAddressDetails();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.address = reader.string();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.blockchainAddressID = longToNumber(reader.uint64() as Long);
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): InternalAddressDetails {
    return {
      address: isSet(object.address) ? globalThis.String(object.address) : "",
      blockchainAddressID: isSet(object.blockchainAddressID) ? globalThis.Number(object.blockchainAddressID) : 0,
    };
  },

  toJSON(message: InternalAddressDetails): unknown {
    const obj: any = {};
    if (message.address !== "") {
      obj.address = message.address;
    }
    if (message.blockchainAddressID !== 0) {
      obj.blockchainAddressID = Math.round(message.blockchainAddressID);
    }
    return obj;
  },

  create(base?: DeepPartial<InternalAddressDetails>): InternalAddressDetails {
    return InternalAddressDetails.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<InternalAddressDetails>): InternalAddressDetails {
    const message = createBaseInternalAddressDetails();
    message.address = object.address ?? "";
    message.blockchainAddressID = object.blockchainAddressID ?? 0;
    return message;
  },
};

function createBaseWhitelistedAddressDetails(): WhitelistedAddressDetails {
  return { address: "", whitelistedAddressID: 0 };
}

export const WhitelistedAddressDetails = {
  encode(message: WhitelistedAddressDetails, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.address !== "") {
      writer.uint32(10).string(message.address);
    }
    if (message.whitelistedAddressID !== 0) {
      writer.uint32(16).uint64(message.whitelistedAddressID);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): WhitelistedAddressDetails {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseWhitelistedAddressDetails();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.address = reader.string();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.whitelistedAddressID = longToNumber(reader.uint64() as Long);
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): WhitelistedAddressDetails {
    return {
      address: isSet(object.address) ? globalThis.String(object.address) : "",
      whitelistedAddressID: isSet(object.whitelistedAddressID) ? globalThis.Number(object.whitelistedAddressID) : 0,
    };
  },

  toJSON(message: WhitelistedAddressDetails): unknown {
    const obj: any = {};
    if (message.address !== "") {
      obj.address = message.address;
    }
    if (message.whitelistedAddressID !== 0) {
      obj.whitelistedAddressID = Math.round(message.whitelistedAddressID);
    }
    return obj;
  },

  create(base?: DeepPartial<WhitelistedAddressDetails>): WhitelistedAddressDetails {
    return WhitelistedAddressDetails.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<WhitelistedAddressDetails>): WhitelistedAddressDetails {
    const message = createBaseWhitelistedAddressDetails();
    message.address = object.address ?? "";
    message.whitelistedAddressID = object.whitelistedAddressID ?? 0;
    return message;
  },
};

function createBaseExternalAddressDetails(): ExternalAddressDetails {
  return { address: "" };
}

export const ExternalAddressDetails = {
  encode(message: ExternalAddressDetails, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.address !== "") {
      writer.uint32(10).string(message.address);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): ExternalAddressDetails {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseExternalAddressDetails();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.address = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ExternalAddressDetails {
    return { address: isSet(object.address) ? globalThis.String(object.address) : "" };
  },

  toJSON(message: ExternalAddressDetails): unknown {
    const obj: any = {};
    if (message.address !== "") {
      obj.address = message.address;
    }
    return obj;
  },

  create(base?: DeepPartial<ExternalAddressDetails>): ExternalAddressDetails {
    return ExternalAddressDetails.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ExternalAddressDetails>): ExternalAddressDetails {
    const message = createBaseExternalAddressDetails();
    message.address = object.address ?? "";
    return message;
  },
};

function createBaseAssetHolder(): AssetHolder {
  return {
    id: "",
    tenantID: 0,
    internalAddressDetails: undefined,
    whitelistedAddressDetails: undefined,
    externalAddressDetails: undefined,
    asset: undefined,
    balance: "",
    createdAt: undefined,
    updatedAt: undefined,
  };
}

export const AssetHolder = {
  encode(message: AssetHolder, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.id !== "") {
      writer.uint32(10).string(message.id);
    }
    if (message.tenantID !== 0) {
      writer.uint32(16).uint64(message.tenantID);
    }
    if (message.internalAddressDetails !== undefined) {
      InternalAddressDetails.encode(message.internalAddressDetails, writer.uint32(26).fork()).ldelim();
    }
    if (message.whitelistedAddressDetails !== undefined) {
      WhitelistedAddressDetails.encode(message.whitelistedAddressDetails, writer.uint32(34).fork()).ldelim();
    }
    if (message.externalAddressDetails !== undefined) {
      ExternalAddressDetails.encode(message.externalAddressDetails, writer.uint32(42).fork()).ldelim();
    }
    if (message.asset !== undefined) {
      Asset.encode(message.asset, writer.uint32(50).fork()).ldelim();
    }
    if (message.balance !== "") {
      writer.uint32(58).string(message.balance);
    }
    if (message.createdAt !== undefined) {
      Timestamp.encode(toTimestamp(message.createdAt), writer.uint32(66).fork()).ldelim();
    }
    if (message.updatedAt !== undefined) {
      Timestamp.encode(toTimestamp(message.updatedAt), writer.uint32(74).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): AssetHolder {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseAssetHolder();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.id = reader.string();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.tenantID = longToNumber(reader.uint64() as Long);
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.internalAddressDetails = InternalAddressDetails.decode(reader, reader.uint32());
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.whitelistedAddressDetails = WhitelistedAddressDetails.decode(reader, reader.uint32());
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.externalAddressDetails = ExternalAddressDetails.decode(reader, reader.uint32());
          continue;
        case 6:
          if (tag !== 50) {
            break;
          }

          message.asset = Asset.decode(reader, reader.uint32());
          continue;
        case 7:
          if (tag !== 58) {
            break;
          }

          message.balance = reader.string();
          continue;
        case 8:
          if (tag !== 66) {
            break;
          }

          message.createdAt = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        case 9:
          if (tag !== 74) {
            break;
          }

          message.updatedAt = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): AssetHolder {
    return {
      id: isSet(object.id) ? globalThis.String(object.id) : "",
      tenantID: isSet(object.tenantID) ? globalThis.Number(object.tenantID) : 0,
      internalAddressDetails: isSet(object.internalAddressDetails)
        ? InternalAddressDetails.fromJSON(object.internalAddressDetails)
        : undefined,
      whitelistedAddressDetails: isSet(object.whitelistedAddressDetails)
        ? WhitelistedAddressDetails.fromJSON(object.whitelistedAddressDetails)
        : undefined,
      externalAddressDetails: isSet(object.externalAddressDetails)
        ? ExternalAddressDetails.fromJSON(object.externalAddressDetails)
        : undefined,
      asset: isSet(object.asset) ? Asset.fromJSON(object.asset) : undefined,
      balance: isSet(object.balance) ? globalThis.String(object.balance) : "",
      createdAt: isSet(object.createdAt) ? fromJsonTimestamp(object.createdAt) : undefined,
      updatedAt: isSet(object.updatedAt) ? fromJsonTimestamp(object.updatedAt) : undefined,
    };
  },

  toJSON(message: AssetHolder): unknown {
    const obj: any = {};
    if (message.id !== "") {
      obj.id = message.id;
    }
    if (message.tenantID !== 0) {
      obj.tenantID = Math.round(message.tenantID);
    }
    if (message.internalAddressDetails !== undefined) {
      obj.internalAddressDetails = InternalAddressDetails.toJSON(message.internalAddressDetails);
    }
    if (message.whitelistedAddressDetails !== undefined) {
      obj.whitelistedAddressDetails = WhitelistedAddressDetails.toJSON(message.whitelistedAddressDetails);
    }
    if (message.externalAddressDetails !== undefined) {
      obj.externalAddressDetails = ExternalAddressDetails.toJSON(message.externalAddressDetails);
    }
    if (message.asset !== undefined) {
      obj.asset = Asset.toJSON(message.asset);
    }
    if (message.balance !== "") {
      obj.balance = message.balance;
    }
    if (message.createdAt !== undefined) {
      obj.createdAt = message.createdAt.toISOString();
    }
    if (message.updatedAt !== undefined) {
      obj.updatedAt = message.updatedAt.toISOString();
    }
    return obj;
  },

  create(base?: DeepPartial<AssetHolder>): AssetHolder {
    return AssetHolder.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<AssetHolder>): AssetHolder {
    const message = createBaseAssetHolder();
    message.id = object.id ?? "";
    message.tenantID = object.tenantID ?? 0;
    message.internalAddressDetails =
      (object.internalAddressDetails !== undefined && object.internalAddressDetails !== null)
        ? InternalAddressDetails.fromPartial(object.internalAddressDetails)
        : undefined;
    message.whitelistedAddressDetails =
      (object.whitelistedAddressDetails !== undefined && object.whitelistedAddressDetails !== null)
        ? WhitelistedAddressDetails.fromPartial(object.whitelistedAddressDetails)
        : undefined;
    message.externalAddressDetails =
      (object.externalAddressDetails !== undefined && object.externalAddressDetails !== null)
        ? ExternalAddressDetails.fromPartial(object.externalAddressDetails)
        : undefined;
    message.asset = (object.asset !== undefined && object.asset !== null) ? Asset.fromPartial(object.asset) : undefined;
    message.balance = object.balance ?? "";
    message.createdAt = object.createdAt ?? undefined;
    message.updatedAt = object.updatedAt ?? undefined;
    return message;
  },
};

function bytesFromBase64(b64: string): Uint8Array {
  const bin = globalThis.atob(b64);
  const arr = new Uint8Array(bin.length);
  for (let i = 0; i < bin.length; ++i) {
    arr[i] = bin.charCodeAt(i);
  }
  return arr;
}

function base64FromBytes(arr: Uint8Array): string {
  const bin: string[] = [];
  arr.forEach((byte) => {
    bin.push(globalThis.String.fromCharCode(byte));
  });
  return globalThis.btoa(bin.join(""));
}

type Builtin = Date | Function | Uint8Array | string | number | boolean | undefined;

export type DeepPartial<T> = T extends Builtin ? T
  : T extends globalThis.Array<infer U> ? globalThis.Array<DeepPartial<U>>
  : T extends ReadonlyArray<infer U> ? ReadonlyArray<DeepPartial<U>>
  : T extends {} ? { [K in keyof T]?: DeepPartial<T[K]> }
  : Partial<T>;

function toTimestamp(date: Date): Timestamp {
  const seconds = Math.trunc(date.getTime() / 1_000);
  const nanos = (date.getTime() % 1_000) * 1_000_000;
  return { seconds, nanos };
}

function fromTimestamp(t: Timestamp): Date {
  let millis = (t.seconds || 0) * 1_000;
  millis += (t.nanos || 0) / 1_000_000;
  return new globalThis.Date(millis);
}

function fromJsonTimestamp(o: any): Date {
  if (o instanceof globalThis.Date) {
    return o;
  } else if (typeof o === "string") {
    return new globalThis.Date(o);
  } else {
    return fromTimestamp(Timestamp.fromJSON(o));
  }
}

function longToNumber(long: Long): number {
  if (long.gt(globalThis.Number.MAX_SAFE_INTEGER)) {
    throw new globalThis.Error("Value is larger than Number.MAX_SAFE_INTEGER");
  }
  if (long.lt(globalThis.Number.MIN_SAFE_INTEGER)) {
    throw new globalThis.Error("Value is smaller than Number.MIN_SAFE_INTEGER");
  }
  return long.toNumber();
}

if (_m0.util.Long !== Long) {
  _m0.util.Long = Long as any;
  _m0.configure();
}

function isSet(value: any): boolean {
  return value !== null && value !== undefined;
}
