/*
Taurus-PROTECT APIs

Taurus-PROTECT APIs description

API version: 1.0
*/

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package openapi

import (
	"bytes"
	"context"
	"io"
	"net/http"
	"net/url"
)


// WebhookCallsAPIService WebhookCallsAPI service
type WebhookCallsAPIService service

type ApiWebhookServiceGetWebhookCallsRequest struct {
	ctx context.Context
	ApiService *WebhookCallsAPIService
	eventID *string
	webhookID *string
	status *string
	cursorCurrentPage *string
	cursorPageRequest *string
	cursorPageSize *string
	sortOrder *string
}

func (r ApiWebhookServiceGetWebhookCallsRequest) EventID(eventID string) ApiWebhookServiceGetWebhookCallsRequest {
	r.eventID = &eventID
	return r
}

func (r ApiWebhookServiceGetWebhookCallsRequest) WebhookID(webhookID string) ApiWebhookServiceGetWebhookCallsRequest {
	r.webhookID = &webhookID
	return r
}

func (r ApiWebhookServiceGetWebhookCallsRequest) Status(status string) ApiWebhookServiceGetWebhookCallsRequest {
	r.status = &status
	return r
}

// Base64-encoded string representing the current window of data
func (r ApiWebhookServiceGetWebhookCallsRequest) CursorCurrentPage(cursorCurrentPage string) ApiWebhookServiceGetWebhookCallsRequest {
	r.cursorCurrentPage = &cursorCurrentPage
	return r
}

// The page to request, w.r.t the current page. Can be one of &#x60;FIRST&#x60;, &#x60;PREVIOUS&#x60;, &#x60;NEXT&#x60;, &#x60;LAST&#x60;
func (r ApiWebhookServiceGetWebhookCallsRequest) CursorPageRequest(cursorPageRequest string) ApiWebhookServiceGetWebhookCallsRequest {
	r.cursorPageRequest = &cursorPageRequest
	return r
}

// The size of the page requested. The handling service should impose a hard limit on this
func (r ApiWebhookServiceGetWebhookCallsRequest) CursorPageSize(cursorPageSize string) ApiWebhookServiceGetWebhookCallsRequest {
	r.cursorPageSize = &cursorPageSize
	return r
}

// Webhook calls are sorted by creation date and ID. Set this to ASC for an ascending order or DESC for descending. The default value is DESC
func (r ApiWebhookServiceGetWebhookCallsRequest) SortOrder(sortOrder string) ApiWebhookServiceGetWebhookCallsRequest {
	r.sortOrder = &sortOrder
	return r
}

func (r ApiWebhookServiceGetWebhookCallsRequest) Execute() (*TgvalidatordGetWebhookCallsReply, *http.Response, error) {
	return r.ApiService.WebhookServiceGetWebhookCallsExecute(r)
}

/*
WebhookServiceGetWebhookCalls Get webhook calls

This endpoint lists calls that have been made to webhooks.
Required Role: **Admin**, **AdminReadOnly.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiWebhookServiceGetWebhookCallsRequest
*/
func (a *WebhookCallsAPIService) WebhookServiceGetWebhookCalls(ctx context.Context) ApiWebhookServiceGetWebhookCallsRequest {
	return ApiWebhookServiceGetWebhookCallsRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return TgvalidatordGetWebhookCallsReply
func (a *WebhookCallsAPIService) WebhookServiceGetWebhookCallsExecute(r ApiWebhookServiceGetWebhookCallsRequest) (*TgvalidatordGetWebhookCallsReply, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *TgvalidatordGetWebhookCallsReply
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "WebhookCallsAPIService.WebhookServiceGetWebhookCalls")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/rest/v1/webhooks/calls"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.eventID != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "eventID", r.eventID, "", "")
	}
	if r.webhookID != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "webhookID", r.webhookID, "", "")
	}
	if r.status != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "status", r.status, "", "")
	}
	if r.cursorCurrentPage != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "cursor.currentPage", r.cursorCurrentPage, "", "")
	}
	if r.cursorPageRequest != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "cursor.pageRequest", r.cursorPageRequest, "", "")
	}
	if r.cursorPageSize != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "cursor.pageSize", r.cursorPageSize, "", "")
	}
	if r.sortOrder != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "sortOrder", r.sortOrder, "", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["ApiKeyTPV1"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v map[string]interface{}
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v map[string]interface{}
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v map[string]interface{}
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v map[string]interface{}
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v map[string]interface{}
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 503 {
			var v map[string]interface{}
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
			var v GooglerpcStatus
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}
