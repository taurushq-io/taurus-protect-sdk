/**
 * Address signature verification using HSM slot public key.
 *
 * This module verifies that addresses were signed by the HSM slot,
 * ensuring they were generated by the hardware security module.
 */

import type { KeyObject } from "crypto";

import { verifySignature, decodePublicKeyPem } from "../crypto";
import { IntegrityError } from "../errors";
import type { DecodedRulesContainer } from "../models/governance-rules";
import { getHsmPublicKey } from "../models/governance-rules";

/**
 * Verifies an address signature using the HSM public key from the rules container.
 *
 * The signed data is the raw blockchain address string (not hex-encoded).
 *
 * @param address - The blockchain address string
 * @param signatureBase64 - Base64-encoded signature
 * @param rulesContainer - The decoded rules container containing HSM public key
 * @returns true if the signature is valid
 * @throws IntegrityError if HSM public key is not found
 */
export function verifyAddressSignature(
  address: string,
  signatureBase64: string,
  rulesContainer: DecodedRulesContainer
): boolean {
  if (!signatureBase64) {
    return false;
  }

  // Get HSM public key from rules container
  const hsmPublicKeyPem = getHsmPublicKey(rulesContainer);
  if (!hsmPublicKeyPem) {
    throw new IntegrityError("HSM public key not found in rules container");
  }

  let hsmPublicKey: KeyObject;
  try {
    hsmPublicKey = decodePublicKeyPem(hsmPublicKeyPem);
  } catch (error) {
    throw new IntegrityError(`Invalid HSM public key format: ${error}`);
  }

  // Verify signature - signed data is the raw address string
  const addressData = Buffer.from(address, "utf-8");

  try {
    return verifySignature(hsmPublicKey, addressData, signatureBase64);
  } catch (error: unknown) {
    if (error instanceof Error &&
        (error.message.includes('signature') ||
         error.message.includes('key') ||
         error.message.includes('Invalid') ||
         error.message.includes('decode') ||
         error.message.includes('ERR_OSSL'))) {
      return false;
    }
    throw error;
  }
}

/**
 * Verifies multiple address signatures.
 *
 * @param addresses - Array of {address, signature} objects
 * @param rulesContainer - The decoded rules container
 * @returns Array of verification results (true/false for each address)
 */
export function verifyAddressSignatures(
  addresses: Array<{ address: string; signature: string | undefined }>,
  rulesContainer: DecodedRulesContainer
): boolean[] {
  return addresses.map(({ address, signature }) => {
    if (!signature) {
      return false;
    }
    try {
      return verifyAddressSignature(address, signature, rulesContainer);
    } catch (error: unknown) {
      if (error instanceof IntegrityError ||
          (error instanceof Error &&
           (error.message.includes('signature') ||
            error.message.includes('key') ||
            error.message.includes('Invalid') ||
            error.message.includes('decode') ||
            error.message.includes('ERR_OSSL')))) {
        return false;
      }
      throw error;
    }
  });
}
