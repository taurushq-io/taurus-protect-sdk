// Code generated by protoc-gen-go. DO NOT EDIT.
// versions:
// 	protoc-gen-go v1.36.11
// 	protoc        v5.29.3
// source: airgap.proto

package proto

import (
	_ "github.com/grpc-ecosystem/grpc-gateway/v2/protoc-gen-openapiv2/options"
	protoreflect "google.golang.org/protobuf/reflect/protoreflect"
	protoimpl "google.golang.org/protobuf/runtime/protoimpl"
	timestamppb "google.golang.org/protobuf/types/known/timestamppb"
	reflect "reflect"
	sync "sync"
	unsafe "unsafe"
)

const (
	// Verify that this generated code is sufficiently up-to-date.
	_ = protoimpl.EnforceVersion(20 - protoimpl.MinVersion)
	// Verify that runtime/protoimpl is sufficiently up-to-date.
	_ = protoimpl.EnforceVersion(protoimpl.MaxVersion - 20)
)

// OutgoingAirGapFile is the protobuf payload returned by calling the outgoing air-gap endpoint. This will be read by the
// signer CLI to request a signature by the cold HSM.
type OutgoingAirGapFile struct {
	state             protoimpl.MessageState       `protogen:"open.v1"`
	EncryptedPayload  []byte                       `protobuf:"bytes,1,opt,name=encryptedPayload,proto3" json:"encryptedPayload,omitempty"`
	WrappingPublicKey string                       `protobuf:"bytes,2,opt,name=wrappingPublicKey,proto3" json:"wrappingPublicKey,omitempty"`
	Signers           []*OutgoingAirGapFile_Signer `protobuf:"bytes,3,rep,name=signers,proto3" json:"signers,omitempty"`
	unknownFields     protoimpl.UnknownFields
	sizeCache         protoimpl.SizeCache
}

func (x *OutgoingAirGapFile) Reset() {
	*x = OutgoingAirGapFile{}
	mi := &file_airgap_proto_msgTypes[0]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *OutgoingAirGapFile) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*OutgoingAirGapFile) ProtoMessage() {}

func (x *OutgoingAirGapFile) ProtoReflect() protoreflect.Message {
	mi := &file_airgap_proto_msgTypes[0]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use OutgoingAirGapFile.ProtoReflect.Descriptor instead.
func (*OutgoingAirGapFile) Descriptor() ([]byte, []int) {
	return file_airgap_proto_rawDescGZIP(), []int{0}
}

func (x *OutgoingAirGapFile) GetEncryptedPayload() []byte {
	if x != nil {
		return x.EncryptedPayload
	}
	return nil
}

func (x *OutgoingAirGapFile) GetWrappingPublicKey() string {
	if x != nil {
		return x.WrappingPublicKey
	}
	return ""
}

func (x *OutgoingAirGapFile) GetSigners() []*OutgoingAirGapFile_Signer {
	if x != nil {
		return x.Signers
	}
	return nil
}

// IncomingAirGapFile is the protobuf payload created by the signer CLI after getting the different signatures for the
// requests from the cold HSM. This is decrypted by the GUI or the CLI to submit the signatures via the incoming
// endpoint.
type IncomingAirGapFile struct {
	state             protoimpl.MessageState         `protogen:"open.v1"`
	EncryptedPayload  []byte                         `protobuf:"bytes,1,opt,name=encryptedPayload,proto3" json:"encryptedPayload,omitempty"`
	WrappingPublicKey string                         `protobuf:"bytes,2,opt,name=wrappingPublicKey,proto3" json:"wrappingPublicKey,omitempty"`
	Importers         []*IncomingAirGapFile_Importer `protobuf:"bytes,3,rep,name=importers,proto3" json:"importers,omitempty"`
	unknownFields     protoimpl.UnknownFields
	sizeCache         protoimpl.SizeCache
}

func (x *IncomingAirGapFile) Reset() {
	*x = IncomingAirGapFile{}
	mi := &file_airgap_proto_msgTypes[1]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *IncomingAirGapFile) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*IncomingAirGapFile) ProtoMessage() {}

func (x *IncomingAirGapFile) ProtoReflect() protoreflect.Message {
	mi := &file_airgap_proto_msgTypes[1]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use IncomingAirGapFile.ProtoReflect.Descriptor instead.
func (*IncomingAirGapFile) Descriptor() ([]byte, []int) {
	return file_airgap_proto_rawDescGZIP(), []int{1}
}

func (x *IncomingAirGapFile) GetEncryptedPayload() []byte {
	if x != nil {
		return x.EncryptedPayload
	}
	return nil
}

func (x *IncomingAirGapFile) GetWrappingPublicKey() string {
	if x != nil {
		return x.WrappingPublicKey
	}
	return ""
}

func (x *IncomingAirGapFile) GetImporters() []*IncomingAirGapFile_Importer {
	if x != nil {
		return x.Importers
	}
	return nil
}

type AirGapMetadata struct {
	state         protoimpl.MessageState `protogen:"open.v1"`
	Value         []byte                 `protobuf:"bytes,1,opt,name=value,proto3" json:"value,omitempty"`
	Signature     []byte                 `protobuf:"bytes,2,opt,name=signature,proto3" json:"signature,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *AirGapMetadata) Reset() {
	*x = AirGapMetadata{}
	mi := &file_airgap_proto_msgTypes[2]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *AirGapMetadata) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*AirGapMetadata) ProtoMessage() {}

func (x *AirGapMetadata) ProtoReflect() protoreflect.Message {
	mi := &file_airgap_proto_msgTypes[2]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use AirGapMetadata.ProtoReflect.Descriptor instead.
func (*AirGapMetadata) Descriptor() ([]byte, []int) {
	return file_airgap_proto_rawDescGZIP(), []int{2}
}

func (x *AirGapMetadata) GetValue() []byte {
	if x != nil {
		return x.Value
	}
	return nil
}

func (x *AirGapMetadata) GetSignature() []byte {
	if x != nil {
		return x.Signature
	}
	return nil
}

type AirGapSignedEnvelope struct {
	state            protoimpl.MessageState `protogen:"open.v1"`
	Id               string                 `protobuf:"bytes,1,opt,name=id,proto3" json:"id,omitempty"`
	PayloadSignature *UserSignature         `protobuf:"bytes,2,opt,name=payloadSignature,proto3" json:"payloadSignature,omitempty"`
	Payload          []byte                 `protobuf:"bytes,3,opt,name=payload,proto3" json:"payload,omitempty"`
	unknownFields    protoimpl.UnknownFields
	sizeCache        protoimpl.SizeCache
}

func (x *AirGapSignedEnvelope) Reset() {
	*x = AirGapSignedEnvelope{}
	mi := &file_airgap_proto_msgTypes[3]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *AirGapSignedEnvelope) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*AirGapSignedEnvelope) ProtoMessage() {}

func (x *AirGapSignedEnvelope) ProtoReflect() protoreflect.Message {
	mi := &file_airgap_proto_msgTypes[3]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use AirGapSignedEnvelope.ProtoReflect.Descriptor instead.
func (*AirGapSignedEnvelope) Descriptor() ([]byte, []int) {
	return file_airgap_proto_rawDescGZIP(), []int{3}
}

func (x *AirGapSignedEnvelope) GetId() string {
	if x != nil {
		return x.Id
	}
	return ""
}

func (x *AirGapSignedEnvelope) GetPayloadSignature() *UserSignature {
	if x != nil {
		return x.PayloadSignature
	}
	return nil
}

func (x *AirGapSignedEnvelope) GetPayload() []byte {
	if x != nil {
		return x.Payload
	}
	return nil
}

type AirGapTrail struct {
	state         protoimpl.MessageState `protogen:"open.v1"`
	ExternalId    string                 `protobuf:"bytes,1,opt,name=externalId,proto3" json:"externalId,omitempty"`
	CreatedAt     *timestamppb.Timestamp `protobuf:"bytes,2,opt,name=createdAt,proto3" json:"createdAt,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *AirGapTrail) Reset() {
	*x = AirGapTrail{}
	mi := &file_airgap_proto_msgTypes[4]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *AirGapTrail) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*AirGapTrail) ProtoMessage() {}

func (x *AirGapTrail) ProtoReflect() protoreflect.Message {
	mi := &file_airgap_proto_msgTypes[4]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use AirGapTrail.ProtoReflect.Descriptor instead.
func (*AirGapTrail) Descriptor() ([]byte, []int) {
	return file_airgap_proto_rawDescGZIP(), []int{4}
}

func (x *AirGapTrail) GetExternalId() string {
	if x != nil {
		return x.ExternalId
	}
	return ""
}

func (x *AirGapTrail) GetCreatedAt() *timestamppb.Timestamp {
	if x != nil {
		return x.CreatedAt
	}
	return nil
}

type OutgoingAirGapFile_Payload struct {
	state         protoimpl.MessageState `protogen:"open.v1"`
	Metadata      *AirGapMetadata        `protobuf:"bytes,1,opt,name=metadata,proto3" json:"metadata,omitempty"`
	Envelope      *AirGapSignedEnvelope  `protobuf:"bytes,2,opt,name=envelope,proto3" json:"envelope,omitempty"`
	Signature     *UserSignature         `protobuf:"bytes,3,opt,name=signature,proto3" json:"signature,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *OutgoingAirGapFile_Payload) Reset() {
	*x = OutgoingAirGapFile_Payload{}
	mi := &file_airgap_proto_msgTypes[5]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *OutgoingAirGapFile_Payload) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*OutgoingAirGapFile_Payload) ProtoMessage() {}

func (x *OutgoingAirGapFile_Payload) ProtoReflect() protoreflect.Message {
	mi := &file_airgap_proto_msgTypes[5]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use OutgoingAirGapFile_Payload.ProtoReflect.Descriptor instead.
func (*OutgoingAirGapFile_Payload) Descriptor() ([]byte, []int) {
	return file_airgap_proto_rawDescGZIP(), []int{0, 0}
}

func (x *OutgoingAirGapFile_Payload) GetMetadata() *AirGapMetadata {
	if x != nil {
		return x.Metadata
	}
	return nil
}

func (x *OutgoingAirGapFile_Payload) GetEnvelope() *AirGapSignedEnvelope {
	if x != nil {
		return x.Envelope
	}
	return nil
}

func (x *OutgoingAirGapFile_Payload) GetSignature() *UserSignature {
	if x != nil {
		return x.Signature
	}
	return nil
}

type OutgoingAirGapFile_Signer struct {
	state              protoimpl.MessageState `protogen:"open.v1"`
	ExternalId         string                 `protobuf:"bytes,1,opt,name=externalId,proto3" json:"externalId,omitempty"`
	EncryptedSharedKey []byte                 `protobuf:"bytes,2,opt,name=encryptedSharedKey,proto3" json:"encryptedSharedKey,omitempty"`
	unknownFields      protoimpl.UnknownFields
	sizeCache          protoimpl.SizeCache
}

func (x *OutgoingAirGapFile_Signer) Reset() {
	*x = OutgoingAirGapFile_Signer{}
	mi := &file_airgap_proto_msgTypes[6]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *OutgoingAirGapFile_Signer) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*OutgoingAirGapFile_Signer) ProtoMessage() {}

func (x *OutgoingAirGapFile_Signer) ProtoReflect() protoreflect.Message {
	mi := &file_airgap_proto_msgTypes[6]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use OutgoingAirGapFile_Signer.ProtoReflect.Descriptor instead.
func (*OutgoingAirGapFile_Signer) Descriptor() ([]byte, []int) {
	return file_airgap_proto_rawDescGZIP(), []int{0, 1}
}

func (x *OutgoingAirGapFile_Signer) GetExternalId() string {
	if x != nil {
		return x.ExternalId
	}
	return ""
}

func (x *OutgoingAirGapFile_Signer) GetEncryptedSharedKey() []byte {
	if x != nil {
		return x.EncryptedSharedKey
	}
	return nil
}

type IncomingAirGapFile_Importer struct {
	state              protoimpl.MessageState `protogen:"open.v1"`
	ExternalId         string                 `protobuf:"bytes,1,opt,name=externalId,proto3" json:"externalId,omitempty"`
	EncryptedSharedKey []byte                 `protobuf:"bytes,2,opt,name=encryptedSharedKey,proto3" json:"encryptedSharedKey,omitempty"`
	unknownFields      protoimpl.UnknownFields
	sizeCache          protoimpl.SizeCache
}

func (x *IncomingAirGapFile_Importer) Reset() {
	*x = IncomingAirGapFile_Importer{}
	mi := &file_airgap_proto_msgTypes[7]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *IncomingAirGapFile_Importer) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*IncomingAirGapFile_Importer) ProtoMessage() {}

func (x *IncomingAirGapFile_Importer) ProtoReflect() protoreflect.Message {
	mi := &file_airgap_proto_msgTypes[7]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use IncomingAirGapFile_Importer.ProtoReflect.Descriptor instead.
func (*IncomingAirGapFile_Importer) Descriptor() ([]byte, []int) {
	return file_airgap_proto_rawDescGZIP(), []int{1, 0}
}

func (x *IncomingAirGapFile_Importer) GetExternalId() string {
	if x != nil {
		return x.ExternalId
	}
	return ""
}

func (x *IncomingAirGapFile_Importer) GetEncryptedSharedKey() []byte {
	if x != nil {
		return x.EncryptedSharedKey
	}
	return nil
}

type IncomingAirGapFile_Payload struct {
	state            protoimpl.MessageState `protogen:"open.v1"`
	Metadata         *AirGapMetadata        `protobuf:"bytes,1,opt,name=metadata,proto3" json:"metadata,omitempty"`
	SignedRequests   *SignedRepliesEnvelope `protobuf:"bytes,2,opt,name=signedRequests,proto3" json:"signedRequests,omitempty"`
	RejectedRequests []*RequestEnvelope     `protobuf:"bytes,3,rep,name=rejectedRequests,proto3" json:"rejectedRequests,omitempty"`
	SignerTrail      *AirGapTrail           `protobuf:"bytes,4,opt,name=signerTrail,proto3" json:"signerTrail,omitempty"`
	unknownFields    protoimpl.UnknownFields
	sizeCache        protoimpl.SizeCache
}

func (x *IncomingAirGapFile_Payload) Reset() {
	*x = IncomingAirGapFile_Payload{}
	mi := &file_airgap_proto_msgTypes[8]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *IncomingAirGapFile_Payload) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*IncomingAirGapFile_Payload) ProtoMessage() {}

func (x *IncomingAirGapFile_Payload) ProtoReflect() protoreflect.Message {
	mi := &file_airgap_proto_msgTypes[8]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use IncomingAirGapFile_Payload.ProtoReflect.Descriptor instead.
func (*IncomingAirGapFile_Payload) Descriptor() ([]byte, []int) {
	return file_airgap_proto_rawDescGZIP(), []int{1, 1}
}

func (x *IncomingAirGapFile_Payload) GetMetadata() *AirGapMetadata {
	if x != nil {
		return x.Metadata
	}
	return nil
}

func (x *IncomingAirGapFile_Payload) GetSignedRequests() *SignedRepliesEnvelope {
	if x != nil {
		return x.SignedRequests
	}
	return nil
}

func (x *IncomingAirGapFile_Payload) GetRejectedRequests() []*RequestEnvelope {
	if x != nil {
		return x.RejectedRequests
	}
	return nil
}

func (x *IncomingAirGapFile_Payload) GetSignerTrail() *AirGapTrail {
	if x != nil {
		return x.SignerTrail
	}
	return nil
}

type IncomingAirGapFile_SignedPayload struct {
	state         protoimpl.MessageState `protogen:"open.v1"`
	Payload       []byte                 `protobuf:"bytes,1,opt,name=payload,proto3" json:"payload,omitempty"`
	Signature     *UserSignature         `protobuf:"bytes,2,opt,name=signature,proto3" json:"signature,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *IncomingAirGapFile_SignedPayload) Reset() {
	*x = IncomingAirGapFile_SignedPayload{}
	mi := &file_airgap_proto_msgTypes[9]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *IncomingAirGapFile_SignedPayload) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*IncomingAirGapFile_SignedPayload) ProtoMessage() {}

func (x *IncomingAirGapFile_SignedPayload) ProtoReflect() protoreflect.Message {
	mi := &file_airgap_proto_msgTypes[9]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use IncomingAirGapFile_SignedPayload.ProtoReflect.Descriptor instead.
func (*IncomingAirGapFile_SignedPayload) Descriptor() ([]byte, []int) {
	return file_airgap_proto_rawDescGZIP(), []int{1, 2}
}

func (x *IncomingAirGapFile_SignedPayload) GetPayload() []byte {
	if x != nil {
		return x.Payload
	}
	return nil
}

func (x *IncomingAirGapFile_SignedPayload) GetSignature() *UserSignature {
	if x != nil {
		return x.Signature
	}
	return nil
}

type AirGapMetadata_Value struct {
	state         protoimpl.MessageState    `protogen:"open.v1"`
	Addresses     []*AirGapMetadata_Address `protobuf:"bytes,1,rep,name=addresses,proto3" json:"addresses,omitempty"`
	ExporterTrail *AirGapTrail              `protobuf:"bytes,2,opt,name=exporterTrail,proto3" json:"exporterTrail,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *AirGapMetadata_Value) Reset() {
	*x = AirGapMetadata_Value{}
	mi := &file_airgap_proto_msgTypes[10]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *AirGapMetadata_Value) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*AirGapMetadata_Value) ProtoMessage() {}

func (x *AirGapMetadata_Value) ProtoReflect() protoreflect.Message {
	mi := &file_airgap_proto_msgTypes[10]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use AirGapMetadata_Value.ProtoReflect.Descriptor instead.
func (*AirGapMetadata_Value) Descriptor() ([]byte, []int) {
	return file_airgap_proto_rawDescGZIP(), []int{2, 0}
}

func (x *AirGapMetadata_Value) GetAddresses() []*AirGapMetadata_Address {
	if x != nil {
		return x.Addresses
	}
	return nil
}

func (x *AirGapMetadata_Value) GetExporterTrail() *AirGapTrail {
	if x != nil {
		return x.ExporterTrail
	}
	return nil
}

type AirGapMetadata_Address struct {
	state         protoimpl.MessageState `protogen:"open.v1"`
	Id            uint64                 `protobuf:"varint,1,opt,name=id,proto3" json:"id,omitempty"`
	RequestId     string                 `protobuf:"bytes,2,opt,name=requestId,proto3" json:"requestId,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *AirGapMetadata_Address) Reset() {
	*x = AirGapMetadata_Address{}
	mi := &file_airgap_proto_msgTypes[11]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *AirGapMetadata_Address) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*AirGapMetadata_Address) ProtoMessage() {}

func (x *AirGapMetadata_Address) ProtoReflect() protoreflect.Message {
	mi := &file_airgap_proto_msgTypes[11]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use AirGapMetadata_Address.ProtoReflect.Descriptor instead.
func (*AirGapMetadata_Address) Descriptor() ([]byte, []int) {
	return file_airgap_proto_rawDescGZIP(), []int{2, 1}
}

func (x *AirGapMetadata_Address) GetId() uint64 {
	if x != nil {
		return x.Id
	}
	return 0
}

func (x *AirGapMetadata_Address) GetRequestId() string {
	if x != nil {
		return x.RequestId
	}
	return ""
}

type AirGapSignedEnvelope_Requests struct {
	state           protoimpl.MessageState          `protogen:"open.v1"`
	Ts              uint64                          `protobuf:"varint,1,opt,name=ts,proto3" json:"ts,omitempty"`
	Slot            uint32                          `protobuf:"varint,2,opt,name=slot,proto3" json:"slot,omitempty"`
	RulesSignatures []*UserSignature                `protobuf:"bytes,3,rep,name=rulesSignatures,proto3" json:"rulesSignatures,omitempty"`
	Rules           []byte                          `protobuf:"bytes,4,opt,name=rules,proto3" json:"rules,omitempty"`
	Requests        []*AirGapSignedEnvelope_Request `protobuf:"bytes,5,rep,name=requests,proto3" json:"requests,omitempty"`
	unknownFields   protoimpl.UnknownFields
	sizeCache       protoimpl.SizeCache
}

func (x *AirGapSignedEnvelope_Requests) Reset() {
	*x = AirGapSignedEnvelope_Requests{}
	mi := &file_airgap_proto_msgTypes[12]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *AirGapSignedEnvelope_Requests) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*AirGapSignedEnvelope_Requests) ProtoMessage() {}

func (x *AirGapSignedEnvelope_Requests) ProtoReflect() protoreflect.Message {
	mi := &file_airgap_proto_msgTypes[12]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use AirGapSignedEnvelope_Requests.ProtoReflect.Descriptor instead.
func (*AirGapSignedEnvelope_Requests) Descriptor() ([]byte, []int) {
	return file_airgap_proto_rawDescGZIP(), []int{3, 0}
}

func (x *AirGapSignedEnvelope_Requests) GetTs() uint64 {
	if x != nil {
		return x.Ts
	}
	return 0
}

func (x *AirGapSignedEnvelope_Requests) GetSlot() uint32 {
	if x != nil {
		return x.Slot
	}
	return 0
}

func (x *AirGapSignedEnvelope_Requests) GetRulesSignatures() []*UserSignature {
	if x != nil {
		return x.RulesSignatures
	}
	return nil
}

func (x *AirGapSignedEnvelope_Requests) GetRules() []byte {
	if x != nil {
		return x.Rules
	}
	return nil
}

func (x *AirGapSignedEnvelope_Requests) GetRequests() []*AirGapSignedEnvelope_Request {
	if x != nil {
		return x.Requests
	}
	return nil
}

type AirGapSignedEnvelope_Request struct {
	state         protoimpl.MessageState `protogen:"open.v1"`
	Envelope      *RequestEnvelope       `protobuf:"bytes,1,opt,name=envelope,proto3" json:"envelope,omitempty"`
	Cancellations []*RequestEnvelope     `protobuf:"bytes,2,rep,name=cancellations,proto3" json:"cancellations,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *AirGapSignedEnvelope_Request) Reset() {
	*x = AirGapSignedEnvelope_Request{}
	mi := &file_airgap_proto_msgTypes[13]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *AirGapSignedEnvelope_Request) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*AirGapSignedEnvelope_Request) ProtoMessage() {}

func (x *AirGapSignedEnvelope_Request) ProtoReflect() protoreflect.Message {
	mi := &file_airgap_proto_msgTypes[13]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use AirGapSignedEnvelope_Request.ProtoReflect.Descriptor instead.
func (*AirGapSignedEnvelope_Request) Descriptor() ([]byte, []int) {
	return file_airgap_proto_rawDescGZIP(), []int{3, 1}
}

func (x *AirGapSignedEnvelope_Request) GetEnvelope() *RequestEnvelope {
	if x != nil {
		return x.Envelope
	}
	return nil
}

func (x *AirGapSignedEnvelope_Request) GetCancellations() []*RequestEnvelope {
	if x != nil {
		return x.Cancellations
	}
	return nil
}

var File_airgap_proto protoreflect.FileDescriptor

const file_airgap_proto_rawDesc = "" +
	"\n" +
	"\fairgap.proto\x12\ftgvalidatord\x1a.protoc-gen-openapiv2/options/annotations.proto\x1a\x1fgoogle/protobuf/timestamp.proto\x1a\x13request_reply.proto\"\x9b\b\n" +
	"\x12OutgoingAirGapFile\x12x\n" +
	"\x10encryptedPayload\x18\x01 \x01(\fBL\x92AI2Gthe encrypted payload by the shared key for signatures by the cold HSM.R\x10encryptedPayload\x12\x88\x01\n" +
	"\x11wrappingPublicKey\x18\x02 \x01(\tBZ\x92AW2UPKIX; the public key to be used to derive the shared key with the signer private key.R\x11wrappingPublicKey\x12\x80\x01\n" +
	"\asigners\x18\x03 \x03(\v2'.tgvalidatord.OutgoingAirGapFile.SignerB=\x92A:28The list of air-gap signer that can decrypt the payload.R\asigners\x1a\x8e\x03\n" +
	"\aPayload\x12\x80\x01\n" +
	"\bmetadata\x18\x01 \x01(\v2\x1c.tgvalidatord.AirGapMetadataBF\x92AC2AMetadata that will be transmitted when submitting signed request.R\bmetadata\x12\x87\x01\n" +
	"\benvelope\x18\x02 \x01(\v2\".tgvalidatord.AirGapSignedEnvelopeBG\x92AD2BThe envelope containing the requests to be signed by the cold HSM.R\benvelope\x12v\n" +
	"\tsignature\x18\x03 \x01(\v2\x1b.tgvalidatord.UserSignatureB;\x92A826The signature of the payload from an air-gap exporter.R\tsignature\x1a\xeb\x01\n" +
	"\x06Signer\x12e\n" +
	"\n" +
	"externalId\x18\x01 \x01(\tBE\x92AB2@The user external id that corresponds to the wrapped shared key.R\n" +
	"externalId\x12z\n" +
	"\x12encryptedSharedKey\x18\x02 \x01(\fBJ\x92AG2EThe air-gap signer can decrypt the shared key from their private key.R\x12encryptedSharedKey\"\xe9\n" +
	"\n" +
	"\x12IncomingAirGapFile\x12o\n" +
	"\x10encryptedPayload\x18\x01 \x01(\fBC\x92A@2>Encrypted payload of type <*IncomingAirGapFile_SignedPayload>.R\x10encryptedPayload\x12\x88\x01\n" +
	"\x11wrappingPublicKey\x18\x02 \x01(\tBZ\x92AW2UPKIX; the public key to be used to derive the shared key with the signer private key.R\x11wrappingPublicKey\x12\x89\x01\n" +
	"\timporters\x18\x03 \x03(\v2).tgvalidatord.IncomingAirGapFile.ImporterB@\x92A=2;The list of air-gap importers that can decrypt the payload.R\timporters\x1a\xef\x01\n" +
	"\bImporter\x12e\n" +
	"\n" +
	"externalId\x18\x01 \x01(\tBE\x92AB2@The user external id that corresponds to the wrapped shared key.R\n" +
	"externalId\x12|\n" +
	"\x12encryptedSharedKey\x18\x02 \x01(\fBL\x92AI2GThe air-gap importer can decrypt the shared key from their private key.R\x12encryptedSharedKey\x1a\x81\x04\n" +
	"\aPayload\x12m\n" +
	"\bmetadata\x18\x01 \x01(\v2\x1c.tgvalidatord.AirGapMetadataB3\x92A02.Metadata returned during the outgoing request.R\bmetadata\x12\xb1\x01\n" +
	"\x0esignedRequests\x18\x02 \x01(\v2#.tgvalidatord.SignedRepliesEnvelopeBd\x92Aa2_Envelope holding the requests signed by the cold HSM, either accepted or cancellation requests.R\x0esignedRequests\x12\x95\x01\n" +
	"\x10rejectedRequests\x18\x03 \x03(\v2\x1d.tgvalidatord.RequestEnvelopeBJ\x92AG2EA list of the requests that have been rejected by the air-gap signer.R\x10rejectedRequests\x12;\n" +
	"\vsignerTrail\x18\x04 \x01(\v2\x19.tgvalidatord.AirGapTrailR\vsignerTrail\x1a\xd4\x01\n" +
	"\rSignedPayload\x12M\n" +
	"\apayload\x18\x01 \x01(\fB3\x92A02.Payload of type <*IncomingAirGapFile_Payload>.R\apayload\x12t\n" +
	"\tsignature\x18\x02 \x01(\v2\x1b.tgvalidatord.UserSignatureB9\x92A624The signature of the payload from an air-gap signer.R\tsignature\"\xf3\x02\n" +
	"\x0eAirGapMetadata\x12A\n" +
	"\x05value\x18\x01 \x01(\fB+\x92A(2&Value of type <*AirGapMetadata_Value>.R\x05value\x12V\n" +
	"\tsignature\x18\x02 \x01(\fB8\x92A523The signature of the value from the Protect daemon.R\tsignature\x1a\x8c\x01\n" +
	"\x05Value\x12B\n" +
	"\taddresses\x18\x01 \x03(\v2$.tgvalidatord.AirGapMetadata.AddressR\taddresses\x12?\n" +
	"\rexporterTrail\x18\x02 \x01(\v2\x19.tgvalidatord.AirGapTrailR\rexporterTrail\x1a7\n" +
	"\aAddress\x12\x0e\n" +
	"\x02id\x18\x01 \x01(\x04R\x02id\x12\x1c\n" +
	"\trequestId\x18\x02 \x01(\tR\trequestId\"\x9c\x05\n" +
	"\x14AirGapSignedEnvelope\x12B\n" +
	"\x02id\x18\x01 \x01(\tB2\x92A/2-<uuid>; a unique identifier for the envelope.R\x02id\x12\x81\x01\n" +
	"\x10payloadSignature\x18\x02 \x01(\v2\x1b.tgvalidatord.UserSignatureB8\x92A523The signature of the value from the Protect daemon.R\x10payloadSignature\x12Z\n" +
	"\apayload\x18\x03 \x01(\fB@\x92A=2;Encrypted payload of type <*AirGapSignedEnvelope_Requests>.R\apayload\x1a\xd3\x01\n" +
	"\bRequests\x12\x0e\n" +
	"\x02ts\x18\x01 \x01(\x04R\x02ts\x12\x12\n" +
	"\x04slot\x18\x02 \x01(\rR\x04slot\x12E\n" +
	"\x0frulesSignatures\x18\x03 \x03(\v2\x1b.tgvalidatord.UserSignatureR\x0frulesSignatures\x12\x14\n" +
	"\x05rules\x18\x04 \x01(\fR\x05rules\x12F\n" +
	"\brequests\x18\x05 \x03(\v2*.tgvalidatord.AirGapSignedEnvelope.RequestR\brequests\x1a\x89\x01\n" +
	"\aRequest\x129\n" +
	"\benvelope\x18\x01 \x01(\v2\x1d.tgvalidatord.RequestEnvelopeR\benvelope\x12C\n" +
	"\rcancellations\x18\x02 \x03(\v2\x1d.tgvalidatord.RequestEnvelopeR\rcancellations\"g\n" +
	"\vAirGapTrail\x12\x1e\n" +
	"\n" +
	"externalId\x18\x01 \x01(\tR\n" +
	"externalId\x128\n" +
	"\tcreatedAt\x18\x02 \x01(\v2\x1a.google.protobuf.TimestampR\tcreatedAtB#\n" +
	"!com.taurushq.sdk.protect.proto.v1b\x06proto3"

var (
	file_airgap_proto_rawDescOnce sync.Once
	file_airgap_proto_rawDescData []byte
)

func file_airgap_proto_rawDescGZIP() []byte {
	file_airgap_proto_rawDescOnce.Do(func() {
		file_airgap_proto_rawDescData = protoimpl.X.CompressGZIP(unsafe.Slice(unsafe.StringData(file_airgap_proto_rawDesc), len(file_airgap_proto_rawDesc)))
	})
	return file_airgap_proto_rawDescData
}

var file_airgap_proto_msgTypes = make([]protoimpl.MessageInfo, 14)
var file_airgap_proto_goTypes = []any{
	(*OutgoingAirGapFile)(nil),               // 0: tgvalidatord.OutgoingAirGapFile
	(*IncomingAirGapFile)(nil),               // 1: tgvalidatord.IncomingAirGapFile
	(*AirGapMetadata)(nil),                   // 2: tgvalidatord.AirGapMetadata
	(*AirGapSignedEnvelope)(nil),             // 3: tgvalidatord.AirGapSignedEnvelope
	(*AirGapTrail)(nil),                      // 4: tgvalidatord.AirGapTrail
	(*OutgoingAirGapFile_Payload)(nil),       // 5: tgvalidatord.OutgoingAirGapFile.Payload
	(*OutgoingAirGapFile_Signer)(nil),        // 6: tgvalidatord.OutgoingAirGapFile.Signer
	(*IncomingAirGapFile_Importer)(nil),      // 7: tgvalidatord.IncomingAirGapFile.Importer
	(*IncomingAirGapFile_Payload)(nil),       // 8: tgvalidatord.IncomingAirGapFile.Payload
	(*IncomingAirGapFile_SignedPayload)(nil), // 9: tgvalidatord.IncomingAirGapFile.SignedPayload
	(*AirGapMetadata_Value)(nil),             // 10: tgvalidatord.AirGapMetadata.Value
	(*AirGapMetadata_Address)(nil),           // 11: tgvalidatord.AirGapMetadata.Address
	(*AirGapSignedEnvelope_Requests)(nil),    // 12: tgvalidatord.AirGapSignedEnvelope.Requests
	(*AirGapSignedEnvelope_Request)(nil),     // 13: tgvalidatord.AirGapSignedEnvelope.Request
	(*UserSignature)(nil),                    // 14: tgvalidatord.UserSignature
	(*timestamppb.Timestamp)(nil),            // 15: google.protobuf.Timestamp
	(*SignedRepliesEnvelope)(nil),            // 16: tgvalidatord.SignedRepliesEnvelope
	(*RequestEnvelope)(nil),                  // 17: tgvalidatord.RequestEnvelope
}
var file_airgap_proto_depIdxs = []int32{
	6,  // 0: tgvalidatord.OutgoingAirGapFile.signers:type_name -> tgvalidatord.OutgoingAirGapFile.Signer
	7,  // 1: tgvalidatord.IncomingAirGapFile.importers:type_name -> tgvalidatord.IncomingAirGapFile.Importer
	14, // 2: tgvalidatord.AirGapSignedEnvelope.payloadSignature:type_name -> tgvalidatord.UserSignature
	15, // 3: tgvalidatord.AirGapTrail.createdAt:type_name -> google.protobuf.Timestamp
	2,  // 4: tgvalidatord.OutgoingAirGapFile.Payload.metadata:type_name -> tgvalidatord.AirGapMetadata
	3,  // 5: tgvalidatord.OutgoingAirGapFile.Payload.envelope:type_name -> tgvalidatord.AirGapSignedEnvelope
	14, // 6: tgvalidatord.OutgoingAirGapFile.Payload.signature:type_name -> tgvalidatord.UserSignature
	2,  // 7: tgvalidatord.IncomingAirGapFile.Payload.metadata:type_name -> tgvalidatord.AirGapMetadata
	16, // 8: tgvalidatord.IncomingAirGapFile.Payload.signedRequests:type_name -> tgvalidatord.SignedRepliesEnvelope
	17, // 9: tgvalidatord.IncomingAirGapFile.Payload.rejectedRequests:type_name -> tgvalidatord.RequestEnvelope
	4,  // 10: tgvalidatord.IncomingAirGapFile.Payload.signerTrail:type_name -> tgvalidatord.AirGapTrail
	14, // 11: tgvalidatord.IncomingAirGapFile.SignedPayload.signature:type_name -> tgvalidatord.UserSignature
	11, // 12: tgvalidatord.AirGapMetadata.Value.addresses:type_name -> tgvalidatord.AirGapMetadata.Address
	4,  // 13: tgvalidatord.AirGapMetadata.Value.exporterTrail:type_name -> tgvalidatord.AirGapTrail
	14, // 14: tgvalidatord.AirGapSignedEnvelope.Requests.rulesSignatures:type_name -> tgvalidatord.UserSignature
	13, // 15: tgvalidatord.AirGapSignedEnvelope.Requests.requests:type_name -> tgvalidatord.AirGapSignedEnvelope.Request
	17, // 16: tgvalidatord.AirGapSignedEnvelope.Request.envelope:type_name -> tgvalidatord.RequestEnvelope
	17, // 17: tgvalidatord.AirGapSignedEnvelope.Request.cancellations:type_name -> tgvalidatord.RequestEnvelope
	18, // [18:18] is the sub-list for method output_type
	18, // [18:18] is the sub-list for method input_type
	18, // [18:18] is the sub-list for extension type_name
	18, // [18:18] is the sub-list for extension extendee
	0,  // [0:18] is the sub-list for field type_name
}

func init() { file_airgap_proto_init() }
func file_airgap_proto_init() {
	if File_airgap_proto != nil {
		return
	}
	file_request_reply_proto_init()
	type x struct{}
	out := protoimpl.TypeBuilder{
		File: protoimpl.DescBuilder{
			GoPackagePath: reflect.TypeOf(x{}).PkgPath(),
			RawDescriptor: unsafe.Slice(unsafe.StringData(file_airgap_proto_rawDesc), len(file_airgap_proto_rawDesc)),
			NumEnums:      0,
			NumMessages:   14,
			NumExtensions: 0,
			NumServices:   0,
		},
		GoTypes:           file_airgap_proto_goTypes,
		DependencyIndexes: file_airgap_proto_depIdxs,
		MessageInfos:      file_airgap_proto_msgTypes,
	}.Build()
	File_airgap_proto = out.File
	file_airgap_proto_goTypes = nil
	file_airgap_proto_depIdxs = nil
}
