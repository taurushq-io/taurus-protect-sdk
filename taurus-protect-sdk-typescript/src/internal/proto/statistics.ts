// Code generated by protoc-gen-ts_proto. DO NOT EDIT.
// versions:
//   protoc-gen-ts_proto  v1.181.2
//   protoc               v6.33.4
// source: statistics.proto

/* eslint-disable */
import Long from "long";
import _m0 from "protobufjs/minimal";
import { Currency } from "./currency";
import { Timestamp } from "./google/protobuf/timestamp";
import { Tag } from "./tag";

export const protobufPackage = "tgvalidatord";

export interface CurrencyStatistics {
  symbol: string;
  blockchain: string;
  avgBalancePerAddress: string;
  addressesCount: number;
  walletsCount: number;
  totalBalance: string;
  baseCurrencyTotalValue: string;
  baseCurrencyTotalValueMainUnit: string;
  currencyInfo: Currency | undefined;
}

export interface CurrencyStatisticsHistory {
  symbol: string;
  blockchain: string;
  history: AggregatedStatsHistoryPoint[];
  currencyInfo: Currency | undefined;
}

export interface AggregatedStatsHistoryPoint {
  pointDate: Date | undefined;
  statsData: AggregatedStatsData | undefined;
}

export interface AggregatedStatsData {
  avgBalancePerAddress: string;
  addressesCount: number;
  walletsCount: number;
  totalBalance: string;
  totalBalanceBaseCurrency: string;
}

export interface TnPledgeStatisticsTnParticipant {
  counterpartyTnParticipantID: string;
  /** total in base currency in main unit (ex. CHF) of all outgoing pledges to THIS counterparty participant for all currencies */
  outgoingPledgesTotalValuationBaseCurrency: string;
  /** total in base currency in main unit (ex. CHF) of all incoming pledges from THIS counterparty participant for all currencies */
  incomingPledgesTotalValuationBaseCurrency: string;
  pledgeStatisticsCurrencies: TnPledgeStatisticsCurrency[];
}

export interface TnPledgeStatisticsCurrency {
  currencyID: string;
  /** total in currency unit of all outgoing pledges to THIS counterparty participant for THIS currency */
  outgoingPledgesAmount: string;
  /** total in base currency in main unit (ex. CHF) of all outgoing pledges to THIS counterparty participant for THIS currency */
  outgoingPledgesValuationBaseCurrency: string;
  /** total in currency unit of all incoming pledges from THIS counterparty participant for THIS currency */
  incomingPledgesAmount: string;
  /** total in base currency in main unit (ex. CHF) of all incoming pledges from THIS counterparty participant for THIS currency */
  incomingPledgesValuationBaseCurrency: string;
}

export interface TagStatistics {
  tagID: string;
  totalValuation: string;
  tag: Tag | undefined;
}

export interface TagAssetStatistics {
  tagID: string;
  currencyID: string;
  totalBalance: string;
  totalBalanceValuation: string;
  creationDate: Date | undefined;
  currencyInfo: Currency | undefined;
}

function createBaseCurrencyStatistics(): CurrencyStatistics {
  return {
    symbol: "",
    blockchain: "",
    avgBalancePerAddress: "",
    addressesCount: 0,
    walletsCount: 0,
    totalBalance: "",
    baseCurrencyTotalValue: "",
    baseCurrencyTotalValueMainUnit: "",
    currencyInfo: undefined,
  };
}

export const CurrencyStatistics = {
  encode(message: CurrencyStatistics, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.symbol !== "") {
      writer.uint32(10).string(message.symbol);
    }
    if (message.blockchain !== "") {
      writer.uint32(18).string(message.blockchain);
    }
    if (message.avgBalancePerAddress !== "") {
      writer.uint32(26).string(message.avgBalancePerAddress);
    }
    if (message.addressesCount !== 0) {
      writer.uint32(32).uint64(message.addressesCount);
    }
    if (message.walletsCount !== 0) {
      writer.uint32(40).uint64(message.walletsCount);
    }
    if (message.totalBalance !== "") {
      writer.uint32(50).string(message.totalBalance);
    }
    if (message.baseCurrencyTotalValue !== "") {
      writer.uint32(58).string(message.baseCurrencyTotalValue);
    }
    if (message.baseCurrencyTotalValueMainUnit !== "") {
      writer.uint32(66).string(message.baseCurrencyTotalValueMainUnit);
    }
    if (message.currencyInfo !== undefined) {
      Currency.encode(message.currencyInfo, writer.uint32(74).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CurrencyStatistics {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCurrencyStatistics();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.symbol = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.blockchain = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.avgBalancePerAddress = reader.string();
          continue;
        case 4:
          if (tag !== 32) {
            break;
          }

          message.addressesCount = longToNumber(reader.uint64() as Long);
          continue;
        case 5:
          if (tag !== 40) {
            break;
          }

          message.walletsCount = longToNumber(reader.uint64() as Long);
          continue;
        case 6:
          if (tag !== 50) {
            break;
          }

          message.totalBalance = reader.string();
          continue;
        case 7:
          if (tag !== 58) {
            break;
          }

          message.baseCurrencyTotalValue = reader.string();
          continue;
        case 8:
          if (tag !== 66) {
            break;
          }

          message.baseCurrencyTotalValueMainUnit = reader.string();
          continue;
        case 9:
          if (tag !== 74) {
            break;
          }

          message.currencyInfo = Currency.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CurrencyStatistics {
    return {
      symbol: isSet(object.symbol) ? globalThis.String(object.symbol) : "",
      blockchain: isSet(object.blockchain) ? globalThis.String(object.blockchain) : "",
      avgBalancePerAddress: isSet(object.avgBalancePerAddress) ? globalThis.String(object.avgBalancePerAddress) : "",
      addressesCount: isSet(object.addressesCount) ? globalThis.Number(object.addressesCount) : 0,
      walletsCount: isSet(object.walletsCount) ? globalThis.Number(object.walletsCount) : 0,
      totalBalance: isSet(object.totalBalance) ? globalThis.String(object.totalBalance) : "",
      baseCurrencyTotalValue: isSet(object.baseCurrencyTotalValue)
        ? globalThis.String(object.baseCurrencyTotalValue)
        : "",
      baseCurrencyTotalValueMainUnit: isSet(object.baseCurrencyTotalValueMainUnit)
        ? globalThis.String(object.baseCurrencyTotalValueMainUnit)
        : "",
      currencyInfo: isSet(object.currencyInfo) ? Currency.fromJSON(object.currencyInfo) : undefined,
    };
  },

  toJSON(message: CurrencyStatistics): unknown {
    const obj: any = {};
    if (message.symbol !== "") {
      obj.symbol = message.symbol;
    }
    if (message.blockchain !== "") {
      obj.blockchain = message.blockchain;
    }
    if (message.avgBalancePerAddress !== "") {
      obj.avgBalancePerAddress = message.avgBalancePerAddress;
    }
    if (message.addressesCount !== 0) {
      obj.addressesCount = Math.round(message.addressesCount);
    }
    if (message.walletsCount !== 0) {
      obj.walletsCount = Math.round(message.walletsCount);
    }
    if (message.totalBalance !== "") {
      obj.totalBalance = message.totalBalance;
    }
    if (message.baseCurrencyTotalValue !== "") {
      obj.baseCurrencyTotalValue = message.baseCurrencyTotalValue;
    }
    if (message.baseCurrencyTotalValueMainUnit !== "") {
      obj.baseCurrencyTotalValueMainUnit = message.baseCurrencyTotalValueMainUnit;
    }
    if (message.currencyInfo !== undefined) {
      obj.currencyInfo = Currency.toJSON(message.currencyInfo);
    }
    return obj;
  },

  create(base?: DeepPartial<CurrencyStatistics>): CurrencyStatistics {
    return CurrencyStatistics.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CurrencyStatistics>): CurrencyStatistics {
    const message = createBaseCurrencyStatistics();
    message.symbol = object.symbol ?? "";
    message.blockchain = object.blockchain ?? "";
    message.avgBalancePerAddress = object.avgBalancePerAddress ?? "";
    message.addressesCount = object.addressesCount ?? 0;
    message.walletsCount = object.walletsCount ?? 0;
    message.totalBalance = object.totalBalance ?? "";
    message.baseCurrencyTotalValue = object.baseCurrencyTotalValue ?? "";
    message.baseCurrencyTotalValueMainUnit = object.baseCurrencyTotalValueMainUnit ?? "";
    message.currencyInfo = (object.currencyInfo !== undefined && object.currencyInfo !== null)
      ? Currency.fromPartial(object.currencyInfo)
      : undefined;
    return message;
  },
};

function createBaseCurrencyStatisticsHistory(): CurrencyStatisticsHistory {
  return { symbol: "", blockchain: "", history: [], currencyInfo: undefined };
}

export const CurrencyStatisticsHistory = {
  encode(message: CurrencyStatisticsHistory, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.symbol !== "") {
      writer.uint32(10).string(message.symbol);
    }
    if (message.blockchain !== "") {
      writer.uint32(18).string(message.blockchain);
    }
    for (const v of message.history) {
      AggregatedStatsHistoryPoint.encode(v!, writer.uint32(26).fork()).ldelim();
    }
    if (message.currencyInfo !== undefined) {
      Currency.encode(message.currencyInfo, writer.uint32(34).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CurrencyStatisticsHistory {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCurrencyStatisticsHistory();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.symbol = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.blockchain = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.history.push(AggregatedStatsHistoryPoint.decode(reader, reader.uint32()));
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.currencyInfo = Currency.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CurrencyStatisticsHistory {
    return {
      symbol: isSet(object.symbol) ? globalThis.String(object.symbol) : "",
      blockchain: isSet(object.blockchain) ? globalThis.String(object.blockchain) : "",
      history: globalThis.Array.isArray(object?.history)
        ? object.history.map((e: any) => AggregatedStatsHistoryPoint.fromJSON(e))
        : [],
      currencyInfo: isSet(object.currencyInfo) ? Currency.fromJSON(object.currencyInfo) : undefined,
    };
  },

  toJSON(message: CurrencyStatisticsHistory): unknown {
    const obj: any = {};
    if (message.symbol !== "") {
      obj.symbol = message.symbol;
    }
    if (message.blockchain !== "") {
      obj.blockchain = message.blockchain;
    }
    if (message.history?.length) {
      obj.history = message.history.map((e) => AggregatedStatsHistoryPoint.toJSON(e));
    }
    if (message.currencyInfo !== undefined) {
      obj.currencyInfo = Currency.toJSON(message.currencyInfo);
    }
    return obj;
  },

  create(base?: DeepPartial<CurrencyStatisticsHistory>): CurrencyStatisticsHistory {
    return CurrencyStatisticsHistory.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CurrencyStatisticsHistory>): CurrencyStatisticsHistory {
    const message = createBaseCurrencyStatisticsHistory();
    message.symbol = object.symbol ?? "";
    message.blockchain = object.blockchain ?? "";
    message.history = object.history?.map((e) => AggregatedStatsHistoryPoint.fromPartial(e)) || [];
    message.currencyInfo = (object.currencyInfo !== undefined && object.currencyInfo !== null)
      ? Currency.fromPartial(object.currencyInfo)
      : undefined;
    return message;
  },
};

function createBaseAggregatedStatsHistoryPoint(): AggregatedStatsHistoryPoint {
  return { pointDate: undefined, statsData: undefined };
}

export const AggregatedStatsHistoryPoint = {
  encode(message: AggregatedStatsHistoryPoint, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.pointDate !== undefined) {
      Timestamp.encode(toTimestamp(message.pointDate), writer.uint32(10).fork()).ldelim();
    }
    if (message.statsData !== undefined) {
      AggregatedStatsData.encode(message.statsData, writer.uint32(18).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): AggregatedStatsHistoryPoint {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseAggregatedStatsHistoryPoint();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.pointDate = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.statsData = AggregatedStatsData.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): AggregatedStatsHistoryPoint {
    return {
      pointDate: isSet(object.pointDate) ? fromJsonTimestamp(object.pointDate) : undefined,
      statsData: isSet(object.statsData) ? AggregatedStatsData.fromJSON(object.statsData) : undefined,
    };
  },

  toJSON(message: AggregatedStatsHistoryPoint): unknown {
    const obj: any = {};
    if (message.pointDate !== undefined) {
      obj.pointDate = message.pointDate.toISOString();
    }
    if (message.statsData !== undefined) {
      obj.statsData = AggregatedStatsData.toJSON(message.statsData);
    }
    return obj;
  },

  create(base?: DeepPartial<AggregatedStatsHistoryPoint>): AggregatedStatsHistoryPoint {
    return AggregatedStatsHistoryPoint.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<AggregatedStatsHistoryPoint>): AggregatedStatsHistoryPoint {
    const message = createBaseAggregatedStatsHistoryPoint();
    message.pointDate = object.pointDate ?? undefined;
    message.statsData = (object.statsData !== undefined && object.statsData !== null)
      ? AggregatedStatsData.fromPartial(object.statsData)
      : undefined;
    return message;
  },
};

function createBaseAggregatedStatsData(): AggregatedStatsData {
  return {
    avgBalancePerAddress: "",
    addressesCount: 0,
    walletsCount: 0,
    totalBalance: "",
    totalBalanceBaseCurrency: "",
  };
}

export const AggregatedStatsData = {
  encode(message: AggregatedStatsData, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.avgBalancePerAddress !== "") {
      writer.uint32(10).string(message.avgBalancePerAddress);
    }
    if (message.addressesCount !== 0) {
      writer.uint32(16).uint64(message.addressesCount);
    }
    if (message.walletsCount !== 0) {
      writer.uint32(24).uint64(message.walletsCount);
    }
    if (message.totalBalance !== "") {
      writer.uint32(34).string(message.totalBalance);
    }
    if (message.totalBalanceBaseCurrency !== "") {
      writer.uint32(42).string(message.totalBalanceBaseCurrency);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): AggregatedStatsData {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseAggregatedStatsData();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.avgBalancePerAddress = reader.string();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.addressesCount = longToNumber(reader.uint64() as Long);
          continue;
        case 3:
          if (tag !== 24) {
            break;
          }

          message.walletsCount = longToNumber(reader.uint64() as Long);
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.totalBalance = reader.string();
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.totalBalanceBaseCurrency = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): AggregatedStatsData {
    return {
      avgBalancePerAddress: isSet(object.avgBalancePerAddress) ? globalThis.String(object.avgBalancePerAddress) : "",
      addressesCount: isSet(object.addressesCount) ? globalThis.Number(object.addressesCount) : 0,
      walletsCount: isSet(object.walletsCount) ? globalThis.Number(object.walletsCount) : 0,
      totalBalance: isSet(object.totalBalance) ? globalThis.String(object.totalBalance) : "",
      totalBalanceBaseCurrency: isSet(object.totalBalanceBaseCurrency)
        ? globalThis.String(object.totalBalanceBaseCurrency)
        : "",
    };
  },

  toJSON(message: AggregatedStatsData): unknown {
    const obj: any = {};
    if (message.avgBalancePerAddress !== "") {
      obj.avgBalancePerAddress = message.avgBalancePerAddress;
    }
    if (message.addressesCount !== 0) {
      obj.addressesCount = Math.round(message.addressesCount);
    }
    if (message.walletsCount !== 0) {
      obj.walletsCount = Math.round(message.walletsCount);
    }
    if (message.totalBalance !== "") {
      obj.totalBalance = message.totalBalance;
    }
    if (message.totalBalanceBaseCurrency !== "") {
      obj.totalBalanceBaseCurrency = message.totalBalanceBaseCurrency;
    }
    return obj;
  },

  create(base?: DeepPartial<AggregatedStatsData>): AggregatedStatsData {
    return AggregatedStatsData.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<AggregatedStatsData>): AggregatedStatsData {
    const message = createBaseAggregatedStatsData();
    message.avgBalancePerAddress = object.avgBalancePerAddress ?? "";
    message.addressesCount = object.addressesCount ?? 0;
    message.walletsCount = object.walletsCount ?? 0;
    message.totalBalance = object.totalBalance ?? "";
    message.totalBalanceBaseCurrency = object.totalBalanceBaseCurrency ?? "";
    return message;
  },
};

function createBaseTnPledgeStatisticsTnParticipant(): TnPledgeStatisticsTnParticipant {
  return {
    counterpartyTnParticipantID: "",
    outgoingPledgesTotalValuationBaseCurrency: "",
    incomingPledgesTotalValuationBaseCurrency: "",
    pledgeStatisticsCurrencies: [],
  };
}

export const TnPledgeStatisticsTnParticipant = {
  encode(message: TnPledgeStatisticsTnParticipant, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.counterpartyTnParticipantID !== "") {
      writer.uint32(10).string(message.counterpartyTnParticipantID);
    }
    if (message.outgoingPledgesTotalValuationBaseCurrency !== "") {
      writer.uint32(18).string(message.outgoingPledgesTotalValuationBaseCurrency);
    }
    if (message.incomingPledgesTotalValuationBaseCurrency !== "") {
      writer.uint32(26).string(message.incomingPledgesTotalValuationBaseCurrency);
    }
    for (const v of message.pledgeStatisticsCurrencies) {
      TnPledgeStatisticsCurrency.encode(v!, writer.uint32(34).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): TnPledgeStatisticsTnParticipant {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseTnPledgeStatisticsTnParticipant();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.counterpartyTnParticipantID = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.outgoingPledgesTotalValuationBaseCurrency = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.incomingPledgesTotalValuationBaseCurrency = reader.string();
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.pledgeStatisticsCurrencies.push(TnPledgeStatisticsCurrency.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): TnPledgeStatisticsTnParticipant {
    return {
      counterpartyTnParticipantID: isSet(object.counterpartyTnParticipantID)
        ? globalThis.String(object.counterpartyTnParticipantID)
        : "",
      outgoingPledgesTotalValuationBaseCurrency: isSet(object.outgoingPledgesTotalValuationBaseCurrency)
        ? globalThis.String(object.outgoingPledgesTotalValuationBaseCurrency)
        : "",
      incomingPledgesTotalValuationBaseCurrency: isSet(object.incomingPledgesTotalValuationBaseCurrency)
        ? globalThis.String(object.incomingPledgesTotalValuationBaseCurrency)
        : "",
      pledgeStatisticsCurrencies: globalThis.Array.isArray(object?.pledgeStatisticsCurrencies)
        ? object.pledgeStatisticsCurrencies.map((e: any) => TnPledgeStatisticsCurrency.fromJSON(e))
        : [],
    };
  },

  toJSON(message: TnPledgeStatisticsTnParticipant): unknown {
    const obj: any = {};
    if (message.counterpartyTnParticipantID !== "") {
      obj.counterpartyTnParticipantID = message.counterpartyTnParticipantID;
    }
    if (message.outgoingPledgesTotalValuationBaseCurrency !== "") {
      obj.outgoingPledgesTotalValuationBaseCurrency = message.outgoingPledgesTotalValuationBaseCurrency;
    }
    if (message.incomingPledgesTotalValuationBaseCurrency !== "") {
      obj.incomingPledgesTotalValuationBaseCurrency = message.incomingPledgesTotalValuationBaseCurrency;
    }
    if (message.pledgeStatisticsCurrencies?.length) {
      obj.pledgeStatisticsCurrencies = message.pledgeStatisticsCurrencies.map((e) =>
        TnPledgeStatisticsCurrency.toJSON(e)
      );
    }
    return obj;
  },

  create(base?: DeepPartial<TnPledgeStatisticsTnParticipant>): TnPledgeStatisticsTnParticipant {
    return TnPledgeStatisticsTnParticipant.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<TnPledgeStatisticsTnParticipant>): TnPledgeStatisticsTnParticipant {
    const message = createBaseTnPledgeStatisticsTnParticipant();
    message.counterpartyTnParticipantID = object.counterpartyTnParticipantID ?? "";
    message.outgoingPledgesTotalValuationBaseCurrency = object.outgoingPledgesTotalValuationBaseCurrency ?? "";
    message.incomingPledgesTotalValuationBaseCurrency = object.incomingPledgesTotalValuationBaseCurrency ?? "";
    message.pledgeStatisticsCurrencies =
      object.pledgeStatisticsCurrencies?.map((e) => TnPledgeStatisticsCurrency.fromPartial(e)) || [];
    return message;
  },
};

function createBaseTnPledgeStatisticsCurrency(): TnPledgeStatisticsCurrency {
  return {
    currencyID: "",
    outgoingPledgesAmount: "",
    outgoingPledgesValuationBaseCurrency: "",
    incomingPledgesAmount: "",
    incomingPledgesValuationBaseCurrency: "",
  };
}

export const TnPledgeStatisticsCurrency = {
  encode(message: TnPledgeStatisticsCurrency, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.currencyID !== "") {
      writer.uint32(10).string(message.currencyID);
    }
    if (message.outgoingPledgesAmount !== "") {
      writer.uint32(18).string(message.outgoingPledgesAmount);
    }
    if (message.outgoingPledgesValuationBaseCurrency !== "") {
      writer.uint32(26).string(message.outgoingPledgesValuationBaseCurrency);
    }
    if (message.incomingPledgesAmount !== "") {
      writer.uint32(34).string(message.incomingPledgesAmount);
    }
    if (message.incomingPledgesValuationBaseCurrency !== "") {
      writer.uint32(42).string(message.incomingPledgesValuationBaseCurrency);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): TnPledgeStatisticsCurrency {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseTnPledgeStatisticsCurrency();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.currencyID = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.outgoingPledgesAmount = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.outgoingPledgesValuationBaseCurrency = reader.string();
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.incomingPledgesAmount = reader.string();
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.incomingPledgesValuationBaseCurrency = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): TnPledgeStatisticsCurrency {
    return {
      currencyID: isSet(object.currencyID) ? globalThis.String(object.currencyID) : "",
      outgoingPledgesAmount: isSet(object.outgoingPledgesAmount) ? globalThis.String(object.outgoingPledgesAmount) : "",
      outgoingPledgesValuationBaseCurrency: isSet(object.outgoingPledgesValuationBaseCurrency)
        ? globalThis.String(object.outgoingPledgesValuationBaseCurrency)
        : "",
      incomingPledgesAmount: isSet(object.incomingPledgesAmount) ? globalThis.String(object.incomingPledgesAmount) : "",
      incomingPledgesValuationBaseCurrency: isSet(object.incomingPledgesValuationBaseCurrency)
        ? globalThis.String(object.incomingPledgesValuationBaseCurrency)
        : "",
    };
  },

  toJSON(message: TnPledgeStatisticsCurrency): unknown {
    const obj: any = {};
    if (message.currencyID !== "") {
      obj.currencyID = message.currencyID;
    }
    if (message.outgoingPledgesAmount !== "") {
      obj.outgoingPledgesAmount = message.outgoingPledgesAmount;
    }
    if (message.outgoingPledgesValuationBaseCurrency !== "") {
      obj.outgoingPledgesValuationBaseCurrency = message.outgoingPledgesValuationBaseCurrency;
    }
    if (message.incomingPledgesAmount !== "") {
      obj.incomingPledgesAmount = message.incomingPledgesAmount;
    }
    if (message.incomingPledgesValuationBaseCurrency !== "") {
      obj.incomingPledgesValuationBaseCurrency = message.incomingPledgesValuationBaseCurrency;
    }
    return obj;
  },

  create(base?: DeepPartial<TnPledgeStatisticsCurrency>): TnPledgeStatisticsCurrency {
    return TnPledgeStatisticsCurrency.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<TnPledgeStatisticsCurrency>): TnPledgeStatisticsCurrency {
    const message = createBaseTnPledgeStatisticsCurrency();
    message.currencyID = object.currencyID ?? "";
    message.outgoingPledgesAmount = object.outgoingPledgesAmount ?? "";
    message.outgoingPledgesValuationBaseCurrency = object.outgoingPledgesValuationBaseCurrency ?? "";
    message.incomingPledgesAmount = object.incomingPledgesAmount ?? "";
    message.incomingPledgesValuationBaseCurrency = object.incomingPledgesValuationBaseCurrency ?? "";
    return message;
  },
};

function createBaseTagStatistics(): TagStatistics {
  return { tagID: "", totalValuation: "", tag: undefined };
}

export const TagStatistics = {
  encode(message: TagStatistics, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.tagID !== "") {
      writer.uint32(10).string(message.tagID);
    }
    if (message.totalValuation !== "") {
      writer.uint32(18).string(message.totalValuation);
    }
    if (message.tag !== undefined) {
      Tag.encode(message.tag, writer.uint32(26).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): TagStatistics {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseTagStatistics();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.tagID = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.totalValuation = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.tag = Tag.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): TagStatistics {
    return {
      tagID: isSet(object.tagID) ? globalThis.String(object.tagID) : "",
      totalValuation: isSet(object.totalValuation) ? globalThis.String(object.totalValuation) : "",
      tag: isSet(object.tag) ? Tag.fromJSON(object.tag) : undefined,
    };
  },

  toJSON(message: TagStatistics): unknown {
    const obj: any = {};
    if (message.tagID !== "") {
      obj.tagID = message.tagID;
    }
    if (message.totalValuation !== "") {
      obj.totalValuation = message.totalValuation;
    }
    if (message.tag !== undefined) {
      obj.tag = Tag.toJSON(message.tag);
    }
    return obj;
  },

  create(base?: DeepPartial<TagStatistics>): TagStatistics {
    return TagStatistics.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<TagStatistics>): TagStatistics {
    const message = createBaseTagStatistics();
    message.tagID = object.tagID ?? "";
    message.totalValuation = object.totalValuation ?? "";
    message.tag = (object.tag !== undefined && object.tag !== null) ? Tag.fromPartial(object.tag) : undefined;
    return message;
  },
};

function createBaseTagAssetStatistics(): TagAssetStatistics {
  return {
    tagID: "",
    currencyID: "",
    totalBalance: "",
    totalBalanceValuation: "",
    creationDate: undefined,
    currencyInfo: undefined,
  };
}

export const TagAssetStatistics = {
  encode(message: TagAssetStatistics, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.tagID !== "") {
      writer.uint32(10).string(message.tagID);
    }
    if (message.currencyID !== "") {
      writer.uint32(18).string(message.currencyID);
    }
    if (message.totalBalance !== "") {
      writer.uint32(26).string(message.totalBalance);
    }
    if (message.totalBalanceValuation !== "") {
      writer.uint32(34).string(message.totalBalanceValuation);
    }
    if (message.creationDate !== undefined) {
      Timestamp.encode(toTimestamp(message.creationDate), writer.uint32(42).fork()).ldelim();
    }
    if (message.currencyInfo !== undefined) {
      Currency.encode(message.currencyInfo, writer.uint32(50).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): TagAssetStatistics {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseTagAssetStatistics();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.tagID = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.currencyID = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.totalBalance = reader.string();
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.totalBalanceValuation = reader.string();
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.creationDate = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        case 6:
          if (tag !== 50) {
            break;
          }

          message.currencyInfo = Currency.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): TagAssetStatistics {
    return {
      tagID: isSet(object.tagID) ? globalThis.String(object.tagID) : "",
      currencyID: isSet(object.currencyID) ? globalThis.String(object.currencyID) : "",
      totalBalance: isSet(object.totalBalance) ? globalThis.String(object.totalBalance) : "",
      totalBalanceValuation: isSet(object.totalBalanceValuation) ? globalThis.String(object.totalBalanceValuation) : "",
      creationDate: isSet(object.creationDate) ? fromJsonTimestamp(object.creationDate) : undefined,
      currencyInfo: isSet(object.currencyInfo) ? Currency.fromJSON(object.currencyInfo) : undefined,
    };
  },

  toJSON(message: TagAssetStatistics): unknown {
    const obj: any = {};
    if (message.tagID !== "") {
      obj.tagID = message.tagID;
    }
    if (message.currencyID !== "") {
      obj.currencyID = message.currencyID;
    }
    if (message.totalBalance !== "") {
      obj.totalBalance = message.totalBalance;
    }
    if (message.totalBalanceValuation !== "") {
      obj.totalBalanceValuation = message.totalBalanceValuation;
    }
    if (message.creationDate !== undefined) {
      obj.creationDate = message.creationDate.toISOString();
    }
    if (message.currencyInfo !== undefined) {
      obj.currencyInfo = Currency.toJSON(message.currencyInfo);
    }
    return obj;
  },

  create(base?: DeepPartial<TagAssetStatistics>): TagAssetStatistics {
    return TagAssetStatistics.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<TagAssetStatistics>): TagAssetStatistics {
    const message = createBaseTagAssetStatistics();
    message.tagID = object.tagID ?? "";
    message.currencyID = object.currencyID ?? "";
    message.totalBalance = object.totalBalance ?? "";
    message.totalBalanceValuation = object.totalBalanceValuation ?? "";
    message.creationDate = object.creationDate ?? undefined;
    message.currencyInfo = (object.currencyInfo !== undefined && object.currencyInfo !== null)
      ? Currency.fromPartial(object.currencyInfo)
      : undefined;
    return message;
  },
};

type Builtin = Date | Function | Uint8Array | string | number | boolean | undefined;

export type DeepPartial<T> = T extends Builtin ? T
  : T extends globalThis.Array<infer U> ? globalThis.Array<DeepPartial<U>>
  : T extends ReadonlyArray<infer U> ? ReadonlyArray<DeepPartial<U>>
  : T extends {} ? { [K in keyof T]?: DeepPartial<T[K]> }
  : Partial<T>;

function toTimestamp(date: Date): Timestamp {
  const seconds = Math.trunc(date.getTime() / 1_000);
  const nanos = (date.getTime() % 1_000) * 1_000_000;
  return { seconds, nanos };
}

function fromTimestamp(t: Timestamp): Date {
  let millis = (t.seconds || 0) * 1_000;
  millis += (t.nanos || 0) / 1_000_000;
  return new globalThis.Date(millis);
}

function fromJsonTimestamp(o: any): Date {
  if (o instanceof globalThis.Date) {
    return o;
  } else if (typeof o === "string") {
    return new globalThis.Date(o);
  } else {
    return fromTimestamp(Timestamp.fromJSON(o));
  }
}

function longToNumber(long: Long): number {
  if (long.gt(globalThis.Number.MAX_SAFE_INTEGER)) {
    throw new globalThis.Error("Value is larger than Number.MAX_SAFE_INTEGER");
  }
  if (long.lt(globalThis.Number.MIN_SAFE_INTEGER)) {
    throw new globalThis.Error("Value is smaller than Number.MIN_SAFE_INTEGER");
  }
  return long.toNumber();
}

if (_m0.util.Long !== Long) {
  _m0.util.Long = Long as any;
  _m0.configure();
}

function isSet(value: any): boolean {
  return value !== null && value !== undefined;
}
