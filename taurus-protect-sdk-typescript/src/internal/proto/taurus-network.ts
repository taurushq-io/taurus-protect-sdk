// Code generated by protoc-gen-ts_proto. DO NOT EDIT.
// versions:
//   protoc-gen-ts_proto  v1.181.2
//   protoc               v6.33.4
// source: taurus-network.proto

/* eslint-disable */
import Long from "long";
import _m0 from "protobufjs/minimal";
import { Approvers } from "./approvers";
import { BlockchainEntity } from "./blockchain-service";
import { Currency } from "./currency";
import { Duration } from "./google/protobuf/duration";
import { Timestamp } from "./google/protobuf/timestamp";
import { Metadata } from "./metadata";
import { ProofOfReserve } from "./wallet";

export const protobufPackage = "tgvalidatord";

export interface TnParticipantSettings {
  interactingAllowedCountries: string[];
  status: string;
  interactingAllowedParticipants: TnAllowedParticipant[];
  termsAndConditionsAcceptedAt: Date | undefined;
}

export interface TnAllowedParticipant {
  id: string;
  name: string;
  status: string;
}

export interface TnParticipant {
  id: string;
  name: string;
  legalAddress: string;
  country: string;
  logoBase64: string;
  publicKey: string;
  /**
   * base64 of a json string containing the shield version and a
   * signature from the participant private key of selected attribute of the 'Participant' payload
   */
  shield: string;
  originRegistrationDate: Date | undefined;
  originDeletionDate: Date | undefined;
  createdAt: Date | undefined;
  updatedAt: Date | undefined;
  details: TnParticipantDetails | undefined;
  blockConfirmations: BlockConfirmations[];
  ownedSharedAddressesCount: number;
  targetedSharedAddressesCount: number;
  outgoingTotalPledgesValuationBaseCurrency: string;
  incomingTotalPledgesValuationBaseCurrency: string;
  publicSubname: string;
  legalEntityIdentifier: string;
  attributes: TnParticipantAttribute[];
  status: string;
  tnLendingOffers: TnLendingOffer[];
  defaultSharedAddresses: DefaultSharedAddresses | undefined;
}

export interface TnParticipantAttribute {
  id: string;
  key: string;
  value: string;
  owner: string;
  type: string;
  subtype: string;
  contentType: string;
  isTaurusNetworkShared: boolean;
}

export interface BlockConfirmations {
  blockchain: string;
  network: string;
  confirmationsThreshold: number;
}

export interface DefaultSharedAddress {
  blockchain: string;
  network: string;
  sharedAddressID: string;
}

export interface DefaultSharedAddresses {
  outgoingDefaultSharedAddresses: DefaultSharedAddress[];
  incomingDefaultSharedAddresses: DefaultSharedAddress[];
}

export interface TnParticipantDetails {
  contactPersons: TnContactPerson[];
  attributesSpecifications: TnParticipantAttributeSpecification[];
  supportedBlockchains: BlockchainEntity[];
}

export interface LendingAgreement {
  id: string;
  lenderParticipantID: string;
  borrowerParticipantID: string;
  lendingOfferID: string;
  amount: string;
  currencyID: string;
  annualYield: number;
  status: string;
  duration: Duration | undefined;
  startLoanDate: Date | undefined;
  workflowID: string;
  borrowerSharedAddressID: string;
  lenderSharedAddressID: string;
  lendingAgreementCollaterals: LendingAgreementCollateral[];
  lendingAgreementTransactions: LendingAgreementTransaction[];
  createdAt: Date | undefined;
  updatedAt: Date | undefined;
  annualYieldMainUnit: string;
  currencyInfo: Currency | undefined;
  amountMainUnit: string;
  repaymentDueDate: Date | undefined;
}

export interface LendingAgreementCollateral {
  id: string;
  lenderParticipantID: string;
  borrowerParticipantID: string;
  lendingAgreementID: string;
  amount: string;
  currencyID: string;
  status: string;
  pledgeID: string;
  sharedAddressID: string;
  createdAt: Date | undefined;
  updatedAt: Date | undefined;
  currencyInfo: Currency | undefined;
  amountMainUnit: string;
  pledgeActionID: string;
}

export interface LendingAgreementTransaction {
  id: string;
  lendingAgreementID: string;
  amount: string;
  currencyID: string;
  requestID: number;
  transactionID: number;
  transactionHash: string;
  transactionBlockNumber: number;
  type: string;
  amountMainUnit: string;
  currencyInfo: Currency | undefined;
  createdAt: Date | undefined;
  updatedAt: Date | undefined;
}

export interface LendingAgreementAttachment {
  id: string;
  lendingAgreementID: string;
  uploaderParticipantID: string;
  name: string;
  type: string;
  contentType: string;
  value: string;
  fileSize: number;
  createdAt: Date | undefined;
  updatedAt: Date | undefined;
}

export interface TnLendingOffer {
  id: string;
  annualPercentageYield: number;
  duration: Duration | undefined;
  collateralRequirement: LendingCollateralRequirement | undefined;
  participantID: string;
  blockchain: string;
  network: string;
  arg1: string;
  arg2: string;
  currencyInfo: Currency | undefined;
  annualPercentageYieldMainUnit: string;
  originCreatedAt: Date | undefined;
  createdAt: Date | undefined;
  updatedAt: Date | undefined;
  amount: string;
  amountMainUnit: string;
}

export interface TnLendingOffersDetails {
  tnLendingOffersDetails: TnLendingOfferDetail[];
}

export interface TnLendingOfferDetail {
  id: string;
  blockchain: string;
  network: string;
  arg1: string;
  arg2: string;
  annualPercentageYield: number;
  duration: Duration | undefined;
  collateralRequirement: LendingCollateralRequirement | undefined;
  originCreatedAt: Date | undefined;
  amount: string;
}

export interface LendingCollateralRequirement {
  acceptedCurrencies: CurrencyCollateralRequirement[];
}

export interface CurrencyCollateralRequirement {
  blockchain: string;
  network: string;
  arg1: string;
  arg2: string;
  ratio: string;
  currencyInfo: Currency | undefined;
}

export interface TnParticipantAttributeSpecification {
  attributeKey: string;
  attributeType: string;
  /** how to get this value ex. TDX subaccount */
  attributeDescription: string;
}

export interface TnContactPerson {
  firstName: string;
  lastName: string;
  phoneNumber: string;
  email: string;
}

export interface TnSharedAddress {
  id: string;
  internalAddressID: number;
  wladdressID: number;
  ownerParticipantId: string;
  targetParticipantId: string;
  blockchain: string;
  network: string;
  address: string;
  originLabel: string;
  originCreationDate: Date | undefined;
  originDeletionDate: Date | undefined;
  createdAt: Date | undefined;
  updatedAt: Date | undefined;
  targetAcceptedAt: Date | undefined;
  status: string;
  proofOfOwnership: ProofOfOwnership | undefined;
  pledgesCount: number;
  trails: TnSharedAddress_Trail[];
}

export interface TnSharedAddress_Trail {
  id: string;
  sharedAddressID: string;
  addressStatus: string;
  comment: string;
  createdAt: Date | undefined;
}

export interface TnSharedAsset {
  id: string;
  wlContractAddressID: number;
  ownerParticipantId: string;
  targetParticipantId: string;
  blockchain: string;
  network: string;
  name: string;
  symbol: string;
  decimals: number;
  contractAddress: string;
  /** XTZ FA2, ERC721, ERC1155 */
  tokenId: string;
  kind: string;
  originCreationDate: Date | undefined;
  originDeletionDate: Date | undefined;
  createdAt: Date | undefined;
  updatedAt: Date | undefined;
  targetAcceptedAt: Date | undefined;
  targetRejectedAt: Date | undefined;
  status: string;
  trails: TnSharedAsset_Trail[];
}

export enum TnSharedAsset_Kind {
  /** _default_ - Default has an empty string as a representation */
  _default_ = 0,
  /** NFT_AUTO - Generic representation for NFTs. Upon receiving this, the backend will try to find the best match, and fill it with one of the types below. */
  NFT_AUTO = 1,
  NFT_XTZ_FA2 = 2,
  /**
   * NFT_ETH_ERC721 - Use NFT_EVM_ERC721 or NFT_AUTO instead.
   *
   * @deprecated
   */
  NFT_ETH_ERC721 = 3,
  /**
   * NFT_ETH_ERC1155 - Use NFT_EVM_ERC1155 or NFT_AUTO instead.
   *
   * @deprecated
   */
  NFT_ETH_ERC1155 = 4,
  NFT_EVM_ERC721 = 5,
  NFT_EVM_ERC1155 = 6,
  SOL_TOKEN = 7,
  SOL_TOKEN2022 = 8,
  NFT_EVM_CRYPTOPUNKS = 9,
  UNRECOGNIZED = -1,
}

export function tnSharedAsset_KindFromJSON(object: any): TnSharedAsset_Kind {
  switch (object) {
    case 0:
    case "_default_":
      return TnSharedAsset_Kind._default_;
    case 1:
    case "NFT_AUTO":
      return TnSharedAsset_Kind.NFT_AUTO;
    case 2:
    case "NFT_XTZ_FA2":
      return TnSharedAsset_Kind.NFT_XTZ_FA2;
    case 3:
    case "NFT_ETH_ERC721":
      return TnSharedAsset_Kind.NFT_ETH_ERC721;
    case 4:
    case "NFT_ETH_ERC1155":
      return TnSharedAsset_Kind.NFT_ETH_ERC1155;
    case 5:
    case "NFT_EVM_ERC721":
      return TnSharedAsset_Kind.NFT_EVM_ERC721;
    case 6:
    case "NFT_EVM_ERC1155":
      return TnSharedAsset_Kind.NFT_EVM_ERC1155;
    case 7:
    case "SOL_TOKEN":
      return TnSharedAsset_Kind.SOL_TOKEN;
    case 8:
    case "SOL_TOKEN2022":
      return TnSharedAsset_Kind.SOL_TOKEN2022;
    case 9:
    case "NFT_EVM_CRYPTOPUNKS":
      return TnSharedAsset_Kind.NFT_EVM_CRYPTOPUNKS;
    case -1:
    case "UNRECOGNIZED":
    default:
      return TnSharedAsset_Kind.UNRECOGNIZED;
  }
}

export function tnSharedAsset_KindToJSON(object: TnSharedAsset_Kind): string {
  switch (object) {
    case TnSharedAsset_Kind._default_:
      return "_default_";
    case TnSharedAsset_Kind.NFT_AUTO:
      return "NFT_AUTO";
    case TnSharedAsset_Kind.NFT_XTZ_FA2:
      return "NFT_XTZ_FA2";
    case TnSharedAsset_Kind.NFT_ETH_ERC721:
      return "NFT_ETH_ERC721";
    case TnSharedAsset_Kind.NFT_ETH_ERC1155:
      return "NFT_ETH_ERC1155";
    case TnSharedAsset_Kind.NFT_EVM_ERC721:
      return "NFT_EVM_ERC721";
    case TnSharedAsset_Kind.NFT_EVM_ERC1155:
      return "NFT_EVM_ERC1155";
    case TnSharedAsset_Kind.SOL_TOKEN:
      return "SOL_TOKEN";
    case TnSharedAsset_Kind.SOL_TOKEN2022:
      return "SOL_TOKEN2022";
    case TnSharedAsset_Kind.NFT_EVM_CRYPTOPUNKS:
      return "NFT_EVM_CRYPTOPUNKS";
    case TnSharedAsset_Kind.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

export interface TnSharedAsset_Trail {
  id: string;
  sharedAssetID: string;
  assetStatus: string;
  comment: string;
  createdAt: Date | undefined;
}

export interface ProofOfOwnership {
  signedPayload: SignedProofOfOwnershipPayload | undefined;
  signedPayloadHash: string;
  proofOfReserve: ProofOfReserve | undefined;
  signedPayloadAsString: string;
}

export interface SignedProofOfOwnershipPayload {
  payload: ProofOfOwnershipPayload | undefined;
  ownerParticipantSignature: string;
}

export interface ProofOfOwnershipPayload {
  ownerParticipantID: string;
  targetParticipantID: string;
  address: string;
  blockchain: string;
  network: string;
}

export interface TnPledge {
  id: string;
  sharedAddressID: string;
  ownerParticipantID: string;
  targetParticipantID: string;
  currencyID: string;
  blockchain: string;
  network: string;
  arg1: string;
  arg2: string;
  amount: string;
  status: string;
  pledgeType: string;
  trails: TnPledge_Trail[];
  originCreationDate: Date | undefined;
  durationSetup: TnPledge_PledgeDurationSetup | undefined;
  unpledgeDate: Date | undefined;
  attributes: TnPledge_PledgeAttribute[];
  createdAt: Date | undefined;
  updatedAt: Date | undefined;
  externalReferenceId: string;
  reconciliationNote: string;
  /** INCOMING or OUTGOING */
  direction: string;
  wladdressID: number;
}

export interface TnPledge_Trail {
  id: string;
  pledgeID: string;
  addressCommandID: string;
  participantID: string;
  pledgeAmount: string;
  action: string;
  comment: string;
  createdAt: Date | undefined;
}

export interface TnPledge_PledgeDurationSetup {
  minimumDuration: Duration | undefined;
  endOfMinimumDurationDate: Date | undefined;
  noticePeriodDuration: Duration | undefined;
  endOfNoticePeriodDate: Date | undefined;
}

export interface TnPledge_PledgeAttribute {
  id: string;
  key: string;
  value: string;
  owner: string;
  type: string;
  subtype: string;
  contentType: string;
  isTaurusNetworkShared: boolean;
}

export interface TnPledgeWithdrawal {
  id: string;
  pledgeID: string;
  destinationSharedAddressID: string;
  amount: string;
  status: string;
  txHash: string;
  txID: number;
  requestID: number;
  txBlockNumber: number;
  trails: TnPledgeWithdrawal_Trail[];
  createdAt: Date | undefined;
  initiatorParticipantID: string;
  externalReferenceID: string;
}

export interface TnPledgeWithdrawal_Trail {
  id: string;
  pledgeWithdrawalID: string;
  addressCommandID: string;
  participantID: string;
  action: string;
  comment: string;
  createdAt: Date | undefined;
}

export interface TnPledgeAction {
  id: string;
  pledgeID: string;
  actionType: string;
  status: string;
  metadata: Metadata | undefined;
  rule: string;
  approvers: Approvers | undefined;
  needsApprovalFrom: string[];
  createdAt: Date | undefined;
  lastApprovalDate: Date | undefined;
  envelope: string;
  trails: TnPledgeAction_Trail[];
  pledgeWithdrawalID: string;
}

export interface TnPledgeAction_Trail {
  id: string;
  pledgeActionID: string;
  userID: number;
  externalUserID: string;
  action: string;
  comment: string;
  createdAt: Date | undefined;
}

export interface TnSettlementAssetTransfer {
  currencyID: string;
  amount: string;
  sourceSharedAddressID: string;
  destinationSharedAddressID: string;
}

export interface TnSettlementClipTransaction {
  id: string;
  assetTransfer: TnSettlementAssetTransfer | undefined;
  requestID: number;
  requestMetadata: Metadata | undefined;
  txHash: string;
  txID: number;
  txBlockNumber: number;
  status: string;
  createdAt: Date | undefined;
  workflowID: string;
}

export interface TnSettlementClip {
  id: string;
  index: number;
  firstLegTransactions: TnSettlementClipTransaction[];
  secondLegTransactions: TnSettlementClipTransaction[];
  status: string;
  workflowID: string;
}

export interface TnSettlement {
  id: string;
  creatorParticipantID: string;
  targetParticipantID: string;
  firstLegParticipantID: string;
  firstLegAssets: TnSettlementAssetTransfer[];
  secondLegAssets: TnSettlementAssetTransfer[];
  clips: TnSettlementClip[];
  startExecutionDate: Date | undefined;
  status: string;
  createdAt: Date | undefined;
  updatedAt: Date | undefined;
  workflowID: string;
}

function createBaseTnParticipantSettings(): TnParticipantSettings {
  return {
    interactingAllowedCountries: [],
    status: "",
    interactingAllowedParticipants: [],
    termsAndConditionsAcceptedAt: undefined,
  };
}

export const TnParticipantSettings = {
  encode(message: TnParticipantSettings, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    for (const v of message.interactingAllowedCountries) {
      writer.uint32(10).string(v!);
    }
    if (message.status !== "") {
      writer.uint32(18).string(message.status);
    }
    for (const v of message.interactingAllowedParticipants) {
      TnAllowedParticipant.encode(v!, writer.uint32(26).fork()).ldelim();
    }
    if (message.termsAndConditionsAcceptedAt !== undefined) {
      Timestamp.encode(toTimestamp(message.termsAndConditionsAcceptedAt), writer.uint32(34).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): TnParticipantSettings {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseTnParticipantSettings();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.interactingAllowedCountries.push(reader.string());
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.status = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.interactingAllowedParticipants.push(TnAllowedParticipant.decode(reader, reader.uint32()));
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.termsAndConditionsAcceptedAt = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): TnParticipantSettings {
    return {
      interactingAllowedCountries: globalThis.Array.isArray(object?.interactingAllowedCountries)
        ? object.interactingAllowedCountries.map((e: any) => globalThis.String(e))
        : [],
      status: isSet(object.status) ? globalThis.String(object.status) : "",
      interactingAllowedParticipants: globalThis.Array.isArray(object?.interactingAllowedParticipants)
        ? object.interactingAllowedParticipants.map((e: any) => TnAllowedParticipant.fromJSON(e))
        : [],
      termsAndConditionsAcceptedAt: isSet(object.termsAndConditionsAcceptedAt)
        ? fromJsonTimestamp(object.termsAndConditionsAcceptedAt)
        : undefined,
    };
  },

  toJSON(message: TnParticipantSettings): unknown {
    const obj: any = {};
    if (message.interactingAllowedCountries?.length) {
      obj.interactingAllowedCountries = message.interactingAllowedCountries;
    }
    if (message.status !== "") {
      obj.status = message.status;
    }
    if (message.interactingAllowedParticipants?.length) {
      obj.interactingAllowedParticipants = message.interactingAllowedParticipants.map((e) =>
        TnAllowedParticipant.toJSON(e)
      );
    }
    if (message.termsAndConditionsAcceptedAt !== undefined) {
      obj.termsAndConditionsAcceptedAt = message.termsAndConditionsAcceptedAt.toISOString();
    }
    return obj;
  },

  create(base?: DeepPartial<TnParticipantSettings>): TnParticipantSettings {
    return TnParticipantSettings.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<TnParticipantSettings>): TnParticipantSettings {
    const message = createBaseTnParticipantSettings();
    message.interactingAllowedCountries = object.interactingAllowedCountries?.map((e) => e) || [];
    message.status = object.status ?? "";
    message.interactingAllowedParticipants =
      object.interactingAllowedParticipants?.map((e) => TnAllowedParticipant.fromPartial(e)) || [];
    message.termsAndConditionsAcceptedAt = object.termsAndConditionsAcceptedAt ?? undefined;
    return message;
  },
};

function createBaseTnAllowedParticipant(): TnAllowedParticipant {
  return { id: "", name: "", status: "" };
}

export const TnAllowedParticipant = {
  encode(message: TnAllowedParticipant, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.id !== "") {
      writer.uint32(10).string(message.id);
    }
    if (message.name !== "") {
      writer.uint32(18).string(message.name);
    }
    if (message.status !== "") {
      writer.uint32(26).string(message.status);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): TnAllowedParticipant {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseTnAllowedParticipant();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.id = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.name = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.status = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): TnAllowedParticipant {
    return {
      id: isSet(object.id) ? globalThis.String(object.id) : "",
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      status: isSet(object.status) ? globalThis.String(object.status) : "",
    };
  },

  toJSON(message: TnAllowedParticipant): unknown {
    const obj: any = {};
    if (message.id !== "") {
      obj.id = message.id;
    }
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.status !== "") {
      obj.status = message.status;
    }
    return obj;
  },

  create(base?: DeepPartial<TnAllowedParticipant>): TnAllowedParticipant {
    return TnAllowedParticipant.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<TnAllowedParticipant>): TnAllowedParticipant {
    const message = createBaseTnAllowedParticipant();
    message.id = object.id ?? "";
    message.name = object.name ?? "";
    message.status = object.status ?? "";
    return message;
  },
};

function createBaseTnParticipant(): TnParticipant {
  return {
    id: "",
    name: "",
    legalAddress: "",
    country: "",
    logoBase64: "",
    publicKey: "",
    shield: "",
    originRegistrationDate: undefined,
    originDeletionDate: undefined,
    createdAt: undefined,
    updatedAt: undefined,
    details: undefined,
    blockConfirmations: [],
    ownedSharedAddressesCount: 0,
    targetedSharedAddressesCount: 0,
    outgoingTotalPledgesValuationBaseCurrency: "",
    incomingTotalPledgesValuationBaseCurrency: "",
    publicSubname: "",
    legalEntityIdentifier: "",
    attributes: [],
    status: "",
    tnLendingOffers: [],
    defaultSharedAddresses: undefined,
  };
}

export const TnParticipant = {
  encode(message: TnParticipant, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.id !== "") {
      writer.uint32(10).string(message.id);
    }
    if (message.name !== "") {
      writer.uint32(18).string(message.name);
    }
    if (message.legalAddress !== "") {
      writer.uint32(26).string(message.legalAddress);
    }
    if (message.country !== "") {
      writer.uint32(34).string(message.country);
    }
    if (message.logoBase64 !== "") {
      writer.uint32(42).string(message.logoBase64);
    }
    if (message.publicKey !== "") {
      writer.uint32(50).string(message.publicKey);
    }
    if (message.shield !== "") {
      writer.uint32(58).string(message.shield);
    }
    if (message.originRegistrationDate !== undefined) {
      Timestamp.encode(toTimestamp(message.originRegistrationDate), writer.uint32(66).fork()).ldelim();
    }
    if (message.originDeletionDate !== undefined) {
      Timestamp.encode(toTimestamp(message.originDeletionDate), writer.uint32(74).fork()).ldelim();
    }
    if (message.createdAt !== undefined) {
      Timestamp.encode(toTimestamp(message.createdAt), writer.uint32(82).fork()).ldelim();
    }
    if (message.updatedAt !== undefined) {
      Timestamp.encode(toTimestamp(message.updatedAt), writer.uint32(90).fork()).ldelim();
    }
    if (message.details !== undefined) {
      TnParticipantDetails.encode(message.details, writer.uint32(98).fork()).ldelim();
    }
    for (const v of message.blockConfirmations) {
      BlockConfirmations.encode(v!, writer.uint32(106).fork()).ldelim();
    }
    if (message.ownedSharedAddressesCount !== 0) {
      writer.uint32(112).uint64(message.ownedSharedAddressesCount);
    }
    if (message.targetedSharedAddressesCount !== 0) {
      writer.uint32(120).uint64(message.targetedSharedAddressesCount);
    }
    if (message.outgoingTotalPledgesValuationBaseCurrency !== "") {
      writer.uint32(130).string(message.outgoingTotalPledgesValuationBaseCurrency);
    }
    if (message.incomingTotalPledgesValuationBaseCurrency !== "") {
      writer.uint32(138).string(message.incomingTotalPledgesValuationBaseCurrency);
    }
    if (message.publicSubname !== "") {
      writer.uint32(146).string(message.publicSubname);
    }
    if (message.legalEntityIdentifier !== "") {
      writer.uint32(154).string(message.legalEntityIdentifier);
    }
    for (const v of message.attributes) {
      TnParticipantAttribute.encode(v!, writer.uint32(162).fork()).ldelim();
    }
    if (message.status !== "") {
      writer.uint32(170).string(message.status);
    }
    for (const v of message.tnLendingOffers) {
      TnLendingOffer.encode(v!, writer.uint32(178).fork()).ldelim();
    }
    if (message.defaultSharedAddresses !== undefined) {
      DefaultSharedAddresses.encode(message.defaultSharedAddresses, writer.uint32(186).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): TnParticipant {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseTnParticipant();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.id = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.name = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.legalAddress = reader.string();
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.country = reader.string();
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.logoBase64 = reader.string();
          continue;
        case 6:
          if (tag !== 50) {
            break;
          }

          message.publicKey = reader.string();
          continue;
        case 7:
          if (tag !== 58) {
            break;
          }

          message.shield = reader.string();
          continue;
        case 8:
          if (tag !== 66) {
            break;
          }

          message.originRegistrationDate = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        case 9:
          if (tag !== 74) {
            break;
          }

          message.originDeletionDate = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        case 10:
          if (tag !== 82) {
            break;
          }

          message.createdAt = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        case 11:
          if (tag !== 90) {
            break;
          }

          message.updatedAt = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        case 12:
          if (tag !== 98) {
            break;
          }

          message.details = TnParticipantDetails.decode(reader, reader.uint32());
          continue;
        case 13:
          if (tag !== 106) {
            break;
          }

          message.blockConfirmations.push(BlockConfirmations.decode(reader, reader.uint32()));
          continue;
        case 14:
          if (tag !== 112) {
            break;
          }

          message.ownedSharedAddressesCount = longToNumber(reader.uint64() as Long);
          continue;
        case 15:
          if (tag !== 120) {
            break;
          }

          message.targetedSharedAddressesCount = longToNumber(reader.uint64() as Long);
          continue;
        case 16:
          if (tag !== 130) {
            break;
          }

          message.outgoingTotalPledgesValuationBaseCurrency = reader.string();
          continue;
        case 17:
          if (tag !== 138) {
            break;
          }

          message.incomingTotalPledgesValuationBaseCurrency = reader.string();
          continue;
        case 18:
          if (tag !== 146) {
            break;
          }

          message.publicSubname = reader.string();
          continue;
        case 19:
          if (tag !== 154) {
            break;
          }

          message.legalEntityIdentifier = reader.string();
          continue;
        case 20:
          if (tag !== 162) {
            break;
          }

          message.attributes.push(TnParticipantAttribute.decode(reader, reader.uint32()));
          continue;
        case 21:
          if (tag !== 170) {
            break;
          }

          message.status = reader.string();
          continue;
        case 22:
          if (tag !== 178) {
            break;
          }

          message.tnLendingOffers.push(TnLendingOffer.decode(reader, reader.uint32()));
          continue;
        case 23:
          if (tag !== 186) {
            break;
          }

          message.defaultSharedAddresses = DefaultSharedAddresses.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): TnParticipant {
    return {
      id: isSet(object.id) ? globalThis.String(object.id) : "",
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      legalAddress: isSet(object.legalAddress) ? globalThis.String(object.legalAddress) : "",
      country: isSet(object.country) ? globalThis.String(object.country) : "",
      logoBase64: isSet(object.logoBase64) ? globalThis.String(object.logoBase64) : "",
      publicKey: isSet(object.publicKey) ? globalThis.String(object.publicKey) : "",
      shield: isSet(object.shield) ? globalThis.String(object.shield) : "",
      originRegistrationDate: isSet(object.originRegistrationDate)
        ? fromJsonTimestamp(object.originRegistrationDate)
        : undefined,
      originDeletionDate: isSet(object.originDeletionDate) ? fromJsonTimestamp(object.originDeletionDate) : undefined,
      createdAt: isSet(object.createdAt) ? fromJsonTimestamp(object.createdAt) : undefined,
      updatedAt: isSet(object.updatedAt) ? fromJsonTimestamp(object.updatedAt) : undefined,
      details: isSet(object.details) ? TnParticipantDetails.fromJSON(object.details) : undefined,
      blockConfirmations: globalThis.Array.isArray(object?.blockConfirmations)
        ? object.blockConfirmations.map((e: any) => BlockConfirmations.fromJSON(e))
        : [],
      ownedSharedAddressesCount: isSet(object.ownedSharedAddressesCount)
        ? globalThis.Number(object.ownedSharedAddressesCount)
        : 0,
      targetedSharedAddressesCount: isSet(object.targetedSharedAddressesCount)
        ? globalThis.Number(object.targetedSharedAddressesCount)
        : 0,
      outgoingTotalPledgesValuationBaseCurrency: isSet(object.outgoingTotalPledgesValuationBaseCurrency)
        ? globalThis.String(object.outgoingTotalPledgesValuationBaseCurrency)
        : "",
      incomingTotalPledgesValuationBaseCurrency: isSet(object.incomingTotalPledgesValuationBaseCurrency)
        ? globalThis.String(object.incomingTotalPledgesValuationBaseCurrency)
        : "",
      publicSubname: isSet(object.publicSubname) ? globalThis.String(object.publicSubname) : "",
      legalEntityIdentifier: isSet(object.legalEntityIdentifier) ? globalThis.String(object.legalEntityIdentifier) : "",
      attributes: globalThis.Array.isArray(object?.attributes)
        ? object.attributes.map((e: any) => TnParticipantAttribute.fromJSON(e))
        : [],
      status: isSet(object.status) ? globalThis.String(object.status) : "",
      tnLendingOffers: globalThis.Array.isArray(object?.tnLendingOffers)
        ? object.tnLendingOffers.map((e: any) => TnLendingOffer.fromJSON(e))
        : [],
      defaultSharedAddresses: isSet(object.defaultSharedAddresses)
        ? DefaultSharedAddresses.fromJSON(object.defaultSharedAddresses)
        : undefined,
    };
  },

  toJSON(message: TnParticipant): unknown {
    const obj: any = {};
    if (message.id !== "") {
      obj.id = message.id;
    }
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.legalAddress !== "") {
      obj.legalAddress = message.legalAddress;
    }
    if (message.country !== "") {
      obj.country = message.country;
    }
    if (message.logoBase64 !== "") {
      obj.logoBase64 = message.logoBase64;
    }
    if (message.publicKey !== "") {
      obj.publicKey = message.publicKey;
    }
    if (message.shield !== "") {
      obj.shield = message.shield;
    }
    if (message.originRegistrationDate !== undefined) {
      obj.originRegistrationDate = message.originRegistrationDate.toISOString();
    }
    if (message.originDeletionDate !== undefined) {
      obj.originDeletionDate = message.originDeletionDate.toISOString();
    }
    if (message.createdAt !== undefined) {
      obj.createdAt = message.createdAt.toISOString();
    }
    if (message.updatedAt !== undefined) {
      obj.updatedAt = message.updatedAt.toISOString();
    }
    if (message.details !== undefined) {
      obj.details = TnParticipantDetails.toJSON(message.details);
    }
    if (message.blockConfirmations?.length) {
      obj.blockConfirmations = message.blockConfirmations.map((e) => BlockConfirmations.toJSON(e));
    }
    if (message.ownedSharedAddressesCount !== 0) {
      obj.ownedSharedAddressesCount = Math.round(message.ownedSharedAddressesCount);
    }
    if (message.targetedSharedAddressesCount !== 0) {
      obj.targetedSharedAddressesCount = Math.round(message.targetedSharedAddressesCount);
    }
    if (message.outgoingTotalPledgesValuationBaseCurrency !== "") {
      obj.outgoingTotalPledgesValuationBaseCurrency = message.outgoingTotalPledgesValuationBaseCurrency;
    }
    if (message.incomingTotalPledgesValuationBaseCurrency !== "") {
      obj.incomingTotalPledgesValuationBaseCurrency = message.incomingTotalPledgesValuationBaseCurrency;
    }
    if (message.publicSubname !== "") {
      obj.publicSubname = message.publicSubname;
    }
    if (message.legalEntityIdentifier !== "") {
      obj.legalEntityIdentifier = message.legalEntityIdentifier;
    }
    if (message.attributes?.length) {
      obj.attributes = message.attributes.map((e) => TnParticipantAttribute.toJSON(e));
    }
    if (message.status !== "") {
      obj.status = message.status;
    }
    if (message.tnLendingOffers?.length) {
      obj.tnLendingOffers = message.tnLendingOffers.map((e) => TnLendingOffer.toJSON(e));
    }
    if (message.defaultSharedAddresses !== undefined) {
      obj.defaultSharedAddresses = DefaultSharedAddresses.toJSON(message.defaultSharedAddresses);
    }
    return obj;
  },

  create(base?: DeepPartial<TnParticipant>): TnParticipant {
    return TnParticipant.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<TnParticipant>): TnParticipant {
    const message = createBaseTnParticipant();
    message.id = object.id ?? "";
    message.name = object.name ?? "";
    message.legalAddress = object.legalAddress ?? "";
    message.country = object.country ?? "";
    message.logoBase64 = object.logoBase64 ?? "";
    message.publicKey = object.publicKey ?? "";
    message.shield = object.shield ?? "";
    message.originRegistrationDate = object.originRegistrationDate ?? undefined;
    message.originDeletionDate = object.originDeletionDate ?? undefined;
    message.createdAt = object.createdAt ?? undefined;
    message.updatedAt = object.updatedAt ?? undefined;
    message.details = (object.details !== undefined && object.details !== null)
      ? TnParticipantDetails.fromPartial(object.details)
      : undefined;
    message.blockConfirmations = object.blockConfirmations?.map((e) => BlockConfirmations.fromPartial(e)) || [];
    message.ownedSharedAddressesCount = object.ownedSharedAddressesCount ?? 0;
    message.targetedSharedAddressesCount = object.targetedSharedAddressesCount ?? 0;
    message.outgoingTotalPledgesValuationBaseCurrency = object.outgoingTotalPledgesValuationBaseCurrency ?? "";
    message.incomingTotalPledgesValuationBaseCurrency = object.incomingTotalPledgesValuationBaseCurrency ?? "";
    message.publicSubname = object.publicSubname ?? "";
    message.legalEntityIdentifier = object.legalEntityIdentifier ?? "";
    message.attributes = object.attributes?.map((e) => TnParticipantAttribute.fromPartial(e)) || [];
    message.status = object.status ?? "";
    message.tnLendingOffers = object.tnLendingOffers?.map((e) => TnLendingOffer.fromPartial(e)) || [];
    message.defaultSharedAddresses =
      (object.defaultSharedAddresses !== undefined && object.defaultSharedAddresses !== null)
        ? DefaultSharedAddresses.fromPartial(object.defaultSharedAddresses)
        : undefined;
    return message;
  },
};

function createBaseTnParticipantAttribute(): TnParticipantAttribute {
  return {
    id: "",
    key: "",
    value: "",
    owner: "",
    type: "",
    subtype: "",
    contentType: "",
    isTaurusNetworkShared: false,
  };
}

export const TnParticipantAttribute = {
  encode(message: TnParticipantAttribute, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.id !== "") {
      writer.uint32(10).string(message.id);
    }
    if (message.key !== "") {
      writer.uint32(18).string(message.key);
    }
    if (message.value !== "") {
      writer.uint32(26).string(message.value);
    }
    if (message.owner !== "") {
      writer.uint32(34).string(message.owner);
    }
    if (message.type !== "") {
      writer.uint32(42).string(message.type);
    }
    if (message.subtype !== "") {
      writer.uint32(50).string(message.subtype);
    }
    if (message.contentType !== "") {
      writer.uint32(58).string(message.contentType);
    }
    if (message.isTaurusNetworkShared !== false) {
      writer.uint32(64).bool(message.isTaurusNetworkShared);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): TnParticipantAttribute {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseTnParticipantAttribute();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.id = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.key = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.value = reader.string();
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.owner = reader.string();
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.type = reader.string();
          continue;
        case 6:
          if (tag !== 50) {
            break;
          }

          message.subtype = reader.string();
          continue;
        case 7:
          if (tag !== 58) {
            break;
          }

          message.contentType = reader.string();
          continue;
        case 8:
          if (tag !== 64) {
            break;
          }

          message.isTaurusNetworkShared = reader.bool();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): TnParticipantAttribute {
    return {
      id: isSet(object.id) ? globalThis.String(object.id) : "",
      key: isSet(object.key) ? globalThis.String(object.key) : "",
      value: isSet(object.value) ? globalThis.String(object.value) : "",
      owner: isSet(object.owner) ? globalThis.String(object.owner) : "",
      type: isSet(object.type) ? globalThis.String(object.type) : "",
      subtype: isSet(object.subtype) ? globalThis.String(object.subtype) : "",
      contentType: isSet(object.contentType) ? globalThis.String(object.contentType) : "",
      isTaurusNetworkShared: isSet(object.isTaurusNetworkShared)
        ? globalThis.Boolean(object.isTaurusNetworkShared)
        : false,
    };
  },

  toJSON(message: TnParticipantAttribute): unknown {
    const obj: any = {};
    if (message.id !== "") {
      obj.id = message.id;
    }
    if (message.key !== "") {
      obj.key = message.key;
    }
    if (message.value !== "") {
      obj.value = message.value;
    }
    if (message.owner !== "") {
      obj.owner = message.owner;
    }
    if (message.type !== "") {
      obj.type = message.type;
    }
    if (message.subtype !== "") {
      obj.subtype = message.subtype;
    }
    if (message.contentType !== "") {
      obj.contentType = message.contentType;
    }
    if (message.isTaurusNetworkShared !== false) {
      obj.isTaurusNetworkShared = message.isTaurusNetworkShared;
    }
    return obj;
  },

  create(base?: DeepPartial<TnParticipantAttribute>): TnParticipantAttribute {
    return TnParticipantAttribute.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<TnParticipantAttribute>): TnParticipantAttribute {
    const message = createBaseTnParticipantAttribute();
    message.id = object.id ?? "";
    message.key = object.key ?? "";
    message.value = object.value ?? "";
    message.owner = object.owner ?? "";
    message.type = object.type ?? "";
    message.subtype = object.subtype ?? "";
    message.contentType = object.contentType ?? "";
    message.isTaurusNetworkShared = object.isTaurusNetworkShared ?? false;
    return message;
  },
};

function createBaseBlockConfirmations(): BlockConfirmations {
  return { blockchain: "", network: "", confirmationsThreshold: 0 };
}

export const BlockConfirmations = {
  encode(message: BlockConfirmations, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.blockchain !== "") {
      writer.uint32(10).string(message.blockchain);
    }
    if (message.network !== "") {
      writer.uint32(18).string(message.network);
    }
    if (message.confirmationsThreshold !== 0) {
      writer.uint32(24).uint64(message.confirmationsThreshold);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): BlockConfirmations {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseBlockConfirmations();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.blockchain = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.network = reader.string();
          continue;
        case 3:
          if (tag !== 24) {
            break;
          }

          message.confirmationsThreshold = longToNumber(reader.uint64() as Long);
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): BlockConfirmations {
    return {
      blockchain: isSet(object.blockchain) ? globalThis.String(object.blockchain) : "",
      network: isSet(object.network) ? globalThis.String(object.network) : "",
      confirmationsThreshold: isSet(object.confirmationsThreshold)
        ? globalThis.Number(object.confirmationsThreshold)
        : 0,
    };
  },

  toJSON(message: BlockConfirmations): unknown {
    const obj: any = {};
    if (message.blockchain !== "") {
      obj.blockchain = message.blockchain;
    }
    if (message.network !== "") {
      obj.network = message.network;
    }
    if (message.confirmationsThreshold !== 0) {
      obj.confirmationsThreshold = Math.round(message.confirmationsThreshold);
    }
    return obj;
  },

  create(base?: DeepPartial<BlockConfirmations>): BlockConfirmations {
    return BlockConfirmations.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<BlockConfirmations>): BlockConfirmations {
    const message = createBaseBlockConfirmations();
    message.blockchain = object.blockchain ?? "";
    message.network = object.network ?? "";
    message.confirmationsThreshold = object.confirmationsThreshold ?? 0;
    return message;
  },
};

function createBaseDefaultSharedAddress(): DefaultSharedAddress {
  return { blockchain: "", network: "", sharedAddressID: "" };
}

export const DefaultSharedAddress = {
  encode(message: DefaultSharedAddress, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.blockchain !== "") {
      writer.uint32(10).string(message.blockchain);
    }
    if (message.network !== "") {
      writer.uint32(18).string(message.network);
    }
    if (message.sharedAddressID !== "") {
      writer.uint32(26).string(message.sharedAddressID);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): DefaultSharedAddress {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseDefaultSharedAddress();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.blockchain = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.network = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.sharedAddressID = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): DefaultSharedAddress {
    return {
      blockchain: isSet(object.blockchain) ? globalThis.String(object.blockchain) : "",
      network: isSet(object.network) ? globalThis.String(object.network) : "",
      sharedAddressID: isSet(object.sharedAddressID) ? globalThis.String(object.sharedAddressID) : "",
    };
  },

  toJSON(message: DefaultSharedAddress): unknown {
    const obj: any = {};
    if (message.blockchain !== "") {
      obj.blockchain = message.blockchain;
    }
    if (message.network !== "") {
      obj.network = message.network;
    }
    if (message.sharedAddressID !== "") {
      obj.sharedAddressID = message.sharedAddressID;
    }
    return obj;
  },

  create(base?: DeepPartial<DefaultSharedAddress>): DefaultSharedAddress {
    return DefaultSharedAddress.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<DefaultSharedAddress>): DefaultSharedAddress {
    const message = createBaseDefaultSharedAddress();
    message.blockchain = object.blockchain ?? "";
    message.network = object.network ?? "";
    message.sharedAddressID = object.sharedAddressID ?? "";
    return message;
  },
};

function createBaseDefaultSharedAddresses(): DefaultSharedAddresses {
  return { outgoingDefaultSharedAddresses: [], incomingDefaultSharedAddresses: [] };
}

export const DefaultSharedAddresses = {
  encode(message: DefaultSharedAddresses, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    for (const v of message.outgoingDefaultSharedAddresses) {
      DefaultSharedAddress.encode(v!, writer.uint32(10).fork()).ldelim();
    }
    for (const v of message.incomingDefaultSharedAddresses) {
      DefaultSharedAddress.encode(v!, writer.uint32(18).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): DefaultSharedAddresses {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseDefaultSharedAddresses();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.outgoingDefaultSharedAddresses.push(DefaultSharedAddress.decode(reader, reader.uint32()));
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.incomingDefaultSharedAddresses.push(DefaultSharedAddress.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): DefaultSharedAddresses {
    return {
      outgoingDefaultSharedAddresses: globalThis.Array.isArray(object?.outgoingDefaultSharedAddresses)
        ? object.outgoingDefaultSharedAddresses.map((e: any) => DefaultSharedAddress.fromJSON(e))
        : [],
      incomingDefaultSharedAddresses: globalThis.Array.isArray(object?.incomingDefaultSharedAddresses)
        ? object.incomingDefaultSharedAddresses.map((e: any) => DefaultSharedAddress.fromJSON(e))
        : [],
    };
  },

  toJSON(message: DefaultSharedAddresses): unknown {
    const obj: any = {};
    if (message.outgoingDefaultSharedAddresses?.length) {
      obj.outgoingDefaultSharedAddresses = message.outgoingDefaultSharedAddresses.map((e) =>
        DefaultSharedAddress.toJSON(e)
      );
    }
    if (message.incomingDefaultSharedAddresses?.length) {
      obj.incomingDefaultSharedAddresses = message.incomingDefaultSharedAddresses.map((e) =>
        DefaultSharedAddress.toJSON(e)
      );
    }
    return obj;
  },

  create(base?: DeepPartial<DefaultSharedAddresses>): DefaultSharedAddresses {
    return DefaultSharedAddresses.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<DefaultSharedAddresses>): DefaultSharedAddresses {
    const message = createBaseDefaultSharedAddresses();
    message.outgoingDefaultSharedAddresses =
      object.outgoingDefaultSharedAddresses?.map((e) => DefaultSharedAddress.fromPartial(e)) || [];
    message.incomingDefaultSharedAddresses =
      object.incomingDefaultSharedAddresses?.map((e) => DefaultSharedAddress.fromPartial(e)) || [];
    return message;
  },
};

function createBaseTnParticipantDetails(): TnParticipantDetails {
  return { contactPersons: [], attributesSpecifications: [], supportedBlockchains: [] };
}

export const TnParticipantDetails = {
  encode(message: TnParticipantDetails, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    for (const v of message.contactPersons) {
      TnContactPerson.encode(v!, writer.uint32(10).fork()).ldelim();
    }
    for (const v of message.attributesSpecifications) {
      TnParticipantAttributeSpecification.encode(v!, writer.uint32(18).fork()).ldelim();
    }
    for (const v of message.supportedBlockchains) {
      BlockchainEntity.encode(v!, writer.uint32(26).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): TnParticipantDetails {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseTnParticipantDetails();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.contactPersons.push(TnContactPerson.decode(reader, reader.uint32()));
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.attributesSpecifications.push(TnParticipantAttributeSpecification.decode(reader, reader.uint32()));
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.supportedBlockchains.push(BlockchainEntity.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): TnParticipantDetails {
    return {
      contactPersons: globalThis.Array.isArray(object?.contactPersons)
        ? object.contactPersons.map((e: any) => TnContactPerson.fromJSON(e))
        : [],
      attributesSpecifications: globalThis.Array.isArray(object?.attributesSpecifications)
        ? object.attributesSpecifications.map((e: any) => TnParticipantAttributeSpecification.fromJSON(e))
        : [],
      supportedBlockchains: globalThis.Array.isArray(object?.supportedBlockchains)
        ? object.supportedBlockchains.map((e: any) => BlockchainEntity.fromJSON(e))
        : [],
    };
  },

  toJSON(message: TnParticipantDetails): unknown {
    const obj: any = {};
    if (message.contactPersons?.length) {
      obj.contactPersons = message.contactPersons.map((e) => TnContactPerson.toJSON(e));
    }
    if (message.attributesSpecifications?.length) {
      obj.attributesSpecifications = message.attributesSpecifications.map((e) =>
        TnParticipantAttributeSpecification.toJSON(e)
      );
    }
    if (message.supportedBlockchains?.length) {
      obj.supportedBlockchains = message.supportedBlockchains.map((e) => BlockchainEntity.toJSON(e));
    }
    return obj;
  },

  create(base?: DeepPartial<TnParticipantDetails>): TnParticipantDetails {
    return TnParticipantDetails.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<TnParticipantDetails>): TnParticipantDetails {
    const message = createBaseTnParticipantDetails();
    message.contactPersons = object.contactPersons?.map((e) => TnContactPerson.fromPartial(e)) || [];
    message.attributesSpecifications =
      object.attributesSpecifications?.map((e) => TnParticipantAttributeSpecification.fromPartial(e)) || [];
    message.supportedBlockchains = object.supportedBlockchains?.map((e) => BlockchainEntity.fromPartial(e)) || [];
    return message;
  },
};

function createBaseLendingAgreement(): LendingAgreement {
  return {
    id: "",
    lenderParticipantID: "",
    borrowerParticipantID: "",
    lendingOfferID: "",
    amount: "",
    currencyID: "",
    annualYield: 0,
    status: "",
    duration: undefined,
    startLoanDate: undefined,
    workflowID: "",
    borrowerSharedAddressID: "",
    lenderSharedAddressID: "",
    lendingAgreementCollaterals: [],
    lendingAgreementTransactions: [],
    createdAt: undefined,
    updatedAt: undefined,
    annualYieldMainUnit: "",
    currencyInfo: undefined,
    amountMainUnit: "",
    repaymentDueDate: undefined,
  };
}

export const LendingAgreement = {
  encode(message: LendingAgreement, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.id !== "") {
      writer.uint32(10).string(message.id);
    }
    if (message.lenderParticipantID !== "") {
      writer.uint32(18).string(message.lenderParticipantID);
    }
    if (message.borrowerParticipantID !== "") {
      writer.uint32(26).string(message.borrowerParticipantID);
    }
    if (message.lendingOfferID !== "") {
      writer.uint32(34).string(message.lendingOfferID);
    }
    if (message.amount !== "") {
      writer.uint32(42).string(message.amount);
    }
    if (message.currencyID !== "") {
      writer.uint32(50).string(message.currencyID);
    }
    if (message.annualYield !== 0) {
      writer.uint32(56).uint64(message.annualYield);
    }
    if (message.status !== "") {
      writer.uint32(66).string(message.status);
    }
    if (message.duration !== undefined) {
      Duration.encode(message.duration, writer.uint32(74).fork()).ldelim();
    }
    if (message.startLoanDate !== undefined) {
      Timestamp.encode(toTimestamp(message.startLoanDate), writer.uint32(82).fork()).ldelim();
    }
    if (message.workflowID !== "") {
      writer.uint32(90).string(message.workflowID);
    }
    if (message.borrowerSharedAddressID !== "") {
      writer.uint32(98).string(message.borrowerSharedAddressID);
    }
    if (message.lenderSharedAddressID !== "") {
      writer.uint32(106).string(message.lenderSharedAddressID);
    }
    for (const v of message.lendingAgreementCollaterals) {
      LendingAgreementCollateral.encode(v!, writer.uint32(114).fork()).ldelim();
    }
    for (const v of message.lendingAgreementTransactions) {
      LendingAgreementTransaction.encode(v!, writer.uint32(122).fork()).ldelim();
    }
    if (message.createdAt !== undefined) {
      Timestamp.encode(toTimestamp(message.createdAt), writer.uint32(130).fork()).ldelim();
    }
    if (message.updatedAt !== undefined) {
      Timestamp.encode(toTimestamp(message.updatedAt), writer.uint32(138).fork()).ldelim();
    }
    if (message.annualYieldMainUnit !== "") {
      writer.uint32(146).string(message.annualYieldMainUnit);
    }
    if (message.currencyInfo !== undefined) {
      Currency.encode(message.currencyInfo, writer.uint32(154).fork()).ldelim();
    }
    if (message.amountMainUnit !== "") {
      writer.uint32(162).string(message.amountMainUnit);
    }
    if (message.repaymentDueDate !== undefined) {
      Timestamp.encode(toTimestamp(message.repaymentDueDate), writer.uint32(170).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): LendingAgreement {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseLendingAgreement();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.id = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.lenderParticipantID = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.borrowerParticipantID = reader.string();
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.lendingOfferID = reader.string();
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.amount = reader.string();
          continue;
        case 6:
          if (tag !== 50) {
            break;
          }

          message.currencyID = reader.string();
          continue;
        case 7:
          if (tag !== 56) {
            break;
          }

          message.annualYield = longToNumber(reader.uint64() as Long);
          continue;
        case 8:
          if (tag !== 66) {
            break;
          }

          message.status = reader.string();
          continue;
        case 9:
          if (tag !== 74) {
            break;
          }

          message.duration = Duration.decode(reader, reader.uint32());
          continue;
        case 10:
          if (tag !== 82) {
            break;
          }

          message.startLoanDate = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        case 11:
          if (tag !== 90) {
            break;
          }

          message.workflowID = reader.string();
          continue;
        case 12:
          if (tag !== 98) {
            break;
          }

          message.borrowerSharedAddressID = reader.string();
          continue;
        case 13:
          if (tag !== 106) {
            break;
          }

          message.lenderSharedAddressID = reader.string();
          continue;
        case 14:
          if (tag !== 114) {
            break;
          }

          message.lendingAgreementCollaterals.push(LendingAgreementCollateral.decode(reader, reader.uint32()));
          continue;
        case 15:
          if (tag !== 122) {
            break;
          }

          message.lendingAgreementTransactions.push(LendingAgreementTransaction.decode(reader, reader.uint32()));
          continue;
        case 16:
          if (tag !== 130) {
            break;
          }

          message.createdAt = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        case 17:
          if (tag !== 138) {
            break;
          }

          message.updatedAt = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        case 18:
          if (tag !== 146) {
            break;
          }

          message.annualYieldMainUnit = reader.string();
          continue;
        case 19:
          if (tag !== 154) {
            break;
          }

          message.currencyInfo = Currency.decode(reader, reader.uint32());
          continue;
        case 20:
          if (tag !== 162) {
            break;
          }

          message.amountMainUnit = reader.string();
          continue;
        case 21:
          if (tag !== 170) {
            break;
          }

          message.repaymentDueDate = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): LendingAgreement {
    return {
      id: isSet(object.id) ? globalThis.String(object.id) : "",
      lenderParticipantID: isSet(object.lenderParticipantID) ? globalThis.String(object.lenderParticipantID) : "",
      borrowerParticipantID: isSet(object.borrowerParticipantID) ? globalThis.String(object.borrowerParticipantID) : "",
      lendingOfferID: isSet(object.lendingOfferID) ? globalThis.String(object.lendingOfferID) : "",
      amount: isSet(object.amount) ? globalThis.String(object.amount) : "",
      currencyID: isSet(object.currencyID) ? globalThis.String(object.currencyID) : "",
      annualYield: isSet(object.annualYield) ? globalThis.Number(object.annualYield) : 0,
      status: isSet(object.status) ? globalThis.String(object.status) : "",
      duration: isSet(object.duration) ? Duration.fromJSON(object.duration) : undefined,
      startLoanDate: isSet(object.startLoanDate) ? fromJsonTimestamp(object.startLoanDate) : undefined,
      workflowID: isSet(object.workflowID) ? globalThis.String(object.workflowID) : "",
      borrowerSharedAddressID: isSet(object.borrowerSharedAddressID)
        ? globalThis.String(object.borrowerSharedAddressID)
        : "",
      lenderSharedAddressID: isSet(object.lenderSharedAddressID) ? globalThis.String(object.lenderSharedAddressID) : "",
      lendingAgreementCollaterals: globalThis.Array.isArray(object?.lendingAgreementCollaterals)
        ? object.lendingAgreementCollaterals.map((e: any) => LendingAgreementCollateral.fromJSON(e))
        : [],
      lendingAgreementTransactions: globalThis.Array.isArray(object?.lendingAgreementTransactions)
        ? object.lendingAgreementTransactions.map((e: any) => LendingAgreementTransaction.fromJSON(e))
        : [],
      createdAt: isSet(object.createdAt) ? fromJsonTimestamp(object.createdAt) : undefined,
      updatedAt: isSet(object.updatedAt) ? fromJsonTimestamp(object.updatedAt) : undefined,
      annualYieldMainUnit: isSet(object.annualYieldMainUnit) ? globalThis.String(object.annualYieldMainUnit) : "",
      currencyInfo: isSet(object.currencyInfo) ? Currency.fromJSON(object.currencyInfo) : undefined,
      amountMainUnit: isSet(object.amountMainUnit) ? globalThis.String(object.amountMainUnit) : "",
      repaymentDueDate: isSet(object.repaymentDueDate) ? fromJsonTimestamp(object.repaymentDueDate) : undefined,
    };
  },

  toJSON(message: LendingAgreement): unknown {
    const obj: any = {};
    if (message.id !== "") {
      obj.id = message.id;
    }
    if (message.lenderParticipantID !== "") {
      obj.lenderParticipantID = message.lenderParticipantID;
    }
    if (message.borrowerParticipantID !== "") {
      obj.borrowerParticipantID = message.borrowerParticipantID;
    }
    if (message.lendingOfferID !== "") {
      obj.lendingOfferID = message.lendingOfferID;
    }
    if (message.amount !== "") {
      obj.amount = message.amount;
    }
    if (message.currencyID !== "") {
      obj.currencyID = message.currencyID;
    }
    if (message.annualYield !== 0) {
      obj.annualYield = Math.round(message.annualYield);
    }
    if (message.status !== "") {
      obj.status = message.status;
    }
    if (message.duration !== undefined) {
      obj.duration = Duration.toJSON(message.duration);
    }
    if (message.startLoanDate !== undefined) {
      obj.startLoanDate = message.startLoanDate.toISOString();
    }
    if (message.workflowID !== "") {
      obj.workflowID = message.workflowID;
    }
    if (message.borrowerSharedAddressID !== "") {
      obj.borrowerSharedAddressID = message.borrowerSharedAddressID;
    }
    if (message.lenderSharedAddressID !== "") {
      obj.lenderSharedAddressID = message.lenderSharedAddressID;
    }
    if (message.lendingAgreementCollaterals?.length) {
      obj.lendingAgreementCollaterals = message.lendingAgreementCollaterals.map((e) =>
        LendingAgreementCollateral.toJSON(e)
      );
    }
    if (message.lendingAgreementTransactions?.length) {
      obj.lendingAgreementTransactions = message.lendingAgreementTransactions.map((e) =>
        LendingAgreementTransaction.toJSON(e)
      );
    }
    if (message.createdAt !== undefined) {
      obj.createdAt = message.createdAt.toISOString();
    }
    if (message.updatedAt !== undefined) {
      obj.updatedAt = message.updatedAt.toISOString();
    }
    if (message.annualYieldMainUnit !== "") {
      obj.annualYieldMainUnit = message.annualYieldMainUnit;
    }
    if (message.currencyInfo !== undefined) {
      obj.currencyInfo = Currency.toJSON(message.currencyInfo);
    }
    if (message.amountMainUnit !== "") {
      obj.amountMainUnit = message.amountMainUnit;
    }
    if (message.repaymentDueDate !== undefined) {
      obj.repaymentDueDate = message.repaymentDueDate.toISOString();
    }
    return obj;
  },

  create(base?: DeepPartial<LendingAgreement>): LendingAgreement {
    return LendingAgreement.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<LendingAgreement>): LendingAgreement {
    const message = createBaseLendingAgreement();
    message.id = object.id ?? "";
    message.lenderParticipantID = object.lenderParticipantID ?? "";
    message.borrowerParticipantID = object.borrowerParticipantID ?? "";
    message.lendingOfferID = object.lendingOfferID ?? "";
    message.amount = object.amount ?? "";
    message.currencyID = object.currencyID ?? "";
    message.annualYield = object.annualYield ?? 0;
    message.status = object.status ?? "";
    message.duration = (object.duration !== undefined && object.duration !== null)
      ? Duration.fromPartial(object.duration)
      : undefined;
    message.startLoanDate = object.startLoanDate ?? undefined;
    message.workflowID = object.workflowID ?? "";
    message.borrowerSharedAddressID = object.borrowerSharedAddressID ?? "";
    message.lenderSharedAddressID = object.lenderSharedAddressID ?? "";
    message.lendingAgreementCollaterals =
      object.lendingAgreementCollaterals?.map((e) => LendingAgreementCollateral.fromPartial(e)) || [];
    message.lendingAgreementTransactions =
      object.lendingAgreementTransactions?.map((e) => LendingAgreementTransaction.fromPartial(e)) || [];
    message.createdAt = object.createdAt ?? undefined;
    message.updatedAt = object.updatedAt ?? undefined;
    message.annualYieldMainUnit = object.annualYieldMainUnit ?? "";
    message.currencyInfo = (object.currencyInfo !== undefined && object.currencyInfo !== null)
      ? Currency.fromPartial(object.currencyInfo)
      : undefined;
    message.amountMainUnit = object.amountMainUnit ?? "";
    message.repaymentDueDate = object.repaymentDueDate ?? undefined;
    return message;
  },
};

function createBaseLendingAgreementCollateral(): LendingAgreementCollateral {
  return {
    id: "",
    lenderParticipantID: "",
    borrowerParticipantID: "",
    lendingAgreementID: "",
    amount: "",
    currencyID: "",
    status: "",
    pledgeID: "",
    sharedAddressID: "",
    createdAt: undefined,
    updatedAt: undefined,
    currencyInfo: undefined,
    amountMainUnit: "",
    pledgeActionID: "",
  };
}

export const LendingAgreementCollateral = {
  encode(message: LendingAgreementCollateral, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.id !== "") {
      writer.uint32(10).string(message.id);
    }
    if (message.lenderParticipantID !== "") {
      writer.uint32(18).string(message.lenderParticipantID);
    }
    if (message.borrowerParticipantID !== "") {
      writer.uint32(26).string(message.borrowerParticipantID);
    }
    if (message.lendingAgreementID !== "") {
      writer.uint32(34).string(message.lendingAgreementID);
    }
    if (message.amount !== "") {
      writer.uint32(42).string(message.amount);
    }
    if (message.currencyID !== "") {
      writer.uint32(50).string(message.currencyID);
    }
    if (message.status !== "") {
      writer.uint32(58).string(message.status);
    }
    if (message.pledgeID !== "") {
      writer.uint32(66).string(message.pledgeID);
    }
    if (message.sharedAddressID !== "") {
      writer.uint32(74).string(message.sharedAddressID);
    }
    if (message.createdAt !== undefined) {
      Timestamp.encode(toTimestamp(message.createdAt), writer.uint32(82).fork()).ldelim();
    }
    if (message.updatedAt !== undefined) {
      Timestamp.encode(toTimestamp(message.updatedAt), writer.uint32(90).fork()).ldelim();
    }
    if (message.currencyInfo !== undefined) {
      Currency.encode(message.currencyInfo, writer.uint32(98).fork()).ldelim();
    }
    if (message.amountMainUnit !== "") {
      writer.uint32(106).string(message.amountMainUnit);
    }
    if (message.pledgeActionID !== "") {
      writer.uint32(114).string(message.pledgeActionID);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): LendingAgreementCollateral {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseLendingAgreementCollateral();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.id = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.lenderParticipantID = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.borrowerParticipantID = reader.string();
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.lendingAgreementID = reader.string();
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.amount = reader.string();
          continue;
        case 6:
          if (tag !== 50) {
            break;
          }

          message.currencyID = reader.string();
          continue;
        case 7:
          if (tag !== 58) {
            break;
          }

          message.status = reader.string();
          continue;
        case 8:
          if (tag !== 66) {
            break;
          }

          message.pledgeID = reader.string();
          continue;
        case 9:
          if (tag !== 74) {
            break;
          }

          message.sharedAddressID = reader.string();
          continue;
        case 10:
          if (tag !== 82) {
            break;
          }

          message.createdAt = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        case 11:
          if (tag !== 90) {
            break;
          }

          message.updatedAt = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        case 12:
          if (tag !== 98) {
            break;
          }

          message.currencyInfo = Currency.decode(reader, reader.uint32());
          continue;
        case 13:
          if (tag !== 106) {
            break;
          }

          message.amountMainUnit = reader.string();
          continue;
        case 14:
          if (tag !== 114) {
            break;
          }

          message.pledgeActionID = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): LendingAgreementCollateral {
    return {
      id: isSet(object.id) ? globalThis.String(object.id) : "",
      lenderParticipantID: isSet(object.lenderParticipantID) ? globalThis.String(object.lenderParticipantID) : "",
      borrowerParticipantID: isSet(object.borrowerParticipantID) ? globalThis.String(object.borrowerParticipantID) : "",
      lendingAgreementID: isSet(object.lendingAgreementID) ? globalThis.String(object.lendingAgreementID) : "",
      amount: isSet(object.amount) ? globalThis.String(object.amount) : "",
      currencyID: isSet(object.currencyID) ? globalThis.String(object.currencyID) : "",
      status: isSet(object.status) ? globalThis.String(object.status) : "",
      pledgeID: isSet(object.pledgeID) ? globalThis.String(object.pledgeID) : "",
      sharedAddressID: isSet(object.sharedAddressID) ? globalThis.String(object.sharedAddressID) : "",
      createdAt: isSet(object.createdAt) ? fromJsonTimestamp(object.createdAt) : undefined,
      updatedAt: isSet(object.updatedAt) ? fromJsonTimestamp(object.updatedAt) : undefined,
      currencyInfo: isSet(object.currencyInfo) ? Currency.fromJSON(object.currencyInfo) : undefined,
      amountMainUnit: isSet(object.amountMainUnit) ? globalThis.String(object.amountMainUnit) : "",
      pledgeActionID: isSet(object.pledgeActionID) ? globalThis.String(object.pledgeActionID) : "",
    };
  },

  toJSON(message: LendingAgreementCollateral): unknown {
    const obj: any = {};
    if (message.id !== "") {
      obj.id = message.id;
    }
    if (message.lenderParticipantID !== "") {
      obj.lenderParticipantID = message.lenderParticipantID;
    }
    if (message.borrowerParticipantID !== "") {
      obj.borrowerParticipantID = message.borrowerParticipantID;
    }
    if (message.lendingAgreementID !== "") {
      obj.lendingAgreementID = message.lendingAgreementID;
    }
    if (message.amount !== "") {
      obj.amount = message.amount;
    }
    if (message.currencyID !== "") {
      obj.currencyID = message.currencyID;
    }
    if (message.status !== "") {
      obj.status = message.status;
    }
    if (message.pledgeID !== "") {
      obj.pledgeID = message.pledgeID;
    }
    if (message.sharedAddressID !== "") {
      obj.sharedAddressID = message.sharedAddressID;
    }
    if (message.createdAt !== undefined) {
      obj.createdAt = message.createdAt.toISOString();
    }
    if (message.updatedAt !== undefined) {
      obj.updatedAt = message.updatedAt.toISOString();
    }
    if (message.currencyInfo !== undefined) {
      obj.currencyInfo = Currency.toJSON(message.currencyInfo);
    }
    if (message.amountMainUnit !== "") {
      obj.amountMainUnit = message.amountMainUnit;
    }
    if (message.pledgeActionID !== "") {
      obj.pledgeActionID = message.pledgeActionID;
    }
    return obj;
  },

  create(base?: DeepPartial<LendingAgreementCollateral>): LendingAgreementCollateral {
    return LendingAgreementCollateral.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<LendingAgreementCollateral>): LendingAgreementCollateral {
    const message = createBaseLendingAgreementCollateral();
    message.id = object.id ?? "";
    message.lenderParticipantID = object.lenderParticipantID ?? "";
    message.borrowerParticipantID = object.borrowerParticipantID ?? "";
    message.lendingAgreementID = object.lendingAgreementID ?? "";
    message.amount = object.amount ?? "";
    message.currencyID = object.currencyID ?? "";
    message.status = object.status ?? "";
    message.pledgeID = object.pledgeID ?? "";
    message.sharedAddressID = object.sharedAddressID ?? "";
    message.createdAt = object.createdAt ?? undefined;
    message.updatedAt = object.updatedAt ?? undefined;
    message.currencyInfo = (object.currencyInfo !== undefined && object.currencyInfo !== null)
      ? Currency.fromPartial(object.currencyInfo)
      : undefined;
    message.amountMainUnit = object.amountMainUnit ?? "";
    message.pledgeActionID = object.pledgeActionID ?? "";
    return message;
  },
};

function createBaseLendingAgreementTransaction(): LendingAgreementTransaction {
  return {
    id: "",
    lendingAgreementID: "",
    amount: "",
    currencyID: "",
    requestID: 0,
    transactionID: 0,
    transactionHash: "",
    transactionBlockNumber: 0,
    type: "",
    amountMainUnit: "",
    currencyInfo: undefined,
    createdAt: undefined,
    updatedAt: undefined,
  };
}

export const LendingAgreementTransaction = {
  encode(message: LendingAgreementTransaction, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.id !== "") {
      writer.uint32(10).string(message.id);
    }
    if (message.lendingAgreementID !== "") {
      writer.uint32(18).string(message.lendingAgreementID);
    }
    if (message.amount !== "") {
      writer.uint32(26).string(message.amount);
    }
    if (message.currencyID !== "") {
      writer.uint32(34).string(message.currencyID);
    }
    if (message.requestID !== 0) {
      writer.uint32(40).uint64(message.requestID);
    }
    if (message.transactionID !== 0) {
      writer.uint32(48).uint64(message.transactionID);
    }
    if (message.transactionHash !== "") {
      writer.uint32(58).string(message.transactionHash);
    }
    if (message.transactionBlockNumber !== 0) {
      writer.uint32(64).uint64(message.transactionBlockNumber);
    }
    if (message.type !== "") {
      writer.uint32(74).string(message.type);
    }
    if (message.amountMainUnit !== "") {
      writer.uint32(82).string(message.amountMainUnit);
    }
    if (message.currencyInfo !== undefined) {
      Currency.encode(message.currencyInfo, writer.uint32(90).fork()).ldelim();
    }
    if (message.createdAt !== undefined) {
      Timestamp.encode(toTimestamp(message.createdAt), writer.uint32(98).fork()).ldelim();
    }
    if (message.updatedAt !== undefined) {
      Timestamp.encode(toTimestamp(message.updatedAt), writer.uint32(106).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): LendingAgreementTransaction {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseLendingAgreementTransaction();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.id = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.lendingAgreementID = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.amount = reader.string();
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.currencyID = reader.string();
          continue;
        case 5:
          if (tag !== 40) {
            break;
          }

          message.requestID = longToNumber(reader.uint64() as Long);
          continue;
        case 6:
          if (tag !== 48) {
            break;
          }

          message.transactionID = longToNumber(reader.uint64() as Long);
          continue;
        case 7:
          if (tag !== 58) {
            break;
          }

          message.transactionHash = reader.string();
          continue;
        case 8:
          if (tag !== 64) {
            break;
          }

          message.transactionBlockNumber = longToNumber(reader.uint64() as Long);
          continue;
        case 9:
          if (tag !== 74) {
            break;
          }

          message.type = reader.string();
          continue;
        case 10:
          if (tag !== 82) {
            break;
          }

          message.amountMainUnit = reader.string();
          continue;
        case 11:
          if (tag !== 90) {
            break;
          }

          message.currencyInfo = Currency.decode(reader, reader.uint32());
          continue;
        case 12:
          if (tag !== 98) {
            break;
          }

          message.createdAt = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        case 13:
          if (tag !== 106) {
            break;
          }

          message.updatedAt = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): LendingAgreementTransaction {
    return {
      id: isSet(object.id) ? globalThis.String(object.id) : "",
      lendingAgreementID: isSet(object.lendingAgreementID) ? globalThis.String(object.lendingAgreementID) : "",
      amount: isSet(object.amount) ? globalThis.String(object.amount) : "",
      currencyID: isSet(object.currencyID) ? globalThis.String(object.currencyID) : "",
      requestID: isSet(object.requestID) ? globalThis.Number(object.requestID) : 0,
      transactionID: isSet(object.transactionID) ? globalThis.Number(object.transactionID) : 0,
      transactionHash: isSet(object.transactionHash) ? globalThis.String(object.transactionHash) : "",
      transactionBlockNumber: isSet(object.transactionBlockNumber)
        ? globalThis.Number(object.transactionBlockNumber)
        : 0,
      type: isSet(object.type) ? globalThis.String(object.type) : "",
      amountMainUnit: isSet(object.amountMainUnit) ? globalThis.String(object.amountMainUnit) : "",
      currencyInfo: isSet(object.currencyInfo) ? Currency.fromJSON(object.currencyInfo) : undefined,
      createdAt: isSet(object.createdAt) ? fromJsonTimestamp(object.createdAt) : undefined,
      updatedAt: isSet(object.updatedAt) ? fromJsonTimestamp(object.updatedAt) : undefined,
    };
  },

  toJSON(message: LendingAgreementTransaction): unknown {
    const obj: any = {};
    if (message.id !== "") {
      obj.id = message.id;
    }
    if (message.lendingAgreementID !== "") {
      obj.lendingAgreementID = message.lendingAgreementID;
    }
    if (message.amount !== "") {
      obj.amount = message.amount;
    }
    if (message.currencyID !== "") {
      obj.currencyID = message.currencyID;
    }
    if (message.requestID !== 0) {
      obj.requestID = Math.round(message.requestID);
    }
    if (message.transactionID !== 0) {
      obj.transactionID = Math.round(message.transactionID);
    }
    if (message.transactionHash !== "") {
      obj.transactionHash = message.transactionHash;
    }
    if (message.transactionBlockNumber !== 0) {
      obj.transactionBlockNumber = Math.round(message.transactionBlockNumber);
    }
    if (message.type !== "") {
      obj.type = message.type;
    }
    if (message.amountMainUnit !== "") {
      obj.amountMainUnit = message.amountMainUnit;
    }
    if (message.currencyInfo !== undefined) {
      obj.currencyInfo = Currency.toJSON(message.currencyInfo);
    }
    if (message.createdAt !== undefined) {
      obj.createdAt = message.createdAt.toISOString();
    }
    if (message.updatedAt !== undefined) {
      obj.updatedAt = message.updatedAt.toISOString();
    }
    return obj;
  },

  create(base?: DeepPartial<LendingAgreementTransaction>): LendingAgreementTransaction {
    return LendingAgreementTransaction.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<LendingAgreementTransaction>): LendingAgreementTransaction {
    const message = createBaseLendingAgreementTransaction();
    message.id = object.id ?? "";
    message.lendingAgreementID = object.lendingAgreementID ?? "";
    message.amount = object.amount ?? "";
    message.currencyID = object.currencyID ?? "";
    message.requestID = object.requestID ?? 0;
    message.transactionID = object.transactionID ?? 0;
    message.transactionHash = object.transactionHash ?? "";
    message.transactionBlockNumber = object.transactionBlockNumber ?? 0;
    message.type = object.type ?? "";
    message.amountMainUnit = object.amountMainUnit ?? "";
    message.currencyInfo = (object.currencyInfo !== undefined && object.currencyInfo !== null)
      ? Currency.fromPartial(object.currencyInfo)
      : undefined;
    message.createdAt = object.createdAt ?? undefined;
    message.updatedAt = object.updatedAt ?? undefined;
    return message;
  },
};

function createBaseLendingAgreementAttachment(): LendingAgreementAttachment {
  return {
    id: "",
    lendingAgreementID: "",
    uploaderParticipantID: "",
    name: "",
    type: "",
    contentType: "",
    value: "",
    fileSize: 0,
    createdAt: undefined,
    updatedAt: undefined,
  };
}

export const LendingAgreementAttachment = {
  encode(message: LendingAgreementAttachment, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.id !== "") {
      writer.uint32(10).string(message.id);
    }
    if (message.lendingAgreementID !== "") {
      writer.uint32(18).string(message.lendingAgreementID);
    }
    if (message.uploaderParticipantID !== "") {
      writer.uint32(26).string(message.uploaderParticipantID);
    }
    if (message.name !== "") {
      writer.uint32(34).string(message.name);
    }
    if (message.type !== "") {
      writer.uint32(42).string(message.type);
    }
    if (message.contentType !== "") {
      writer.uint32(50).string(message.contentType);
    }
    if (message.value !== "") {
      writer.uint32(58).string(message.value);
    }
    if (message.fileSize !== 0) {
      writer.uint32(64).uint64(message.fileSize);
    }
    if (message.createdAt !== undefined) {
      Timestamp.encode(toTimestamp(message.createdAt), writer.uint32(74).fork()).ldelim();
    }
    if (message.updatedAt !== undefined) {
      Timestamp.encode(toTimestamp(message.updatedAt), writer.uint32(82).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): LendingAgreementAttachment {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseLendingAgreementAttachment();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.id = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.lendingAgreementID = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.uploaderParticipantID = reader.string();
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.name = reader.string();
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.type = reader.string();
          continue;
        case 6:
          if (tag !== 50) {
            break;
          }

          message.contentType = reader.string();
          continue;
        case 7:
          if (tag !== 58) {
            break;
          }

          message.value = reader.string();
          continue;
        case 8:
          if (tag !== 64) {
            break;
          }

          message.fileSize = longToNumber(reader.uint64() as Long);
          continue;
        case 9:
          if (tag !== 74) {
            break;
          }

          message.createdAt = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        case 10:
          if (tag !== 82) {
            break;
          }

          message.updatedAt = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): LendingAgreementAttachment {
    return {
      id: isSet(object.id) ? globalThis.String(object.id) : "",
      lendingAgreementID: isSet(object.lendingAgreementID) ? globalThis.String(object.lendingAgreementID) : "",
      uploaderParticipantID: isSet(object.uploaderParticipantID) ? globalThis.String(object.uploaderParticipantID) : "",
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      type: isSet(object.type) ? globalThis.String(object.type) : "",
      contentType: isSet(object.contentType) ? globalThis.String(object.contentType) : "",
      value: isSet(object.value) ? globalThis.String(object.value) : "",
      fileSize: isSet(object.fileSize) ? globalThis.Number(object.fileSize) : 0,
      createdAt: isSet(object.createdAt) ? fromJsonTimestamp(object.createdAt) : undefined,
      updatedAt: isSet(object.updatedAt) ? fromJsonTimestamp(object.updatedAt) : undefined,
    };
  },

  toJSON(message: LendingAgreementAttachment): unknown {
    const obj: any = {};
    if (message.id !== "") {
      obj.id = message.id;
    }
    if (message.lendingAgreementID !== "") {
      obj.lendingAgreementID = message.lendingAgreementID;
    }
    if (message.uploaderParticipantID !== "") {
      obj.uploaderParticipantID = message.uploaderParticipantID;
    }
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.type !== "") {
      obj.type = message.type;
    }
    if (message.contentType !== "") {
      obj.contentType = message.contentType;
    }
    if (message.value !== "") {
      obj.value = message.value;
    }
    if (message.fileSize !== 0) {
      obj.fileSize = Math.round(message.fileSize);
    }
    if (message.createdAt !== undefined) {
      obj.createdAt = message.createdAt.toISOString();
    }
    if (message.updatedAt !== undefined) {
      obj.updatedAt = message.updatedAt.toISOString();
    }
    return obj;
  },

  create(base?: DeepPartial<LendingAgreementAttachment>): LendingAgreementAttachment {
    return LendingAgreementAttachment.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<LendingAgreementAttachment>): LendingAgreementAttachment {
    const message = createBaseLendingAgreementAttachment();
    message.id = object.id ?? "";
    message.lendingAgreementID = object.lendingAgreementID ?? "";
    message.uploaderParticipantID = object.uploaderParticipantID ?? "";
    message.name = object.name ?? "";
    message.type = object.type ?? "";
    message.contentType = object.contentType ?? "";
    message.value = object.value ?? "";
    message.fileSize = object.fileSize ?? 0;
    message.createdAt = object.createdAt ?? undefined;
    message.updatedAt = object.updatedAt ?? undefined;
    return message;
  },
};

function createBaseTnLendingOffer(): TnLendingOffer {
  return {
    id: "",
    annualPercentageYield: 0,
    duration: undefined,
    collateralRequirement: undefined,
    participantID: "",
    blockchain: "",
    network: "",
    arg1: "",
    arg2: "",
    currencyInfo: undefined,
    annualPercentageYieldMainUnit: "",
    originCreatedAt: undefined,
    createdAt: undefined,
    updatedAt: undefined,
    amount: "",
    amountMainUnit: "",
  };
}

export const TnLendingOffer = {
  encode(message: TnLendingOffer, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.id !== "") {
      writer.uint32(10).string(message.id);
    }
    if (message.annualPercentageYield !== 0) {
      writer.uint32(16).uint64(message.annualPercentageYield);
    }
    if (message.duration !== undefined) {
      Duration.encode(message.duration, writer.uint32(26).fork()).ldelim();
    }
    if (message.collateralRequirement !== undefined) {
      LendingCollateralRequirement.encode(message.collateralRequirement, writer.uint32(34).fork()).ldelim();
    }
    if (message.participantID !== "") {
      writer.uint32(42).string(message.participantID);
    }
    if (message.blockchain !== "") {
      writer.uint32(50).string(message.blockchain);
    }
    if (message.network !== "") {
      writer.uint32(58).string(message.network);
    }
    if (message.arg1 !== "") {
      writer.uint32(66).string(message.arg1);
    }
    if (message.arg2 !== "") {
      writer.uint32(74).string(message.arg2);
    }
    if (message.currencyInfo !== undefined) {
      Currency.encode(message.currencyInfo, writer.uint32(82).fork()).ldelim();
    }
    if (message.annualPercentageYieldMainUnit !== "") {
      writer.uint32(90).string(message.annualPercentageYieldMainUnit);
    }
    if (message.originCreatedAt !== undefined) {
      Timestamp.encode(toTimestamp(message.originCreatedAt), writer.uint32(98).fork()).ldelim();
    }
    if (message.createdAt !== undefined) {
      Timestamp.encode(toTimestamp(message.createdAt), writer.uint32(106).fork()).ldelim();
    }
    if (message.updatedAt !== undefined) {
      Timestamp.encode(toTimestamp(message.updatedAt), writer.uint32(114).fork()).ldelim();
    }
    if (message.amount !== "") {
      writer.uint32(122).string(message.amount);
    }
    if (message.amountMainUnit !== "") {
      writer.uint32(130).string(message.amountMainUnit);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): TnLendingOffer {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseTnLendingOffer();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.id = reader.string();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.annualPercentageYield = longToNumber(reader.uint64() as Long);
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.duration = Duration.decode(reader, reader.uint32());
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.collateralRequirement = LendingCollateralRequirement.decode(reader, reader.uint32());
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.participantID = reader.string();
          continue;
        case 6:
          if (tag !== 50) {
            break;
          }

          message.blockchain = reader.string();
          continue;
        case 7:
          if (tag !== 58) {
            break;
          }

          message.network = reader.string();
          continue;
        case 8:
          if (tag !== 66) {
            break;
          }

          message.arg1 = reader.string();
          continue;
        case 9:
          if (tag !== 74) {
            break;
          }

          message.arg2 = reader.string();
          continue;
        case 10:
          if (tag !== 82) {
            break;
          }

          message.currencyInfo = Currency.decode(reader, reader.uint32());
          continue;
        case 11:
          if (tag !== 90) {
            break;
          }

          message.annualPercentageYieldMainUnit = reader.string();
          continue;
        case 12:
          if (tag !== 98) {
            break;
          }

          message.originCreatedAt = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        case 13:
          if (tag !== 106) {
            break;
          }

          message.createdAt = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        case 14:
          if (tag !== 114) {
            break;
          }

          message.updatedAt = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        case 15:
          if (tag !== 122) {
            break;
          }

          message.amount = reader.string();
          continue;
        case 16:
          if (tag !== 130) {
            break;
          }

          message.amountMainUnit = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): TnLendingOffer {
    return {
      id: isSet(object.id) ? globalThis.String(object.id) : "",
      annualPercentageYield: isSet(object.annualPercentageYield) ? globalThis.Number(object.annualPercentageYield) : 0,
      duration: isSet(object.duration) ? Duration.fromJSON(object.duration) : undefined,
      collateralRequirement: isSet(object.collateralRequirement)
        ? LendingCollateralRequirement.fromJSON(object.collateralRequirement)
        : undefined,
      participantID: isSet(object.participantID) ? globalThis.String(object.participantID) : "",
      blockchain: isSet(object.blockchain) ? globalThis.String(object.blockchain) : "",
      network: isSet(object.network) ? globalThis.String(object.network) : "",
      arg1: isSet(object.arg1) ? globalThis.String(object.arg1) : "",
      arg2: isSet(object.arg2) ? globalThis.String(object.arg2) : "",
      currencyInfo: isSet(object.currencyInfo) ? Currency.fromJSON(object.currencyInfo) : undefined,
      annualPercentageYieldMainUnit: isSet(object.annualPercentageYieldMainUnit)
        ? globalThis.String(object.annualPercentageYieldMainUnit)
        : "",
      originCreatedAt: isSet(object.originCreatedAt) ? fromJsonTimestamp(object.originCreatedAt) : undefined,
      createdAt: isSet(object.createdAt) ? fromJsonTimestamp(object.createdAt) : undefined,
      updatedAt: isSet(object.updatedAt) ? fromJsonTimestamp(object.updatedAt) : undefined,
      amount: isSet(object.amount) ? globalThis.String(object.amount) : "",
      amountMainUnit: isSet(object.amountMainUnit) ? globalThis.String(object.amountMainUnit) : "",
    };
  },

  toJSON(message: TnLendingOffer): unknown {
    const obj: any = {};
    if (message.id !== "") {
      obj.id = message.id;
    }
    if (message.annualPercentageYield !== 0) {
      obj.annualPercentageYield = Math.round(message.annualPercentageYield);
    }
    if (message.duration !== undefined) {
      obj.duration = Duration.toJSON(message.duration);
    }
    if (message.collateralRequirement !== undefined) {
      obj.collateralRequirement = LendingCollateralRequirement.toJSON(message.collateralRequirement);
    }
    if (message.participantID !== "") {
      obj.participantID = message.participantID;
    }
    if (message.blockchain !== "") {
      obj.blockchain = message.blockchain;
    }
    if (message.network !== "") {
      obj.network = message.network;
    }
    if (message.arg1 !== "") {
      obj.arg1 = message.arg1;
    }
    if (message.arg2 !== "") {
      obj.arg2 = message.arg2;
    }
    if (message.currencyInfo !== undefined) {
      obj.currencyInfo = Currency.toJSON(message.currencyInfo);
    }
    if (message.annualPercentageYieldMainUnit !== "") {
      obj.annualPercentageYieldMainUnit = message.annualPercentageYieldMainUnit;
    }
    if (message.originCreatedAt !== undefined) {
      obj.originCreatedAt = message.originCreatedAt.toISOString();
    }
    if (message.createdAt !== undefined) {
      obj.createdAt = message.createdAt.toISOString();
    }
    if (message.updatedAt !== undefined) {
      obj.updatedAt = message.updatedAt.toISOString();
    }
    if (message.amount !== "") {
      obj.amount = message.amount;
    }
    if (message.amountMainUnit !== "") {
      obj.amountMainUnit = message.amountMainUnit;
    }
    return obj;
  },

  create(base?: DeepPartial<TnLendingOffer>): TnLendingOffer {
    return TnLendingOffer.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<TnLendingOffer>): TnLendingOffer {
    const message = createBaseTnLendingOffer();
    message.id = object.id ?? "";
    message.annualPercentageYield = object.annualPercentageYield ?? 0;
    message.duration = (object.duration !== undefined && object.duration !== null)
      ? Duration.fromPartial(object.duration)
      : undefined;
    message.collateralRequirement =
      (object.collateralRequirement !== undefined && object.collateralRequirement !== null)
        ? LendingCollateralRequirement.fromPartial(object.collateralRequirement)
        : undefined;
    message.participantID = object.participantID ?? "";
    message.blockchain = object.blockchain ?? "";
    message.network = object.network ?? "";
    message.arg1 = object.arg1 ?? "";
    message.arg2 = object.arg2 ?? "";
    message.currencyInfo = (object.currencyInfo !== undefined && object.currencyInfo !== null)
      ? Currency.fromPartial(object.currencyInfo)
      : undefined;
    message.annualPercentageYieldMainUnit = object.annualPercentageYieldMainUnit ?? "";
    message.originCreatedAt = object.originCreatedAt ?? undefined;
    message.createdAt = object.createdAt ?? undefined;
    message.updatedAt = object.updatedAt ?? undefined;
    message.amount = object.amount ?? "";
    message.amountMainUnit = object.amountMainUnit ?? "";
    return message;
  },
};

function createBaseTnLendingOffersDetails(): TnLendingOffersDetails {
  return { tnLendingOffersDetails: [] };
}

export const TnLendingOffersDetails = {
  encode(message: TnLendingOffersDetails, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    for (const v of message.tnLendingOffersDetails) {
      TnLendingOfferDetail.encode(v!, writer.uint32(10).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): TnLendingOffersDetails {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseTnLendingOffersDetails();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.tnLendingOffersDetails.push(TnLendingOfferDetail.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): TnLendingOffersDetails {
    return {
      tnLendingOffersDetails: globalThis.Array.isArray(object?.tnLendingOffersDetails)
        ? object.tnLendingOffersDetails.map((e: any) => TnLendingOfferDetail.fromJSON(e))
        : [],
    };
  },

  toJSON(message: TnLendingOffersDetails): unknown {
    const obj: any = {};
    if (message.tnLendingOffersDetails?.length) {
      obj.tnLendingOffersDetails = message.tnLendingOffersDetails.map((e) => TnLendingOfferDetail.toJSON(e));
    }
    return obj;
  },

  create(base?: DeepPartial<TnLendingOffersDetails>): TnLendingOffersDetails {
    return TnLendingOffersDetails.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<TnLendingOffersDetails>): TnLendingOffersDetails {
    const message = createBaseTnLendingOffersDetails();
    message.tnLendingOffersDetails = object.tnLendingOffersDetails?.map((e) => TnLendingOfferDetail.fromPartial(e)) ||
      [];
    return message;
  },
};

function createBaseTnLendingOfferDetail(): TnLendingOfferDetail {
  return {
    id: "",
    blockchain: "",
    network: "",
    arg1: "",
    arg2: "",
    annualPercentageYield: 0,
    duration: undefined,
    collateralRequirement: undefined,
    originCreatedAt: undefined,
    amount: "",
  };
}

export const TnLendingOfferDetail = {
  encode(message: TnLendingOfferDetail, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.id !== "") {
      writer.uint32(10).string(message.id);
    }
    if (message.blockchain !== "") {
      writer.uint32(18).string(message.blockchain);
    }
    if (message.network !== "") {
      writer.uint32(26).string(message.network);
    }
    if (message.arg1 !== "") {
      writer.uint32(34).string(message.arg1);
    }
    if (message.arg2 !== "") {
      writer.uint32(42).string(message.arg2);
    }
    if (message.annualPercentageYield !== 0) {
      writer.uint32(48).uint64(message.annualPercentageYield);
    }
    if (message.duration !== undefined) {
      Duration.encode(message.duration, writer.uint32(58).fork()).ldelim();
    }
    if (message.collateralRequirement !== undefined) {
      LendingCollateralRequirement.encode(message.collateralRequirement, writer.uint32(66).fork()).ldelim();
    }
    if (message.originCreatedAt !== undefined) {
      Timestamp.encode(toTimestamp(message.originCreatedAt), writer.uint32(74).fork()).ldelim();
    }
    if (message.amount !== "") {
      writer.uint32(82).string(message.amount);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): TnLendingOfferDetail {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseTnLendingOfferDetail();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.id = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.blockchain = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.network = reader.string();
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.arg1 = reader.string();
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.arg2 = reader.string();
          continue;
        case 6:
          if (tag !== 48) {
            break;
          }

          message.annualPercentageYield = longToNumber(reader.uint64() as Long);
          continue;
        case 7:
          if (tag !== 58) {
            break;
          }

          message.duration = Duration.decode(reader, reader.uint32());
          continue;
        case 8:
          if (tag !== 66) {
            break;
          }

          message.collateralRequirement = LendingCollateralRequirement.decode(reader, reader.uint32());
          continue;
        case 9:
          if (tag !== 74) {
            break;
          }

          message.originCreatedAt = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        case 10:
          if (tag !== 82) {
            break;
          }

          message.amount = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): TnLendingOfferDetail {
    return {
      id: isSet(object.id) ? globalThis.String(object.id) : "",
      blockchain: isSet(object.blockchain) ? globalThis.String(object.blockchain) : "",
      network: isSet(object.network) ? globalThis.String(object.network) : "",
      arg1: isSet(object.arg1) ? globalThis.String(object.arg1) : "",
      arg2: isSet(object.arg2) ? globalThis.String(object.arg2) : "",
      annualPercentageYield: isSet(object.annualPercentageYield) ? globalThis.Number(object.annualPercentageYield) : 0,
      duration: isSet(object.duration) ? Duration.fromJSON(object.duration) : undefined,
      collateralRequirement: isSet(object.collateralRequirement)
        ? LendingCollateralRequirement.fromJSON(object.collateralRequirement)
        : undefined,
      originCreatedAt: isSet(object.originCreatedAt) ? fromJsonTimestamp(object.originCreatedAt) : undefined,
      amount: isSet(object.amount) ? globalThis.String(object.amount) : "",
    };
  },

  toJSON(message: TnLendingOfferDetail): unknown {
    const obj: any = {};
    if (message.id !== "") {
      obj.id = message.id;
    }
    if (message.blockchain !== "") {
      obj.blockchain = message.blockchain;
    }
    if (message.network !== "") {
      obj.network = message.network;
    }
    if (message.arg1 !== "") {
      obj.arg1 = message.arg1;
    }
    if (message.arg2 !== "") {
      obj.arg2 = message.arg2;
    }
    if (message.annualPercentageYield !== 0) {
      obj.annualPercentageYield = Math.round(message.annualPercentageYield);
    }
    if (message.duration !== undefined) {
      obj.duration = Duration.toJSON(message.duration);
    }
    if (message.collateralRequirement !== undefined) {
      obj.collateralRequirement = LendingCollateralRequirement.toJSON(message.collateralRequirement);
    }
    if (message.originCreatedAt !== undefined) {
      obj.originCreatedAt = message.originCreatedAt.toISOString();
    }
    if (message.amount !== "") {
      obj.amount = message.amount;
    }
    return obj;
  },

  create(base?: DeepPartial<TnLendingOfferDetail>): TnLendingOfferDetail {
    return TnLendingOfferDetail.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<TnLendingOfferDetail>): TnLendingOfferDetail {
    const message = createBaseTnLendingOfferDetail();
    message.id = object.id ?? "";
    message.blockchain = object.blockchain ?? "";
    message.network = object.network ?? "";
    message.arg1 = object.arg1 ?? "";
    message.arg2 = object.arg2 ?? "";
    message.annualPercentageYield = object.annualPercentageYield ?? 0;
    message.duration = (object.duration !== undefined && object.duration !== null)
      ? Duration.fromPartial(object.duration)
      : undefined;
    message.collateralRequirement =
      (object.collateralRequirement !== undefined && object.collateralRequirement !== null)
        ? LendingCollateralRequirement.fromPartial(object.collateralRequirement)
        : undefined;
    message.originCreatedAt = object.originCreatedAt ?? undefined;
    message.amount = object.amount ?? "";
    return message;
  },
};

function createBaseLendingCollateralRequirement(): LendingCollateralRequirement {
  return { acceptedCurrencies: [] };
}

export const LendingCollateralRequirement = {
  encode(message: LendingCollateralRequirement, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    for (const v of message.acceptedCurrencies) {
      CurrencyCollateralRequirement.encode(v!, writer.uint32(10).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): LendingCollateralRequirement {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseLendingCollateralRequirement();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.acceptedCurrencies.push(CurrencyCollateralRequirement.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): LendingCollateralRequirement {
    return {
      acceptedCurrencies: globalThis.Array.isArray(object?.acceptedCurrencies)
        ? object.acceptedCurrencies.map((e: any) => CurrencyCollateralRequirement.fromJSON(e))
        : [],
    };
  },

  toJSON(message: LendingCollateralRequirement): unknown {
    const obj: any = {};
    if (message.acceptedCurrencies?.length) {
      obj.acceptedCurrencies = message.acceptedCurrencies.map((e) => CurrencyCollateralRequirement.toJSON(e));
    }
    return obj;
  },

  create(base?: DeepPartial<LendingCollateralRequirement>): LendingCollateralRequirement {
    return LendingCollateralRequirement.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<LendingCollateralRequirement>): LendingCollateralRequirement {
    const message = createBaseLendingCollateralRequirement();
    message.acceptedCurrencies = object.acceptedCurrencies?.map((e) => CurrencyCollateralRequirement.fromPartial(e)) ||
      [];
    return message;
  },
};

function createBaseCurrencyCollateralRequirement(): CurrencyCollateralRequirement {
  return { blockchain: "", network: "", arg1: "", arg2: "", ratio: "", currencyInfo: undefined };
}

export const CurrencyCollateralRequirement = {
  encode(message: CurrencyCollateralRequirement, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.blockchain !== "") {
      writer.uint32(10).string(message.blockchain);
    }
    if (message.network !== "") {
      writer.uint32(18).string(message.network);
    }
    if (message.arg1 !== "") {
      writer.uint32(26).string(message.arg1);
    }
    if (message.arg2 !== "") {
      writer.uint32(34).string(message.arg2);
    }
    if (message.ratio !== "") {
      writer.uint32(42).string(message.ratio);
    }
    if (message.currencyInfo !== undefined) {
      Currency.encode(message.currencyInfo, writer.uint32(50).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CurrencyCollateralRequirement {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCurrencyCollateralRequirement();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.blockchain = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.network = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.arg1 = reader.string();
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.arg2 = reader.string();
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.ratio = reader.string();
          continue;
        case 6:
          if (tag !== 50) {
            break;
          }

          message.currencyInfo = Currency.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CurrencyCollateralRequirement {
    return {
      blockchain: isSet(object.blockchain) ? globalThis.String(object.blockchain) : "",
      network: isSet(object.network) ? globalThis.String(object.network) : "",
      arg1: isSet(object.arg1) ? globalThis.String(object.arg1) : "",
      arg2: isSet(object.arg2) ? globalThis.String(object.arg2) : "",
      ratio: isSet(object.ratio) ? globalThis.String(object.ratio) : "",
      currencyInfo: isSet(object.currencyInfo) ? Currency.fromJSON(object.currencyInfo) : undefined,
    };
  },

  toJSON(message: CurrencyCollateralRequirement): unknown {
    const obj: any = {};
    if (message.blockchain !== "") {
      obj.blockchain = message.blockchain;
    }
    if (message.network !== "") {
      obj.network = message.network;
    }
    if (message.arg1 !== "") {
      obj.arg1 = message.arg1;
    }
    if (message.arg2 !== "") {
      obj.arg2 = message.arg2;
    }
    if (message.ratio !== "") {
      obj.ratio = message.ratio;
    }
    if (message.currencyInfo !== undefined) {
      obj.currencyInfo = Currency.toJSON(message.currencyInfo);
    }
    return obj;
  },

  create(base?: DeepPartial<CurrencyCollateralRequirement>): CurrencyCollateralRequirement {
    return CurrencyCollateralRequirement.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CurrencyCollateralRequirement>): CurrencyCollateralRequirement {
    const message = createBaseCurrencyCollateralRequirement();
    message.blockchain = object.blockchain ?? "";
    message.network = object.network ?? "";
    message.arg1 = object.arg1 ?? "";
    message.arg2 = object.arg2 ?? "";
    message.ratio = object.ratio ?? "";
    message.currencyInfo = (object.currencyInfo !== undefined && object.currencyInfo !== null)
      ? Currency.fromPartial(object.currencyInfo)
      : undefined;
    return message;
  },
};

function createBaseTnParticipantAttributeSpecification(): TnParticipantAttributeSpecification {
  return { attributeKey: "", attributeType: "", attributeDescription: "" };
}

export const TnParticipantAttributeSpecification = {
  encode(message: TnParticipantAttributeSpecification, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.attributeKey !== "") {
      writer.uint32(10).string(message.attributeKey);
    }
    if (message.attributeType !== "") {
      writer.uint32(18).string(message.attributeType);
    }
    if (message.attributeDescription !== "") {
      writer.uint32(26).string(message.attributeDescription);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): TnParticipantAttributeSpecification {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseTnParticipantAttributeSpecification();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.attributeKey = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.attributeType = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.attributeDescription = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): TnParticipantAttributeSpecification {
    return {
      attributeKey: isSet(object.attributeKey) ? globalThis.String(object.attributeKey) : "",
      attributeType: isSet(object.attributeType) ? globalThis.String(object.attributeType) : "",
      attributeDescription: isSet(object.attributeDescription) ? globalThis.String(object.attributeDescription) : "",
    };
  },

  toJSON(message: TnParticipantAttributeSpecification): unknown {
    const obj: any = {};
    if (message.attributeKey !== "") {
      obj.attributeKey = message.attributeKey;
    }
    if (message.attributeType !== "") {
      obj.attributeType = message.attributeType;
    }
    if (message.attributeDescription !== "") {
      obj.attributeDescription = message.attributeDescription;
    }
    return obj;
  },

  create(base?: DeepPartial<TnParticipantAttributeSpecification>): TnParticipantAttributeSpecification {
    return TnParticipantAttributeSpecification.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<TnParticipantAttributeSpecification>): TnParticipantAttributeSpecification {
    const message = createBaseTnParticipantAttributeSpecification();
    message.attributeKey = object.attributeKey ?? "";
    message.attributeType = object.attributeType ?? "";
    message.attributeDescription = object.attributeDescription ?? "";
    return message;
  },
};

function createBaseTnContactPerson(): TnContactPerson {
  return { firstName: "", lastName: "", phoneNumber: "", email: "" };
}

export const TnContactPerson = {
  encode(message: TnContactPerson, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.firstName !== "") {
      writer.uint32(10).string(message.firstName);
    }
    if (message.lastName !== "") {
      writer.uint32(18).string(message.lastName);
    }
    if (message.phoneNumber !== "") {
      writer.uint32(26).string(message.phoneNumber);
    }
    if (message.email !== "") {
      writer.uint32(34).string(message.email);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): TnContactPerson {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseTnContactPerson();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.firstName = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.lastName = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.phoneNumber = reader.string();
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.email = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): TnContactPerson {
    return {
      firstName: isSet(object.firstName) ? globalThis.String(object.firstName) : "",
      lastName: isSet(object.lastName) ? globalThis.String(object.lastName) : "",
      phoneNumber: isSet(object.phoneNumber) ? globalThis.String(object.phoneNumber) : "",
      email: isSet(object.email) ? globalThis.String(object.email) : "",
    };
  },

  toJSON(message: TnContactPerson): unknown {
    const obj: any = {};
    if (message.firstName !== "") {
      obj.firstName = message.firstName;
    }
    if (message.lastName !== "") {
      obj.lastName = message.lastName;
    }
    if (message.phoneNumber !== "") {
      obj.phoneNumber = message.phoneNumber;
    }
    if (message.email !== "") {
      obj.email = message.email;
    }
    return obj;
  },

  create(base?: DeepPartial<TnContactPerson>): TnContactPerson {
    return TnContactPerson.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<TnContactPerson>): TnContactPerson {
    const message = createBaseTnContactPerson();
    message.firstName = object.firstName ?? "";
    message.lastName = object.lastName ?? "";
    message.phoneNumber = object.phoneNumber ?? "";
    message.email = object.email ?? "";
    return message;
  },
};

function createBaseTnSharedAddress(): TnSharedAddress {
  return {
    id: "",
    internalAddressID: 0,
    wladdressID: 0,
    ownerParticipantId: "",
    targetParticipantId: "",
    blockchain: "",
    network: "",
    address: "",
    originLabel: "",
    originCreationDate: undefined,
    originDeletionDate: undefined,
    createdAt: undefined,
    updatedAt: undefined,
    targetAcceptedAt: undefined,
    status: "",
    proofOfOwnership: undefined,
    pledgesCount: 0,
    trails: [],
  };
}

export const TnSharedAddress = {
  encode(message: TnSharedAddress, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.id !== "") {
      writer.uint32(10).string(message.id);
    }
    if (message.internalAddressID !== 0) {
      writer.uint32(16).uint64(message.internalAddressID);
    }
    if (message.wladdressID !== 0) {
      writer.uint32(24).uint64(message.wladdressID);
    }
    if (message.ownerParticipantId !== "") {
      writer.uint32(34).string(message.ownerParticipantId);
    }
    if (message.targetParticipantId !== "") {
      writer.uint32(42).string(message.targetParticipantId);
    }
    if (message.blockchain !== "") {
      writer.uint32(50).string(message.blockchain);
    }
    if (message.network !== "") {
      writer.uint32(58).string(message.network);
    }
    if (message.address !== "") {
      writer.uint32(66).string(message.address);
    }
    if (message.originLabel !== "") {
      writer.uint32(74).string(message.originLabel);
    }
    if (message.originCreationDate !== undefined) {
      Timestamp.encode(toTimestamp(message.originCreationDate), writer.uint32(82).fork()).ldelim();
    }
    if (message.originDeletionDate !== undefined) {
      Timestamp.encode(toTimestamp(message.originDeletionDate), writer.uint32(90).fork()).ldelim();
    }
    if (message.createdAt !== undefined) {
      Timestamp.encode(toTimestamp(message.createdAt), writer.uint32(98).fork()).ldelim();
    }
    if (message.updatedAt !== undefined) {
      Timestamp.encode(toTimestamp(message.updatedAt), writer.uint32(106).fork()).ldelim();
    }
    if (message.targetAcceptedAt !== undefined) {
      Timestamp.encode(toTimestamp(message.targetAcceptedAt), writer.uint32(114).fork()).ldelim();
    }
    if (message.status !== "") {
      writer.uint32(122).string(message.status);
    }
    if (message.proofOfOwnership !== undefined) {
      ProofOfOwnership.encode(message.proofOfOwnership, writer.uint32(130).fork()).ldelim();
    }
    if (message.pledgesCount !== 0) {
      writer.uint32(136).uint64(message.pledgesCount);
    }
    for (const v of message.trails) {
      TnSharedAddress_Trail.encode(v!, writer.uint32(146).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): TnSharedAddress {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseTnSharedAddress();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.id = reader.string();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.internalAddressID = longToNumber(reader.uint64() as Long);
          continue;
        case 3:
          if (tag !== 24) {
            break;
          }

          message.wladdressID = longToNumber(reader.uint64() as Long);
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.ownerParticipantId = reader.string();
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.targetParticipantId = reader.string();
          continue;
        case 6:
          if (tag !== 50) {
            break;
          }

          message.blockchain = reader.string();
          continue;
        case 7:
          if (tag !== 58) {
            break;
          }

          message.network = reader.string();
          continue;
        case 8:
          if (tag !== 66) {
            break;
          }

          message.address = reader.string();
          continue;
        case 9:
          if (tag !== 74) {
            break;
          }

          message.originLabel = reader.string();
          continue;
        case 10:
          if (tag !== 82) {
            break;
          }

          message.originCreationDate = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        case 11:
          if (tag !== 90) {
            break;
          }

          message.originDeletionDate = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        case 12:
          if (tag !== 98) {
            break;
          }

          message.createdAt = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        case 13:
          if (tag !== 106) {
            break;
          }

          message.updatedAt = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        case 14:
          if (tag !== 114) {
            break;
          }

          message.targetAcceptedAt = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        case 15:
          if (tag !== 122) {
            break;
          }

          message.status = reader.string();
          continue;
        case 16:
          if (tag !== 130) {
            break;
          }

          message.proofOfOwnership = ProofOfOwnership.decode(reader, reader.uint32());
          continue;
        case 17:
          if (tag !== 136) {
            break;
          }

          message.pledgesCount = longToNumber(reader.uint64() as Long);
          continue;
        case 18:
          if (tag !== 146) {
            break;
          }

          message.trails.push(TnSharedAddress_Trail.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): TnSharedAddress {
    return {
      id: isSet(object.id) ? globalThis.String(object.id) : "",
      internalAddressID: isSet(object.internalAddressID) ? globalThis.Number(object.internalAddressID) : 0,
      wladdressID: isSet(object.wladdressID) ? globalThis.Number(object.wladdressID) : 0,
      ownerParticipantId: isSet(object.ownerParticipantId) ? globalThis.String(object.ownerParticipantId) : "",
      targetParticipantId: isSet(object.targetParticipantId) ? globalThis.String(object.targetParticipantId) : "",
      blockchain: isSet(object.blockchain) ? globalThis.String(object.blockchain) : "",
      network: isSet(object.network) ? globalThis.String(object.network) : "",
      address: isSet(object.address) ? globalThis.String(object.address) : "",
      originLabel: isSet(object.originLabel) ? globalThis.String(object.originLabel) : "",
      originCreationDate: isSet(object.originCreationDate) ? fromJsonTimestamp(object.originCreationDate) : undefined,
      originDeletionDate: isSet(object.originDeletionDate) ? fromJsonTimestamp(object.originDeletionDate) : undefined,
      createdAt: isSet(object.createdAt) ? fromJsonTimestamp(object.createdAt) : undefined,
      updatedAt: isSet(object.updatedAt) ? fromJsonTimestamp(object.updatedAt) : undefined,
      targetAcceptedAt: isSet(object.targetAcceptedAt) ? fromJsonTimestamp(object.targetAcceptedAt) : undefined,
      status: isSet(object.status) ? globalThis.String(object.status) : "",
      proofOfOwnership: isSet(object.proofOfOwnership) ? ProofOfOwnership.fromJSON(object.proofOfOwnership) : undefined,
      pledgesCount: isSet(object.pledgesCount) ? globalThis.Number(object.pledgesCount) : 0,
      trails: globalThis.Array.isArray(object?.trails)
        ? object.trails.map((e: any) => TnSharedAddress_Trail.fromJSON(e))
        : [],
    };
  },

  toJSON(message: TnSharedAddress): unknown {
    const obj: any = {};
    if (message.id !== "") {
      obj.id = message.id;
    }
    if (message.internalAddressID !== 0) {
      obj.internalAddressID = Math.round(message.internalAddressID);
    }
    if (message.wladdressID !== 0) {
      obj.wladdressID = Math.round(message.wladdressID);
    }
    if (message.ownerParticipantId !== "") {
      obj.ownerParticipantId = message.ownerParticipantId;
    }
    if (message.targetParticipantId !== "") {
      obj.targetParticipantId = message.targetParticipantId;
    }
    if (message.blockchain !== "") {
      obj.blockchain = message.blockchain;
    }
    if (message.network !== "") {
      obj.network = message.network;
    }
    if (message.address !== "") {
      obj.address = message.address;
    }
    if (message.originLabel !== "") {
      obj.originLabel = message.originLabel;
    }
    if (message.originCreationDate !== undefined) {
      obj.originCreationDate = message.originCreationDate.toISOString();
    }
    if (message.originDeletionDate !== undefined) {
      obj.originDeletionDate = message.originDeletionDate.toISOString();
    }
    if (message.createdAt !== undefined) {
      obj.createdAt = message.createdAt.toISOString();
    }
    if (message.updatedAt !== undefined) {
      obj.updatedAt = message.updatedAt.toISOString();
    }
    if (message.targetAcceptedAt !== undefined) {
      obj.targetAcceptedAt = message.targetAcceptedAt.toISOString();
    }
    if (message.status !== "") {
      obj.status = message.status;
    }
    if (message.proofOfOwnership !== undefined) {
      obj.proofOfOwnership = ProofOfOwnership.toJSON(message.proofOfOwnership);
    }
    if (message.pledgesCount !== 0) {
      obj.pledgesCount = Math.round(message.pledgesCount);
    }
    if (message.trails?.length) {
      obj.trails = message.trails.map((e) => TnSharedAddress_Trail.toJSON(e));
    }
    return obj;
  },

  create(base?: DeepPartial<TnSharedAddress>): TnSharedAddress {
    return TnSharedAddress.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<TnSharedAddress>): TnSharedAddress {
    const message = createBaseTnSharedAddress();
    message.id = object.id ?? "";
    message.internalAddressID = object.internalAddressID ?? 0;
    message.wladdressID = object.wladdressID ?? 0;
    message.ownerParticipantId = object.ownerParticipantId ?? "";
    message.targetParticipantId = object.targetParticipantId ?? "";
    message.blockchain = object.blockchain ?? "";
    message.network = object.network ?? "";
    message.address = object.address ?? "";
    message.originLabel = object.originLabel ?? "";
    message.originCreationDate = object.originCreationDate ?? undefined;
    message.originDeletionDate = object.originDeletionDate ?? undefined;
    message.createdAt = object.createdAt ?? undefined;
    message.updatedAt = object.updatedAt ?? undefined;
    message.targetAcceptedAt = object.targetAcceptedAt ?? undefined;
    message.status = object.status ?? "";
    message.proofOfOwnership = (object.proofOfOwnership !== undefined && object.proofOfOwnership !== null)
      ? ProofOfOwnership.fromPartial(object.proofOfOwnership)
      : undefined;
    message.pledgesCount = object.pledgesCount ?? 0;
    message.trails = object.trails?.map((e) => TnSharedAddress_Trail.fromPartial(e)) || [];
    return message;
  },
};

function createBaseTnSharedAddress_Trail(): TnSharedAddress_Trail {
  return { id: "", sharedAddressID: "", addressStatus: "", comment: "", createdAt: undefined };
}

export const TnSharedAddress_Trail = {
  encode(message: TnSharedAddress_Trail, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.id !== "") {
      writer.uint32(10).string(message.id);
    }
    if (message.sharedAddressID !== "") {
      writer.uint32(18).string(message.sharedAddressID);
    }
    if (message.addressStatus !== "") {
      writer.uint32(26).string(message.addressStatus);
    }
    if (message.comment !== "") {
      writer.uint32(34).string(message.comment);
    }
    if (message.createdAt !== undefined) {
      Timestamp.encode(toTimestamp(message.createdAt), writer.uint32(42).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): TnSharedAddress_Trail {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseTnSharedAddress_Trail();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.id = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.sharedAddressID = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.addressStatus = reader.string();
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.comment = reader.string();
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.createdAt = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): TnSharedAddress_Trail {
    return {
      id: isSet(object.id) ? globalThis.String(object.id) : "",
      sharedAddressID: isSet(object.sharedAddressID) ? globalThis.String(object.sharedAddressID) : "",
      addressStatus: isSet(object.addressStatus) ? globalThis.String(object.addressStatus) : "",
      comment: isSet(object.comment) ? globalThis.String(object.comment) : "",
      createdAt: isSet(object.createdAt) ? fromJsonTimestamp(object.createdAt) : undefined,
    };
  },

  toJSON(message: TnSharedAddress_Trail): unknown {
    const obj: any = {};
    if (message.id !== "") {
      obj.id = message.id;
    }
    if (message.sharedAddressID !== "") {
      obj.sharedAddressID = message.sharedAddressID;
    }
    if (message.addressStatus !== "") {
      obj.addressStatus = message.addressStatus;
    }
    if (message.comment !== "") {
      obj.comment = message.comment;
    }
    if (message.createdAt !== undefined) {
      obj.createdAt = message.createdAt.toISOString();
    }
    return obj;
  },

  create(base?: DeepPartial<TnSharedAddress_Trail>): TnSharedAddress_Trail {
    return TnSharedAddress_Trail.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<TnSharedAddress_Trail>): TnSharedAddress_Trail {
    const message = createBaseTnSharedAddress_Trail();
    message.id = object.id ?? "";
    message.sharedAddressID = object.sharedAddressID ?? "";
    message.addressStatus = object.addressStatus ?? "";
    message.comment = object.comment ?? "";
    message.createdAt = object.createdAt ?? undefined;
    return message;
  },
};

function createBaseTnSharedAsset(): TnSharedAsset {
  return {
    id: "",
    wlContractAddressID: 0,
    ownerParticipantId: "",
    targetParticipantId: "",
    blockchain: "",
    network: "",
    name: "",
    symbol: "",
    decimals: 0,
    contractAddress: "",
    tokenId: "",
    kind: "",
    originCreationDate: undefined,
    originDeletionDate: undefined,
    createdAt: undefined,
    updatedAt: undefined,
    targetAcceptedAt: undefined,
    targetRejectedAt: undefined,
    status: "",
    trails: [],
  };
}

export const TnSharedAsset = {
  encode(message: TnSharedAsset, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.id !== "") {
      writer.uint32(10).string(message.id);
    }
    if (message.wlContractAddressID !== 0) {
      writer.uint32(16).uint64(message.wlContractAddressID);
    }
    if (message.ownerParticipantId !== "") {
      writer.uint32(26).string(message.ownerParticipantId);
    }
    if (message.targetParticipantId !== "") {
      writer.uint32(34).string(message.targetParticipantId);
    }
    if (message.blockchain !== "") {
      writer.uint32(42).string(message.blockchain);
    }
    if (message.network !== "") {
      writer.uint32(50).string(message.network);
    }
    if (message.name !== "") {
      writer.uint32(58).string(message.name);
    }
    if (message.symbol !== "") {
      writer.uint32(66).string(message.symbol);
    }
    if (message.decimals !== 0) {
      writer.uint32(72).uint64(message.decimals);
    }
    if (message.contractAddress !== "") {
      writer.uint32(82).string(message.contractAddress);
    }
    if (message.tokenId !== "") {
      writer.uint32(90).string(message.tokenId);
    }
    if (message.kind !== "") {
      writer.uint32(98).string(message.kind);
    }
    if (message.originCreationDate !== undefined) {
      Timestamp.encode(toTimestamp(message.originCreationDate), writer.uint32(106).fork()).ldelim();
    }
    if (message.originDeletionDate !== undefined) {
      Timestamp.encode(toTimestamp(message.originDeletionDate), writer.uint32(114).fork()).ldelim();
    }
    if (message.createdAt !== undefined) {
      Timestamp.encode(toTimestamp(message.createdAt), writer.uint32(122).fork()).ldelim();
    }
    if (message.updatedAt !== undefined) {
      Timestamp.encode(toTimestamp(message.updatedAt), writer.uint32(130).fork()).ldelim();
    }
    if (message.targetAcceptedAt !== undefined) {
      Timestamp.encode(toTimestamp(message.targetAcceptedAt), writer.uint32(138).fork()).ldelim();
    }
    if (message.targetRejectedAt !== undefined) {
      Timestamp.encode(toTimestamp(message.targetRejectedAt), writer.uint32(146).fork()).ldelim();
    }
    if (message.status !== "") {
      writer.uint32(154).string(message.status);
    }
    for (const v of message.trails) {
      TnSharedAsset_Trail.encode(v!, writer.uint32(162).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): TnSharedAsset {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseTnSharedAsset();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.id = reader.string();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.wlContractAddressID = longToNumber(reader.uint64() as Long);
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.ownerParticipantId = reader.string();
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.targetParticipantId = reader.string();
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.blockchain = reader.string();
          continue;
        case 6:
          if (tag !== 50) {
            break;
          }

          message.network = reader.string();
          continue;
        case 7:
          if (tag !== 58) {
            break;
          }

          message.name = reader.string();
          continue;
        case 8:
          if (tag !== 66) {
            break;
          }

          message.symbol = reader.string();
          continue;
        case 9:
          if (tag !== 72) {
            break;
          }

          message.decimals = longToNumber(reader.uint64() as Long);
          continue;
        case 10:
          if (tag !== 82) {
            break;
          }

          message.contractAddress = reader.string();
          continue;
        case 11:
          if (tag !== 90) {
            break;
          }

          message.tokenId = reader.string();
          continue;
        case 12:
          if (tag !== 98) {
            break;
          }

          message.kind = reader.string();
          continue;
        case 13:
          if (tag !== 106) {
            break;
          }

          message.originCreationDate = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        case 14:
          if (tag !== 114) {
            break;
          }

          message.originDeletionDate = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        case 15:
          if (tag !== 122) {
            break;
          }

          message.createdAt = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        case 16:
          if (tag !== 130) {
            break;
          }

          message.updatedAt = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        case 17:
          if (tag !== 138) {
            break;
          }

          message.targetAcceptedAt = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        case 18:
          if (tag !== 146) {
            break;
          }

          message.targetRejectedAt = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        case 19:
          if (tag !== 154) {
            break;
          }

          message.status = reader.string();
          continue;
        case 20:
          if (tag !== 162) {
            break;
          }

          message.trails.push(TnSharedAsset_Trail.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): TnSharedAsset {
    return {
      id: isSet(object.id) ? globalThis.String(object.id) : "",
      wlContractAddressID: isSet(object.wlContractAddressID) ? globalThis.Number(object.wlContractAddressID) : 0,
      ownerParticipantId: isSet(object.ownerParticipantId) ? globalThis.String(object.ownerParticipantId) : "",
      targetParticipantId: isSet(object.targetParticipantId) ? globalThis.String(object.targetParticipantId) : "",
      blockchain: isSet(object.blockchain) ? globalThis.String(object.blockchain) : "",
      network: isSet(object.network) ? globalThis.String(object.network) : "",
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      symbol: isSet(object.symbol) ? globalThis.String(object.symbol) : "",
      decimals: isSet(object.decimals) ? globalThis.Number(object.decimals) : 0,
      contractAddress: isSet(object.contractAddress) ? globalThis.String(object.contractAddress) : "",
      tokenId: isSet(object.tokenId) ? globalThis.String(object.tokenId) : "",
      kind: isSet(object.kind) ? globalThis.String(object.kind) : "",
      originCreationDate: isSet(object.originCreationDate) ? fromJsonTimestamp(object.originCreationDate) : undefined,
      originDeletionDate: isSet(object.originDeletionDate) ? fromJsonTimestamp(object.originDeletionDate) : undefined,
      createdAt: isSet(object.createdAt) ? fromJsonTimestamp(object.createdAt) : undefined,
      updatedAt: isSet(object.updatedAt) ? fromJsonTimestamp(object.updatedAt) : undefined,
      targetAcceptedAt: isSet(object.targetAcceptedAt) ? fromJsonTimestamp(object.targetAcceptedAt) : undefined,
      targetRejectedAt: isSet(object.targetRejectedAt) ? fromJsonTimestamp(object.targetRejectedAt) : undefined,
      status: isSet(object.status) ? globalThis.String(object.status) : "",
      trails: globalThis.Array.isArray(object?.trails)
        ? object.trails.map((e: any) => TnSharedAsset_Trail.fromJSON(e))
        : [],
    };
  },

  toJSON(message: TnSharedAsset): unknown {
    const obj: any = {};
    if (message.id !== "") {
      obj.id = message.id;
    }
    if (message.wlContractAddressID !== 0) {
      obj.wlContractAddressID = Math.round(message.wlContractAddressID);
    }
    if (message.ownerParticipantId !== "") {
      obj.ownerParticipantId = message.ownerParticipantId;
    }
    if (message.targetParticipantId !== "") {
      obj.targetParticipantId = message.targetParticipantId;
    }
    if (message.blockchain !== "") {
      obj.blockchain = message.blockchain;
    }
    if (message.network !== "") {
      obj.network = message.network;
    }
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.symbol !== "") {
      obj.symbol = message.symbol;
    }
    if (message.decimals !== 0) {
      obj.decimals = Math.round(message.decimals);
    }
    if (message.contractAddress !== "") {
      obj.contractAddress = message.contractAddress;
    }
    if (message.tokenId !== "") {
      obj.tokenId = message.tokenId;
    }
    if (message.kind !== "") {
      obj.kind = message.kind;
    }
    if (message.originCreationDate !== undefined) {
      obj.originCreationDate = message.originCreationDate.toISOString();
    }
    if (message.originDeletionDate !== undefined) {
      obj.originDeletionDate = message.originDeletionDate.toISOString();
    }
    if (message.createdAt !== undefined) {
      obj.createdAt = message.createdAt.toISOString();
    }
    if (message.updatedAt !== undefined) {
      obj.updatedAt = message.updatedAt.toISOString();
    }
    if (message.targetAcceptedAt !== undefined) {
      obj.targetAcceptedAt = message.targetAcceptedAt.toISOString();
    }
    if (message.targetRejectedAt !== undefined) {
      obj.targetRejectedAt = message.targetRejectedAt.toISOString();
    }
    if (message.status !== "") {
      obj.status = message.status;
    }
    if (message.trails?.length) {
      obj.trails = message.trails.map((e) => TnSharedAsset_Trail.toJSON(e));
    }
    return obj;
  },

  create(base?: DeepPartial<TnSharedAsset>): TnSharedAsset {
    return TnSharedAsset.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<TnSharedAsset>): TnSharedAsset {
    const message = createBaseTnSharedAsset();
    message.id = object.id ?? "";
    message.wlContractAddressID = object.wlContractAddressID ?? 0;
    message.ownerParticipantId = object.ownerParticipantId ?? "";
    message.targetParticipantId = object.targetParticipantId ?? "";
    message.blockchain = object.blockchain ?? "";
    message.network = object.network ?? "";
    message.name = object.name ?? "";
    message.symbol = object.symbol ?? "";
    message.decimals = object.decimals ?? 0;
    message.contractAddress = object.contractAddress ?? "";
    message.tokenId = object.tokenId ?? "";
    message.kind = object.kind ?? "";
    message.originCreationDate = object.originCreationDate ?? undefined;
    message.originDeletionDate = object.originDeletionDate ?? undefined;
    message.createdAt = object.createdAt ?? undefined;
    message.updatedAt = object.updatedAt ?? undefined;
    message.targetAcceptedAt = object.targetAcceptedAt ?? undefined;
    message.targetRejectedAt = object.targetRejectedAt ?? undefined;
    message.status = object.status ?? "";
    message.trails = object.trails?.map((e) => TnSharedAsset_Trail.fromPartial(e)) || [];
    return message;
  },
};

function createBaseTnSharedAsset_Trail(): TnSharedAsset_Trail {
  return { id: "", sharedAssetID: "", assetStatus: "", comment: "", createdAt: undefined };
}

export const TnSharedAsset_Trail = {
  encode(message: TnSharedAsset_Trail, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.id !== "") {
      writer.uint32(10).string(message.id);
    }
    if (message.sharedAssetID !== "") {
      writer.uint32(18).string(message.sharedAssetID);
    }
    if (message.assetStatus !== "") {
      writer.uint32(26).string(message.assetStatus);
    }
    if (message.comment !== "") {
      writer.uint32(34).string(message.comment);
    }
    if (message.createdAt !== undefined) {
      Timestamp.encode(toTimestamp(message.createdAt), writer.uint32(42).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): TnSharedAsset_Trail {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseTnSharedAsset_Trail();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.id = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.sharedAssetID = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.assetStatus = reader.string();
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.comment = reader.string();
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.createdAt = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): TnSharedAsset_Trail {
    return {
      id: isSet(object.id) ? globalThis.String(object.id) : "",
      sharedAssetID: isSet(object.sharedAssetID) ? globalThis.String(object.sharedAssetID) : "",
      assetStatus: isSet(object.assetStatus) ? globalThis.String(object.assetStatus) : "",
      comment: isSet(object.comment) ? globalThis.String(object.comment) : "",
      createdAt: isSet(object.createdAt) ? fromJsonTimestamp(object.createdAt) : undefined,
    };
  },

  toJSON(message: TnSharedAsset_Trail): unknown {
    const obj: any = {};
    if (message.id !== "") {
      obj.id = message.id;
    }
    if (message.sharedAssetID !== "") {
      obj.sharedAssetID = message.sharedAssetID;
    }
    if (message.assetStatus !== "") {
      obj.assetStatus = message.assetStatus;
    }
    if (message.comment !== "") {
      obj.comment = message.comment;
    }
    if (message.createdAt !== undefined) {
      obj.createdAt = message.createdAt.toISOString();
    }
    return obj;
  },

  create(base?: DeepPartial<TnSharedAsset_Trail>): TnSharedAsset_Trail {
    return TnSharedAsset_Trail.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<TnSharedAsset_Trail>): TnSharedAsset_Trail {
    const message = createBaseTnSharedAsset_Trail();
    message.id = object.id ?? "";
    message.sharedAssetID = object.sharedAssetID ?? "";
    message.assetStatus = object.assetStatus ?? "";
    message.comment = object.comment ?? "";
    message.createdAt = object.createdAt ?? undefined;
    return message;
  },
};

function createBaseProofOfOwnership(): ProofOfOwnership {
  return { signedPayload: undefined, signedPayloadHash: "", proofOfReserve: undefined, signedPayloadAsString: "" };
}

export const ProofOfOwnership = {
  encode(message: ProofOfOwnership, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.signedPayload !== undefined) {
      SignedProofOfOwnershipPayload.encode(message.signedPayload, writer.uint32(10).fork()).ldelim();
    }
    if (message.signedPayloadHash !== "") {
      writer.uint32(18).string(message.signedPayloadHash);
    }
    if (message.proofOfReserve !== undefined) {
      ProofOfReserve.encode(message.proofOfReserve, writer.uint32(26).fork()).ldelim();
    }
    if (message.signedPayloadAsString !== "") {
      writer.uint32(34).string(message.signedPayloadAsString);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): ProofOfOwnership {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseProofOfOwnership();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.signedPayload = SignedProofOfOwnershipPayload.decode(reader, reader.uint32());
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.signedPayloadHash = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.proofOfReserve = ProofOfReserve.decode(reader, reader.uint32());
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.signedPayloadAsString = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ProofOfOwnership {
    return {
      signedPayload: isSet(object.signedPayload)
        ? SignedProofOfOwnershipPayload.fromJSON(object.signedPayload)
        : undefined,
      signedPayloadHash: isSet(object.signedPayloadHash) ? globalThis.String(object.signedPayloadHash) : "",
      proofOfReserve: isSet(object.proofOfReserve) ? ProofOfReserve.fromJSON(object.proofOfReserve) : undefined,
      signedPayloadAsString: isSet(object.signedPayloadAsString) ? globalThis.String(object.signedPayloadAsString) : "",
    };
  },

  toJSON(message: ProofOfOwnership): unknown {
    const obj: any = {};
    if (message.signedPayload !== undefined) {
      obj.signedPayload = SignedProofOfOwnershipPayload.toJSON(message.signedPayload);
    }
    if (message.signedPayloadHash !== "") {
      obj.signedPayloadHash = message.signedPayloadHash;
    }
    if (message.proofOfReserve !== undefined) {
      obj.proofOfReserve = ProofOfReserve.toJSON(message.proofOfReserve);
    }
    if (message.signedPayloadAsString !== "") {
      obj.signedPayloadAsString = message.signedPayloadAsString;
    }
    return obj;
  },

  create(base?: DeepPartial<ProofOfOwnership>): ProofOfOwnership {
    return ProofOfOwnership.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ProofOfOwnership>): ProofOfOwnership {
    const message = createBaseProofOfOwnership();
    message.signedPayload = (object.signedPayload !== undefined && object.signedPayload !== null)
      ? SignedProofOfOwnershipPayload.fromPartial(object.signedPayload)
      : undefined;
    message.signedPayloadHash = object.signedPayloadHash ?? "";
    message.proofOfReserve = (object.proofOfReserve !== undefined && object.proofOfReserve !== null)
      ? ProofOfReserve.fromPartial(object.proofOfReserve)
      : undefined;
    message.signedPayloadAsString = object.signedPayloadAsString ?? "";
    return message;
  },
};

function createBaseSignedProofOfOwnershipPayload(): SignedProofOfOwnershipPayload {
  return { payload: undefined, ownerParticipantSignature: "" };
}

export const SignedProofOfOwnershipPayload = {
  encode(message: SignedProofOfOwnershipPayload, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.payload !== undefined) {
      ProofOfOwnershipPayload.encode(message.payload, writer.uint32(10).fork()).ldelim();
    }
    if (message.ownerParticipantSignature !== "") {
      writer.uint32(18).string(message.ownerParticipantSignature);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): SignedProofOfOwnershipPayload {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSignedProofOfOwnershipPayload();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.payload = ProofOfOwnershipPayload.decode(reader, reader.uint32());
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.ownerParticipantSignature = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): SignedProofOfOwnershipPayload {
    return {
      payload: isSet(object.payload) ? ProofOfOwnershipPayload.fromJSON(object.payload) : undefined,
      ownerParticipantSignature: isSet(object.ownerParticipantSignature)
        ? globalThis.String(object.ownerParticipantSignature)
        : "",
    };
  },

  toJSON(message: SignedProofOfOwnershipPayload): unknown {
    const obj: any = {};
    if (message.payload !== undefined) {
      obj.payload = ProofOfOwnershipPayload.toJSON(message.payload);
    }
    if (message.ownerParticipantSignature !== "") {
      obj.ownerParticipantSignature = message.ownerParticipantSignature;
    }
    return obj;
  },

  create(base?: DeepPartial<SignedProofOfOwnershipPayload>): SignedProofOfOwnershipPayload {
    return SignedProofOfOwnershipPayload.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<SignedProofOfOwnershipPayload>): SignedProofOfOwnershipPayload {
    const message = createBaseSignedProofOfOwnershipPayload();
    message.payload = (object.payload !== undefined && object.payload !== null)
      ? ProofOfOwnershipPayload.fromPartial(object.payload)
      : undefined;
    message.ownerParticipantSignature = object.ownerParticipantSignature ?? "";
    return message;
  },
};

function createBaseProofOfOwnershipPayload(): ProofOfOwnershipPayload {
  return { ownerParticipantID: "", targetParticipantID: "", address: "", blockchain: "", network: "" };
}

export const ProofOfOwnershipPayload = {
  encode(message: ProofOfOwnershipPayload, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.ownerParticipantID !== "") {
      writer.uint32(10).string(message.ownerParticipantID);
    }
    if (message.targetParticipantID !== "") {
      writer.uint32(18).string(message.targetParticipantID);
    }
    if (message.address !== "") {
      writer.uint32(26).string(message.address);
    }
    if (message.blockchain !== "") {
      writer.uint32(34).string(message.blockchain);
    }
    if (message.network !== "") {
      writer.uint32(42).string(message.network);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): ProofOfOwnershipPayload {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseProofOfOwnershipPayload();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.ownerParticipantID = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.targetParticipantID = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.address = reader.string();
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.blockchain = reader.string();
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.network = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ProofOfOwnershipPayload {
    return {
      ownerParticipantID: isSet(object.ownerParticipantID) ? globalThis.String(object.ownerParticipantID) : "",
      targetParticipantID: isSet(object.targetParticipantID) ? globalThis.String(object.targetParticipantID) : "",
      address: isSet(object.address) ? globalThis.String(object.address) : "",
      blockchain: isSet(object.blockchain) ? globalThis.String(object.blockchain) : "",
      network: isSet(object.network) ? globalThis.String(object.network) : "",
    };
  },

  toJSON(message: ProofOfOwnershipPayload): unknown {
    const obj: any = {};
    if (message.ownerParticipantID !== "") {
      obj.ownerParticipantID = message.ownerParticipantID;
    }
    if (message.targetParticipantID !== "") {
      obj.targetParticipantID = message.targetParticipantID;
    }
    if (message.address !== "") {
      obj.address = message.address;
    }
    if (message.blockchain !== "") {
      obj.blockchain = message.blockchain;
    }
    if (message.network !== "") {
      obj.network = message.network;
    }
    return obj;
  },

  create(base?: DeepPartial<ProofOfOwnershipPayload>): ProofOfOwnershipPayload {
    return ProofOfOwnershipPayload.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ProofOfOwnershipPayload>): ProofOfOwnershipPayload {
    const message = createBaseProofOfOwnershipPayload();
    message.ownerParticipantID = object.ownerParticipantID ?? "";
    message.targetParticipantID = object.targetParticipantID ?? "";
    message.address = object.address ?? "";
    message.blockchain = object.blockchain ?? "";
    message.network = object.network ?? "";
    return message;
  },
};

function createBaseTnPledge(): TnPledge {
  return {
    id: "",
    sharedAddressID: "",
    ownerParticipantID: "",
    targetParticipantID: "",
    currencyID: "",
    blockchain: "",
    network: "",
    arg1: "",
    arg2: "",
    amount: "",
    status: "",
    pledgeType: "",
    trails: [],
    originCreationDate: undefined,
    durationSetup: undefined,
    unpledgeDate: undefined,
    attributes: [],
    createdAt: undefined,
    updatedAt: undefined,
    externalReferenceId: "",
    reconciliationNote: "",
    direction: "",
    wladdressID: 0,
  };
}

export const TnPledge = {
  encode(message: TnPledge, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.id !== "") {
      writer.uint32(10).string(message.id);
    }
    if (message.sharedAddressID !== "") {
      writer.uint32(18).string(message.sharedAddressID);
    }
    if (message.ownerParticipantID !== "") {
      writer.uint32(26).string(message.ownerParticipantID);
    }
    if (message.targetParticipantID !== "") {
      writer.uint32(34).string(message.targetParticipantID);
    }
    if (message.currencyID !== "") {
      writer.uint32(42).string(message.currencyID);
    }
    if (message.blockchain !== "") {
      writer.uint32(50).string(message.blockchain);
    }
    if (message.network !== "") {
      writer.uint32(58).string(message.network);
    }
    if (message.arg1 !== "") {
      writer.uint32(66).string(message.arg1);
    }
    if (message.arg2 !== "") {
      writer.uint32(74).string(message.arg2);
    }
    if (message.amount !== "") {
      writer.uint32(82).string(message.amount);
    }
    if (message.status !== "") {
      writer.uint32(90).string(message.status);
    }
    if (message.pledgeType !== "") {
      writer.uint32(98).string(message.pledgeType);
    }
    for (const v of message.trails) {
      TnPledge_Trail.encode(v!, writer.uint32(106).fork()).ldelim();
    }
    if (message.originCreationDate !== undefined) {
      Timestamp.encode(toTimestamp(message.originCreationDate), writer.uint32(114).fork()).ldelim();
    }
    if (message.durationSetup !== undefined) {
      TnPledge_PledgeDurationSetup.encode(message.durationSetup, writer.uint32(122).fork()).ldelim();
    }
    if (message.unpledgeDate !== undefined) {
      Timestamp.encode(toTimestamp(message.unpledgeDate), writer.uint32(130).fork()).ldelim();
    }
    for (const v of message.attributes) {
      TnPledge_PledgeAttribute.encode(v!, writer.uint32(138).fork()).ldelim();
    }
    if (message.createdAt !== undefined) {
      Timestamp.encode(toTimestamp(message.createdAt), writer.uint32(146).fork()).ldelim();
    }
    if (message.updatedAt !== undefined) {
      Timestamp.encode(toTimestamp(message.updatedAt), writer.uint32(154).fork()).ldelim();
    }
    if (message.externalReferenceId !== "") {
      writer.uint32(162).string(message.externalReferenceId);
    }
    if (message.reconciliationNote !== "") {
      writer.uint32(170).string(message.reconciliationNote);
    }
    if (message.direction !== "") {
      writer.uint32(178).string(message.direction);
    }
    if (message.wladdressID !== 0) {
      writer.uint32(184).uint64(message.wladdressID);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): TnPledge {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseTnPledge();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.id = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.sharedAddressID = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.ownerParticipantID = reader.string();
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.targetParticipantID = reader.string();
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.currencyID = reader.string();
          continue;
        case 6:
          if (tag !== 50) {
            break;
          }

          message.blockchain = reader.string();
          continue;
        case 7:
          if (tag !== 58) {
            break;
          }

          message.network = reader.string();
          continue;
        case 8:
          if (tag !== 66) {
            break;
          }

          message.arg1 = reader.string();
          continue;
        case 9:
          if (tag !== 74) {
            break;
          }

          message.arg2 = reader.string();
          continue;
        case 10:
          if (tag !== 82) {
            break;
          }

          message.amount = reader.string();
          continue;
        case 11:
          if (tag !== 90) {
            break;
          }

          message.status = reader.string();
          continue;
        case 12:
          if (tag !== 98) {
            break;
          }

          message.pledgeType = reader.string();
          continue;
        case 13:
          if (tag !== 106) {
            break;
          }

          message.trails.push(TnPledge_Trail.decode(reader, reader.uint32()));
          continue;
        case 14:
          if (tag !== 114) {
            break;
          }

          message.originCreationDate = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        case 15:
          if (tag !== 122) {
            break;
          }

          message.durationSetup = TnPledge_PledgeDurationSetup.decode(reader, reader.uint32());
          continue;
        case 16:
          if (tag !== 130) {
            break;
          }

          message.unpledgeDate = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        case 17:
          if (tag !== 138) {
            break;
          }

          message.attributes.push(TnPledge_PledgeAttribute.decode(reader, reader.uint32()));
          continue;
        case 18:
          if (tag !== 146) {
            break;
          }

          message.createdAt = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        case 19:
          if (tag !== 154) {
            break;
          }

          message.updatedAt = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        case 20:
          if (tag !== 162) {
            break;
          }

          message.externalReferenceId = reader.string();
          continue;
        case 21:
          if (tag !== 170) {
            break;
          }

          message.reconciliationNote = reader.string();
          continue;
        case 22:
          if (tag !== 178) {
            break;
          }

          message.direction = reader.string();
          continue;
        case 23:
          if (tag !== 184) {
            break;
          }

          message.wladdressID = longToNumber(reader.uint64() as Long);
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): TnPledge {
    return {
      id: isSet(object.id) ? globalThis.String(object.id) : "",
      sharedAddressID: isSet(object.sharedAddressID) ? globalThis.String(object.sharedAddressID) : "",
      ownerParticipantID: isSet(object.ownerParticipantID) ? globalThis.String(object.ownerParticipantID) : "",
      targetParticipantID: isSet(object.targetParticipantID) ? globalThis.String(object.targetParticipantID) : "",
      currencyID: isSet(object.currencyID) ? globalThis.String(object.currencyID) : "",
      blockchain: isSet(object.blockchain) ? globalThis.String(object.blockchain) : "",
      network: isSet(object.network) ? globalThis.String(object.network) : "",
      arg1: isSet(object.arg1) ? globalThis.String(object.arg1) : "",
      arg2: isSet(object.arg2) ? globalThis.String(object.arg2) : "",
      amount: isSet(object.amount) ? globalThis.String(object.amount) : "",
      status: isSet(object.status) ? globalThis.String(object.status) : "",
      pledgeType: isSet(object.pledgeType) ? globalThis.String(object.pledgeType) : "",
      trails: globalThis.Array.isArray(object?.trails) ? object.trails.map((e: any) => TnPledge_Trail.fromJSON(e)) : [],
      originCreationDate: isSet(object.originCreationDate) ? fromJsonTimestamp(object.originCreationDate) : undefined,
      durationSetup: isSet(object.durationSetup)
        ? TnPledge_PledgeDurationSetup.fromJSON(object.durationSetup)
        : undefined,
      unpledgeDate: isSet(object.unpledgeDate) ? fromJsonTimestamp(object.unpledgeDate) : undefined,
      attributes: globalThis.Array.isArray(object?.attributes)
        ? object.attributes.map((e: any) => TnPledge_PledgeAttribute.fromJSON(e))
        : [],
      createdAt: isSet(object.createdAt) ? fromJsonTimestamp(object.createdAt) : undefined,
      updatedAt: isSet(object.updatedAt) ? fromJsonTimestamp(object.updatedAt) : undefined,
      externalReferenceId: isSet(object.externalReferenceId) ? globalThis.String(object.externalReferenceId) : "",
      reconciliationNote: isSet(object.reconciliationNote) ? globalThis.String(object.reconciliationNote) : "",
      direction: isSet(object.direction) ? globalThis.String(object.direction) : "",
      wladdressID: isSet(object.wladdressID) ? globalThis.Number(object.wladdressID) : 0,
    };
  },

  toJSON(message: TnPledge): unknown {
    const obj: any = {};
    if (message.id !== "") {
      obj.id = message.id;
    }
    if (message.sharedAddressID !== "") {
      obj.sharedAddressID = message.sharedAddressID;
    }
    if (message.ownerParticipantID !== "") {
      obj.ownerParticipantID = message.ownerParticipantID;
    }
    if (message.targetParticipantID !== "") {
      obj.targetParticipantID = message.targetParticipantID;
    }
    if (message.currencyID !== "") {
      obj.currencyID = message.currencyID;
    }
    if (message.blockchain !== "") {
      obj.blockchain = message.blockchain;
    }
    if (message.network !== "") {
      obj.network = message.network;
    }
    if (message.arg1 !== "") {
      obj.arg1 = message.arg1;
    }
    if (message.arg2 !== "") {
      obj.arg2 = message.arg2;
    }
    if (message.amount !== "") {
      obj.amount = message.amount;
    }
    if (message.status !== "") {
      obj.status = message.status;
    }
    if (message.pledgeType !== "") {
      obj.pledgeType = message.pledgeType;
    }
    if (message.trails?.length) {
      obj.trails = message.trails.map((e) => TnPledge_Trail.toJSON(e));
    }
    if (message.originCreationDate !== undefined) {
      obj.originCreationDate = message.originCreationDate.toISOString();
    }
    if (message.durationSetup !== undefined) {
      obj.durationSetup = TnPledge_PledgeDurationSetup.toJSON(message.durationSetup);
    }
    if (message.unpledgeDate !== undefined) {
      obj.unpledgeDate = message.unpledgeDate.toISOString();
    }
    if (message.attributes?.length) {
      obj.attributes = message.attributes.map((e) => TnPledge_PledgeAttribute.toJSON(e));
    }
    if (message.createdAt !== undefined) {
      obj.createdAt = message.createdAt.toISOString();
    }
    if (message.updatedAt !== undefined) {
      obj.updatedAt = message.updatedAt.toISOString();
    }
    if (message.externalReferenceId !== "") {
      obj.externalReferenceId = message.externalReferenceId;
    }
    if (message.reconciliationNote !== "") {
      obj.reconciliationNote = message.reconciliationNote;
    }
    if (message.direction !== "") {
      obj.direction = message.direction;
    }
    if (message.wladdressID !== 0) {
      obj.wladdressID = Math.round(message.wladdressID);
    }
    return obj;
  },

  create(base?: DeepPartial<TnPledge>): TnPledge {
    return TnPledge.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<TnPledge>): TnPledge {
    const message = createBaseTnPledge();
    message.id = object.id ?? "";
    message.sharedAddressID = object.sharedAddressID ?? "";
    message.ownerParticipantID = object.ownerParticipantID ?? "";
    message.targetParticipantID = object.targetParticipantID ?? "";
    message.currencyID = object.currencyID ?? "";
    message.blockchain = object.blockchain ?? "";
    message.network = object.network ?? "";
    message.arg1 = object.arg1 ?? "";
    message.arg2 = object.arg2 ?? "";
    message.amount = object.amount ?? "";
    message.status = object.status ?? "";
    message.pledgeType = object.pledgeType ?? "";
    message.trails = object.trails?.map((e) => TnPledge_Trail.fromPartial(e)) || [];
    message.originCreationDate = object.originCreationDate ?? undefined;
    message.durationSetup = (object.durationSetup !== undefined && object.durationSetup !== null)
      ? TnPledge_PledgeDurationSetup.fromPartial(object.durationSetup)
      : undefined;
    message.unpledgeDate = object.unpledgeDate ?? undefined;
    message.attributes = object.attributes?.map((e) => TnPledge_PledgeAttribute.fromPartial(e)) || [];
    message.createdAt = object.createdAt ?? undefined;
    message.updatedAt = object.updatedAt ?? undefined;
    message.externalReferenceId = object.externalReferenceId ?? "";
    message.reconciliationNote = object.reconciliationNote ?? "";
    message.direction = object.direction ?? "";
    message.wladdressID = object.wladdressID ?? 0;
    return message;
  },
};

function createBaseTnPledge_Trail(): TnPledge_Trail {
  return {
    id: "",
    pledgeID: "",
    addressCommandID: "",
    participantID: "",
    pledgeAmount: "",
    action: "",
    comment: "",
    createdAt: undefined,
  };
}

export const TnPledge_Trail = {
  encode(message: TnPledge_Trail, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.id !== "") {
      writer.uint32(10).string(message.id);
    }
    if (message.pledgeID !== "") {
      writer.uint32(18).string(message.pledgeID);
    }
    if (message.addressCommandID !== "") {
      writer.uint32(26).string(message.addressCommandID);
    }
    if (message.participantID !== "") {
      writer.uint32(34).string(message.participantID);
    }
    if (message.pledgeAmount !== "") {
      writer.uint32(42).string(message.pledgeAmount);
    }
    if (message.action !== "") {
      writer.uint32(50).string(message.action);
    }
    if (message.comment !== "") {
      writer.uint32(58).string(message.comment);
    }
    if (message.createdAt !== undefined) {
      Timestamp.encode(toTimestamp(message.createdAt), writer.uint32(66).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): TnPledge_Trail {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseTnPledge_Trail();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.id = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.pledgeID = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.addressCommandID = reader.string();
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.participantID = reader.string();
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.pledgeAmount = reader.string();
          continue;
        case 6:
          if (tag !== 50) {
            break;
          }

          message.action = reader.string();
          continue;
        case 7:
          if (tag !== 58) {
            break;
          }

          message.comment = reader.string();
          continue;
        case 8:
          if (tag !== 66) {
            break;
          }

          message.createdAt = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): TnPledge_Trail {
    return {
      id: isSet(object.id) ? globalThis.String(object.id) : "",
      pledgeID: isSet(object.pledgeID) ? globalThis.String(object.pledgeID) : "",
      addressCommandID: isSet(object.addressCommandID) ? globalThis.String(object.addressCommandID) : "",
      participantID: isSet(object.participantID) ? globalThis.String(object.participantID) : "",
      pledgeAmount: isSet(object.pledgeAmount) ? globalThis.String(object.pledgeAmount) : "",
      action: isSet(object.action) ? globalThis.String(object.action) : "",
      comment: isSet(object.comment) ? globalThis.String(object.comment) : "",
      createdAt: isSet(object.createdAt) ? fromJsonTimestamp(object.createdAt) : undefined,
    };
  },

  toJSON(message: TnPledge_Trail): unknown {
    const obj: any = {};
    if (message.id !== "") {
      obj.id = message.id;
    }
    if (message.pledgeID !== "") {
      obj.pledgeID = message.pledgeID;
    }
    if (message.addressCommandID !== "") {
      obj.addressCommandID = message.addressCommandID;
    }
    if (message.participantID !== "") {
      obj.participantID = message.participantID;
    }
    if (message.pledgeAmount !== "") {
      obj.pledgeAmount = message.pledgeAmount;
    }
    if (message.action !== "") {
      obj.action = message.action;
    }
    if (message.comment !== "") {
      obj.comment = message.comment;
    }
    if (message.createdAt !== undefined) {
      obj.createdAt = message.createdAt.toISOString();
    }
    return obj;
  },

  create(base?: DeepPartial<TnPledge_Trail>): TnPledge_Trail {
    return TnPledge_Trail.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<TnPledge_Trail>): TnPledge_Trail {
    const message = createBaseTnPledge_Trail();
    message.id = object.id ?? "";
    message.pledgeID = object.pledgeID ?? "";
    message.addressCommandID = object.addressCommandID ?? "";
    message.participantID = object.participantID ?? "";
    message.pledgeAmount = object.pledgeAmount ?? "";
    message.action = object.action ?? "";
    message.comment = object.comment ?? "";
    message.createdAt = object.createdAt ?? undefined;
    return message;
  },
};

function createBaseTnPledge_PledgeDurationSetup(): TnPledge_PledgeDurationSetup {
  return {
    minimumDuration: undefined,
    endOfMinimumDurationDate: undefined,
    noticePeriodDuration: undefined,
    endOfNoticePeriodDate: undefined,
  };
}

export const TnPledge_PledgeDurationSetup = {
  encode(message: TnPledge_PledgeDurationSetup, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.minimumDuration !== undefined) {
      Duration.encode(message.minimumDuration, writer.uint32(10).fork()).ldelim();
    }
    if (message.endOfMinimumDurationDate !== undefined) {
      Timestamp.encode(toTimestamp(message.endOfMinimumDurationDate), writer.uint32(18).fork()).ldelim();
    }
    if (message.noticePeriodDuration !== undefined) {
      Duration.encode(message.noticePeriodDuration, writer.uint32(26).fork()).ldelim();
    }
    if (message.endOfNoticePeriodDate !== undefined) {
      Timestamp.encode(toTimestamp(message.endOfNoticePeriodDate), writer.uint32(34).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): TnPledge_PledgeDurationSetup {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseTnPledge_PledgeDurationSetup();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.minimumDuration = Duration.decode(reader, reader.uint32());
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.endOfMinimumDurationDate = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.noticePeriodDuration = Duration.decode(reader, reader.uint32());
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.endOfNoticePeriodDate = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): TnPledge_PledgeDurationSetup {
    return {
      minimumDuration: isSet(object.minimumDuration) ? Duration.fromJSON(object.minimumDuration) : undefined,
      endOfMinimumDurationDate: isSet(object.endOfMinimumDurationDate)
        ? fromJsonTimestamp(object.endOfMinimumDurationDate)
        : undefined,
      noticePeriodDuration: isSet(object.noticePeriodDuration)
        ? Duration.fromJSON(object.noticePeriodDuration)
        : undefined,
      endOfNoticePeriodDate: isSet(object.endOfNoticePeriodDate)
        ? fromJsonTimestamp(object.endOfNoticePeriodDate)
        : undefined,
    };
  },

  toJSON(message: TnPledge_PledgeDurationSetup): unknown {
    const obj: any = {};
    if (message.minimumDuration !== undefined) {
      obj.minimumDuration = Duration.toJSON(message.minimumDuration);
    }
    if (message.endOfMinimumDurationDate !== undefined) {
      obj.endOfMinimumDurationDate = message.endOfMinimumDurationDate.toISOString();
    }
    if (message.noticePeriodDuration !== undefined) {
      obj.noticePeriodDuration = Duration.toJSON(message.noticePeriodDuration);
    }
    if (message.endOfNoticePeriodDate !== undefined) {
      obj.endOfNoticePeriodDate = message.endOfNoticePeriodDate.toISOString();
    }
    return obj;
  },

  create(base?: DeepPartial<TnPledge_PledgeDurationSetup>): TnPledge_PledgeDurationSetup {
    return TnPledge_PledgeDurationSetup.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<TnPledge_PledgeDurationSetup>): TnPledge_PledgeDurationSetup {
    const message = createBaseTnPledge_PledgeDurationSetup();
    message.minimumDuration = (object.minimumDuration !== undefined && object.minimumDuration !== null)
      ? Duration.fromPartial(object.minimumDuration)
      : undefined;
    message.endOfMinimumDurationDate = object.endOfMinimumDurationDate ?? undefined;
    message.noticePeriodDuration = (object.noticePeriodDuration !== undefined && object.noticePeriodDuration !== null)
      ? Duration.fromPartial(object.noticePeriodDuration)
      : undefined;
    message.endOfNoticePeriodDate = object.endOfNoticePeriodDate ?? undefined;
    return message;
  },
};

function createBaseTnPledge_PledgeAttribute(): TnPledge_PledgeAttribute {
  return {
    id: "",
    key: "",
    value: "",
    owner: "",
    type: "",
    subtype: "",
    contentType: "",
    isTaurusNetworkShared: false,
  };
}

export const TnPledge_PledgeAttribute = {
  encode(message: TnPledge_PledgeAttribute, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.id !== "") {
      writer.uint32(10).string(message.id);
    }
    if (message.key !== "") {
      writer.uint32(18).string(message.key);
    }
    if (message.value !== "") {
      writer.uint32(26).string(message.value);
    }
    if (message.owner !== "") {
      writer.uint32(34).string(message.owner);
    }
    if (message.type !== "") {
      writer.uint32(42).string(message.type);
    }
    if (message.subtype !== "") {
      writer.uint32(50).string(message.subtype);
    }
    if (message.contentType !== "") {
      writer.uint32(58).string(message.contentType);
    }
    if (message.isTaurusNetworkShared !== false) {
      writer.uint32(64).bool(message.isTaurusNetworkShared);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): TnPledge_PledgeAttribute {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseTnPledge_PledgeAttribute();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.id = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.key = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.value = reader.string();
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.owner = reader.string();
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.type = reader.string();
          continue;
        case 6:
          if (tag !== 50) {
            break;
          }

          message.subtype = reader.string();
          continue;
        case 7:
          if (tag !== 58) {
            break;
          }

          message.contentType = reader.string();
          continue;
        case 8:
          if (tag !== 64) {
            break;
          }

          message.isTaurusNetworkShared = reader.bool();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): TnPledge_PledgeAttribute {
    return {
      id: isSet(object.id) ? globalThis.String(object.id) : "",
      key: isSet(object.key) ? globalThis.String(object.key) : "",
      value: isSet(object.value) ? globalThis.String(object.value) : "",
      owner: isSet(object.owner) ? globalThis.String(object.owner) : "",
      type: isSet(object.type) ? globalThis.String(object.type) : "",
      subtype: isSet(object.subtype) ? globalThis.String(object.subtype) : "",
      contentType: isSet(object.contentType) ? globalThis.String(object.contentType) : "",
      isTaurusNetworkShared: isSet(object.isTaurusNetworkShared)
        ? globalThis.Boolean(object.isTaurusNetworkShared)
        : false,
    };
  },

  toJSON(message: TnPledge_PledgeAttribute): unknown {
    const obj: any = {};
    if (message.id !== "") {
      obj.id = message.id;
    }
    if (message.key !== "") {
      obj.key = message.key;
    }
    if (message.value !== "") {
      obj.value = message.value;
    }
    if (message.owner !== "") {
      obj.owner = message.owner;
    }
    if (message.type !== "") {
      obj.type = message.type;
    }
    if (message.subtype !== "") {
      obj.subtype = message.subtype;
    }
    if (message.contentType !== "") {
      obj.contentType = message.contentType;
    }
    if (message.isTaurusNetworkShared !== false) {
      obj.isTaurusNetworkShared = message.isTaurusNetworkShared;
    }
    return obj;
  },

  create(base?: DeepPartial<TnPledge_PledgeAttribute>): TnPledge_PledgeAttribute {
    return TnPledge_PledgeAttribute.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<TnPledge_PledgeAttribute>): TnPledge_PledgeAttribute {
    const message = createBaseTnPledge_PledgeAttribute();
    message.id = object.id ?? "";
    message.key = object.key ?? "";
    message.value = object.value ?? "";
    message.owner = object.owner ?? "";
    message.type = object.type ?? "";
    message.subtype = object.subtype ?? "";
    message.contentType = object.contentType ?? "";
    message.isTaurusNetworkShared = object.isTaurusNetworkShared ?? false;
    return message;
  },
};

function createBaseTnPledgeWithdrawal(): TnPledgeWithdrawal {
  return {
    id: "",
    pledgeID: "",
    destinationSharedAddressID: "",
    amount: "",
    status: "",
    txHash: "",
    txID: 0,
    requestID: 0,
    txBlockNumber: 0,
    trails: [],
    createdAt: undefined,
    initiatorParticipantID: "",
    externalReferenceID: "",
  };
}

export const TnPledgeWithdrawal = {
  encode(message: TnPledgeWithdrawal, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.id !== "") {
      writer.uint32(10).string(message.id);
    }
    if (message.pledgeID !== "") {
      writer.uint32(18).string(message.pledgeID);
    }
    if (message.destinationSharedAddressID !== "") {
      writer.uint32(26).string(message.destinationSharedAddressID);
    }
    if (message.amount !== "") {
      writer.uint32(34).string(message.amount);
    }
    if (message.status !== "") {
      writer.uint32(42).string(message.status);
    }
    if (message.txHash !== "") {
      writer.uint32(50).string(message.txHash);
    }
    if (message.txID !== 0) {
      writer.uint32(56).uint64(message.txID);
    }
    if (message.requestID !== 0) {
      writer.uint32(64).uint64(message.requestID);
    }
    if (message.txBlockNumber !== 0) {
      writer.uint32(72).uint64(message.txBlockNumber);
    }
    for (const v of message.trails) {
      TnPledgeWithdrawal_Trail.encode(v!, writer.uint32(82).fork()).ldelim();
    }
    if (message.createdAt !== undefined) {
      Timestamp.encode(toTimestamp(message.createdAt), writer.uint32(90).fork()).ldelim();
    }
    if (message.initiatorParticipantID !== "") {
      writer.uint32(98).string(message.initiatorParticipantID);
    }
    if (message.externalReferenceID !== "") {
      writer.uint32(106).string(message.externalReferenceID);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): TnPledgeWithdrawal {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseTnPledgeWithdrawal();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.id = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.pledgeID = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.destinationSharedAddressID = reader.string();
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.amount = reader.string();
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.status = reader.string();
          continue;
        case 6:
          if (tag !== 50) {
            break;
          }

          message.txHash = reader.string();
          continue;
        case 7:
          if (tag !== 56) {
            break;
          }

          message.txID = longToNumber(reader.uint64() as Long);
          continue;
        case 8:
          if (tag !== 64) {
            break;
          }

          message.requestID = longToNumber(reader.uint64() as Long);
          continue;
        case 9:
          if (tag !== 72) {
            break;
          }

          message.txBlockNumber = longToNumber(reader.uint64() as Long);
          continue;
        case 10:
          if (tag !== 82) {
            break;
          }

          message.trails.push(TnPledgeWithdrawal_Trail.decode(reader, reader.uint32()));
          continue;
        case 11:
          if (tag !== 90) {
            break;
          }

          message.createdAt = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        case 12:
          if (tag !== 98) {
            break;
          }

          message.initiatorParticipantID = reader.string();
          continue;
        case 13:
          if (tag !== 106) {
            break;
          }

          message.externalReferenceID = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): TnPledgeWithdrawal {
    return {
      id: isSet(object.id) ? globalThis.String(object.id) : "",
      pledgeID: isSet(object.pledgeID) ? globalThis.String(object.pledgeID) : "",
      destinationSharedAddressID: isSet(object.destinationSharedAddressID)
        ? globalThis.String(object.destinationSharedAddressID)
        : "",
      amount: isSet(object.amount) ? globalThis.String(object.amount) : "",
      status: isSet(object.status) ? globalThis.String(object.status) : "",
      txHash: isSet(object.txHash) ? globalThis.String(object.txHash) : "",
      txID: isSet(object.txID) ? globalThis.Number(object.txID) : 0,
      requestID: isSet(object.requestID) ? globalThis.Number(object.requestID) : 0,
      txBlockNumber: isSet(object.txBlockNumber) ? globalThis.Number(object.txBlockNumber) : 0,
      trails: globalThis.Array.isArray(object?.trails)
        ? object.trails.map((e: any) => TnPledgeWithdrawal_Trail.fromJSON(e))
        : [],
      createdAt: isSet(object.createdAt) ? fromJsonTimestamp(object.createdAt) : undefined,
      initiatorParticipantID: isSet(object.initiatorParticipantID)
        ? globalThis.String(object.initiatorParticipantID)
        : "",
      externalReferenceID: isSet(object.externalReferenceID) ? globalThis.String(object.externalReferenceID) : "",
    };
  },

  toJSON(message: TnPledgeWithdrawal): unknown {
    const obj: any = {};
    if (message.id !== "") {
      obj.id = message.id;
    }
    if (message.pledgeID !== "") {
      obj.pledgeID = message.pledgeID;
    }
    if (message.destinationSharedAddressID !== "") {
      obj.destinationSharedAddressID = message.destinationSharedAddressID;
    }
    if (message.amount !== "") {
      obj.amount = message.amount;
    }
    if (message.status !== "") {
      obj.status = message.status;
    }
    if (message.txHash !== "") {
      obj.txHash = message.txHash;
    }
    if (message.txID !== 0) {
      obj.txID = Math.round(message.txID);
    }
    if (message.requestID !== 0) {
      obj.requestID = Math.round(message.requestID);
    }
    if (message.txBlockNumber !== 0) {
      obj.txBlockNumber = Math.round(message.txBlockNumber);
    }
    if (message.trails?.length) {
      obj.trails = message.trails.map((e) => TnPledgeWithdrawal_Trail.toJSON(e));
    }
    if (message.createdAt !== undefined) {
      obj.createdAt = message.createdAt.toISOString();
    }
    if (message.initiatorParticipantID !== "") {
      obj.initiatorParticipantID = message.initiatorParticipantID;
    }
    if (message.externalReferenceID !== "") {
      obj.externalReferenceID = message.externalReferenceID;
    }
    return obj;
  },

  create(base?: DeepPartial<TnPledgeWithdrawal>): TnPledgeWithdrawal {
    return TnPledgeWithdrawal.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<TnPledgeWithdrawal>): TnPledgeWithdrawal {
    const message = createBaseTnPledgeWithdrawal();
    message.id = object.id ?? "";
    message.pledgeID = object.pledgeID ?? "";
    message.destinationSharedAddressID = object.destinationSharedAddressID ?? "";
    message.amount = object.amount ?? "";
    message.status = object.status ?? "";
    message.txHash = object.txHash ?? "";
    message.txID = object.txID ?? 0;
    message.requestID = object.requestID ?? 0;
    message.txBlockNumber = object.txBlockNumber ?? 0;
    message.trails = object.trails?.map((e) => TnPledgeWithdrawal_Trail.fromPartial(e)) || [];
    message.createdAt = object.createdAt ?? undefined;
    message.initiatorParticipantID = object.initiatorParticipantID ?? "";
    message.externalReferenceID = object.externalReferenceID ?? "";
    return message;
  },
};

function createBaseTnPledgeWithdrawal_Trail(): TnPledgeWithdrawal_Trail {
  return {
    id: "",
    pledgeWithdrawalID: "",
    addressCommandID: "",
    participantID: "",
    action: "",
    comment: "",
    createdAt: undefined,
  };
}

export const TnPledgeWithdrawal_Trail = {
  encode(message: TnPledgeWithdrawal_Trail, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.id !== "") {
      writer.uint32(10).string(message.id);
    }
    if (message.pledgeWithdrawalID !== "") {
      writer.uint32(18).string(message.pledgeWithdrawalID);
    }
    if (message.addressCommandID !== "") {
      writer.uint32(26).string(message.addressCommandID);
    }
    if (message.participantID !== "") {
      writer.uint32(34).string(message.participantID);
    }
    if (message.action !== "") {
      writer.uint32(42).string(message.action);
    }
    if (message.comment !== "") {
      writer.uint32(50).string(message.comment);
    }
    if (message.createdAt !== undefined) {
      Timestamp.encode(toTimestamp(message.createdAt), writer.uint32(58).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): TnPledgeWithdrawal_Trail {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseTnPledgeWithdrawal_Trail();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.id = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.pledgeWithdrawalID = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.addressCommandID = reader.string();
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.participantID = reader.string();
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.action = reader.string();
          continue;
        case 6:
          if (tag !== 50) {
            break;
          }

          message.comment = reader.string();
          continue;
        case 7:
          if (tag !== 58) {
            break;
          }

          message.createdAt = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): TnPledgeWithdrawal_Trail {
    return {
      id: isSet(object.id) ? globalThis.String(object.id) : "",
      pledgeWithdrawalID: isSet(object.pledgeWithdrawalID) ? globalThis.String(object.pledgeWithdrawalID) : "",
      addressCommandID: isSet(object.addressCommandID) ? globalThis.String(object.addressCommandID) : "",
      participantID: isSet(object.participantID) ? globalThis.String(object.participantID) : "",
      action: isSet(object.action) ? globalThis.String(object.action) : "",
      comment: isSet(object.comment) ? globalThis.String(object.comment) : "",
      createdAt: isSet(object.createdAt) ? fromJsonTimestamp(object.createdAt) : undefined,
    };
  },

  toJSON(message: TnPledgeWithdrawal_Trail): unknown {
    const obj: any = {};
    if (message.id !== "") {
      obj.id = message.id;
    }
    if (message.pledgeWithdrawalID !== "") {
      obj.pledgeWithdrawalID = message.pledgeWithdrawalID;
    }
    if (message.addressCommandID !== "") {
      obj.addressCommandID = message.addressCommandID;
    }
    if (message.participantID !== "") {
      obj.participantID = message.participantID;
    }
    if (message.action !== "") {
      obj.action = message.action;
    }
    if (message.comment !== "") {
      obj.comment = message.comment;
    }
    if (message.createdAt !== undefined) {
      obj.createdAt = message.createdAt.toISOString();
    }
    return obj;
  },

  create(base?: DeepPartial<TnPledgeWithdrawal_Trail>): TnPledgeWithdrawal_Trail {
    return TnPledgeWithdrawal_Trail.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<TnPledgeWithdrawal_Trail>): TnPledgeWithdrawal_Trail {
    const message = createBaseTnPledgeWithdrawal_Trail();
    message.id = object.id ?? "";
    message.pledgeWithdrawalID = object.pledgeWithdrawalID ?? "";
    message.addressCommandID = object.addressCommandID ?? "";
    message.participantID = object.participantID ?? "";
    message.action = object.action ?? "";
    message.comment = object.comment ?? "";
    message.createdAt = object.createdAt ?? undefined;
    return message;
  },
};

function createBaseTnPledgeAction(): TnPledgeAction {
  return {
    id: "",
    pledgeID: "",
    actionType: "",
    status: "",
    metadata: undefined,
    rule: "",
    approvers: undefined,
    needsApprovalFrom: [],
    createdAt: undefined,
    lastApprovalDate: undefined,
    envelope: "",
    trails: [],
    pledgeWithdrawalID: "",
  };
}

export const TnPledgeAction = {
  encode(message: TnPledgeAction, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.id !== "") {
      writer.uint32(10).string(message.id);
    }
    if (message.pledgeID !== "") {
      writer.uint32(18).string(message.pledgeID);
    }
    if (message.actionType !== "") {
      writer.uint32(26).string(message.actionType);
    }
    if (message.status !== "") {
      writer.uint32(34).string(message.status);
    }
    if (message.metadata !== undefined) {
      Metadata.encode(message.metadata, writer.uint32(42).fork()).ldelim();
    }
    if (message.rule !== "") {
      writer.uint32(50).string(message.rule);
    }
    if (message.approvers !== undefined) {
      Approvers.encode(message.approvers, writer.uint32(58).fork()).ldelim();
    }
    for (const v of message.needsApprovalFrom) {
      writer.uint32(66).string(v!);
    }
    if (message.createdAt !== undefined) {
      Timestamp.encode(toTimestamp(message.createdAt), writer.uint32(74).fork()).ldelim();
    }
    if (message.lastApprovalDate !== undefined) {
      Timestamp.encode(toTimestamp(message.lastApprovalDate), writer.uint32(82).fork()).ldelim();
    }
    if (message.envelope !== "") {
      writer.uint32(90).string(message.envelope);
    }
    for (const v of message.trails) {
      TnPledgeAction_Trail.encode(v!, writer.uint32(98).fork()).ldelim();
    }
    if (message.pledgeWithdrawalID !== "") {
      writer.uint32(106).string(message.pledgeWithdrawalID);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): TnPledgeAction {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseTnPledgeAction();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.id = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.pledgeID = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.actionType = reader.string();
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.status = reader.string();
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.metadata = Metadata.decode(reader, reader.uint32());
          continue;
        case 6:
          if (tag !== 50) {
            break;
          }

          message.rule = reader.string();
          continue;
        case 7:
          if (tag !== 58) {
            break;
          }

          message.approvers = Approvers.decode(reader, reader.uint32());
          continue;
        case 8:
          if (tag !== 66) {
            break;
          }

          message.needsApprovalFrom.push(reader.string());
          continue;
        case 9:
          if (tag !== 74) {
            break;
          }

          message.createdAt = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        case 10:
          if (tag !== 82) {
            break;
          }

          message.lastApprovalDate = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        case 11:
          if (tag !== 90) {
            break;
          }

          message.envelope = reader.string();
          continue;
        case 12:
          if (tag !== 98) {
            break;
          }

          message.trails.push(TnPledgeAction_Trail.decode(reader, reader.uint32()));
          continue;
        case 13:
          if (tag !== 106) {
            break;
          }

          message.pledgeWithdrawalID = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): TnPledgeAction {
    return {
      id: isSet(object.id) ? globalThis.String(object.id) : "",
      pledgeID: isSet(object.pledgeID) ? globalThis.String(object.pledgeID) : "",
      actionType: isSet(object.actionType) ? globalThis.String(object.actionType) : "",
      status: isSet(object.status) ? globalThis.String(object.status) : "",
      metadata: isSet(object.metadata) ? Metadata.fromJSON(object.metadata) : undefined,
      rule: isSet(object.rule) ? globalThis.String(object.rule) : "",
      approvers: isSet(object.approvers) ? Approvers.fromJSON(object.approvers) : undefined,
      needsApprovalFrom: globalThis.Array.isArray(object?.needsApprovalFrom)
        ? object.needsApprovalFrom.map((e: any) => globalThis.String(e))
        : [],
      createdAt: isSet(object.createdAt) ? fromJsonTimestamp(object.createdAt) : undefined,
      lastApprovalDate: isSet(object.lastApprovalDate) ? fromJsonTimestamp(object.lastApprovalDate) : undefined,
      envelope: isSet(object.envelope) ? globalThis.String(object.envelope) : "",
      trails: globalThis.Array.isArray(object?.trails)
        ? object.trails.map((e: any) => TnPledgeAction_Trail.fromJSON(e))
        : [],
      pledgeWithdrawalID: isSet(object.pledgeWithdrawalID) ? globalThis.String(object.pledgeWithdrawalID) : "",
    };
  },

  toJSON(message: TnPledgeAction): unknown {
    const obj: any = {};
    if (message.id !== "") {
      obj.id = message.id;
    }
    if (message.pledgeID !== "") {
      obj.pledgeID = message.pledgeID;
    }
    if (message.actionType !== "") {
      obj.actionType = message.actionType;
    }
    if (message.status !== "") {
      obj.status = message.status;
    }
    if (message.metadata !== undefined) {
      obj.metadata = Metadata.toJSON(message.metadata);
    }
    if (message.rule !== "") {
      obj.rule = message.rule;
    }
    if (message.approvers !== undefined) {
      obj.approvers = Approvers.toJSON(message.approvers);
    }
    if (message.needsApprovalFrom?.length) {
      obj.needsApprovalFrom = message.needsApprovalFrom;
    }
    if (message.createdAt !== undefined) {
      obj.createdAt = message.createdAt.toISOString();
    }
    if (message.lastApprovalDate !== undefined) {
      obj.lastApprovalDate = message.lastApprovalDate.toISOString();
    }
    if (message.envelope !== "") {
      obj.envelope = message.envelope;
    }
    if (message.trails?.length) {
      obj.trails = message.trails.map((e) => TnPledgeAction_Trail.toJSON(e));
    }
    if (message.pledgeWithdrawalID !== "") {
      obj.pledgeWithdrawalID = message.pledgeWithdrawalID;
    }
    return obj;
  },

  create(base?: DeepPartial<TnPledgeAction>): TnPledgeAction {
    return TnPledgeAction.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<TnPledgeAction>): TnPledgeAction {
    const message = createBaseTnPledgeAction();
    message.id = object.id ?? "";
    message.pledgeID = object.pledgeID ?? "";
    message.actionType = object.actionType ?? "";
    message.status = object.status ?? "";
    message.metadata = (object.metadata !== undefined && object.metadata !== null)
      ? Metadata.fromPartial(object.metadata)
      : undefined;
    message.rule = object.rule ?? "";
    message.approvers = (object.approvers !== undefined && object.approvers !== null)
      ? Approvers.fromPartial(object.approvers)
      : undefined;
    message.needsApprovalFrom = object.needsApprovalFrom?.map((e) => e) || [];
    message.createdAt = object.createdAt ?? undefined;
    message.lastApprovalDate = object.lastApprovalDate ?? undefined;
    message.envelope = object.envelope ?? "";
    message.trails = object.trails?.map((e) => TnPledgeAction_Trail.fromPartial(e)) || [];
    message.pledgeWithdrawalID = object.pledgeWithdrawalID ?? "";
    return message;
  },
};

function createBaseTnPledgeAction_Trail(): TnPledgeAction_Trail {
  return { id: "", pledgeActionID: "", userID: 0, externalUserID: "", action: "", comment: "", createdAt: undefined };
}

export const TnPledgeAction_Trail = {
  encode(message: TnPledgeAction_Trail, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.id !== "") {
      writer.uint32(10).string(message.id);
    }
    if (message.pledgeActionID !== "") {
      writer.uint32(18).string(message.pledgeActionID);
    }
    if (message.userID !== 0) {
      writer.uint32(24).uint64(message.userID);
    }
    if (message.externalUserID !== "") {
      writer.uint32(34).string(message.externalUserID);
    }
    if (message.action !== "") {
      writer.uint32(42).string(message.action);
    }
    if (message.comment !== "") {
      writer.uint32(50).string(message.comment);
    }
    if (message.createdAt !== undefined) {
      Timestamp.encode(toTimestamp(message.createdAt), writer.uint32(58).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): TnPledgeAction_Trail {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseTnPledgeAction_Trail();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.id = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.pledgeActionID = reader.string();
          continue;
        case 3:
          if (tag !== 24) {
            break;
          }

          message.userID = longToNumber(reader.uint64() as Long);
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.externalUserID = reader.string();
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.action = reader.string();
          continue;
        case 6:
          if (tag !== 50) {
            break;
          }

          message.comment = reader.string();
          continue;
        case 7:
          if (tag !== 58) {
            break;
          }

          message.createdAt = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): TnPledgeAction_Trail {
    return {
      id: isSet(object.id) ? globalThis.String(object.id) : "",
      pledgeActionID: isSet(object.pledgeActionID) ? globalThis.String(object.pledgeActionID) : "",
      userID: isSet(object.userID) ? globalThis.Number(object.userID) : 0,
      externalUserID: isSet(object.externalUserID) ? globalThis.String(object.externalUserID) : "",
      action: isSet(object.action) ? globalThis.String(object.action) : "",
      comment: isSet(object.comment) ? globalThis.String(object.comment) : "",
      createdAt: isSet(object.createdAt) ? fromJsonTimestamp(object.createdAt) : undefined,
    };
  },

  toJSON(message: TnPledgeAction_Trail): unknown {
    const obj: any = {};
    if (message.id !== "") {
      obj.id = message.id;
    }
    if (message.pledgeActionID !== "") {
      obj.pledgeActionID = message.pledgeActionID;
    }
    if (message.userID !== 0) {
      obj.userID = Math.round(message.userID);
    }
    if (message.externalUserID !== "") {
      obj.externalUserID = message.externalUserID;
    }
    if (message.action !== "") {
      obj.action = message.action;
    }
    if (message.comment !== "") {
      obj.comment = message.comment;
    }
    if (message.createdAt !== undefined) {
      obj.createdAt = message.createdAt.toISOString();
    }
    return obj;
  },

  create(base?: DeepPartial<TnPledgeAction_Trail>): TnPledgeAction_Trail {
    return TnPledgeAction_Trail.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<TnPledgeAction_Trail>): TnPledgeAction_Trail {
    const message = createBaseTnPledgeAction_Trail();
    message.id = object.id ?? "";
    message.pledgeActionID = object.pledgeActionID ?? "";
    message.userID = object.userID ?? 0;
    message.externalUserID = object.externalUserID ?? "";
    message.action = object.action ?? "";
    message.comment = object.comment ?? "";
    message.createdAt = object.createdAt ?? undefined;
    return message;
  },
};

function createBaseTnSettlementAssetTransfer(): TnSettlementAssetTransfer {
  return { currencyID: "", amount: "", sourceSharedAddressID: "", destinationSharedAddressID: "" };
}

export const TnSettlementAssetTransfer = {
  encode(message: TnSettlementAssetTransfer, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.currencyID !== "") {
      writer.uint32(10).string(message.currencyID);
    }
    if (message.amount !== "") {
      writer.uint32(18).string(message.amount);
    }
    if (message.sourceSharedAddressID !== "") {
      writer.uint32(26).string(message.sourceSharedAddressID);
    }
    if (message.destinationSharedAddressID !== "") {
      writer.uint32(34).string(message.destinationSharedAddressID);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): TnSettlementAssetTransfer {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseTnSettlementAssetTransfer();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.currencyID = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.amount = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.sourceSharedAddressID = reader.string();
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.destinationSharedAddressID = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): TnSettlementAssetTransfer {
    return {
      currencyID: isSet(object.currencyID) ? globalThis.String(object.currencyID) : "",
      amount: isSet(object.amount) ? globalThis.String(object.amount) : "",
      sourceSharedAddressID: isSet(object.sourceSharedAddressID) ? globalThis.String(object.sourceSharedAddressID) : "",
      destinationSharedAddressID: isSet(object.destinationSharedAddressID)
        ? globalThis.String(object.destinationSharedAddressID)
        : "",
    };
  },

  toJSON(message: TnSettlementAssetTransfer): unknown {
    const obj: any = {};
    if (message.currencyID !== "") {
      obj.currencyID = message.currencyID;
    }
    if (message.amount !== "") {
      obj.amount = message.amount;
    }
    if (message.sourceSharedAddressID !== "") {
      obj.sourceSharedAddressID = message.sourceSharedAddressID;
    }
    if (message.destinationSharedAddressID !== "") {
      obj.destinationSharedAddressID = message.destinationSharedAddressID;
    }
    return obj;
  },

  create(base?: DeepPartial<TnSettlementAssetTransfer>): TnSettlementAssetTransfer {
    return TnSettlementAssetTransfer.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<TnSettlementAssetTransfer>): TnSettlementAssetTransfer {
    const message = createBaseTnSettlementAssetTransfer();
    message.currencyID = object.currencyID ?? "";
    message.amount = object.amount ?? "";
    message.sourceSharedAddressID = object.sourceSharedAddressID ?? "";
    message.destinationSharedAddressID = object.destinationSharedAddressID ?? "";
    return message;
  },
};

function createBaseTnSettlementClipTransaction(): TnSettlementClipTransaction {
  return {
    id: "",
    assetTransfer: undefined,
    requestID: 0,
    requestMetadata: undefined,
    txHash: "",
    txID: 0,
    txBlockNumber: 0,
    status: "",
    createdAt: undefined,
    workflowID: "",
  };
}

export const TnSettlementClipTransaction = {
  encode(message: TnSettlementClipTransaction, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.id !== "") {
      writer.uint32(10).string(message.id);
    }
    if (message.assetTransfer !== undefined) {
      TnSettlementAssetTransfer.encode(message.assetTransfer, writer.uint32(18).fork()).ldelim();
    }
    if (message.requestID !== 0) {
      writer.uint32(24).uint64(message.requestID);
    }
    if (message.requestMetadata !== undefined) {
      Metadata.encode(message.requestMetadata, writer.uint32(34).fork()).ldelim();
    }
    if (message.txHash !== "") {
      writer.uint32(42).string(message.txHash);
    }
    if (message.txID !== 0) {
      writer.uint32(48).uint64(message.txID);
    }
    if (message.txBlockNumber !== 0) {
      writer.uint32(56).uint64(message.txBlockNumber);
    }
    if (message.status !== "") {
      writer.uint32(66).string(message.status);
    }
    if (message.createdAt !== undefined) {
      Timestamp.encode(toTimestamp(message.createdAt), writer.uint32(74).fork()).ldelim();
    }
    if (message.workflowID !== "") {
      writer.uint32(82).string(message.workflowID);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): TnSettlementClipTransaction {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseTnSettlementClipTransaction();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.id = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.assetTransfer = TnSettlementAssetTransfer.decode(reader, reader.uint32());
          continue;
        case 3:
          if (tag !== 24) {
            break;
          }

          message.requestID = longToNumber(reader.uint64() as Long);
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.requestMetadata = Metadata.decode(reader, reader.uint32());
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.txHash = reader.string();
          continue;
        case 6:
          if (tag !== 48) {
            break;
          }

          message.txID = longToNumber(reader.uint64() as Long);
          continue;
        case 7:
          if (tag !== 56) {
            break;
          }

          message.txBlockNumber = longToNumber(reader.uint64() as Long);
          continue;
        case 8:
          if (tag !== 66) {
            break;
          }

          message.status = reader.string();
          continue;
        case 9:
          if (tag !== 74) {
            break;
          }

          message.createdAt = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        case 10:
          if (tag !== 82) {
            break;
          }

          message.workflowID = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): TnSettlementClipTransaction {
    return {
      id: isSet(object.id) ? globalThis.String(object.id) : "",
      assetTransfer: isSet(object.assetTransfer) ? TnSettlementAssetTransfer.fromJSON(object.assetTransfer) : undefined,
      requestID: isSet(object.requestID) ? globalThis.Number(object.requestID) : 0,
      requestMetadata: isSet(object.requestMetadata) ? Metadata.fromJSON(object.requestMetadata) : undefined,
      txHash: isSet(object.txHash) ? globalThis.String(object.txHash) : "",
      txID: isSet(object.txID) ? globalThis.Number(object.txID) : 0,
      txBlockNumber: isSet(object.txBlockNumber) ? globalThis.Number(object.txBlockNumber) : 0,
      status: isSet(object.status) ? globalThis.String(object.status) : "",
      createdAt: isSet(object.createdAt) ? fromJsonTimestamp(object.createdAt) : undefined,
      workflowID: isSet(object.workflowID) ? globalThis.String(object.workflowID) : "",
    };
  },

  toJSON(message: TnSettlementClipTransaction): unknown {
    const obj: any = {};
    if (message.id !== "") {
      obj.id = message.id;
    }
    if (message.assetTransfer !== undefined) {
      obj.assetTransfer = TnSettlementAssetTransfer.toJSON(message.assetTransfer);
    }
    if (message.requestID !== 0) {
      obj.requestID = Math.round(message.requestID);
    }
    if (message.requestMetadata !== undefined) {
      obj.requestMetadata = Metadata.toJSON(message.requestMetadata);
    }
    if (message.txHash !== "") {
      obj.txHash = message.txHash;
    }
    if (message.txID !== 0) {
      obj.txID = Math.round(message.txID);
    }
    if (message.txBlockNumber !== 0) {
      obj.txBlockNumber = Math.round(message.txBlockNumber);
    }
    if (message.status !== "") {
      obj.status = message.status;
    }
    if (message.createdAt !== undefined) {
      obj.createdAt = message.createdAt.toISOString();
    }
    if (message.workflowID !== "") {
      obj.workflowID = message.workflowID;
    }
    return obj;
  },

  create(base?: DeepPartial<TnSettlementClipTransaction>): TnSettlementClipTransaction {
    return TnSettlementClipTransaction.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<TnSettlementClipTransaction>): TnSettlementClipTransaction {
    const message = createBaseTnSettlementClipTransaction();
    message.id = object.id ?? "";
    message.assetTransfer = (object.assetTransfer !== undefined && object.assetTransfer !== null)
      ? TnSettlementAssetTransfer.fromPartial(object.assetTransfer)
      : undefined;
    message.requestID = object.requestID ?? 0;
    message.requestMetadata = (object.requestMetadata !== undefined && object.requestMetadata !== null)
      ? Metadata.fromPartial(object.requestMetadata)
      : undefined;
    message.txHash = object.txHash ?? "";
    message.txID = object.txID ?? 0;
    message.txBlockNumber = object.txBlockNumber ?? 0;
    message.status = object.status ?? "";
    message.createdAt = object.createdAt ?? undefined;
    message.workflowID = object.workflowID ?? "";
    return message;
  },
};

function createBaseTnSettlementClip(): TnSettlementClip {
  return { id: "", index: 0, firstLegTransactions: [], secondLegTransactions: [], status: "", workflowID: "" };
}

export const TnSettlementClip = {
  encode(message: TnSettlementClip, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.id !== "") {
      writer.uint32(10).string(message.id);
    }
    if (message.index !== 0) {
      writer.uint32(16).uint64(message.index);
    }
    for (const v of message.firstLegTransactions) {
      TnSettlementClipTransaction.encode(v!, writer.uint32(26).fork()).ldelim();
    }
    for (const v of message.secondLegTransactions) {
      TnSettlementClipTransaction.encode(v!, writer.uint32(34).fork()).ldelim();
    }
    if (message.status !== "") {
      writer.uint32(42).string(message.status);
    }
    if (message.workflowID !== "") {
      writer.uint32(50).string(message.workflowID);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): TnSettlementClip {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseTnSettlementClip();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.id = reader.string();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.index = longToNumber(reader.uint64() as Long);
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.firstLegTransactions.push(TnSettlementClipTransaction.decode(reader, reader.uint32()));
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.secondLegTransactions.push(TnSettlementClipTransaction.decode(reader, reader.uint32()));
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.status = reader.string();
          continue;
        case 6:
          if (tag !== 50) {
            break;
          }

          message.workflowID = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): TnSettlementClip {
    return {
      id: isSet(object.id) ? globalThis.String(object.id) : "",
      index: isSet(object.index) ? globalThis.Number(object.index) : 0,
      firstLegTransactions: globalThis.Array.isArray(object?.firstLegTransactions)
        ? object.firstLegTransactions.map((e: any) => TnSettlementClipTransaction.fromJSON(e))
        : [],
      secondLegTransactions: globalThis.Array.isArray(object?.secondLegTransactions)
        ? object.secondLegTransactions.map((e: any) => TnSettlementClipTransaction.fromJSON(e))
        : [],
      status: isSet(object.status) ? globalThis.String(object.status) : "",
      workflowID: isSet(object.workflowID) ? globalThis.String(object.workflowID) : "",
    };
  },

  toJSON(message: TnSettlementClip): unknown {
    const obj: any = {};
    if (message.id !== "") {
      obj.id = message.id;
    }
    if (message.index !== 0) {
      obj.index = Math.round(message.index);
    }
    if (message.firstLegTransactions?.length) {
      obj.firstLegTransactions = message.firstLegTransactions.map((e) => TnSettlementClipTransaction.toJSON(e));
    }
    if (message.secondLegTransactions?.length) {
      obj.secondLegTransactions = message.secondLegTransactions.map((e) => TnSettlementClipTransaction.toJSON(e));
    }
    if (message.status !== "") {
      obj.status = message.status;
    }
    if (message.workflowID !== "") {
      obj.workflowID = message.workflowID;
    }
    return obj;
  },

  create(base?: DeepPartial<TnSettlementClip>): TnSettlementClip {
    return TnSettlementClip.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<TnSettlementClip>): TnSettlementClip {
    const message = createBaseTnSettlementClip();
    message.id = object.id ?? "";
    message.index = object.index ?? 0;
    message.firstLegTransactions =
      object.firstLegTransactions?.map((e) => TnSettlementClipTransaction.fromPartial(e)) || [];
    message.secondLegTransactions =
      object.secondLegTransactions?.map((e) => TnSettlementClipTransaction.fromPartial(e)) || [];
    message.status = object.status ?? "";
    message.workflowID = object.workflowID ?? "";
    return message;
  },
};

function createBaseTnSettlement(): TnSettlement {
  return {
    id: "",
    creatorParticipantID: "",
    targetParticipantID: "",
    firstLegParticipantID: "",
    firstLegAssets: [],
    secondLegAssets: [],
    clips: [],
    startExecutionDate: undefined,
    status: "",
    createdAt: undefined,
    updatedAt: undefined,
    workflowID: "",
  };
}

export const TnSettlement = {
  encode(message: TnSettlement, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.id !== "") {
      writer.uint32(10).string(message.id);
    }
    if (message.creatorParticipantID !== "") {
      writer.uint32(18).string(message.creatorParticipantID);
    }
    if (message.targetParticipantID !== "") {
      writer.uint32(26).string(message.targetParticipantID);
    }
    if (message.firstLegParticipantID !== "") {
      writer.uint32(34).string(message.firstLegParticipantID);
    }
    for (const v of message.firstLegAssets) {
      TnSettlementAssetTransfer.encode(v!, writer.uint32(42).fork()).ldelim();
    }
    for (const v of message.secondLegAssets) {
      TnSettlementAssetTransfer.encode(v!, writer.uint32(50).fork()).ldelim();
    }
    for (const v of message.clips) {
      TnSettlementClip.encode(v!, writer.uint32(58).fork()).ldelim();
    }
    if (message.startExecutionDate !== undefined) {
      Timestamp.encode(toTimestamp(message.startExecutionDate), writer.uint32(66).fork()).ldelim();
    }
    if (message.status !== "") {
      writer.uint32(74).string(message.status);
    }
    if (message.createdAt !== undefined) {
      Timestamp.encode(toTimestamp(message.createdAt), writer.uint32(82).fork()).ldelim();
    }
    if (message.updatedAt !== undefined) {
      Timestamp.encode(toTimestamp(message.updatedAt), writer.uint32(90).fork()).ldelim();
    }
    if (message.workflowID !== "") {
      writer.uint32(98).string(message.workflowID);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): TnSettlement {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseTnSettlement();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.id = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.creatorParticipantID = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.targetParticipantID = reader.string();
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.firstLegParticipantID = reader.string();
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.firstLegAssets.push(TnSettlementAssetTransfer.decode(reader, reader.uint32()));
          continue;
        case 6:
          if (tag !== 50) {
            break;
          }

          message.secondLegAssets.push(TnSettlementAssetTransfer.decode(reader, reader.uint32()));
          continue;
        case 7:
          if (tag !== 58) {
            break;
          }

          message.clips.push(TnSettlementClip.decode(reader, reader.uint32()));
          continue;
        case 8:
          if (tag !== 66) {
            break;
          }

          message.startExecutionDate = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        case 9:
          if (tag !== 74) {
            break;
          }

          message.status = reader.string();
          continue;
        case 10:
          if (tag !== 82) {
            break;
          }

          message.createdAt = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        case 11:
          if (tag !== 90) {
            break;
          }

          message.updatedAt = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        case 12:
          if (tag !== 98) {
            break;
          }

          message.workflowID = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): TnSettlement {
    return {
      id: isSet(object.id) ? globalThis.String(object.id) : "",
      creatorParticipantID: isSet(object.creatorParticipantID) ? globalThis.String(object.creatorParticipantID) : "",
      targetParticipantID: isSet(object.targetParticipantID) ? globalThis.String(object.targetParticipantID) : "",
      firstLegParticipantID: isSet(object.firstLegParticipantID) ? globalThis.String(object.firstLegParticipantID) : "",
      firstLegAssets: globalThis.Array.isArray(object?.firstLegAssets)
        ? object.firstLegAssets.map((e: any) => TnSettlementAssetTransfer.fromJSON(e))
        : [],
      secondLegAssets: globalThis.Array.isArray(object?.secondLegAssets)
        ? object.secondLegAssets.map((e: any) => TnSettlementAssetTransfer.fromJSON(e))
        : [],
      clips: globalThis.Array.isArray(object?.clips) ? object.clips.map((e: any) => TnSettlementClip.fromJSON(e)) : [],
      startExecutionDate: isSet(object.startExecutionDate) ? fromJsonTimestamp(object.startExecutionDate) : undefined,
      status: isSet(object.status) ? globalThis.String(object.status) : "",
      createdAt: isSet(object.createdAt) ? fromJsonTimestamp(object.createdAt) : undefined,
      updatedAt: isSet(object.updatedAt) ? fromJsonTimestamp(object.updatedAt) : undefined,
      workflowID: isSet(object.workflowID) ? globalThis.String(object.workflowID) : "",
    };
  },

  toJSON(message: TnSettlement): unknown {
    const obj: any = {};
    if (message.id !== "") {
      obj.id = message.id;
    }
    if (message.creatorParticipantID !== "") {
      obj.creatorParticipantID = message.creatorParticipantID;
    }
    if (message.targetParticipantID !== "") {
      obj.targetParticipantID = message.targetParticipantID;
    }
    if (message.firstLegParticipantID !== "") {
      obj.firstLegParticipantID = message.firstLegParticipantID;
    }
    if (message.firstLegAssets?.length) {
      obj.firstLegAssets = message.firstLegAssets.map((e) => TnSettlementAssetTransfer.toJSON(e));
    }
    if (message.secondLegAssets?.length) {
      obj.secondLegAssets = message.secondLegAssets.map((e) => TnSettlementAssetTransfer.toJSON(e));
    }
    if (message.clips?.length) {
      obj.clips = message.clips.map((e) => TnSettlementClip.toJSON(e));
    }
    if (message.startExecutionDate !== undefined) {
      obj.startExecutionDate = message.startExecutionDate.toISOString();
    }
    if (message.status !== "") {
      obj.status = message.status;
    }
    if (message.createdAt !== undefined) {
      obj.createdAt = message.createdAt.toISOString();
    }
    if (message.updatedAt !== undefined) {
      obj.updatedAt = message.updatedAt.toISOString();
    }
    if (message.workflowID !== "") {
      obj.workflowID = message.workflowID;
    }
    return obj;
  },

  create(base?: DeepPartial<TnSettlement>): TnSettlement {
    return TnSettlement.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<TnSettlement>): TnSettlement {
    const message = createBaseTnSettlement();
    message.id = object.id ?? "";
    message.creatorParticipantID = object.creatorParticipantID ?? "";
    message.targetParticipantID = object.targetParticipantID ?? "";
    message.firstLegParticipantID = object.firstLegParticipantID ?? "";
    message.firstLegAssets = object.firstLegAssets?.map((e) => TnSettlementAssetTransfer.fromPartial(e)) || [];
    message.secondLegAssets = object.secondLegAssets?.map((e) => TnSettlementAssetTransfer.fromPartial(e)) || [];
    message.clips = object.clips?.map((e) => TnSettlementClip.fromPartial(e)) || [];
    message.startExecutionDate = object.startExecutionDate ?? undefined;
    message.status = object.status ?? "";
    message.createdAt = object.createdAt ?? undefined;
    message.updatedAt = object.updatedAt ?? undefined;
    message.workflowID = object.workflowID ?? "";
    return message;
  },
};

type Builtin = Date | Function | Uint8Array | string | number | boolean | undefined;

export type DeepPartial<T> = T extends Builtin ? T
  : T extends globalThis.Array<infer U> ? globalThis.Array<DeepPartial<U>>
  : T extends ReadonlyArray<infer U> ? ReadonlyArray<DeepPartial<U>>
  : T extends {} ? { [K in keyof T]?: DeepPartial<T[K]> }
  : Partial<T>;

function toTimestamp(date: Date): Timestamp {
  const seconds = Math.trunc(date.getTime() / 1_000);
  const nanos = (date.getTime() % 1_000) * 1_000_000;
  return { seconds, nanos };
}

function fromTimestamp(t: Timestamp): Date {
  let millis = (t.seconds || 0) * 1_000;
  millis += (t.nanos || 0) / 1_000_000;
  return new globalThis.Date(millis);
}

function fromJsonTimestamp(o: any): Date {
  if (o instanceof globalThis.Date) {
    return o;
  } else if (typeof o === "string") {
    return new globalThis.Date(o);
  } else {
    return fromTimestamp(Timestamp.fromJSON(o));
  }
}

function longToNumber(long: Long): number {
  if (long.gt(globalThis.Number.MAX_SAFE_INTEGER)) {
    throw new globalThis.Error("Value is larger than Number.MAX_SAFE_INTEGER");
  }
  if (long.lt(globalThis.Number.MIN_SAFE_INTEGER)) {
    throw new globalThis.Error("Value is smaller than Number.MIN_SAFE_INTEGER");
  }
  return long.toNumber();
}

if (_m0.util.Long !== Long) {
  _m0.util.Long = Long as any;
  _m0.configure();
}

function isSet(value: any): boolean {
  return value !== null && value !== undefined;
}
