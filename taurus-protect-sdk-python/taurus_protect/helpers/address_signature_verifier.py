"""Address signature verification using HSM slot public keys."""

from __future__ import annotations

from cryptography.exceptions import InvalidSignature

from taurus_protect.crypto.signing import verify_signature
from taurus_protect.errors import IntegrityError
from taurus_protect.models.address import Address
from taurus_protect.models.governance_rules import DecodedRulesContainer


def verify_address_signature(
    address: Address,
    rules_container: DecodedRulesContainer,
) -> None:
    """
    Verify the address signature using the HSM slot public key.

    The signed data is the blockchain address string only. The public key
    is found by locating a user with the HSMSLOT role in the rules container.

    This verification is mandatory for all address operations to ensure
    the address was generated by the HSM and has not been tampered with.

    Args:
        address: The address to verify.
        rules_container: The decoded rules container containing HSM public keys.

    Raises:
        IntegrityError: If the address has no signature, no user with HSMSLOT
            role is found, or signature verification fails.
        ValueError: If arguments are None.

    Example:
        >>> # Typically called internally by AddressService.get()
        >>> verify_address_signature(address, decoded_rules)
    """
    if address is None:
        raise ValueError("address cannot be None")
    if rules_container is None:
        raise ValueError("rules_container cannot be None")

    # Check for signature presence (mandatory)
    if not address.signature:
        raise IntegrityError(f"Address {address.id} has no signature")

    # Check for address string presence
    if not address.address:
        raise IntegrityError(f"Address {address.id} has no blockchain address to verify")

    # Get the HSM public key (cached in rules container)
    hsm_public_key = rules_container.get_hsm_public_key()
    if hsm_public_key is None:
        raise IntegrityError("No user with HSMSLOT role found in rules container")

    # Verify the signature
    # The signed data is just the blockchain address string
    address_data = address.address.encode("utf-8")

    try:
        valid = verify_signature(hsm_public_key, address_data, address.signature)
        if not valid:
            raise IntegrityError(f"Address signature verification failed for address {address.id}")
    except IntegrityError:
        raise
    except (ValueError, TypeError, InvalidSignature) as e:
        # ValueError: Invalid key/signature format
        # TypeError: Invalid data types
        # InvalidSignature: Cryptographic signature verification failed
        raise IntegrityError(f"Address signature verification failed for address {address.id}: {e}")
