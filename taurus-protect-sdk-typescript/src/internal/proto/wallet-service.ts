// Code generated by protoc-gen-ts_proto. DO NOT EDIT.
// versions:
//   protoc-gen-ts_proto  v1.181.2
//   protoc               v6.33.4
// source: wallet-service.proto

/* eslint-disable */
import Long from "long";
import _m0 from "protobufjs/minimal";
import { Currency, UniqueCurrencyFilter } from "./currency";
import { RequestCursor, ResponseCursor } from "./cursor";
import { Empty } from "./google/protobuf/empty";
import { Reservation } from "./reservation";
import { ScoreFilter } from "./score";
import {
  Address,
  AddressAttribute,
  Asset,
  AssetBalance,
  BalanceHistoryPoint,
  LightAddressInfo,
  NFTCollectionBalance,
  ProofOfReserve,
  UTXO,
  Wallet,
  WalletAttribute,
  WalletInfo,
} from "./wallet";

export const protobufPackage = "tgvalidatord";

export interface GetCurrenciesRequest {
  showDisabled: boolean;
  includeLogo: boolean;
}

export interface GetCurrenciesReply {
  result: Currency[];
}

export interface GetCurrencyRequest {
  showDisabled: boolean;
  uniqueCurrencyFilter: UniqueCurrencyFilter | undefined;
  currencyID: string;
  includeLogo: boolean;
}

export interface GetCurrencyReply {
  result: Currency | undefined;
}

export interface GetBaseCurrencyReply {
  result: string;
}

export interface CreateWalletRequest {
  currency: string;
  name: string;
  /** @deprecated */
  container: string;
  isOmnibus: boolean;
  comment: string;
  customerId: string;
  blockchain: string;
  network: string;
  visibilityGroupID: string;
  externalWalletId: string;
}

export interface GetWalletRequest {
  id: number;
}

export interface GetWalletReply {
  result: Wallet | undefined;
}

export interface GetWalletInfoReply {
  result: WalletInfo | undefined;
}

export interface CreateWalletReply {
  result: Wallet | undefined;
}

export interface GetWalletsRequest {
  currencies: string[];
}

export interface GetWalletsInfoRequest {
  currencies: string[];
  query: string;
  limit: number;
  offset: number;
  name: string;
  sortOrder: string;
  excludeDisabled: boolean;
  tagIDs: string[];
  onlyPositiveBalance: boolean;
  blockchain: string;
  network: string;
  ids: number[];
}

export interface GetWalletsReply {
  result: Wallet[];
}

export interface GetWalletsInfoReply {
  result: WalletInfo[];
  totalItems: number;
  offset: number;
}

export interface GetAddressTokensReply {
  balances: AssetBalance[];
  total: number;
  next: Uint8Array;
  totalAssetBalance: AssetBalance | undefined;
}

export interface GetAddressTokensRequest {
  id: number;
  limit: number;
  cursor: Uint8Array;
}

export interface GetWalletTokensReply {
  balances: AssetBalance[];
  total: number;
  next: Uint8Array;
}

export interface GetWalletTokensRequest {
  id: number;
  limit: number;
  cursor: Uint8Array;
}

export interface GetBalancesRequest {
  currency: string;
  limit: number;
  cursor: Uint8Array;
  tokenId: string;
  requestCursor: RequestCursor | undefined;
}

export interface GetBalancesReply {
  balances: AssetBalance[];
  total: number;
  next: Uint8Array;
  cursor: ResponseCursor | undefined;
}

export interface GetNFTCollectionBalancesRequest {
  blockchain: string;
  query: string;
  cursor: RequestCursor | undefined;
  network: string;
  onlyPositiveBalance: boolean;
}

export interface GetNFTCollectionBalancesReply {
  balances: NFTCollectionBalance[];
  cursor: ResponseCursor | undefined;
}

export interface GetAssetWalletsReply {
  wallets: WalletInfo[];
  totalItems: number;
  next: Uint8Array;
  cursor: ResponseCursor | undefined;
}

export interface GetAssetWalletsRequest {
  asset: Asset | undefined;
  limit: number;
  cursor: Uint8Array;
  walletId: number;
  walletName: string;
  requestCursor: RequestCursor | undefined;
}

export interface GetAssetAddressesReply {
  addresses: Address[];
  totalItems: number;
  /**
   * Use cursor instead
   *
   * @deprecated
   */
  next: Uint8Array;
  cursor: ResponseCursor | undefined;
}

export interface GetAssetAddressesRequest {
  asset: Asset | undefined;
  limit: number;
  /**
   * Use requestCursor instead
   *
   * @deprecated
   */
  cursor: Uint8Array;
  /** Pagination */
  sorting: GetAssetAddressesRequest_Sorting | undefined;
  requestCursor: RequestCursor | undefined;
  walletId: number;
  addressId: number;
  addresses: string[];
}

export interface GetAssetAddressesRequest_Sorting {
  sortOrder: GetAssetAddressesRequest_Sorting_SortOrder;
}

export enum GetAssetAddressesRequest_Sorting_SortOrder {
  /** ASC - default */
  ASC = 0,
  DESC = 1,
  UNRECOGNIZED = -1,
}

export function getAssetAddressesRequest_Sorting_SortOrderFromJSON(
  object: any,
): GetAssetAddressesRequest_Sorting_SortOrder {
  switch (object) {
    case 0:
    case "ASC":
      return GetAssetAddressesRequest_Sorting_SortOrder.ASC;
    case 1:
    case "DESC":
      return GetAssetAddressesRequest_Sorting_SortOrder.DESC;
    case -1:
    case "UNRECOGNIZED":
    default:
      return GetAssetAddressesRequest_Sorting_SortOrder.UNRECOGNIZED;
  }
}

export function getAssetAddressesRequest_Sorting_SortOrderToJSON(
  object: GetAssetAddressesRequest_Sorting_SortOrder,
): string {
  switch (object) {
    case GetAssetAddressesRequest_Sorting_SortOrder.ASC:
      return "ASC";
    case GetAssetAddressesRequest_Sorting_SortOrder.DESC:
      return "DESC";
    case GetAssetAddressesRequest_Sorting_SortOrder.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

export interface CreateWalletAttributesRequest {
  walletId: number;
  attributes: CreateWalletAttributeRequest[];
}

export interface CreateWalletAttributesReply {
  result: WalletAttribute[];
}

export interface CreateWalletAttributeRequest {
  key: string;
  value: string;
  contentType: string;
  type: string;
  subtype: string;
  isfile: boolean;
}

export interface DeleteWalletAttributeRequest {
  walletId: number;
  id: number;
}

export interface CreateAddressAttributesRequest {
  addressId: number;
  attributes: CreateAddressAttributeRequest[];
}

export interface CreateAddressAttributesReply {
  result: AddressAttribute[];
}

export interface CreateAddressAttributeRequest {
  key: string;
  value: string;
  contentType: string;
  type: string;
  subtype: string;
  isfile: boolean;
}

export interface DeleteAddressAttributeRequest {
  addressId: number;
  id: number;
}

export interface GetAddressesRequest {
  currency: string;
  query: string;
  limit: number;
  offset: number;
  /** @deprecated */
  scoreProvider: string;
  /** @deprecated */
  scoreInBelow: string;
  /** @deprecated */
  scoreOutBelow: string;
  /** @deprecated */
  scoreExclusive: boolean;
  onlyPositiveBalance: boolean;
  sortBy: string;
  sortOrder: string;
  balanceBelow: string;
  balanceAbove: string;
  walletId: number;
  customerId: string;
  /** @deprecated */
  coinfirmScoreGreater: string;
  /** @deprecated */
  chainalysisScoreGreater: string;
  tagIDs: string[];
  blockchain: string;
  network: string;
  addressIds: number[];
  nfts: string;
  addresses: string[];
  scoreFilter: ScoreFilter | undefined;
  attributeFiltersJson: string;
  attributeFiltersOperator: string;
}

export interface GetAddressesReply {
  result: Address[];
  totalItems: number;
}

export interface GetLightAddressesRequest {
  currencyID: string;
  uniqueCurrencyFilter: UniqueCurrencyFilter | undefined;
  addresses: string[];
}

export interface GetLightAddressesReply {
  result: LightAddressInfo[];
}

export interface GetAddressesStatusRequest {
  walletIds: number[];
  addressIds: number[];
  currencyIds: string[];
  sorting: GetAddressesStatusRequest_Sorting | undefined;
  cursor: RequestCursor | undefined;
}

export interface GetAddressesStatusRequest_Sorting {
  sortOrder: GetAddressesStatusRequest_Sorting_SortOrder;
}

export enum GetAddressesStatusRequest_Sorting_SortOrder {
  ASC = 0,
  DESC = 1,
  UNRECOGNIZED = -1,
}

export function getAddressesStatusRequest_Sorting_SortOrderFromJSON(
  object: any,
): GetAddressesStatusRequest_Sorting_SortOrder {
  switch (object) {
    case 0:
    case "ASC":
      return GetAddressesStatusRequest_Sorting_SortOrder.ASC;
    case 1:
    case "DESC":
      return GetAddressesStatusRequest_Sorting_SortOrder.DESC;
    case -1:
    case "UNRECOGNIZED":
    default:
      return GetAddressesStatusRequest_Sorting_SortOrder.UNRECOGNIZED;
  }
}

export function getAddressesStatusRequest_Sorting_SortOrderToJSON(
  object: GetAddressesStatusRequest_Sorting_SortOrder,
): string {
  switch (object) {
    case GetAddressesStatusRequest_Sorting_SortOrder.ASC:
      return "ASC";
    case GetAddressesStatusRequest_Sorting_SortOrder.DESC:
      return "DESC";
    case GetAddressesStatusRequest_Sorting_SortOrder.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

export interface GetAddressesStatusReply {
  result: LightAddressInfo[];
  cursor: ResponseCursor | undefined;
}

/** Using non-convential name because of names collision with legacy HSM calls. Must be cleaned up later */
export interface GetAddressRequest {
  id: number;
}

/** Using non-convential name because of names collision with legacy HSM calls. Must be cleaned up later */
export interface GetAddressReply {
  result: Address | undefined;
}

export interface GetAddressUTXOsRequest {
  id: number;
}

export interface GetAddressUTXOsReply {
  result: UTXO[];
}

export interface GetAddressBalanceHistoryRequest {
  id: number;
  intervalHours: number;
}

export interface ExportAddressBalanceHistoryRequest {
  id: number;
  intervalHours: number;
  format: string;
}

export interface GetAddressBalanceHistoryReply {
  result: BalanceHistoryPoint[];
}

export interface ExportAddressBalanceHistoryReply {
  result: string;
  totalItems: number;
}

export interface GetWalletBalanceHistoryRequest {
  id: number;
  intervalHours: number;
}

export interface GetWalletBalanceHistoryReply {
  result: BalanceHistoryPoint[];
}

export interface CreateAddressRequest {
  walletId: number;
  label: string;
  comment: string;
  customerId: string;
  nonHardenedDerivation: boolean;
  workchainId: number;
  type: string;
  externalAddressId: string;
}

export interface CreateAddressesRequest {
  addresses: CreateAddressRequest[];
}

export interface CreateAddressReply {
  result: Address | undefined;
}

export interface CreateAddressesReply {
  result: LightAddressInfo[];
}

export interface ComputeAddressesSignatureRequest {
  walletId: number;
  addressId: number;
}

export interface ComputeAddressesSignatureReply {
  result: ComputeAddressesSignatureReply_AddressSignature[];
  totalItems: number;
}

export interface ComputeAddressesSignatureReply_AddressSignature {
  walletId: number;
  addressId: number;
  address: string;
  currency: string;
  signature: string;
  error: string;
  currencyInfo: Currency | undefined;
}

export interface GetAddressProofOfReserveRequest {
  id: number;
  challenge: string;
}

export interface GetAddressProofOfReserveReply {
  result: ProofOfReserve | undefined;
}

export interface GetAddressesProofOfReserveRequest {
  addresses: string[];
  blockchain: string;
  challenge: string;
  network: string;
}

export interface GetAddressesProofOfReserveReply {
  result: ProofOfReserve[];
}

export interface BTCSignMessageRequest {
  addressId: number;
  message: string;
}

export interface BTCSignMessageReply {
  address: string;
  message: string;
  signature: string;
}

export interface ETHSignMessageRequest {
  addressId: number;
  message: string;
}

export interface ETHSignMessageReply {
  address: string;
  message: string;
  signature: string;
}

export interface ExportAddressesRequest {
  walletId: number;
  currency: string;
  format: string;
  query: string;
  /** @deprecated */
  scoreProvider: string;
  /** @deprecated */
  scoreInBelow: string;
  /** @deprecated */
  scoreOutBelow: string;
  /** @deprecated */
  scoreExclusive: boolean;
  customerId: string;
  /** @deprecated */
  coinfirmScoreGreater: string;
  /** @deprecated */
  chainalysisScoreGreater: string;
  scoreFilter: ScoreFilter | undefined;
  blockchain: string;
  network: string;
}

export interface ExportAddressesReply {
  result: string;
  totalItems: number;
}

export interface GetReservationsRequest {
  /** @deprecated */
  kind: string;
  address: string;
  addressId: number;
  cursor: RequestCursor | undefined;
  kinds: string[];
}

export interface GetReservationsReply {
  result: Reservation[];
  cursor: ResponseCursor | undefined;
}

export interface GetReservationRequest {
  id: number;
}

export interface GetReservationReply {
  result: Reservation | undefined;
}

export interface GetReservationUTXORequest {
  id: number;
}

export interface GetReservationUTXOReply {
  result: UTXO | undefined;
}

function createBaseGetCurrenciesRequest(): GetCurrenciesRequest {
  return { showDisabled: false, includeLogo: false };
}

export const GetCurrenciesRequest = {
  encode(message: GetCurrenciesRequest, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.showDisabled !== false) {
      writer.uint32(8).bool(message.showDisabled);
    }
    if (message.includeLogo !== false) {
      writer.uint32(16).bool(message.includeLogo);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): GetCurrenciesRequest {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetCurrenciesRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.showDisabled = reader.bool();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.includeLogo = reader.bool();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetCurrenciesRequest {
    return {
      showDisabled: isSet(object.showDisabled) ? globalThis.Boolean(object.showDisabled) : false,
      includeLogo: isSet(object.includeLogo) ? globalThis.Boolean(object.includeLogo) : false,
    };
  },

  toJSON(message: GetCurrenciesRequest): unknown {
    const obj: any = {};
    if (message.showDisabled !== false) {
      obj.showDisabled = message.showDisabled;
    }
    if (message.includeLogo !== false) {
      obj.includeLogo = message.includeLogo;
    }
    return obj;
  },

  create(base?: DeepPartial<GetCurrenciesRequest>): GetCurrenciesRequest {
    return GetCurrenciesRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<GetCurrenciesRequest>): GetCurrenciesRequest {
    const message = createBaseGetCurrenciesRequest();
    message.showDisabled = object.showDisabled ?? false;
    message.includeLogo = object.includeLogo ?? false;
    return message;
  },
};

function createBaseGetCurrenciesReply(): GetCurrenciesReply {
  return { result: [] };
}

export const GetCurrenciesReply = {
  encode(message: GetCurrenciesReply, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    for (const v of message.result) {
      Currency.encode(v!, writer.uint32(10).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): GetCurrenciesReply {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetCurrenciesReply();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.result.push(Currency.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetCurrenciesReply {
    return {
      result: globalThis.Array.isArray(object?.result) ? object.result.map((e: any) => Currency.fromJSON(e)) : [],
    };
  },

  toJSON(message: GetCurrenciesReply): unknown {
    const obj: any = {};
    if (message.result?.length) {
      obj.result = message.result.map((e) => Currency.toJSON(e));
    }
    return obj;
  },

  create(base?: DeepPartial<GetCurrenciesReply>): GetCurrenciesReply {
    return GetCurrenciesReply.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<GetCurrenciesReply>): GetCurrenciesReply {
    const message = createBaseGetCurrenciesReply();
    message.result = object.result?.map((e) => Currency.fromPartial(e)) || [];
    return message;
  },
};

function createBaseGetCurrencyRequest(): GetCurrencyRequest {
  return { showDisabled: false, uniqueCurrencyFilter: undefined, currencyID: "", includeLogo: false };
}

export const GetCurrencyRequest = {
  encode(message: GetCurrencyRequest, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.showDisabled !== false) {
      writer.uint32(8).bool(message.showDisabled);
    }
    if (message.uniqueCurrencyFilter !== undefined) {
      UniqueCurrencyFilter.encode(message.uniqueCurrencyFilter, writer.uint32(18).fork()).ldelim();
    }
    if (message.currencyID !== "") {
      writer.uint32(26).string(message.currencyID);
    }
    if (message.includeLogo !== false) {
      writer.uint32(32).bool(message.includeLogo);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): GetCurrencyRequest {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetCurrencyRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.showDisabled = reader.bool();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.uniqueCurrencyFilter = UniqueCurrencyFilter.decode(reader, reader.uint32());
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.currencyID = reader.string();
          continue;
        case 4:
          if (tag !== 32) {
            break;
          }

          message.includeLogo = reader.bool();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetCurrencyRequest {
    return {
      showDisabled: isSet(object.showDisabled) ? globalThis.Boolean(object.showDisabled) : false,
      uniqueCurrencyFilter: isSet(object.uniqueCurrencyFilter)
        ? UniqueCurrencyFilter.fromJSON(object.uniqueCurrencyFilter)
        : undefined,
      currencyID: isSet(object.currencyID) ? globalThis.String(object.currencyID) : "",
      includeLogo: isSet(object.includeLogo) ? globalThis.Boolean(object.includeLogo) : false,
    };
  },

  toJSON(message: GetCurrencyRequest): unknown {
    const obj: any = {};
    if (message.showDisabled !== false) {
      obj.showDisabled = message.showDisabled;
    }
    if (message.uniqueCurrencyFilter !== undefined) {
      obj.uniqueCurrencyFilter = UniqueCurrencyFilter.toJSON(message.uniqueCurrencyFilter);
    }
    if (message.currencyID !== "") {
      obj.currencyID = message.currencyID;
    }
    if (message.includeLogo !== false) {
      obj.includeLogo = message.includeLogo;
    }
    return obj;
  },

  create(base?: DeepPartial<GetCurrencyRequest>): GetCurrencyRequest {
    return GetCurrencyRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<GetCurrencyRequest>): GetCurrencyRequest {
    const message = createBaseGetCurrencyRequest();
    message.showDisabled = object.showDisabled ?? false;
    message.uniqueCurrencyFilter = (object.uniqueCurrencyFilter !== undefined && object.uniqueCurrencyFilter !== null)
      ? UniqueCurrencyFilter.fromPartial(object.uniqueCurrencyFilter)
      : undefined;
    message.currencyID = object.currencyID ?? "";
    message.includeLogo = object.includeLogo ?? false;
    return message;
  },
};

function createBaseGetCurrencyReply(): GetCurrencyReply {
  return { result: undefined };
}

export const GetCurrencyReply = {
  encode(message: GetCurrencyReply, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.result !== undefined) {
      Currency.encode(message.result, writer.uint32(10).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): GetCurrencyReply {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetCurrencyReply();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.result = Currency.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetCurrencyReply {
    return { result: isSet(object.result) ? Currency.fromJSON(object.result) : undefined };
  },

  toJSON(message: GetCurrencyReply): unknown {
    const obj: any = {};
    if (message.result !== undefined) {
      obj.result = Currency.toJSON(message.result);
    }
    return obj;
  },

  create(base?: DeepPartial<GetCurrencyReply>): GetCurrencyReply {
    return GetCurrencyReply.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<GetCurrencyReply>): GetCurrencyReply {
    const message = createBaseGetCurrencyReply();
    message.result = (object.result !== undefined && object.result !== null)
      ? Currency.fromPartial(object.result)
      : undefined;
    return message;
  },
};

function createBaseGetBaseCurrencyReply(): GetBaseCurrencyReply {
  return { result: "" };
}

export const GetBaseCurrencyReply = {
  encode(message: GetBaseCurrencyReply, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.result !== "") {
      writer.uint32(10).string(message.result);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): GetBaseCurrencyReply {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetBaseCurrencyReply();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.result = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetBaseCurrencyReply {
    return { result: isSet(object.result) ? globalThis.String(object.result) : "" };
  },

  toJSON(message: GetBaseCurrencyReply): unknown {
    const obj: any = {};
    if (message.result !== "") {
      obj.result = message.result;
    }
    return obj;
  },

  create(base?: DeepPartial<GetBaseCurrencyReply>): GetBaseCurrencyReply {
    return GetBaseCurrencyReply.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<GetBaseCurrencyReply>): GetBaseCurrencyReply {
    const message = createBaseGetBaseCurrencyReply();
    message.result = object.result ?? "";
    return message;
  },
};

function createBaseCreateWalletRequest(): CreateWalletRequest {
  return {
    currency: "",
    name: "",
    container: "",
    isOmnibus: false,
    comment: "",
    customerId: "",
    blockchain: "",
    network: "",
    visibilityGroupID: "",
    externalWalletId: "",
  };
}

export const CreateWalletRequest = {
  encode(message: CreateWalletRequest, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.currency !== "") {
      writer.uint32(10).string(message.currency);
    }
    if (message.name !== "") {
      writer.uint32(18).string(message.name);
    }
    if (message.container !== "") {
      writer.uint32(26).string(message.container);
    }
    if (message.isOmnibus !== false) {
      writer.uint32(32).bool(message.isOmnibus);
    }
    if (message.comment !== "") {
      writer.uint32(42).string(message.comment);
    }
    if (message.customerId !== "") {
      writer.uint32(50).string(message.customerId);
    }
    if (message.blockchain !== "") {
      writer.uint32(58).string(message.blockchain);
    }
    if (message.network !== "") {
      writer.uint32(66).string(message.network);
    }
    if (message.visibilityGroupID !== "") {
      writer.uint32(74).string(message.visibilityGroupID);
    }
    if (message.externalWalletId !== "") {
      writer.uint32(82).string(message.externalWalletId);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CreateWalletRequest {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCreateWalletRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.currency = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.name = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.container = reader.string();
          continue;
        case 4:
          if (tag !== 32) {
            break;
          }

          message.isOmnibus = reader.bool();
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.comment = reader.string();
          continue;
        case 6:
          if (tag !== 50) {
            break;
          }

          message.customerId = reader.string();
          continue;
        case 7:
          if (tag !== 58) {
            break;
          }

          message.blockchain = reader.string();
          continue;
        case 8:
          if (tag !== 66) {
            break;
          }

          message.network = reader.string();
          continue;
        case 9:
          if (tag !== 74) {
            break;
          }

          message.visibilityGroupID = reader.string();
          continue;
        case 10:
          if (tag !== 82) {
            break;
          }

          message.externalWalletId = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CreateWalletRequest {
    return {
      currency: isSet(object.currency) ? globalThis.String(object.currency) : "",
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      container: isSet(object.container) ? globalThis.String(object.container) : "",
      isOmnibus: isSet(object.isOmnibus) ? globalThis.Boolean(object.isOmnibus) : false,
      comment: isSet(object.comment) ? globalThis.String(object.comment) : "",
      customerId: isSet(object.customerId) ? globalThis.String(object.customerId) : "",
      blockchain: isSet(object.blockchain) ? globalThis.String(object.blockchain) : "",
      network: isSet(object.network) ? globalThis.String(object.network) : "",
      visibilityGroupID: isSet(object.visibilityGroupID) ? globalThis.String(object.visibilityGroupID) : "",
      externalWalletId: isSet(object.externalWalletId) ? globalThis.String(object.externalWalletId) : "",
    };
  },

  toJSON(message: CreateWalletRequest): unknown {
    const obj: any = {};
    if (message.currency !== "") {
      obj.currency = message.currency;
    }
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.container !== "") {
      obj.container = message.container;
    }
    if (message.isOmnibus !== false) {
      obj.isOmnibus = message.isOmnibus;
    }
    if (message.comment !== "") {
      obj.comment = message.comment;
    }
    if (message.customerId !== "") {
      obj.customerId = message.customerId;
    }
    if (message.blockchain !== "") {
      obj.blockchain = message.blockchain;
    }
    if (message.network !== "") {
      obj.network = message.network;
    }
    if (message.visibilityGroupID !== "") {
      obj.visibilityGroupID = message.visibilityGroupID;
    }
    if (message.externalWalletId !== "") {
      obj.externalWalletId = message.externalWalletId;
    }
    return obj;
  },

  create(base?: DeepPartial<CreateWalletRequest>): CreateWalletRequest {
    return CreateWalletRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CreateWalletRequest>): CreateWalletRequest {
    const message = createBaseCreateWalletRequest();
    message.currency = object.currency ?? "";
    message.name = object.name ?? "";
    message.container = object.container ?? "";
    message.isOmnibus = object.isOmnibus ?? false;
    message.comment = object.comment ?? "";
    message.customerId = object.customerId ?? "";
    message.blockchain = object.blockchain ?? "";
    message.network = object.network ?? "";
    message.visibilityGroupID = object.visibilityGroupID ?? "";
    message.externalWalletId = object.externalWalletId ?? "";
    return message;
  },
};

function createBaseGetWalletRequest(): GetWalletRequest {
  return { id: 0 };
}

export const GetWalletRequest = {
  encode(message: GetWalletRequest, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.id !== 0) {
      writer.uint32(8).uint64(message.id);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): GetWalletRequest {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetWalletRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.id = longToNumber(reader.uint64() as Long);
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetWalletRequest {
    return { id: isSet(object.id) ? globalThis.Number(object.id) : 0 };
  },

  toJSON(message: GetWalletRequest): unknown {
    const obj: any = {};
    if (message.id !== 0) {
      obj.id = Math.round(message.id);
    }
    return obj;
  },

  create(base?: DeepPartial<GetWalletRequest>): GetWalletRequest {
    return GetWalletRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<GetWalletRequest>): GetWalletRequest {
    const message = createBaseGetWalletRequest();
    message.id = object.id ?? 0;
    return message;
  },
};

function createBaseGetWalletReply(): GetWalletReply {
  return { result: undefined };
}

export const GetWalletReply = {
  encode(message: GetWalletReply, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.result !== undefined) {
      Wallet.encode(message.result, writer.uint32(10).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): GetWalletReply {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetWalletReply();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.result = Wallet.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetWalletReply {
    return { result: isSet(object.result) ? Wallet.fromJSON(object.result) : undefined };
  },

  toJSON(message: GetWalletReply): unknown {
    const obj: any = {};
    if (message.result !== undefined) {
      obj.result = Wallet.toJSON(message.result);
    }
    return obj;
  },

  create(base?: DeepPartial<GetWalletReply>): GetWalletReply {
    return GetWalletReply.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<GetWalletReply>): GetWalletReply {
    const message = createBaseGetWalletReply();
    message.result = (object.result !== undefined && object.result !== null)
      ? Wallet.fromPartial(object.result)
      : undefined;
    return message;
  },
};

function createBaseGetWalletInfoReply(): GetWalletInfoReply {
  return { result: undefined };
}

export const GetWalletInfoReply = {
  encode(message: GetWalletInfoReply, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.result !== undefined) {
      WalletInfo.encode(message.result, writer.uint32(10).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): GetWalletInfoReply {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetWalletInfoReply();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.result = WalletInfo.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetWalletInfoReply {
    return { result: isSet(object.result) ? WalletInfo.fromJSON(object.result) : undefined };
  },

  toJSON(message: GetWalletInfoReply): unknown {
    const obj: any = {};
    if (message.result !== undefined) {
      obj.result = WalletInfo.toJSON(message.result);
    }
    return obj;
  },

  create(base?: DeepPartial<GetWalletInfoReply>): GetWalletInfoReply {
    return GetWalletInfoReply.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<GetWalletInfoReply>): GetWalletInfoReply {
    const message = createBaseGetWalletInfoReply();
    message.result = (object.result !== undefined && object.result !== null)
      ? WalletInfo.fromPartial(object.result)
      : undefined;
    return message;
  },
};

function createBaseCreateWalletReply(): CreateWalletReply {
  return { result: undefined };
}

export const CreateWalletReply = {
  encode(message: CreateWalletReply, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.result !== undefined) {
      Wallet.encode(message.result, writer.uint32(10).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CreateWalletReply {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCreateWalletReply();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.result = Wallet.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CreateWalletReply {
    return { result: isSet(object.result) ? Wallet.fromJSON(object.result) : undefined };
  },

  toJSON(message: CreateWalletReply): unknown {
    const obj: any = {};
    if (message.result !== undefined) {
      obj.result = Wallet.toJSON(message.result);
    }
    return obj;
  },

  create(base?: DeepPartial<CreateWalletReply>): CreateWalletReply {
    return CreateWalletReply.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CreateWalletReply>): CreateWalletReply {
    const message = createBaseCreateWalletReply();
    message.result = (object.result !== undefined && object.result !== null)
      ? Wallet.fromPartial(object.result)
      : undefined;
    return message;
  },
};

function createBaseGetWalletsRequest(): GetWalletsRequest {
  return { currencies: [] };
}

export const GetWalletsRequest = {
  encode(message: GetWalletsRequest, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    for (const v of message.currencies) {
      writer.uint32(10).string(v!);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): GetWalletsRequest {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetWalletsRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.currencies.push(reader.string());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetWalletsRequest {
    return {
      currencies: globalThis.Array.isArray(object?.currencies)
        ? object.currencies.map((e: any) => globalThis.String(e))
        : [],
    };
  },

  toJSON(message: GetWalletsRequest): unknown {
    const obj: any = {};
    if (message.currencies?.length) {
      obj.currencies = message.currencies;
    }
    return obj;
  },

  create(base?: DeepPartial<GetWalletsRequest>): GetWalletsRequest {
    return GetWalletsRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<GetWalletsRequest>): GetWalletsRequest {
    const message = createBaseGetWalletsRequest();
    message.currencies = object.currencies?.map((e) => e) || [];
    return message;
  },
};

function createBaseGetWalletsInfoRequest(): GetWalletsInfoRequest {
  return {
    currencies: [],
    query: "",
    limit: 0,
    offset: 0,
    name: "",
    sortOrder: "",
    excludeDisabled: false,
    tagIDs: [],
    onlyPositiveBalance: false,
    blockchain: "",
    network: "",
    ids: [],
  };
}

export const GetWalletsInfoRequest = {
  encode(message: GetWalletsInfoRequest, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    for (const v of message.currencies) {
      writer.uint32(10).string(v!);
    }
    if (message.query !== "") {
      writer.uint32(18).string(message.query);
    }
    if (message.limit !== 0) {
      writer.uint32(24).uint64(message.limit);
    }
    if (message.offset !== 0) {
      writer.uint32(32).uint64(message.offset);
    }
    if (message.name !== "") {
      writer.uint32(42).string(message.name);
    }
    if (message.sortOrder !== "") {
      writer.uint32(50).string(message.sortOrder);
    }
    if (message.excludeDisabled !== false) {
      writer.uint32(56).bool(message.excludeDisabled);
    }
    for (const v of message.tagIDs) {
      writer.uint32(66).string(v!);
    }
    if (message.onlyPositiveBalance !== false) {
      writer.uint32(72).bool(message.onlyPositiveBalance);
    }
    if (message.blockchain !== "") {
      writer.uint32(82).string(message.blockchain);
    }
    if (message.network !== "") {
      writer.uint32(90).string(message.network);
    }
    writer.uint32(98).fork();
    for (const v of message.ids) {
      writer.uint64(v);
    }
    writer.ldelim();
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): GetWalletsInfoRequest {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetWalletsInfoRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.currencies.push(reader.string());
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.query = reader.string();
          continue;
        case 3:
          if (tag !== 24) {
            break;
          }

          message.limit = longToNumber(reader.uint64() as Long);
          continue;
        case 4:
          if (tag !== 32) {
            break;
          }

          message.offset = longToNumber(reader.uint64() as Long);
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.name = reader.string();
          continue;
        case 6:
          if (tag !== 50) {
            break;
          }

          message.sortOrder = reader.string();
          continue;
        case 7:
          if (tag !== 56) {
            break;
          }

          message.excludeDisabled = reader.bool();
          continue;
        case 8:
          if (tag !== 66) {
            break;
          }

          message.tagIDs.push(reader.string());
          continue;
        case 9:
          if (tag !== 72) {
            break;
          }

          message.onlyPositiveBalance = reader.bool();
          continue;
        case 10:
          if (tag !== 82) {
            break;
          }

          message.blockchain = reader.string();
          continue;
        case 11:
          if (tag !== 90) {
            break;
          }

          message.network = reader.string();
          continue;
        case 12:
          if (tag === 96) {
            message.ids.push(longToNumber(reader.uint64() as Long));

            continue;
          }

          if (tag === 98) {
            const end2 = reader.uint32() + reader.pos;
            while (reader.pos < end2) {
              message.ids.push(longToNumber(reader.uint64() as Long));
            }

            continue;
          }

          break;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetWalletsInfoRequest {
    return {
      currencies: globalThis.Array.isArray(object?.currencies)
        ? object.currencies.map((e: any) => globalThis.String(e))
        : [],
      query: isSet(object.query) ? globalThis.String(object.query) : "",
      limit: isSet(object.limit) ? globalThis.Number(object.limit) : 0,
      offset: isSet(object.offset) ? globalThis.Number(object.offset) : 0,
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      sortOrder: isSet(object.sortOrder) ? globalThis.String(object.sortOrder) : "",
      excludeDisabled: isSet(object.excludeDisabled) ? globalThis.Boolean(object.excludeDisabled) : false,
      tagIDs: globalThis.Array.isArray(object?.tagIDs) ? object.tagIDs.map((e: any) => globalThis.String(e)) : [],
      onlyPositiveBalance: isSet(object.onlyPositiveBalance) ? globalThis.Boolean(object.onlyPositiveBalance) : false,
      blockchain: isSet(object.blockchain) ? globalThis.String(object.blockchain) : "",
      network: isSet(object.network) ? globalThis.String(object.network) : "",
      ids: globalThis.Array.isArray(object?.ids) ? object.ids.map((e: any) => globalThis.Number(e)) : [],
    };
  },

  toJSON(message: GetWalletsInfoRequest): unknown {
    const obj: any = {};
    if (message.currencies?.length) {
      obj.currencies = message.currencies;
    }
    if (message.query !== "") {
      obj.query = message.query;
    }
    if (message.limit !== 0) {
      obj.limit = Math.round(message.limit);
    }
    if (message.offset !== 0) {
      obj.offset = Math.round(message.offset);
    }
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.sortOrder !== "") {
      obj.sortOrder = message.sortOrder;
    }
    if (message.excludeDisabled !== false) {
      obj.excludeDisabled = message.excludeDisabled;
    }
    if (message.tagIDs?.length) {
      obj.tagIDs = message.tagIDs;
    }
    if (message.onlyPositiveBalance !== false) {
      obj.onlyPositiveBalance = message.onlyPositiveBalance;
    }
    if (message.blockchain !== "") {
      obj.blockchain = message.blockchain;
    }
    if (message.network !== "") {
      obj.network = message.network;
    }
    if (message.ids?.length) {
      obj.ids = message.ids.map((e) => Math.round(e));
    }
    return obj;
  },

  create(base?: DeepPartial<GetWalletsInfoRequest>): GetWalletsInfoRequest {
    return GetWalletsInfoRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<GetWalletsInfoRequest>): GetWalletsInfoRequest {
    const message = createBaseGetWalletsInfoRequest();
    message.currencies = object.currencies?.map((e) => e) || [];
    message.query = object.query ?? "";
    message.limit = object.limit ?? 0;
    message.offset = object.offset ?? 0;
    message.name = object.name ?? "";
    message.sortOrder = object.sortOrder ?? "";
    message.excludeDisabled = object.excludeDisabled ?? false;
    message.tagIDs = object.tagIDs?.map((e) => e) || [];
    message.onlyPositiveBalance = object.onlyPositiveBalance ?? false;
    message.blockchain = object.blockchain ?? "";
    message.network = object.network ?? "";
    message.ids = object.ids?.map((e) => e) || [];
    return message;
  },
};

function createBaseGetWalletsReply(): GetWalletsReply {
  return { result: [] };
}

export const GetWalletsReply = {
  encode(message: GetWalletsReply, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    for (const v of message.result) {
      Wallet.encode(v!, writer.uint32(10).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): GetWalletsReply {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetWalletsReply();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.result.push(Wallet.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetWalletsReply {
    return {
      result: globalThis.Array.isArray(object?.result) ? object.result.map((e: any) => Wallet.fromJSON(e)) : [],
    };
  },

  toJSON(message: GetWalletsReply): unknown {
    const obj: any = {};
    if (message.result?.length) {
      obj.result = message.result.map((e) => Wallet.toJSON(e));
    }
    return obj;
  },

  create(base?: DeepPartial<GetWalletsReply>): GetWalletsReply {
    return GetWalletsReply.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<GetWalletsReply>): GetWalletsReply {
    const message = createBaseGetWalletsReply();
    message.result = object.result?.map((e) => Wallet.fromPartial(e)) || [];
    return message;
  },
};

function createBaseGetWalletsInfoReply(): GetWalletsInfoReply {
  return { result: [], totalItems: 0, offset: 0 };
}

export const GetWalletsInfoReply = {
  encode(message: GetWalletsInfoReply, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    for (const v of message.result) {
      WalletInfo.encode(v!, writer.uint32(10).fork()).ldelim();
    }
    if (message.totalItems !== 0) {
      writer.uint32(16).uint64(message.totalItems);
    }
    if (message.offset !== 0) {
      writer.uint32(24).uint64(message.offset);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): GetWalletsInfoReply {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetWalletsInfoReply();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.result.push(WalletInfo.decode(reader, reader.uint32()));
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.totalItems = longToNumber(reader.uint64() as Long);
          continue;
        case 3:
          if (tag !== 24) {
            break;
          }

          message.offset = longToNumber(reader.uint64() as Long);
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetWalletsInfoReply {
    return {
      result: globalThis.Array.isArray(object?.result) ? object.result.map((e: any) => WalletInfo.fromJSON(e)) : [],
      totalItems: isSet(object.totalItems) ? globalThis.Number(object.totalItems) : 0,
      offset: isSet(object.offset) ? globalThis.Number(object.offset) : 0,
    };
  },

  toJSON(message: GetWalletsInfoReply): unknown {
    const obj: any = {};
    if (message.result?.length) {
      obj.result = message.result.map((e) => WalletInfo.toJSON(e));
    }
    if (message.totalItems !== 0) {
      obj.totalItems = Math.round(message.totalItems);
    }
    if (message.offset !== 0) {
      obj.offset = Math.round(message.offset);
    }
    return obj;
  },

  create(base?: DeepPartial<GetWalletsInfoReply>): GetWalletsInfoReply {
    return GetWalletsInfoReply.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<GetWalletsInfoReply>): GetWalletsInfoReply {
    const message = createBaseGetWalletsInfoReply();
    message.result = object.result?.map((e) => WalletInfo.fromPartial(e)) || [];
    message.totalItems = object.totalItems ?? 0;
    message.offset = object.offset ?? 0;
    return message;
  },
};

function createBaseGetAddressTokensReply(): GetAddressTokensReply {
  return { balances: [], total: 0, next: new Uint8Array(0), totalAssetBalance: undefined };
}

export const GetAddressTokensReply = {
  encode(message: GetAddressTokensReply, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    for (const v of message.balances) {
      AssetBalance.encode(v!, writer.uint32(10).fork()).ldelim();
    }
    if (message.total !== 0) {
      writer.uint32(16).uint64(message.total);
    }
    if (message.next.length !== 0) {
      writer.uint32(26).bytes(message.next);
    }
    if (message.totalAssetBalance !== undefined) {
      AssetBalance.encode(message.totalAssetBalance, writer.uint32(34).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): GetAddressTokensReply {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetAddressTokensReply();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.balances.push(AssetBalance.decode(reader, reader.uint32()));
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.total = longToNumber(reader.uint64() as Long);
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.next = reader.bytes();
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.totalAssetBalance = AssetBalance.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetAddressTokensReply {
    return {
      balances: globalThis.Array.isArray(object?.balances)
        ? object.balances.map((e: any) => AssetBalance.fromJSON(e))
        : [],
      total: isSet(object.total) ? globalThis.Number(object.total) : 0,
      next: isSet(object.next) ? bytesFromBase64(object.next) : new Uint8Array(0),
      totalAssetBalance: isSet(object.totalAssetBalance) ? AssetBalance.fromJSON(object.totalAssetBalance) : undefined,
    };
  },

  toJSON(message: GetAddressTokensReply): unknown {
    const obj: any = {};
    if (message.balances?.length) {
      obj.balances = message.balances.map((e) => AssetBalance.toJSON(e));
    }
    if (message.total !== 0) {
      obj.total = Math.round(message.total);
    }
    if (message.next.length !== 0) {
      obj.next = base64FromBytes(message.next);
    }
    if (message.totalAssetBalance !== undefined) {
      obj.totalAssetBalance = AssetBalance.toJSON(message.totalAssetBalance);
    }
    return obj;
  },

  create(base?: DeepPartial<GetAddressTokensReply>): GetAddressTokensReply {
    return GetAddressTokensReply.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<GetAddressTokensReply>): GetAddressTokensReply {
    const message = createBaseGetAddressTokensReply();
    message.balances = object.balances?.map((e) => AssetBalance.fromPartial(e)) || [];
    message.total = object.total ?? 0;
    message.next = object.next ?? new Uint8Array(0);
    message.totalAssetBalance = (object.totalAssetBalance !== undefined && object.totalAssetBalance !== null)
      ? AssetBalance.fromPartial(object.totalAssetBalance)
      : undefined;
    return message;
  },
};

function createBaseGetAddressTokensRequest(): GetAddressTokensRequest {
  return { id: 0, limit: 0, cursor: new Uint8Array(0) };
}

export const GetAddressTokensRequest = {
  encode(message: GetAddressTokensRequest, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.id !== 0) {
      writer.uint32(8).uint64(message.id);
    }
    if (message.limit !== 0) {
      writer.uint32(16).uint64(message.limit);
    }
    if (message.cursor.length !== 0) {
      writer.uint32(26).bytes(message.cursor);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): GetAddressTokensRequest {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetAddressTokensRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.id = longToNumber(reader.uint64() as Long);
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.limit = longToNumber(reader.uint64() as Long);
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.cursor = reader.bytes();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetAddressTokensRequest {
    return {
      id: isSet(object.id) ? globalThis.Number(object.id) : 0,
      limit: isSet(object.limit) ? globalThis.Number(object.limit) : 0,
      cursor: isSet(object.cursor) ? bytesFromBase64(object.cursor) : new Uint8Array(0),
    };
  },

  toJSON(message: GetAddressTokensRequest): unknown {
    const obj: any = {};
    if (message.id !== 0) {
      obj.id = Math.round(message.id);
    }
    if (message.limit !== 0) {
      obj.limit = Math.round(message.limit);
    }
    if (message.cursor.length !== 0) {
      obj.cursor = base64FromBytes(message.cursor);
    }
    return obj;
  },

  create(base?: DeepPartial<GetAddressTokensRequest>): GetAddressTokensRequest {
    return GetAddressTokensRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<GetAddressTokensRequest>): GetAddressTokensRequest {
    const message = createBaseGetAddressTokensRequest();
    message.id = object.id ?? 0;
    message.limit = object.limit ?? 0;
    message.cursor = object.cursor ?? new Uint8Array(0);
    return message;
  },
};

function createBaseGetWalletTokensReply(): GetWalletTokensReply {
  return { balances: [], total: 0, next: new Uint8Array(0) };
}

export const GetWalletTokensReply = {
  encode(message: GetWalletTokensReply, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    for (const v of message.balances) {
      AssetBalance.encode(v!, writer.uint32(10).fork()).ldelim();
    }
    if (message.total !== 0) {
      writer.uint32(16).uint64(message.total);
    }
    if (message.next.length !== 0) {
      writer.uint32(26).bytes(message.next);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): GetWalletTokensReply {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetWalletTokensReply();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.balances.push(AssetBalance.decode(reader, reader.uint32()));
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.total = longToNumber(reader.uint64() as Long);
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.next = reader.bytes();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetWalletTokensReply {
    return {
      balances: globalThis.Array.isArray(object?.balances)
        ? object.balances.map((e: any) => AssetBalance.fromJSON(e))
        : [],
      total: isSet(object.total) ? globalThis.Number(object.total) : 0,
      next: isSet(object.next) ? bytesFromBase64(object.next) : new Uint8Array(0),
    };
  },

  toJSON(message: GetWalletTokensReply): unknown {
    const obj: any = {};
    if (message.balances?.length) {
      obj.balances = message.balances.map((e) => AssetBalance.toJSON(e));
    }
    if (message.total !== 0) {
      obj.total = Math.round(message.total);
    }
    if (message.next.length !== 0) {
      obj.next = base64FromBytes(message.next);
    }
    return obj;
  },

  create(base?: DeepPartial<GetWalletTokensReply>): GetWalletTokensReply {
    return GetWalletTokensReply.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<GetWalletTokensReply>): GetWalletTokensReply {
    const message = createBaseGetWalletTokensReply();
    message.balances = object.balances?.map((e) => AssetBalance.fromPartial(e)) || [];
    message.total = object.total ?? 0;
    message.next = object.next ?? new Uint8Array(0);
    return message;
  },
};

function createBaseGetWalletTokensRequest(): GetWalletTokensRequest {
  return { id: 0, limit: 0, cursor: new Uint8Array(0) };
}

export const GetWalletTokensRequest = {
  encode(message: GetWalletTokensRequest, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.id !== 0) {
      writer.uint32(8).uint64(message.id);
    }
    if (message.limit !== 0) {
      writer.uint32(16).uint64(message.limit);
    }
    if (message.cursor.length !== 0) {
      writer.uint32(26).bytes(message.cursor);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): GetWalletTokensRequest {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetWalletTokensRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.id = longToNumber(reader.uint64() as Long);
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.limit = longToNumber(reader.uint64() as Long);
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.cursor = reader.bytes();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetWalletTokensRequest {
    return {
      id: isSet(object.id) ? globalThis.Number(object.id) : 0,
      limit: isSet(object.limit) ? globalThis.Number(object.limit) : 0,
      cursor: isSet(object.cursor) ? bytesFromBase64(object.cursor) : new Uint8Array(0),
    };
  },

  toJSON(message: GetWalletTokensRequest): unknown {
    const obj: any = {};
    if (message.id !== 0) {
      obj.id = Math.round(message.id);
    }
    if (message.limit !== 0) {
      obj.limit = Math.round(message.limit);
    }
    if (message.cursor.length !== 0) {
      obj.cursor = base64FromBytes(message.cursor);
    }
    return obj;
  },

  create(base?: DeepPartial<GetWalletTokensRequest>): GetWalletTokensRequest {
    return GetWalletTokensRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<GetWalletTokensRequest>): GetWalletTokensRequest {
    const message = createBaseGetWalletTokensRequest();
    message.id = object.id ?? 0;
    message.limit = object.limit ?? 0;
    message.cursor = object.cursor ?? new Uint8Array(0);
    return message;
  },
};

function createBaseGetBalancesRequest(): GetBalancesRequest {
  return { currency: "", limit: 0, cursor: new Uint8Array(0), tokenId: "", requestCursor: undefined };
}

export const GetBalancesRequest = {
  encode(message: GetBalancesRequest, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.currency !== "") {
      writer.uint32(10).string(message.currency);
    }
    if (message.limit !== 0) {
      writer.uint32(16).uint64(message.limit);
    }
    if (message.cursor.length !== 0) {
      writer.uint32(26).bytes(message.cursor);
    }
    if (message.tokenId !== "") {
      writer.uint32(34).string(message.tokenId);
    }
    if (message.requestCursor !== undefined) {
      RequestCursor.encode(message.requestCursor, writer.uint32(42).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): GetBalancesRequest {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetBalancesRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.currency = reader.string();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.limit = longToNumber(reader.uint64() as Long);
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.cursor = reader.bytes();
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.tokenId = reader.string();
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.requestCursor = RequestCursor.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetBalancesRequest {
    return {
      currency: isSet(object.currency) ? globalThis.String(object.currency) : "",
      limit: isSet(object.limit) ? globalThis.Number(object.limit) : 0,
      cursor: isSet(object.cursor) ? bytesFromBase64(object.cursor) : new Uint8Array(0),
      tokenId: isSet(object.tokenId) ? globalThis.String(object.tokenId) : "",
      requestCursor: isSet(object.requestCursor) ? RequestCursor.fromJSON(object.requestCursor) : undefined,
    };
  },

  toJSON(message: GetBalancesRequest): unknown {
    const obj: any = {};
    if (message.currency !== "") {
      obj.currency = message.currency;
    }
    if (message.limit !== 0) {
      obj.limit = Math.round(message.limit);
    }
    if (message.cursor.length !== 0) {
      obj.cursor = base64FromBytes(message.cursor);
    }
    if (message.tokenId !== "") {
      obj.tokenId = message.tokenId;
    }
    if (message.requestCursor !== undefined) {
      obj.requestCursor = RequestCursor.toJSON(message.requestCursor);
    }
    return obj;
  },

  create(base?: DeepPartial<GetBalancesRequest>): GetBalancesRequest {
    return GetBalancesRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<GetBalancesRequest>): GetBalancesRequest {
    const message = createBaseGetBalancesRequest();
    message.currency = object.currency ?? "";
    message.limit = object.limit ?? 0;
    message.cursor = object.cursor ?? new Uint8Array(0);
    message.tokenId = object.tokenId ?? "";
    message.requestCursor = (object.requestCursor !== undefined && object.requestCursor !== null)
      ? RequestCursor.fromPartial(object.requestCursor)
      : undefined;
    return message;
  },
};

function createBaseGetBalancesReply(): GetBalancesReply {
  return { balances: [], total: 0, next: new Uint8Array(0), cursor: undefined };
}

export const GetBalancesReply = {
  encode(message: GetBalancesReply, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    for (const v of message.balances) {
      AssetBalance.encode(v!, writer.uint32(10).fork()).ldelim();
    }
    if (message.total !== 0) {
      writer.uint32(16).uint64(message.total);
    }
    if (message.next.length !== 0) {
      writer.uint32(26).bytes(message.next);
    }
    if (message.cursor !== undefined) {
      ResponseCursor.encode(message.cursor, writer.uint32(34).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): GetBalancesReply {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetBalancesReply();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.balances.push(AssetBalance.decode(reader, reader.uint32()));
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.total = longToNumber(reader.uint64() as Long);
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.next = reader.bytes();
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.cursor = ResponseCursor.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetBalancesReply {
    return {
      balances: globalThis.Array.isArray(object?.balances)
        ? object.balances.map((e: any) => AssetBalance.fromJSON(e))
        : [],
      total: isSet(object.total) ? globalThis.Number(object.total) : 0,
      next: isSet(object.next) ? bytesFromBase64(object.next) : new Uint8Array(0),
      cursor: isSet(object.cursor) ? ResponseCursor.fromJSON(object.cursor) : undefined,
    };
  },

  toJSON(message: GetBalancesReply): unknown {
    const obj: any = {};
    if (message.balances?.length) {
      obj.balances = message.balances.map((e) => AssetBalance.toJSON(e));
    }
    if (message.total !== 0) {
      obj.total = Math.round(message.total);
    }
    if (message.next.length !== 0) {
      obj.next = base64FromBytes(message.next);
    }
    if (message.cursor !== undefined) {
      obj.cursor = ResponseCursor.toJSON(message.cursor);
    }
    return obj;
  },

  create(base?: DeepPartial<GetBalancesReply>): GetBalancesReply {
    return GetBalancesReply.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<GetBalancesReply>): GetBalancesReply {
    const message = createBaseGetBalancesReply();
    message.balances = object.balances?.map((e) => AssetBalance.fromPartial(e)) || [];
    message.total = object.total ?? 0;
    message.next = object.next ?? new Uint8Array(0);
    message.cursor = (object.cursor !== undefined && object.cursor !== null)
      ? ResponseCursor.fromPartial(object.cursor)
      : undefined;
    return message;
  },
};

function createBaseGetNFTCollectionBalancesRequest(): GetNFTCollectionBalancesRequest {
  return { blockchain: "", query: "", cursor: undefined, network: "", onlyPositiveBalance: false };
}

export const GetNFTCollectionBalancesRequest = {
  encode(message: GetNFTCollectionBalancesRequest, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.blockchain !== "") {
      writer.uint32(10).string(message.blockchain);
    }
    if (message.query !== "") {
      writer.uint32(18).string(message.query);
    }
    if (message.cursor !== undefined) {
      RequestCursor.encode(message.cursor, writer.uint32(26).fork()).ldelim();
    }
    if (message.network !== "") {
      writer.uint32(34).string(message.network);
    }
    if (message.onlyPositiveBalance !== false) {
      writer.uint32(40).bool(message.onlyPositiveBalance);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): GetNFTCollectionBalancesRequest {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetNFTCollectionBalancesRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.blockchain = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.query = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.cursor = RequestCursor.decode(reader, reader.uint32());
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.network = reader.string();
          continue;
        case 5:
          if (tag !== 40) {
            break;
          }

          message.onlyPositiveBalance = reader.bool();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetNFTCollectionBalancesRequest {
    return {
      blockchain: isSet(object.blockchain) ? globalThis.String(object.blockchain) : "",
      query: isSet(object.query) ? globalThis.String(object.query) : "",
      cursor: isSet(object.cursor) ? RequestCursor.fromJSON(object.cursor) : undefined,
      network: isSet(object.network) ? globalThis.String(object.network) : "",
      onlyPositiveBalance: isSet(object.onlyPositiveBalance) ? globalThis.Boolean(object.onlyPositiveBalance) : false,
    };
  },

  toJSON(message: GetNFTCollectionBalancesRequest): unknown {
    const obj: any = {};
    if (message.blockchain !== "") {
      obj.blockchain = message.blockchain;
    }
    if (message.query !== "") {
      obj.query = message.query;
    }
    if (message.cursor !== undefined) {
      obj.cursor = RequestCursor.toJSON(message.cursor);
    }
    if (message.network !== "") {
      obj.network = message.network;
    }
    if (message.onlyPositiveBalance !== false) {
      obj.onlyPositiveBalance = message.onlyPositiveBalance;
    }
    return obj;
  },

  create(base?: DeepPartial<GetNFTCollectionBalancesRequest>): GetNFTCollectionBalancesRequest {
    return GetNFTCollectionBalancesRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<GetNFTCollectionBalancesRequest>): GetNFTCollectionBalancesRequest {
    const message = createBaseGetNFTCollectionBalancesRequest();
    message.blockchain = object.blockchain ?? "";
    message.query = object.query ?? "";
    message.cursor = (object.cursor !== undefined && object.cursor !== null)
      ? RequestCursor.fromPartial(object.cursor)
      : undefined;
    message.network = object.network ?? "";
    message.onlyPositiveBalance = object.onlyPositiveBalance ?? false;
    return message;
  },
};

function createBaseGetNFTCollectionBalancesReply(): GetNFTCollectionBalancesReply {
  return { balances: [], cursor: undefined };
}

export const GetNFTCollectionBalancesReply = {
  encode(message: GetNFTCollectionBalancesReply, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    for (const v of message.balances) {
      NFTCollectionBalance.encode(v!, writer.uint32(10).fork()).ldelim();
    }
    if (message.cursor !== undefined) {
      ResponseCursor.encode(message.cursor, writer.uint32(18).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): GetNFTCollectionBalancesReply {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetNFTCollectionBalancesReply();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.balances.push(NFTCollectionBalance.decode(reader, reader.uint32()));
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.cursor = ResponseCursor.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetNFTCollectionBalancesReply {
    return {
      balances: globalThis.Array.isArray(object?.balances)
        ? object.balances.map((e: any) => NFTCollectionBalance.fromJSON(e))
        : [],
      cursor: isSet(object.cursor) ? ResponseCursor.fromJSON(object.cursor) : undefined,
    };
  },

  toJSON(message: GetNFTCollectionBalancesReply): unknown {
    const obj: any = {};
    if (message.balances?.length) {
      obj.balances = message.balances.map((e) => NFTCollectionBalance.toJSON(e));
    }
    if (message.cursor !== undefined) {
      obj.cursor = ResponseCursor.toJSON(message.cursor);
    }
    return obj;
  },

  create(base?: DeepPartial<GetNFTCollectionBalancesReply>): GetNFTCollectionBalancesReply {
    return GetNFTCollectionBalancesReply.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<GetNFTCollectionBalancesReply>): GetNFTCollectionBalancesReply {
    const message = createBaseGetNFTCollectionBalancesReply();
    message.balances = object.balances?.map((e) => NFTCollectionBalance.fromPartial(e)) || [];
    message.cursor = (object.cursor !== undefined && object.cursor !== null)
      ? ResponseCursor.fromPartial(object.cursor)
      : undefined;
    return message;
  },
};

function createBaseGetAssetWalletsReply(): GetAssetWalletsReply {
  return { wallets: [], totalItems: 0, next: new Uint8Array(0), cursor: undefined };
}

export const GetAssetWalletsReply = {
  encode(message: GetAssetWalletsReply, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    for (const v of message.wallets) {
      WalletInfo.encode(v!, writer.uint32(10).fork()).ldelim();
    }
    if (message.totalItems !== 0) {
      writer.uint32(16).uint64(message.totalItems);
    }
    if (message.next.length !== 0) {
      writer.uint32(26).bytes(message.next);
    }
    if (message.cursor !== undefined) {
      ResponseCursor.encode(message.cursor, writer.uint32(34).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): GetAssetWalletsReply {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetAssetWalletsReply();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.wallets.push(WalletInfo.decode(reader, reader.uint32()));
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.totalItems = longToNumber(reader.uint64() as Long);
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.next = reader.bytes();
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.cursor = ResponseCursor.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetAssetWalletsReply {
    return {
      wallets: globalThis.Array.isArray(object?.wallets) ? object.wallets.map((e: any) => WalletInfo.fromJSON(e)) : [],
      totalItems: isSet(object.totalItems) ? globalThis.Number(object.totalItems) : 0,
      next: isSet(object.next) ? bytesFromBase64(object.next) : new Uint8Array(0),
      cursor: isSet(object.cursor) ? ResponseCursor.fromJSON(object.cursor) : undefined,
    };
  },

  toJSON(message: GetAssetWalletsReply): unknown {
    const obj: any = {};
    if (message.wallets?.length) {
      obj.wallets = message.wallets.map((e) => WalletInfo.toJSON(e));
    }
    if (message.totalItems !== 0) {
      obj.totalItems = Math.round(message.totalItems);
    }
    if (message.next.length !== 0) {
      obj.next = base64FromBytes(message.next);
    }
    if (message.cursor !== undefined) {
      obj.cursor = ResponseCursor.toJSON(message.cursor);
    }
    return obj;
  },

  create(base?: DeepPartial<GetAssetWalletsReply>): GetAssetWalletsReply {
    return GetAssetWalletsReply.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<GetAssetWalletsReply>): GetAssetWalletsReply {
    const message = createBaseGetAssetWalletsReply();
    message.wallets = object.wallets?.map((e) => WalletInfo.fromPartial(e)) || [];
    message.totalItems = object.totalItems ?? 0;
    message.next = object.next ?? new Uint8Array(0);
    message.cursor = (object.cursor !== undefined && object.cursor !== null)
      ? ResponseCursor.fromPartial(object.cursor)
      : undefined;
    return message;
  },
};

function createBaseGetAssetWalletsRequest(): GetAssetWalletsRequest {
  return {
    asset: undefined,
    limit: 0,
    cursor: new Uint8Array(0),
    walletId: 0,
    walletName: "",
    requestCursor: undefined,
  };
}

export const GetAssetWalletsRequest = {
  encode(message: GetAssetWalletsRequest, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.asset !== undefined) {
      Asset.encode(message.asset, writer.uint32(10).fork()).ldelim();
    }
    if (message.limit !== 0) {
      writer.uint32(16).uint64(message.limit);
    }
    if (message.cursor.length !== 0) {
      writer.uint32(26).bytes(message.cursor);
    }
    if (message.walletId !== 0) {
      writer.uint32(32).uint64(message.walletId);
    }
    if (message.walletName !== "") {
      writer.uint32(42).string(message.walletName);
    }
    if (message.requestCursor !== undefined) {
      RequestCursor.encode(message.requestCursor, writer.uint32(50).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): GetAssetWalletsRequest {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetAssetWalletsRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.asset = Asset.decode(reader, reader.uint32());
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.limit = longToNumber(reader.uint64() as Long);
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.cursor = reader.bytes();
          continue;
        case 4:
          if (tag !== 32) {
            break;
          }

          message.walletId = longToNumber(reader.uint64() as Long);
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.walletName = reader.string();
          continue;
        case 6:
          if (tag !== 50) {
            break;
          }

          message.requestCursor = RequestCursor.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetAssetWalletsRequest {
    return {
      asset: isSet(object.asset) ? Asset.fromJSON(object.asset) : undefined,
      limit: isSet(object.limit) ? globalThis.Number(object.limit) : 0,
      cursor: isSet(object.cursor) ? bytesFromBase64(object.cursor) : new Uint8Array(0),
      walletId: isSet(object.walletId) ? globalThis.Number(object.walletId) : 0,
      walletName: isSet(object.walletName) ? globalThis.String(object.walletName) : "",
      requestCursor: isSet(object.requestCursor) ? RequestCursor.fromJSON(object.requestCursor) : undefined,
    };
  },

  toJSON(message: GetAssetWalletsRequest): unknown {
    const obj: any = {};
    if (message.asset !== undefined) {
      obj.asset = Asset.toJSON(message.asset);
    }
    if (message.limit !== 0) {
      obj.limit = Math.round(message.limit);
    }
    if (message.cursor.length !== 0) {
      obj.cursor = base64FromBytes(message.cursor);
    }
    if (message.walletId !== 0) {
      obj.walletId = Math.round(message.walletId);
    }
    if (message.walletName !== "") {
      obj.walletName = message.walletName;
    }
    if (message.requestCursor !== undefined) {
      obj.requestCursor = RequestCursor.toJSON(message.requestCursor);
    }
    return obj;
  },

  create(base?: DeepPartial<GetAssetWalletsRequest>): GetAssetWalletsRequest {
    return GetAssetWalletsRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<GetAssetWalletsRequest>): GetAssetWalletsRequest {
    const message = createBaseGetAssetWalletsRequest();
    message.asset = (object.asset !== undefined && object.asset !== null) ? Asset.fromPartial(object.asset) : undefined;
    message.limit = object.limit ?? 0;
    message.cursor = object.cursor ?? new Uint8Array(0);
    message.walletId = object.walletId ?? 0;
    message.walletName = object.walletName ?? "";
    message.requestCursor = (object.requestCursor !== undefined && object.requestCursor !== null)
      ? RequestCursor.fromPartial(object.requestCursor)
      : undefined;
    return message;
  },
};

function createBaseGetAssetAddressesReply(): GetAssetAddressesReply {
  return { addresses: [], totalItems: 0, next: new Uint8Array(0), cursor: undefined };
}

export const GetAssetAddressesReply = {
  encode(message: GetAssetAddressesReply, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    for (const v of message.addresses) {
      Address.encode(v!, writer.uint32(10).fork()).ldelim();
    }
    if (message.totalItems !== 0) {
      writer.uint32(16).uint64(message.totalItems);
    }
    if (message.next.length !== 0) {
      writer.uint32(26).bytes(message.next);
    }
    if (message.cursor !== undefined) {
      ResponseCursor.encode(message.cursor, writer.uint32(34).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): GetAssetAddressesReply {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetAssetAddressesReply();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.addresses.push(Address.decode(reader, reader.uint32()));
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.totalItems = longToNumber(reader.uint64() as Long);
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.next = reader.bytes();
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.cursor = ResponseCursor.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetAssetAddressesReply {
    return {
      addresses: globalThis.Array.isArray(object?.addresses)
        ? object.addresses.map((e: any) => Address.fromJSON(e))
        : [],
      totalItems: isSet(object.totalItems) ? globalThis.Number(object.totalItems) : 0,
      next: isSet(object.next) ? bytesFromBase64(object.next) : new Uint8Array(0),
      cursor: isSet(object.cursor) ? ResponseCursor.fromJSON(object.cursor) : undefined,
    };
  },

  toJSON(message: GetAssetAddressesReply): unknown {
    const obj: any = {};
    if (message.addresses?.length) {
      obj.addresses = message.addresses.map((e) => Address.toJSON(e));
    }
    if (message.totalItems !== 0) {
      obj.totalItems = Math.round(message.totalItems);
    }
    if (message.next.length !== 0) {
      obj.next = base64FromBytes(message.next);
    }
    if (message.cursor !== undefined) {
      obj.cursor = ResponseCursor.toJSON(message.cursor);
    }
    return obj;
  },

  create(base?: DeepPartial<GetAssetAddressesReply>): GetAssetAddressesReply {
    return GetAssetAddressesReply.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<GetAssetAddressesReply>): GetAssetAddressesReply {
    const message = createBaseGetAssetAddressesReply();
    message.addresses = object.addresses?.map((e) => Address.fromPartial(e)) || [];
    message.totalItems = object.totalItems ?? 0;
    message.next = object.next ?? new Uint8Array(0);
    message.cursor = (object.cursor !== undefined && object.cursor !== null)
      ? ResponseCursor.fromPartial(object.cursor)
      : undefined;
    return message;
  },
};

function createBaseGetAssetAddressesRequest(): GetAssetAddressesRequest {
  return {
    asset: undefined,
    limit: 0,
    cursor: new Uint8Array(0),
    sorting: undefined,
    requestCursor: undefined,
    walletId: 0,
    addressId: 0,
    addresses: [],
  };
}

export const GetAssetAddressesRequest = {
  encode(message: GetAssetAddressesRequest, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.asset !== undefined) {
      Asset.encode(message.asset, writer.uint32(10).fork()).ldelim();
    }
    if (message.limit !== 0) {
      writer.uint32(16).uint64(message.limit);
    }
    if (message.cursor.length !== 0) {
      writer.uint32(26).bytes(message.cursor);
    }
    if (message.sorting !== undefined) {
      GetAssetAddressesRequest_Sorting.encode(message.sorting, writer.uint32(34).fork()).ldelim();
    }
    if (message.requestCursor !== undefined) {
      RequestCursor.encode(message.requestCursor, writer.uint32(42).fork()).ldelim();
    }
    if (message.walletId !== 0) {
      writer.uint32(48).uint64(message.walletId);
    }
    if (message.addressId !== 0) {
      writer.uint32(56).uint64(message.addressId);
    }
    for (const v of message.addresses) {
      writer.uint32(66).string(v!);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): GetAssetAddressesRequest {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetAssetAddressesRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.asset = Asset.decode(reader, reader.uint32());
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.limit = longToNumber(reader.uint64() as Long);
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.cursor = reader.bytes();
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.sorting = GetAssetAddressesRequest_Sorting.decode(reader, reader.uint32());
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.requestCursor = RequestCursor.decode(reader, reader.uint32());
          continue;
        case 6:
          if (tag !== 48) {
            break;
          }

          message.walletId = longToNumber(reader.uint64() as Long);
          continue;
        case 7:
          if (tag !== 56) {
            break;
          }

          message.addressId = longToNumber(reader.uint64() as Long);
          continue;
        case 8:
          if (tag !== 66) {
            break;
          }

          message.addresses.push(reader.string());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetAssetAddressesRequest {
    return {
      asset: isSet(object.asset) ? Asset.fromJSON(object.asset) : undefined,
      limit: isSet(object.limit) ? globalThis.Number(object.limit) : 0,
      cursor: isSet(object.cursor) ? bytesFromBase64(object.cursor) : new Uint8Array(0),
      sorting: isSet(object.sorting) ? GetAssetAddressesRequest_Sorting.fromJSON(object.sorting) : undefined,
      requestCursor: isSet(object.requestCursor) ? RequestCursor.fromJSON(object.requestCursor) : undefined,
      walletId: isSet(object.walletId) ? globalThis.Number(object.walletId) : 0,
      addressId: isSet(object.addressId) ? globalThis.Number(object.addressId) : 0,
      addresses: globalThis.Array.isArray(object?.addresses)
        ? object.addresses.map((e: any) => globalThis.String(e))
        : [],
    };
  },

  toJSON(message: GetAssetAddressesRequest): unknown {
    const obj: any = {};
    if (message.asset !== undefined) {
      obj.asset = Asset.toJSON(message.asset);
    }
    if (message.limit !== 0) {
      obj.limit = Math.round(message.limit);
    }
    if (message.cursor.length !== 0) {
      obj.cursor = base64FromBytes(message.cursor);
    }
    if (message.sorting !== undefined) {
      obj.sorting = GetAssetAddressesRequest_Sorting.toJSON(message.sorting);
    }
    if (message.requestCursor !== undefined) {
      obj.requestCursor = RequestCursor.toJSON(message.requestCursor);
    }
    if (message.walletId !== 0) {
      obj.walletId = Math.round(message.walletId);
    }
    if (message.addressId !== 0) {
      obj.addressId = Math.round(message.addressId);
    }
    if (message.addresses?.length) {
      obj.addresses = message.addresses;
    }
    return obj;
  },

  create(base?: DeepPartial<GetAssetAddressesRequest>): GetAssetAddressesRequest {
    return GetAssetAddressesRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<GetAssetAddressesRequest>): GetAssetAddressesRequest {
    const message = createBaseGetAssetAddressesRequest();
    message.asset = (object.asset !== undefined && object.asset !== null) ? Asset.fromPartial(object.asset) : undefined;
    message.limit = object.limit ?? 0;
    message.cursor = object.cursor ?? new Uint8Array(0);
    message.sorting = (object.sorting !== undefined && object.sorting !== null)
      ? GetAssetAddressesRequest_Sorting.fromPartial(object.sorting)
      : undefined;
    message.requestCursor = (object.requestCursor !== undefined && object.requestCursor !== null)
      ? RequestCursor.fromPartial(object.requestCursor)
      : undefined;
    message.walletId = object.walletId ?? 0;
    message.addressId = object.addressId ?? 0;
    message.addresses = object.addresses?.map((e) => e) || [];
    return message;
  },
};

function createBaseGetAssetAddressesRequest_Sorting(): GetAssetAddressesRequest_Sorting {
  return { sortOrder: 0 };
}

export const GetAssetAddressesRequest_Sorting = {
  encode(message: GetAssetAddressesRequest_Sorting, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.sortOrder !== 0) {
      writer.uint32(8).int32(message.sortOrder);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): GetAssetAddressesRequest_Sorting {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetAssetAddressesRequest_Sorting();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.sortOrder = reader.int32() as any;
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetAssetAddressesRequest_Sorting {
    return {
      sortOrder: isSet(object.sortOrder) ? getAssetAddressesRequest_Sorting_SortOrderFromJSON(object.sortOrder) : 0,
    };
  },

  toJSON(message: GetAssetAddressesRequest_Sorting): unknown {
    const obj: any = {};
    if (message.sortOrder !== 0) {
      obj.sortOrder = getAssetAddressesRequest_Sorting_SortOrderToJSON(message.sortOrder);
    }
    return obj;
  },

  create(base?: DeepPartial<GetAssetAddressesRequest_Sorting>): GetAssetAddressesRequest_Sorting {
    return GetAssetAddressesRequest_Sorting.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<GetAssetAddressesRequest_Sorting>): GetAssetAddressesRequest_Sorting {
    const message = createBaseGetAssetAddressesRequest_Sorting();
    message.sortOrder = object.sortOrder ?? 0;
    return message;
  },
};

function createBaseCreateWalletAttributesRequest(): CreateWalletAttributesRequest {
  return { walletId: 0, attributes: [] };
}

export const CreateWalletAttributesRequest = {
  encode(message: CreateWalletAttributesRequest, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.walletId !== 0) {
      writer.uint32(8).uint64(message.walletId);
    }
    for (const v of message.attributes) {
      CreateWalletAttributeRequest.encode(v!, writer.uint32(18).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CreateWalletAttributesRequest {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCreateWalletAttributesRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.walletId = longToNumber(reader.uint64() as Long);
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.attributes.push(CreateWalletAttributeRequest.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CreateWalletAttributesRequest {
    return {
      walletId: isSet(object.walletId) ? globalThis.Number(object.walletId) : 0,
      attributes: globalThis.Array.isArray(object?.attributes)
        ? object.attributes.map((e: any) => CreateWalletAttributeRequest.fromJSON(e))
        : [],
    };
  },

  toJSON(message: CreateWalletAttributesRequest): unknown {
    const obj: any = {};
    if (message.walletId !== 0) {
      obj.walletId = Math.round(message.walletId);
    }
    if (message.attributes?.length) {
      obj.attributes = message.attributes.map((e) => CreateWalletAttributeRequest.toJSON(e));
    }
    return obj;
  },

  create(base?: DeepPartial<CreateWalletAttributesRequest>): CreateWalletAttributesRequest {
    return CreateWalletAttributesRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CreateWalletAttributesRequest>): CreateWalletAttributesRequest {
    const message = createBaseCreateWalletAttributesRequest();
    message.walletId = object.walletId ?? 0;
    message.attributes = object.attributes?.map((e) => CreateWalletAttributeRequest.fromPartial(e)) || [];
    return message;
  },
};

function createBaseCreateWalletAttributesReply(): CreateWalletAttributesReply {
  return { result: [] };
}

export const CreateWalletAttributesReply = {
  encode(message: CreateWalletAttributesReply, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    for (const v of message.result) {
      WalletAttribute.encode(v!, writer.uint32(10).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CreateWalletAttributesReply {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCreateWalletAttributesReply();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.result.push(WalletAttribute.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CreateWalletAttributesReply {
    return {
      result: globalThis.Array.isArray(object?.result)
        ? object.result.map((e: any) => WalletAttribute.fromJSON(e))
        : [],
    };
  },

  toJSON(message: CreateWalletAttributesReply): unknown {
    const obj: any = {};
    if (message.result?.length) {
      obj.result = message.result.map((e) => WalletAttribute.toJSON(e));
    }
    return obj;
  },

  create(base?: DeepPartial<CreateWalletAttributesReply>): CreateWalletAttributesReply {
    return CreateWalletAttributesReply.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CreateWalletAttributesReply>): CreateWalletAttributesReply {
    const message = createBaseCreateWalletAttributesReply();
    message.result = object.result?.map((e) => WalletAttribute.fromPartial(e)) || [];
    return message;
  },
};

function createBaseCreateWalletAttributeRequest(): CreateWalletAttributeRequest {
  return { key: "", value: "", contentType: "", type: "", subtype: "", isfile: false };
}

export const CreateWalletAttributeRequest = {
  encode(message: CreateWalletAttributeRequest, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.key !== "") {
      writer.uint32(10).string(message.key);
    }
    if (message.value !== "") {
      writer.uint32(18).string(message.value);
    }
    if (message.contentType !== "") {
      writer.uint32(26).string(message.contentType);
    }
    if (message.type !== "") {
      writer.uint32(34).string(message.type);
    }
    if (message.subtype !== "") {
      writer.uint32(42).string(message.subtype);
    }
    if (message.isfile !== false) {
      writer.uint32(48).bool(message.isfile);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CreateWalletAttributeRequest {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCreateWalletAttributeRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.key = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.value = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.contentType = reader.string();
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.type = reader.string();
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.subtype = reader.string();
          continue;
        case 6:
          if (tag !== 48) {
            break;
          }

          message.isfile = reader.bool();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CreateWalletAttributeRequest {
    return {
      key: isSet(object.key) ? globalThis.String(object.key) : "",
      value: isSet(object.value) ? globalThis.String(object.value) : "",
      contentType: isSet(object.contentType) ? globalThis.String(object.contentType) : "",
      type: isSet(object.type) ? globalThis.String(object.type) : "",
      subtype: isSet(object.subtype) ? globalThis.String(object.subtype) : "",
      isfile: isSet(object.isfile) ? globalThis.Boolean(object.isfile) : false,
    };
  },

  toJSON(message: CreateWalletAttributeRequest): unknown {
    const obj: any = {};
    if (message.key !== "") {
      obj.key = message.key;
    }
    if (message.value !== "") {
      obj.value = message.value;
    }
    if (message.contentType !== "") {
      obj.contentType = message.contentType;
    }
    if (message.type !== "") {
      obj.type = message.type;
    }
    if (message.subtype !== "") {
      obj.subtype = message.subtype;
    }
    if (message.isfile !== false) {
      obj.isfile = message.isfile;
    }
    return obj;
  },

  create(base?: DeepPartial<CreateWalletAttributeRequest>): CreateWalletAttributeRequest {
    return CreateWalletAttributeRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CreateWalletAttributeRequest>): CreateWalletAttributeRequest {
    const message = createBaseCreateWalletAttributeRequest();
    message.key = object.key ?? "";
    message.value = object.value ?? "";
    message.contentType = object.contentType ?? "";
    message.type = object.type ?? "";
    message.subtype = object.subtype ?? "";
    message.isfile = object.isfile ?? false;
    return message;
  },
};

function createBaseDeleteWalletAttributeRequest(): DeleteWalletAttributeRequest {
  return { walletId: 0, id: 0 };
}

export const DeleteWalletAttributeRequest = {
  encode(message: DeleteWalletAttributeRequest, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.walletId !== 0) {
      writer.uint32(8).uint64(message.walletId);
    }
    if (message.id !== 0) {
      writer.uint32(16).uint64(message.id);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): DeleteWalletAttributeRequest {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseDeleteWalletAttributeRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.walletId = longToNumber(reader.uint64() as Long);
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.id = longToNumber(reader.uint64() as Long);
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): DeleteWalletAttributeRequest {
    return {
      walletId: isSet(object.walletId) ? globalThis.Number(object.walletId) : 0,
      id: isSet(object.id) ? globalThis.Number(object.id) : 0,
    };
  },

  toJSON(message: DeleteWalletAttributeRequest): unknown {
    const obj: any = {};
    if (message.walletId !== 0) {
      obj.walletId = Math.round(message.walletId);
    }
    if (message.id !== 0) {
      obj.id = Math.round(message.id);
    }
    return obj;
  },

  create(base?: DeepPartial<DeleteWalletAttributeRequest>): DeleteWalletAttributeRequest {
    return DeleteWalletAttributeRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<DeleteWalletAttributeRequest>): DeleteWalletAttributeRequest {
    const message = createBaseDeleteWalletAttributeRequest();
    message.walletId = object.walletId ?? 0;
    message.id = object.id ?? 0;
    return message;
  },
};

function createBaseCreateAddressAttributesRequest(): CreateAddressAttributesRequest {
  return { addressId: 0, attributes: [] };
}

export const CreateAddressAttributesRequest = {
  encode(message: CreateAddressAttributesRequest, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.addressId !== 0) {
      writer.uint32(8).uint64(message.addressId);
    }
    for (const v of message.attributes) {
      CreateAddressAttributeRequest.encode(v!, writer.uint32(18).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CreateAddressAttributesRequest {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCreateAddressAttributesRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.addressId = longToNumber(reader.uint64() as Long);
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.attributes.push(CreateAddressAttributeRequest.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CreateAddressAttributesRequest {
    return {
      addressId: isSet(object.addressId) ? globalThis.Number(object.addressId) : 0,
      attributes: globalThis.Array.isArray(object?.attributes)
        ? object.attributes.map((e: any) => CreateAddressAttributeRequest.fromJSON(e))
        : [],
    };
  },

  toJSON(message: CreateAddressAttributesRequest): unknown {
    const obj: any = {};
    if (message.addressId !== 0) {
      obj.addressId = Math.round(message.addressId);
    }
    if (message.attributes?.length) {
      obj.attributes = message.attributes.map((e) => CreateAddressAttributeRequest.toJSON(e));
    }
    return obj;
  },

  create(base?: DeepPartial<CreateAddressAttributesRequest>): CreateAddressAttributesRequest {
    return CreateAddressAttributesRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CreateAddressAttributesRequest>): CreateAddressAttributesRequest {
    const message = createBaseCreateAddressAttributesRequest();
    message.addressId = object.addressId ?? 0;
    message.attributes = object.attributes?.map((e) => CreateAddressAttributeRequest.fromPartial(e)) || [];
    return message;
  },
};

function createBaseCreateAddressAttributesReply(): CreateAddressAttributesReply {
  return { result: [] };
}

export const CreateAddressAttributesReply = {
  encode(message: CreateAddressAttributesReply, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    for (const v of message.result) {
      AddressAttribute.encode(v!, writer.uint32(10).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CreateAddressAttributesReply {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCreateAddressAttributesReply();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.result.push(AddressAttribute.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CreateAddressAttributesReply {
    return {
      result: globalThis.Array.isArray(object?.result)
        ? object.result.map((e: any) => AddressAttribute.fromJSON(e))
        : [],
    };
  },

  toJSON(message: CreateAddressAttributesReply): unknown {
    const obj: any = {};
    if (message.result?.length) {
      obj.result = message.result.map((e) => AddressAttribute.toJSON(e));
    }
    return obj;
  },

  create(base?: DeepPartial<CreateAddressAttributesReply>): CreateAddressAttributesReply {
    return CreateAddressAttributesReply.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CreateAddressAttributesReply>): CreateAddressAttributesReply {
    const message = createBaseCreateAddressAttributesReply();
    message.result = object.result?.map((e) => AddressAttribute.fromPartial(e)) || [];
    return message;
  },
};

function createBaseCreateAddressAttributeRequest(): CreateAddressAttributeRequest {
  return { key: "", value: "", contentType: "", type: "", subtype: "", isfile: false };
}

export const CreateAddressAttributeRequest = {
  encode(message: CreateAddressAttributeRequest, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.key !== "") {
      writer.uint32(10).string(message.key);
    }
    if (message.value !== "") {
      writer.uint32(18).string(message.value);
    }
    if (message.contentType !== "") {
      writer.uint32(26).string(message.contentType);
    }
    if (message.type !== "") {
      writer.uint32(34).string(message.type);
    }
    if (message.subtype !== "") {
      writer.uint32(42).string(message.subtype);
    }
    if (message.isfile !== false) {
      writer.uint32(48).bool(message.isfile);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CreateAddressAttributeRequest {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCreateAddressAttributeRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.key = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.value = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.contentType = reader.string();
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.type = reader.string();
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.subtype = reader.string();
          continue;
        case 6:
          if (tag !== 48) {
            break;
          }

          message.isfile = reader.bool();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CreateAddressAttributeRequest {
    return {
      key: isSet(object.key) ? globalThis.String(object.key) : "",
      value: isSet(object.value) ? globalThis.String(object.value) : "",
      contentType: isSet(object.contentType) ? globalThis.String(object.contentType) : "",
      type: isSet(object.type) ? globalThis.String(object.type) : "",
      subtype: isSet(object.subtype) ? globalThis.String(object.subtype) : "",
      isfile: isSet(object.isfile) ? globalThis.Boolean(object.isfile) : false,
    };
  },

  toJSON(message: CreateAddressAttributeRequest): unknown {
    const obj: any = {};
    if (message.key !== "") {
      obj.key = message.key;
    }
    if (message.value !== "") {
      obj.value = message.value;
    }
    if (message.contentType !== "") {
      obj.contentType = message.contentType;
    }
    if (message.type !== "") {
      obj.type = message.type;
    }
    if (message.subtype !== "") {
      obj.subtype = message.subtype;
    }
    if (message.isfile !== false) {
      obj.isfile = message.isfile;
    }
    return obj;
  },

  create(base?: DeepPartial<CreateAddressAttributeRequest>): CreateAddressAttributeRequest {
    return CreateAddressAttributeRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CreateAddressAttributeRequest>): CreateAddressAttributeRequest {
    const message = createBaseCreateAddressAttributeRequest();
    message.key = object.key ?? "";
    message.value = object.value ?? "";
    message.contentType = object.contentType ?? "";
    message.type = object.type ?? "";
    message.subtype = object.subtype ?? "";
    message.isfile = object.isfile ?? false;
    return message;
  },
};

function createBaseDeleteAddressAttributeRequest(): DeleteAddressAttributeRequest {
  return { addressId: 0, id: 0 };
}

export const DeleteAddressAttributeRequest = {
  encode(message: DeleteAddressAttributeRequest, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.addressId !== 0) {
      writer.uint32(8).uint64(message.addressId);
    }
    if (message.id !== 0) {
      writer.uint32(16).uint64(message.id);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): DeleteAddressAttributeRequest {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseDeleteAddressAttributeRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.addressId = longToNumber(reader.uint64() as Long);
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.id = longToNumber(reader.uint64() as Long);
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): DeleteAddressAttributeRequest {
    return {
      addressId: isSet(object.addressId) ? globalThis.Number(object.addressId) : 0,
      id: isSet(object.id) ? globalThis.Number(object.id) : 0,
    };
  },

  toJSON(message: DeleteAddressAttributeRequest): unknown {
    const obj: any = {};
    if (message.addressId !== 0) {
      obj.addressId = Math.round(message.addressId);
    }
    if (message.id !== 0) {
      obj.id = Math.round(message.id);
    }
    return obj;
  },

  create(base?: DeepPartial<DeleteAddressAttributeRequest>): DeleteAddressAttributeRequest {
    return DeleteAddressAttributeRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<DeleteAddressAttributeRequest>): DeleteAddressAttributeRequest {
    const message = createBaseDeleteAddressAttributeRequest();
    message.addressId = object.addressId ?? 0;
    message.id = object.id ?? 0;
    return message;
  },
};

function createBaseGetAddressesRequest(): GetAddressesRequest {
  return {
    currency: "",
    query: "",
    limit: 0,
    offset: 0,
    scoreProvider: "",
    scoreInBelow: "",
    scoreOutBelow: "",
    scoreExclusive: false,
    onlyPositiveBalance: false,
    sortBy: "",
    sortOrder: "",
    balanceBelow: "",
    balanceAbove: "",
    walletId: 0,
    customerId: "",
    coinfirmScoreGreater: "",
    chainalysisScoreGreater: "",
    tagIDs: [],
    blockchain: "",
    network: "",
    addressIds: [],
    nfts: "",
    addresses: [],
    scoreFilter: undefined,
    attributeFiltersJson: "",
    attributeFiltersOperator: "",
  };
}

export const GetAddressesRequest = {
  encode(message: GetAddressesRequest, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.currency !== "") {
      writer.uint32(10).string(message.currency);
    }
    if (message.query !== "") {
      writer.uint32(18).string(message.query);
    }
    if (message.limit !== 0) {
      writer.uint32(24).uint64(message.limit);
    }
    if (message.offset !== 0) {
      writer.uint32(32).uint64(message.offset);
    }
    if (message.scoreProvider !== "") {
      writer.uint32(42).string(message.scoreProvider);
    }
    if (message.scoreInBelow !== "") {
      writer.uint32(50).string(message.scoreInBelow);
    }
    if (message.scoreOutBelow !== "") {
      writer.uint32(58).string(message.scoreOutBelow);
    }
    if (message.scoreExclusive !== false) {
      writer.uint32(64).bool(message.scoreExclusive);
    }
    if (message.onlyPositiveBalance !== false) {
      writer.uint32(72).bool(message.onlyPositiveBalance);
    }
    if (message.sortBy !== "") {
      writer.uint32(82).string(message.sortBy);
    }
    if (message.sortOrder !== "") {
      writer.uint32(90).string(message.sortOrder);
    }
    if (message.balanceBelow !== "") {
      writer.uint32(98).string(message.balanceBelow);
    }
    if (message.balanceAbove !== "") {
      writer.uint32(106).string(message.balanceAbove);
    }
    if (message.walletId !== 0) {
      writer.uint32(112).uint64(message.walletId);
    }
    if (message.customerId !== "") {
      writer.uint32(122).string(message.customerId);
    }
    if (message.coinfirmScoreGreater !== "") {
      writer.uint32(130).string(message.coinfirmScoreGreater);
    }
    if (message.chainalysisScoreGreater !== "") {
      writer.uint32(138).string(message.chainalysisScoreGreater);
    }
    for (const v of message.tagIDs) {
      writer.uint32(146).string(v!);
    }
    if (message.blockchain !== "") {
      writer.uint32(154).string(message.blockchain);
    }
    if (message.network !== "") {
      writer.uint32(162).string(message.network);
    }
    writer.uint32(170).fork();
    for (const v of message.addressIds) {
      writer.uint64(v);
    }
    writer.ldelim();
    if (message.nfts !== "") {
      writer.uint32(178).string(message.nfts);
    }
    for (const v of message.addresses) {
      writer.uint32(186).string(v!);
    }
    if (message.scoreFilter !== undefined) {
      ScoreFilter.encode(message.scoreFilter, writer.uint32(194).fork()).ldelim();
    }
    if (message.attributeFiltersJson !== "") {
      writer.uint32(202).string(message.attributeFiltersJson);
    }
    if (message.attributeFiltersOperator !== "") {
      writer.uint32(210).string(message.attributeFiltersOperator);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): GetAddressesRequest {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetAddressesRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.currency = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.query = reader.string();
          continue;
        case 3:
          if (tag !== 24) {
            break;
          }

          message.limit = longToNumber(reader.uint64() as Long);
          continue;
        case 4:
          if (tag !== 32) {
            break;
          }

          message.offset = longToNumber(reader.uint64() as Long);
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.scoreProvider = reader.string();
          continue;
        case 6:
          if (tag !== 50) {
            break;
          }

          message.scoreInBelow = reader.string();
          continue;
        case 7:
          if (tag !== 58) {
            break;
          }

          message.scoreOutBelow = reader.string();
          continue;
        case 8:
          if (tag !== 64) {
            break;
          }

          message.scoreExclusive = reader.bool();
          continue;
        case 9:
          if (tag !== 72) {
            break;
          }

          message.onlyPositiveBalance = reader.bool();
          continue;
        case 10:
          if (tag !== 82) {
            break;
          }

          message.sortBy = reader.string();
          continue;
        case 11:
          if (tag !== 90) {
            break;
          }

          message.sortOrder = reader.string();
          continue;
        case 12:
          if (tag !== 98) {
            break;
          }

          message.balanceBelow = reader.string();
          continue;
        case 13:
          if (tag !== 106) {
            break;
          }

          message.balanceAbove = reader.string();
          continue;
        case 14:
          if (tag !== 112) {
            break;
          }

          message.walletId = longToNumber(reader.uint64() as Long);
          continue;
        case 15:
          if (tag !== 122) {
            break;
          }

          message.customerId = reader.string();
          continue;
        case 16:
          if (tag !== 130) {
            break;
          }

          message.coinfirmScoreGreater = reader.string();
          continue;
        case 17:
          if (tag !== 138) {
            break;
          }

          message.chainalysisScoreGreater = reader.string();
          continue;
        case 18:
          if (tag !== 146) {
            break;
          }

          message.tagIDs.push(reader.string());
          continue;
        case 19:
          if (tag !== 154) {
            break;
          }

          message.blockchain = reader.string();
          continue;
        case 20:
          if (tag !== 162) {
            break;
          }

          message.network = reader.string();
          continue;
        case 21:
          if (tag === 168) {
            message.addressIds.push(longToNumber(reader.uint64() as Long));

            continue;
          }

          if (tag === 170) {
            const end2 = reader.uint32() + reader.pos;
            while (reader.pos < end2) {
              message.addressIds.push(longToNumber(reader.uint64() as Long));
            }

            continue;
          }

          break;
        case 22:
          if (tag !== 178) {
            break;
          }

          message.nfts = reader.string();
          continue;
        case 23:
          if (tag !== 186) {
            break;
          }

          message.addresses.push(reader.string());
          continue;
        case 24:
          if (tag !== 194) {
            break;
          }

          message.scoreFilter = ScoreFilter.decode(reader, reader.uint32());
          continue;
        case 25:
          if (tag !== 202) {
            break;
          }

          message.attributeFiltersJson = reader.string();
          continue;
        case 26:
          if (tag !== 210) {
            break;
          }

          message.attributeFiltersOperator = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetAddressesRequest {
    return {
      currency: isSet(object.currency) ? globalThis.String(object.currency) : "",
      query: isSet(object.query) ? globalThis.String(object.query) : "",
      limit: isSet(object.limit) ? globalThis.Number(object.limit) : 0,
      offset: isSet(object.offset) ? globalThis.Number(object.offset) : 0,
      scoreProvider: isSet(object.scoreProvider) ? globalThis.String(object.scoreProvider) : "",
      scoreInBelow: isSet(object.scoreInBelow) ? globalThis.String(object.scoreInBelow) : "",
      scoreOutBelow: isSet(object.scoreOutBelow) ? globalThis.String(object.scoreOutBelow) : "",
      scoreExclusive: isSet(object.scoreExclusive) ? globalThis.Boolean(object.scoreExclusive) : false,
      onlyPositiveBalance: isSet(object.onlyPositiveBalance) ? globalThis.Boolean(object.onlyPositiveBalance) : false,
      sortBy: isSet(object.sortBy) ? globalThis.String(object.sortBy) : "",
      sortOrder: isSet(object.sortOrder) ? globalThis.String(object.sortOrder) : "",
      balanceBelow: isSet(object.balanceBelow) ? globalThis.String(object.balanceBelow) : "",
      balanceAbove: isSet(object.balanceAbove) ? globalThis.String(object.balanceAbove) : "",
      walletId: isSet(object.walletId) ? globalThis.Number(object.walletId) : 0,
      customerId: isSet(object.customerId) ? globalThis.String(object.customerId) : "",
      coinfirmScoreGreater: isSet(object.coinfirmScoreGreater) ? globalThis.String(object.coinfirmScoreGreater) : "",
      chainalysisScoreGreater: isSet(object.chainalysisScoreGreater)
        ? globalThis.String(object.chainalysisScoreGreater)
        : "",
      tagIDs: globalThis.Array.isArray(object?.tagIDs) ? object.tagIDs.map((e: any) => globalThis.String(e)) : [],
      blockchain: isSet(object.blockchain) ? globalThis.String(object.blockchain) : "",
      network: isSet(object.network) ? globalThis.String(object.network) : "",
      addressIds: globalThis.Array.isArray(object?.addressIds)
        ? object.addressIds.map((e: any) => globalThis.Number(e))
        : [],
      nfts: isSet(object.nfts) ? globalThis.String(object.nfts) : "",
      addresses: globalThis.Array.isArray(object?.addresses)
        ? object.addresses.map((e: any) => globalThis.String(e))
        : [],
      scoreFilter: isSet(object.scoreFilter) ? ScoreFilter.fromJSON(object.scoreFilter) : undefined,
      attributeFiltersJson: isSet(object.attributeFiltersJson) ? globalThis.String(object.attributeFiltersJson) : "",
      attributeFiltersOperator: isSet(object.attributeFiltersOperator)
        ? globalThis.String(object.attributeFiltersOperator)
        : "",
    };
  },

  toJSON(message: GetAddressesRequest): unknown {
    const obj: any = {};
    if (message.currency !== "") {
      obj.currency = message.currency;
    }
    if (message.query !== "") {
      obj.query = message.query;
    }
    if (message.limit !== 0) {
      obj.limit = Math.round(message.limit);
    }
    if (message.offset !== 0) {
      obj.offset = Math.round(message.offset);
    }
    if (message.scoreProvider !== "") {
      obj.scoreProvider = message.scoreProvider;
    }
    if (message.scoreInBelow !== "") {
      obj.scoreInBelow = message.scoreInBelow;
    }
    if (message.scoreOutBelow !== "") {
      obj.scoreOutBelow = message.scoreOutBelow;
    }
    if (message.scoreExclusive !== false) {
      obj.scoreExclusive = message.scoreExclusive;
    }
    if (message.onlyPositiveBalance !== false) {
      obj.onlyPositiveBalance = message.onlyPositiveBalance;
    }
    if (message.sortBy !== "") {
      obj.sortBy = message.sortBy;
    }
    if (message.sortOrder !== "") {
      obj.sortOrder = message.sortOrder;
    }
    if (message.balanceBelow !== "") {
      obj.balanceBelow = message.balanceBelow;
    }
    if (message.balanceAbove !== "") {
      obj.balanceAbove = message.balanceAbove;
    }
    if (message.walletId !== 0) {
      obj.walletId = Math.round(message.walletId);
    }
    if (message.customerId !== "") {
      obj.customerId = message.customerId;
    }
    if (message.coinfirmScoreGreater !== "") {
      obj.coinfirmScoreGreater = message.coinfirmScoreGreater;
    }
    if (message.chainalysisScoreGreater !== "") {
      obj.chainalysisScoreGreater = message.chainalysisScoreGreater;
    }
    if (message.tagIDs?.length) {
      obj.tagIDs = message.tagIDs;
    }
    if (message.blockchain !== "") {
      obj.blockchain = message.blockchain;
    }
    if (message.network !== "") {
      obj.network = message.network;
    }
    if (message.addressIds?.length) {
      obj.addressIds = message.addressIds.map((e) => Math.round(e));
    }
    if (message.nfts !== "") {
      obj.nfts = message.nfts;
    }
    if (message.addresses?.length) {
      obj.addresses = message.addresses;
    }
    if (message.scoreFilter !== undefined) {
      obj.scoreFilter = ScoreFilter.toJSON(message.scoreFilter);
    }
    if (message.attributeFiltersJson !== "") {
      obj.attributeFiltersJson = message.attributeFiltersJson;
    }
    if (message.attributeFiltersOperator !== "") {
      obj.attributeFiltersOperator = message.attributeFiltersOperator;
    }
    return obj;
  },

  create(base?: DeepPartial<GetAddressesRequest>): GetAddressesRequest {
    return GetAddressesRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<GetAddressesRequest>): GetAddressesRequest {
    const message = createBaseGetAddressesRequest();
    message.currency = object.currency ?? "";
    message.query = object.query ?? "";
    message.limit = object.limit ?? 0;
    message.offset = object.offset ?? 0;
    message.scoreProvider = object.scoreProvider ?? "";
    message.scoreInBelow = object.scoreInBelow ?? "";
    message.scoreOutBelow = object.scoreOutBelow ?? "";
    message.scoreExclusive = object.scoreExclusive ?? false;
    message.onlyPositiveBalance = object.onlyPositiveBalance ?? false;
    message.sortBy = object.sortBy ?? "";
    message.sortOrder = object.sortOrder ?? "";
    message.balanceBelow = object.balanceBelow ?? "";
    message.balanceAbove = object.balanceAbove ?? "";
    message.walletId = object.walletId ?? 0;
    message.customerId = object.customerId ?? "";
    message.coinfirmScoreGreater = object.coinfirmScoreGreater ?? "";
    message.chainalysisScoreGreater = object.chainalysisScoreGreater ?? "";
    message.tagIDs = object.tagIDs?.map((e) => e) || [];
    message.blockchain = object.blockchain ?? "";
    message.network = object.network ?? "";
    message.addressIds = object.addressIds?.map((e) => e) || [];
    message.nfts = object.nfts ?? "";
    message.addresses = object.addresses?.map((e) => e) || [];
    message.scoreFilter = (object.scoreFilter !== undefined && object.scoreFilter !== null)
      ? ScoreFilter.fromPartial(object.scoreFilter)
      : undefined;
    message.attributeFiltersJson = object.attributeFiltersJson ?? "";
    message.attributeFiltersOperator = object.attributeFiltersOperator ?? "";
    return message;
  },
};

function createBaseGetAddressesReply(): GetAddressesReply {
  return { result: [], totalItems: 0 };
}

export const GetAddressesReply = {
  encode(message: GetAddressesReply, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    for (const v of message.result) {
      Address.encode(v!, writer.uint32(10).fork()).ldelim();
    }
    if (message.totalItems !== 0) {
      writer.uint32(16).uint64(message.totalItems);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): GetAddressesReply {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetAddressesReply();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.result.push(Address.decode(reader, reader.uint32()));
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.totalItems = longToNumber(reader.uint64() as Long);
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetAddressesReply {
    return {
      result: globalThis.Array.isArray(object?.result) ? object.result.map((e: any) => Address.fromJSON(e)) : [],
      totalItems: isSet(object.totalItems) ? globalThis.Number(object.totalItems) : 0,
    };
  },

  toJSON(message: GetAddressesReply): unknown {
    const obj: any = {};
    if (message.result?.length) {
      obj.result = message.result.map((e) => Address.toJSON(e));
    }
    if (message.totalItems !== 0) {
      obj.totalItems = Math.round(message.totalItems);
    }
    return obj;
  },

  create(base?: DeepPartial<GetAddressesReply>): GetAddressesReply {
    return GetAddressesReply.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<GetAddressesReply>): GetAddressesReply {
    const message = createBaseGetAddressesReply();
    message.result = object.result?.map((e) => Address.fromPartial(e)) || [];
    message.totalItems = object.totalItems ?? 0;
    return message;
  },
};

function createBaseGetLightAddressesRequest(): GetLightAddressesRequest {
  return { currencyID: "", uniqueCurrencyFilter: undefined, addresses: [] };
}

export const GetLightAddressesRequest = {
  encode(message: GetLightAddressesRequest, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.currencyID !== "") {
      writer.uint32(10).string(message.currencyID);
    }
    if (message.uniqueCurrencyFilter !== undefined) {
      UniqueCurrencyFilter.encode(message.uniqueCurrencyFilter, writer.uint32(18).fork()).ldelim();
    }
    for (const v of message.addresses) {
      writer.uint32(26).string(v!);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): GetLightAddressesRequest {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetLightAddressesRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.currencyID = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.uniqueCurrencyFilter = UniqueCurrencyFilter.decode(reader, reader.uint32());
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.addresses.push(reader.string());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetLightAddressesRequest {
    return {
      currencyID: isSet(object.currencyID) ? globalThis.String(object.currencyID) : "",
      uniqueCurrencyFilter: isSet(object.uniqueCurrencyFilter)
        ? UniqueCurrencyFilter.fromJSON(object.uniqueCurrencyFilter)
        : undefined,
      addresses: globalThis.Array.isArray(object?.addresses)
        ? object.addresses.map((e: any) => globalThis.String(e))
        : [],
    };
  },

  toJSON(message: GetLightAddressesRequest): unknown {
    const obj: any = {};
    if (message.currencyID !== "") {
      obj.currencyID = message.currencyID;
    }
    if (message.uniqueCurrencyFilter !== undefined) {
      obj.uniqueCurrencyFilter = UniqueCurrencyFilter.toJSON(message.uniqueCurrencyFilter);
    }
    if (message.addresses?.length) {
      obj.addresses = message.addresses;
    }
    return obj;
  },

  create(base?: DeepPartial<GetLightAddressesRequest>): GetLightAddressesRequest {
    return GetLightAddressesRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<GetLightAddressesRequest>): GetLightAddressesRequest {
    const message = createBaseGetLightAddressesRequest();
    message.currencyID = object.currencyID ?? "";
    message.uniqueCurrencyFilter = (object.uniqueCurrencyFilter !== undefined && object.uniqueCurrencyFilter !== null)
      ? UniqueCurrencyFilter.fromPartial(object.uniqueCurrencyFilter)
      : undefined;
    message.addresses = object.addresses?.map((e) => e) || [];
    return message;
  },
};

function createBaseGetLightAddressesReply(): GetLightAddressesReply {
  return { result: [] };
}

export const GetLightAddressesReply = {
  encode(message: GetLightAddressesReply, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    for (const v of message.result) {
      LightAddressInfo.encode(v!, writer.uint32(10).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): GetLightAddressesReply {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetLightAddressesReply();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.result.push(LightAddressInfo.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetLightAddressesReply {
    return {
      result: globalThis.Array.isArray(object?.result)
        ? object.result.map((e: any) => LightAddressInfo.fromJSON(e))
        : [],
    };
  },

  toJSON(message: GetLightAddressesReply): unknown {
    const obj: any = {};
    if (message.result?.length) {
      obj.result = message.result.map((e) => LightAddressInfo.toJSON(e));
    }
    return obj;
  },

  create(base?: DeepPartial<GetLightAddressesReply>): GetLightAddressesReply {
    return GetLightAddressesReply.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<GetLightAddressesReply>): GetLightAddressesReply {
    const message = createBaseGetLightAddressesReply();
    message.result = object.result?.map((e) => LightAddressInfo.fromPartial(e)) || [];
    return message;
  },
};

function createBaseGetAddressesStatusRequest(): GetAddressesStatusRequest {
  return { walletIds: [], addressIds: [], currencyIds: [], sorting: undefined, cursor: undefined };
}

export const GetAddressesStatusRequest = {
  encode(message: GetAddressesStatusRequest, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    writer.uint32(10).fork();
    for (const v of message.walletIds) {
      writer.uint64(v);
    }
    writer.ldelim();
    writer.uint32(18).fork();
    for (const v of message.addressIds) {
      writer.uint64(v);
    }
    writer.ldelim();
    for (const v of message.currencyIds) {
      writer.uint32(26).string(v!);
    }
    if (message.sorting !== undefined) {
      GetAddressesStatusRequest_Sorting.encode(message.sorting, writer.uint32(34).fork()).ldelim();
    }
    if (message.cursor !== undefined) {
      RequestCursor.encode(message.cursor, writer.uint32(42).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): GetAddressesStatusRequest {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetAddressesStatusRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag === 8) {
            message.walletIds.push(longToNumber(reader.uint64() as Long));

            continue;
          }

          if (tag === 10) {
            const end2 = reader.uint32() + reader.pos;
            while (reader.pos < end2) {
              message.walletIds.push(longToNumber(reader.uint64() as Long));
            }

            continue;
          }

          break;
        case 2:
          if (tag === 16) {
            message.addressIds.push(longToNumber(reader.uint64() as Long));

            continue;
          }

          if (tag === 18) {
            const end2 = reader.uint32() + reader.pos;
            while (reader.pos < end2) {
              message.addressIds.push(longToNumber(reader.uint64() as Long));
            }

            continue;
          }

          break;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.currencyIds.push(reader.string());
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.sorting = GetAddressesStatusRequest_Sorting.decode(reader, reader.uint32());
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.cursor = RequestCursor.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetAddressesStatusRequest {
    return {
      walletIds: globalThis.Array.isArray(object?.walletIds)
        ? object.walletIds.map((e: any) => globalThis.Number(e))
        : [],
      addressIds: globalThis.Array.isArray(object?.addressIds)
        ? object.addressIds.map((e: any) => globalThis.Number(e))
        : [],
      currencyIds: globalThis.Array.isArray(object?.currencyIds)
        ? object.currencyIds.map((e: any) => globalThis.String(e))
        : [],
      sorting: isSet(object.sorting) ? GetAddressesStatusRequest_Sorting.fromJSON(object.sorting) : undefined,
      cursor: isSet(object.cursor) ? RequestCursor.fromJSON(object.cursor) : undefined,
    };
  },

  toJSON(message: GetAddressesStatusRequest): unknown {
    const obj: any = {};
    if (message.walletIds?.length) {
      obj.walletIds = message.walletIds.map((e) => Math.round(e));
    }
    if (message.addressIds?.length) {
      obj.addressIds = message.addressIds.map((e) => Math.round(e));
    }
    if (message.currencyIds?.length) {
      obj.currencyIds = message.currencyIds;
    }
    if (message.sorting !== undefined) {
      obj.sorting = GetAddressesStatusRequest_Sorting.toJSON(message.sorting);
    }
    if (message.cursor !== undefined) {
      obj.cursor = RequestCursor.toJSON(message.cursor);
    }
    return obj;
  },

  create(base?: DeepPartial<GetAddressesStatusRequest>): GetAddressesStatusRequest {
    return GetAddressesStatusRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<GetAddressesStatusRequest>): GetAddressesStatusRequest {
    const message = createBaseGetAddressesStatusRequest();
    message.walletIds = object.walletIds?.map((e) => e) || [];
    message.addressIds = object.addressIds?.map((e) => e) || [];
    message.currencyIds = object.currencyIds?.map((e) => e) || [];
    message.sorting = (object.sorting !== undefined && object.sorting !== null)
      ? GetAddressesStatusRequest_Sorting.fromPartial(object.sorting)
      : undefined;
    message.cursor = (object.cursor !== undefined && object.cursor !== null)
      ? RequestCursor.fromPartial(object.cursor)
      : undefined;
    return message;
  },
};

function createBaseGetAddressesStatusRequest_Sorting(): GetAddressesStatusRequest_Sorting {
  return { sortOrder: 0 };
}

export const GetAddressesStatusRequest_Sorting = {
  encode(message: GetAddressesStatusRequest_Sorting, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.sortOrder !== 0) {
      writer.uint32(8).int32(message.sortOrder);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): GetAddressesStatusRequest_Sorting {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetAddressesStatusRequest_Sorting();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.sortOrder = reader.int32() as any;
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetAddressesStatusRequest_Sorting {
    return {
      sortOrder: isSet(object.sortOrder) ? getAddressesStatusRequest_Sorting_SortOrderFromJSON(object.sortOrder) : 0,
    };
  },

  toJSON(message: GetAddressesStatusRequest_Sorting): unknown {
    const obj: any = {};
    if (message.sortOrder !== 0) {
      obj.sortOrder = getAddressesStatusRequest_Sorting_SortOrderToJSON(message.sortOrder);
    }
    return obj;
  },

  create(base?: DeepPartial<GetAddressesStatusRequest_Sorting>): GetAddressesStatusRequest_Sorting {
    return GetAddressesStatusRequest_Sorting.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<GetAddressesStatusRequest_Sorting>): GetAddressesStatusRequest_Sorting {
    const message = createBaseGetAddressesStatusRequest_Sorting();
    message.sortOrder = object.sortOrder ?? 0;
    return message;
  },
};

function createBaseGetAddressesStatusReply(): GetAddressesStatusReply {
  return { result: [], cursor: undefined };
}

export const GetAddressesStatusReply = {
  encode(message: GetAddressesStatusReply, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    for (const v of message.result) {
      LightAddressInfo.encode(v!, writer.uint32(10).fork()).ldelim();
    }
    if (message.cursor !== undefined) {
      ResponseCursor.encode(message.cursor, writer.uint32(18).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): GetAddressesStatusReply {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetAddressesStatusReply();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.result.push(LightAddressInfo.decode(reader, reader.uint32()));
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.cursor = ResponseCursor.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetAddressesStatusReply {
    return {
      result: globalThis.Array.isArray(object?.result)
        ? object.result.map((e: any) => LightAddressInfo.fromJSON(e))
        : [],
      cursor: isSet(object.cursor) ? ResponseCursor.fromJSON(object.cursor) : undefined,
    };
  },

  toJSON(message: GetAddressesStatusReply): unknown {
    const obj: any = {};
    if (message.result?.length) {
      obj.result = message.result.map((e) => LightAddressInfo.toJSON(e));
    }
    if (message.cursor !== undefined) {
      obj.cursor = ResponseCursor.toJSON(message.cursor);
    }
    return obj;
  },

  create(base?: DeepPartial<GetAddressesStatusReply>): GetAddressesStatusReply {
    return GetAddressesStatusReply.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<GetAddressesStatusReply>): GetAddressesStatusReply {
    const message = createBaseGetAddressesStatusReply();
    message.result = object.result?.map((e) => LightAddressInfo.fromPartial(e)) || [];
    message.cursor = (object.cursor !== undefined && object.cursor !== null)
      ? ResponseCursor.fromPartial(object.cursor)
      : undefined;
    return message;
  },
};

function createBaseGetAddressRequest(): GetAddressRequest {
  return { id: 0 };
}

export const GetAddressRequest = {
  encode(message: GetAddressRequest, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.id !== 0) {
      writer.uint32(8).uint64(message.id);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): GetAddressRequest {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetAddressRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.id = longToNumber(reader.uint64() as Long);
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetAddressRequest {
    return { id: isSet(object.id) ? globalThis.Number(object.id) : 0 };
  },

  toJSON(message: GetAddressRequest): unknown {
    const obj: any = {};
    if (message.id !== 0) {
      obj.id = Math.round(message.id);
    }
    return obj;
  },

  create(base?: DeepPartial<GetAddressRequest>): GetAddressRequest {
    return GetAddressRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<GetAddressRequest>): GetAddressRequest {
    const message = createBaseGetAddressRequest();
    message.id = object.id ?? 0;
    return message;
  },
};

function createBaseGetAddressReply(): GetAddressReply {
  return { result: undefined };
}

export const GetAddressReply = {
  encode(message: GetAddressReply, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.result !== undefined) {
      Address.encode(message.result, writer.uint32(10).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): GetAddressReply {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetAddressReply();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.result = Address.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetAddressReply {
    return { result: isSet(object.result) ? Address.fromJSON(object.result) : undefined };
  },

  toJSON(message: GetAddressReply): unknown {
    const obj: any = {};
    if (message.result !== undefined) {
      obj.result = Address.toJSON(message.result);
    }
    return obj;
  },

  create(base?: DeepPartial<GetAddressReply>): GetAddressReply {
    return GetAddressReply.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<GetAddressReply>): GetAddressReply {
    const message = createBaseGetAddressReply();
    message.result = (object.result !== undefined && object.result !== null)
      ? Address.fromPartial(object.result)
      : undefined;
    return message;
  },
};

function createBaseGetAddressUTXOsRequest(): GetAddressUTXOsRequest {
  return { id: 0 };
}

export const GetAddressUTXOsRequest = {
  encode(message: GetAddressUTXOsRequest, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.id !== 0) {
      writer.uint32(8).uint64(message.id);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): GetAddressUTXOsRequest {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetAddressUTXOsRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.id = longToNumber(reader.uint64() as Long);
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetAddressUTXOsRequest {
    return { id: isSet(object.id) ? globalThis.Number(object.id) : 0 };
  },

  toJSON(message: GetAddressUTXOsRequest): unknown {
    const obj: any = {};
    if (message.id !== 0) {
      obj.id = Math.round(message.id);
    }
    return obj;
  },

  create(base?: DeepPartial<GetAddressUTXOsRequest>): GetAddressUTXOsRequest {
    return GetAddressUTXOsRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<GetAddressUTXOsRequest>): GetAddressUTXOsRequest {
    const message = createBaseGetAddressUTXOsRequest();
    message.id = object.id ?? 0;
    return message;
  },
};

function createBaseGetAddressUTXOsReply(): GetAddressUTXOsReply {
  return { result: [] };
}

export const GetAddressUTXOsReply = {
  encode(message: GetAddressUTXOsReply, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    for (const v of message.result) {
      UTXO.encode(v!, writer.uint32(10).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): GetAddressUTXOsReply {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetAddressUTXOsReply();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.result.push(UTXO.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetAddressUTXOsReply {
    return { result: globalThis.Array.isArray(object?.result) ? object.result.map((e: any) => UTXO.fromJSON(e)) : [] };
  },

  toJSON(message: GetAddressUTXOsReply): unknown {
    const obj: any = {};
    if (message.result?.length) {
      obj.result = message.result.map((e) => UTXO.toJSON(e));
    }
    return obj;
  },

  create(base?: DeepPartial<GetAddressUTXOsReply>): GetAddressUTXOsReply {
    return GetAddressUTXOsReply.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<GetAddressUTXOsReply>): GetAddressUTXOsReply {
    const message = createBaseGetAddressUTXOsReply();
    message.result = object.result?.map((e) => UTXO.fromPartial(e)) || [];
    return message;
  },
};

function createBaseGetAddressBalanceHistoryRequest(): GetAddressBalanceHistoryRequest {
  return { id: 0, intervalHours: 0 };
}

export const GetAddressBalanceHistoryRequest = {
  encode(message: GetAddressBalanceHistoryRequest, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.id !== 0) {
      writer.uint32(8).uint64(message.id);
    }
    if (message.intervalHours !== 0) {
      writer.uint32(16).uint64(message.intervalHours);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): GetAddressBalanceHistoryRequest {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetAddressBalanceHistoryRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.id = longToNumber(reader.uint64() as Long);
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.intervalHours = longToNumber(reader.uint64() as Long);
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetAddressBalanceHistoryRequest {
    return {
      id: isSet(object.id) ? globalThis.Number(object.id) : 0,
      intervalHours: isSet(object.intervalHours) ? globalThis.Number(object.intervalHours) : 0,
    };
  },

  toJSON(message: GetAddressBalanceHistoryRequest): unknown {
    const obj: any = {};
    if (message.id !== 0) {
      obj.id = Math.round(message.id);
    }
    if (message.intervalHours !== 0) {
      obj.intervalHours = Math.round(message.intervalHours);
    }
    return obj;
  },

  create(base?: DeepPartial<GetAddressBalanceHistoryRequest>): GetAddressBalanceHistoryRequest {
    return GetAddressBalanceHistoryRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<GetAddressBalanceHistoryRequest>): GetAddressBalanceHistoryRequest {
    const message = createBaseGetAddressBalanceHistoryRequest();
    message.id = object.id ?? 0;
    message.intervalHours = object.intervalHours ?? 0;
    return message;
  },
};

function createBaseExportAddressBalanceHistoryRequest(): ExportAddressBalanceHistoryRequest {
  return { id: 0, intervalHours: 0, format: "" };
}

export const ExportAddressBalanceHistoryRequest = {
  encode(message: ExportAddressBalanceHistoryRequest, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.id !== 0) {
      writer.uint32(8).uint64(message.id);
    }
    if (message.intervalHours !== 0) {
      writer.uint32(16).uint64(message.intervalHours);
    }
    if (message.format !== "") {
      writer.uint32(26).string(message.format);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): ExportAddressBalanceHistoryRequest {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseExportAddressBalanceHistoryRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.id = longToNumber(reader.uint64() as Long);
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.intervalHours = longToNumber(reader.uint64() as Long);
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.format = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ExportAddressBalanceHistoryRequest {
    return {
      id: isSet(object.id) ? globalThis.Number(object.id) : 0,
      intervalHours: isSet(object.intervalHours) ? globalThis.Number(object.intervalHours) : 0,
      format: isSet(object.format) ? globalThis.String(object.format) : "",
    };
  },

  toJSON(message: ExportAddressBalanceHistoryRequest): unknown {
    const obj: any = {};
    if (message.id !== 0) {
      obj.id = Math.round(message.id);
    }
    if (message.intervalHours !== 0) {
      obj.intervalHours = Math.round(message.intervalHours);
    }
    if (message.format !== "") {
      obj.format = message.format;
    }
    return obj;
  },

  create(base?: DeepPartial<ExportAddressBalanceHistoryRequest>): ExportAddressBalanceHistoryRequest {
    return ExportAddressBalanceHistoryRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ExportAddressBalanceHistoryRequest>): ExportAddressBalanceHistoryRequest {
    const message = createBaseExportAddressBalanceHistoryRequest();
    message.id = object.id ?? 0;
    message.intervalHours = object.intervalHours ?? 0;
    message.format = object.format ?? "";
    return message;
  },
};

function createBaseGetAddressBalanceHistoryReply(): GetAddressBalanceHistoryReply {
  return { result: [] };
}

export const GetAddressBalanceHistoryReply = {
  encode(message: GetAddressBalanceHistoryReply, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    for (const v of message.result) {
      BalanceHistoryPoint.encode(v!, writer.uint32(10).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): GetAddressBalanceHistoryReply {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetAddressBalanceHistoryReply();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.result.push(BalanceHistoryPoint.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetAddressBalanceHistoryReply {
    return {
      result: globalThis.Array.isArray(object?.result)
        ? object.result.map((e: any) => BalanceHistoryPoint.fromJSON(e))
        : [],
    };
  },

  toJSON(message: GetAddressBalanceHistoryReply): unknown {
    const obj: any = {};
    if (message.result?.length) {
      obj.result = message.result.map((e) => BalanceHistoryPoint.toJSON(e));
    }
    return obj;
  },

  create(base?: DeepPartial<GetAddressBalanceHistoryReply>): GetAddressBalanceHistoryReply {
    return GetAddressBalanceHistoryReply.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<GetAddressBalanceHistoryReply>): GetAddressBalanceHistoryReply {
    const message = createBaseGetAddressBalanceHistoryReply();
    message.result = object.result?.map((e) => BalanceHistoryPoint.fromPartial(e)) || [];
    return message;
  },
};

function createBaseExportAddressBalanceHistoryReply(): ExportAddressBalanceHistoryReply {
  return { result: "", totalItems: 0 };
}

export const ExportAddressBalanceHistoryReply = {
  encode(message: ExportAddressBalanceHistoryReply, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.result !== "") {
      writer.uint32(10).string(message.result);
    }
    if (message.totalItems !== 0) {
      writer.uint32(16).uint64(message.totalItems);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): ExportAddressBalanceHistoryReply {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseExportAddressBalanceHistoryReply();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.result = reader.string();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.totalItems = longToNumber(reader.uint64() as Long);
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ExportAddressBalanceHistoryReply {
    return {
      result: isSet(object.result) ? globalThis.String(object.result) : "",
      totalItems: isSet(object.totalItems) ? globalThis.Number(object.totalItems) : 0,
    };
  },

  toJSON(message: ExportAddressBalanceHistoryReply): unknown {
    const obj: any = {};
    if (message.result !== "") {
      obj.result = message.result;
    }
    if (message.totalItems !== 0) {
      obj.totalItems = Math.round(message.totalItems);
    }
    return obj;
  },

  create(base?: DeepPartial<ExportAddressBalanceHistoryReply>): ExportAddressBalanceHistoryReply {
    return ExportAddressBalanceHistoryReply.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ExportAddressBalanceHistoryReply>): ExportAddressBalanceHistoryReply {
    const message = createBaseExportAddressBalanceHistoryReply();
    message.result = object.result ?? "";
    message.totalItems = object.totalItems ?? 0;
    return message;
  },
};

function createBaseGetWalletBalanceHistoryRequest(): GetWalletBalanceHistoryRequest {
  return { id: 0, intervalHours: 0 };
}

export const GetWalletBalanceHistoryRequest = {
  encode(message: GetWalletBalanceHistoryRequest, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.id !== 0) {
      writer.uint32(8).uint64(message.id);
    }
    if (message.intervalHours !== 0) {
      writer.uint32(16).uint64(message.intervalHours);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): GetWalletBalanceHistoryRequest {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetWalletBalanceHistoryRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.id = longToNumber(reader.uint64() as Long);
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.intervalHours = longToNumber(reader.uint64() as Long);
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetWalletBalanceHistoryRequest {
    return {
      id: isSet(object.id) ? globalThis.Number(object.id) : 0,
      intervalHours: isSet(object.intervalHours) ? globalThis.Number(object.intervalHours) : 0,
    };
  },

  toJSON(message: GetWalletBalanceHistoryRequest): unknown {
    const obj: any = {};
    if (message.id !== 0) {
      obj.id = Math.round(message.id);
    }
    if (message.intervalHours !== 0) {
      obj.intervalHours = Math.round(message.intervalHours);
    }
    return obj;
  },

  create(base?: DeepPartial<GetWalletBalanceHistoryRequest>): GetWalletBalanceHistoryRequest {
    return GetWalletBalanceHistoryRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<GetWalletBalanceHistoryRequest>): GetWalletBalanceHistoryRequest {
    const message = createBaseGetWalletBalanceHistoryRequest();
    message.id = object.id ?? 0;
    message.intervalHours = object.intervalHours ?? 0;
    return message;
  },
};

function createBaseGetWalletBalanceHistoryReply(): GetWalletBalanceHistoryReply {
  return { result: [] };
}

export const GetWalletBalanceHistoryReply = {
  encode(message: GetWalletBalanceHistoryReply, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    for (const v of message.result) {
      BalanceHistoryPoint.encode(v!, writer.uint32(10).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): GetWalletBalanceHistoryReply {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetWalletBalanceHistoryReply();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.result.push(BalanceHistoryPoint.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetWalletBalanceHistoryReply {
    return {
      result: globalThis.Array.isArray(object?.result)
        ? object.result.map((e: any) => BalanceHistoryPoint.fromJSON(e))
        : [],
    };
  },

  toJSON(message: GetWalletBalanceHistoryReply): unknown {
    const obj: any = {};
    if (message.result?.length) {
      obj.result = message.result.map((e) => BalanceHistoryPoint.toJSON(e));
    }
    return obj;
  },

  create(base?: DeepPartial<GetWalletBalanceHistoryReply>): GetWalletBalanceHistoryReply {
    return GetWalletBalanceHistoryReply.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<GetWalletBalanceHistoryReply>): GetWalletBalanceHistoryReply {
    const message = createBaseGetWalletBalanceHistoryReply();
    message.result = object.result?.map((e) => BalanceHistoryPoint.fromPartial(e)) || [];
    return message;
  },
};

function createBaseCreateAddressRequest(): CreateAddressRequest {
  return {
    walletId: 0,
    label: "",
    comment: "",
    customerId: "",
    nonHardenedDerivation: false,
    workchainId: 0,
    type: "",
    externalAddressId: "",
  };
}

export const CreateAddressRequest = {
  encode(message: CreateAddressRequest, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.walletId !== 0) {
      writer.uint32(8).uint64(message.walletId);
    }
    if (message.label !== "") {
      writer.uint32(18).string(message.label);
    }
    if (message.comment !== "") {
      writer.uint32(26).string(message.comment);
    }
    if (message.customerId !== "") {
      writer.uint32(34).string(message.customerId);
    }
    if (message.nonHardenedDerivation !== false) {
      writer.uint32(40).bool(message.nonHardenedDerivation);
    }
    if (message.workchainId !== 0) {
      writer.uint32(48).int32(message.workchainId);
    }
    if (message.type !== "") {
      writer.uint32(58).string(message.type);
    }
    if (message.externalAddressId !== "") {
      writer.uint32(130).string(message.externalAddressId);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CreateAddressRequest {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCreateAddressRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.walletId = longToNumber(reader.uint64() as Long);
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.label = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.comment = reader.string();
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.customerId = reader.string();
          continue;
        case 5:
          if (tag !== 40) {
            break;
          }

          message.nonHardenedDerivation = reader.bool();
          continue;
        case 6:
          if (tag !== 48) {
            break;
          }

          message.workchainId = reader.int32();
          continue;
        case 7:
          if (tag !== 58) {
            break;
          }

          message.type = reader.string();
          continue;
        case 16:
          if (tag !== 130) {
            break;
          }

          message.externalAddressId = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CreateAddressRequest {
    return {
      walletId: isSet(object.walletId) ? globalThis.Number(object.walletId) : 0,
      label: isSet(object.label) ? globalThis.String(object.label) : "",
      comment: isSet(object.comment) ? globalThis.String(object.comment) : "",
      customerId: isSet(object.customerId) ? globalThis.String(object.customerId) : "",
      nonHardenedDerivation: isSet(object.nonHardenedDerivation)
        ? globalThis.Boolean(object.nonHardenedDerivation)
        : false,
      workchainId: isSet(object.workchainId) ? globalThis.Number(object.workchainId) : 0,
      type: isSet(object.type) ? globalThis.String(object.type) : "",
      externalAddressId: isSet(object.externalAddressId) ? globalThis.String(object.externalAddressId) : "",
    };
  },

  toJSON(message: CreateAddressRequest): unknown {
    const obj: any = {};
    if (message.walletId !== 0) {
      obj.walletId = Math.round(message.walletId);
    }
    if (message.label !== "") {
      obj.label = message.label;
    }
    if (message.comment !== "") {
      obj.comment = message.comment;
    }
    if (message.customerId !== "") {
      obj.customerId = message.customerId;
    }
    if (message.nonHardenedDerivation !== false) {
      obj.nonHardenedDerivation = message.nonHardenedDerivation;
    }
    if (message.workchainId !== 0) {
      obj.workchainId = Math.round(message.workchainId);
    }
    if (message.type !== "") {
      obj.type = message.type;
    }
    if (message.externalAddressId !== "") {
      obj.externalAddressId = message.externalAddressId;
    }
    return obj;
  },

  create(base?: DeepPartial<CreateAddressRequest>): CreateAddressRequest {
    return CreateAddressRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CreateAddressRequest>): CreateAddressRequest {
    const message = createBaseCreateAddressRequest();
    message.walletId = object.walletId ?? 0;
    message.label = object.label ?? "";
    message.comment = object.comment ?? "";
    message.customerId = object.customerId ?? "";
    message.nonHardenedDerivation = object.nonHardenedDerivation ?? false;
    message.workchainId = object.workchainId ?? 0;
    message.type = object.type ?? "";
    message.externalAddressId = object.externalAddressId ?? "";
    return message;
  },
};

function createBaseCreateAddressesRequest(): CreateAddressesRequest {
  return { addresses: [] };
}

export const CreateAddressesRequest = {
  encode(message: CreateAddressesRequest, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    for (const v of message.addresses) {
      CreateAddressRequest.encode(v!, writer.uint32(10).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CreateAddressesRequest {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCreateAddressesRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.addresses.push(CreateAddressRequest.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CreateAddressesRequest {
    return {
      addresses: globalThis.Array.isArray(object?.addresses)
        ? object.addresses.map((e: any) => CreateAddressRequest.fromJSON(e))
        : [],
    };
  },

  toJSON(message: CreateAddressesRequest): unknown {
    const obj: any = {};
    if (message.addresses?.length) {
      obj.addresses = message.addresses.map((e) => CreateAddressRequest.toJSON(e));
    }
    return obj;
  },

  create(base?: DeepPartial<CreateAddressesRequest>): CreateAddressesRequest {
    return CreateAddressesRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CreateAddressesRequest>): CreateAddressesRequest {
    const message = createBaseCreateAddressesRequest();
    message.addresses = object.addresses?.map((e) => CreateAddressRequest.fromPartial(e)) || [];
    return message;
  },
};

function createBaseCreateAddressReply(): CreateAddressReply {
  return { result: undefined };
}

export const CreateAddressReply = {
  encode(message: CreateAddressReply, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.result !== undefined) {
      Address.encode(message.result, writer.uint32(10).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CreateAddressReply {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCreateAddressReply();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.result = Address.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CreateAddressReply {
    return { result: isSet(object.result) ? Address.fromJSON(object.result) : undefined };
  },

  toJSON(message: CreateAddressReply): unknown {
    const obj: any = {};
    if (message.result !== undefined) {
      obj.result = Address.toJSON(message.result);
    }
    return obj;
  },

  create(base?: DeepPartial<CreateAddressReply>): CreateAddressReply {
    return CreateAddressReply.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CreateAddressReply>): CreateAddressReply {
    const message = createBaseCreateAddressReply();
    message.result = (object.result !== undefined && object.result !== null)
      ? Address.fromPartial(object.result)
      : undefined;
    return message;
  },
};

function createBaseCreateAddressesReply(): CreateAddressesReply {
  return { result: [] };
}

export const CreateAddressesReply = {
  encode(message: CreateAddressesReply, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    for (const v of message.result) {
      LightAddressInfo.encode(v!, writer.uint32(10).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CreateAddressesReply {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCreateAddressesReply();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.result.push(LightAddressInfo.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CreateAddressesReply {
    return {
      result: globalThis.Array.isArray(object?.result)
        ? object.result.map((e: any) => LightAddressInfo.fromJSON(e))
        : [],
    };
  },

  toJSON(message: CreateAddressesReply): unknown {
    const obj: any = {};
    if (message.result?.length) {
      obj.result = message.result.map((e) => LightAddressInfo.toJSON(e));
    }
    return obj;
  },

  create(base?: DeepPartial<CreateAddressesReply>): CreateAddressesReply {
    return CreateAddressesReply.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CreateAddressesReply>): CreateAddressesReply {
    const message = createBaseCreateAddressesReply();
    message.result = object.result?.map((e) => LightAddressInfo.fromPartial(e)) || [];
    return message;
  },
};

function createBaseComputeAddressesSignatureRequest(): ComputeAddressesSignatureRequest {
  return { walletId: 0, addressId: 0 };
}

export const ComputeAddressesSignatureRequest = {
  encode(message: ComputeAddressesSignatureRequest, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.walletId !== 0) {
      writer.uint32(8).uint64(message.walletId);
    }
    if (message.addressId !== 0) {
      writer.uint32(16).uint64(message.addressId);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): ComputeAddressesSignatureRequest {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseComputeAddressesSignatureRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.walletId = longToNumber(reader.uint64() as Long);
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.addressId = longToNumber(reader.uint64() as Long);
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ComputeAddressesSignatureRequest {
    return {
      walletId: isSet(object.walletId) ? globalThis.Number(object.walletId) : 0,
      addressId: isSet(object.addressId) ? globalThis.Number(object.addressId) : 0,
    };
  },

  toJSON(message: ComputeAddressesSignatureRequest): unknown {
    const obj: any = {};
    if (message.walletId !== 0) {
      obj.walletId = Math.round(message.walletId);
    }
    if (message.addressId !== 0) {
      obj.addressId = Math.round(message.addressId);
    }
    return obj;
  },

  create(base?: DeepPartial<ComputeAddressesSignatureRequest>): ComputeAddressesSignatureRequest {
    return ComputeAddressesSignatureRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ComputeAddressesSignatureRequest>): ComputeAddressesSignatureRequest {
    const message = createBaseComputeAddressesSignatureRequest();
    message.walletId = object.walletId ?? 0;
    message.addressId = object.addressId ?? 0;
    return message;
  },
};

function createBaseComputeAddressesSignatureReply(): ComputeAddressesSignatureReply {
  return { result: [], totalItems: 0 };
}

export const ComputeAddressesSignatureReply = {
  encode(message: ComputeAddressesSignatureReply, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    for (const v of message.result) {
      ComputeAddressesSignatureReply_AddressSignature.encode(v!, writer.uint32(10).fork()).ldelim();
    }
    if (message.totalItems !== 0) {
      writer.uint32(16).uint64(message.totalItems);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): ComputeAddressesSignatureReply {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseComputeAddressesSignatureReply();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.result.push(ComputeAddressesSignatureReply_AddressSignature.decode(reader, reader.uint32()));
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.totalItems = longToNumber(reader.uint64() as Long);
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ComputeAddressesSignatureReply {
    return {
      result: globalThis.Array.isArray(object?.result)
        ? object.result.map((e: any) => ComputeAddressesSignatureReply_AddressSignature.fromJSON(e))
        : [],
      totalItems: isSet(object.totalItems) ? globalThis.Number(object.totalItems) : 0,
    };
  },

  toJSON(message: ComputeAddressesSignatureReply): unknown {
    const obj: any = {};
    if (message.result?.length) {
      obj.result = message.result.map((e) => ComputeAddressesSignatureReply_AddressSignature.toJSON(e));
    }
    if (message.totalItems !== 0) {
      obj.totalItems = Math.round(message.totalItems);
    }
    return obj;
  },

  create(base?: DeepPartial<ComputeAddressesSignatureReply>): ComputeAddressesSignatureReply {
    return ComputeAddressesSignatureReply.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ComputeAddressesSignatureReply>): ComputeAddressesSignatureReply {
    const message = createBaseComputeAddressesSignatureReply();
    message.result = object.result?.map((e) => ComputeAddressesSignatureReply_AddressSignature.fromPartial(e)) || [];
    message.totalItems = object.totalItems ?? 0;
    return message;
  },
};

function createBaseComputeAddressesSignatureReply_AddressSignature(): ComputeAddressesSignatureReply_AddressSignature {
  return { walletId: 0, addressId: 0, address: "", currency: "", signature: "", error: "", currencyInfo: undefined };
}

export const ComputeAddressesSignatureReply_AddressSignature = {
  encode(
    message: ComputeAddressesSignatureReply_AddressSignature,
    writer: _m0.Writer = _m0.Writer.create(),
  ): _m0.Writer {
    if (message.walletId !== 0) {
      writer.uint32(8).uint64(message.walletId);
    }
    if (message.addressId !== 0) {
      writer.uint32(16).uint64(message.addressId);
    }
    if (message.address !== "") {
      writer.uint32(26).string(message.address);
    }
    if (message.currency !== "") {
      writer.uint32(34).string(message.currency);
    }
    if (message.signature !== "") {
      writer.uint32(42).string(message.signature);
    }
    if (message.error !== "") {
      writer.uint32(50).string(message.error);
    }
    if (message.currencyInfo !== undefined) {
      Currency.encode(message.currencyInfo, writer.uint32(58).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): ComputeAddressesSignatureReply_AddressSignature {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseComputeAddressesSignatureReply_AddressSignature();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.walletId = longToNumber(reader.uint64() as Long);
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.addressId = longToNumber(reader.uint64() as Long);
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.address = reader.string();
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.currency = reader.string();
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.signature = reader.string();
          continue;
        case 6:
          if (tag !== 50) {
            break;
          }

          message.error = reader.string();
          continue;
        case 7:
          if (tag !== 58) {
            break;
          }

          message.currencyInfo = Currency.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ComputeAddressesSignatureReply_AddressSignature {
    return {
      walletId: isSet(object.walletId) ? globalThis.Number(object.walletId) : 0,
      addressId: isSet(object.addressId) ? globalThis.Number(object.addressId) : 0,
      address: isSet(object.address) ? globalThis.String(object.address) : "",
      currency: isSet(object.currency) ? globalThis.String(object.currency) : "",
      signature: isSet(object.signature) ? globalThis.String(object.signature) : "",
      error: isSet(object.error) ? globalThis.String(object.error) : "",
      currencyInfo: isSet(object.currencyInfo) ? Currency.fromJSON(object.currencyInfo) : undefined,
    };
  },

  toJSON(message: ComputeAddressesSignatureReply_AddressSignature): unknown {
    const obj: any = {};
    if (message.walletId !== 0) {
      obj.walletId = Math.round(message.walletId);
    }
    if (message.addressId !== 0) {
      obj.addressId = Math.round(message.addressId);
    }
    if (message.address !== "") {
      obj.address = message.address;
    }
    if (message.currency !== "") {
      obj.currency = message.currency;
    }
    if (message.signature !== "") {
      obj.signature = message.signature;
    }
    if (message.error !== "") {
      obj.error = message.error;
    }
    if (message.currencyInfo !== undefined) {
      obj.currencyInfo = Currency.toJSON(message.currencyInfo);
    }
    return obj;
  },

  create(
    base?: DeepPartial<ComputeAddressesSignatureReply_AddressSignature>,
  ): ComputeAddressesSignatureReply_AddressSignature {
    return ComputeAddressesSignatureReply_AddressSignature.fromPartial(base ?? {});
  },
  fromPartial(
    object: DeepPartial<ComputeAddressesSignatureReply_AddressSignature>,
  ): ComputeAddressesSignatureReply_AddressSignature {
    const message = createBaseComputeAddressesSignatureReply_AddressSignature();
    message.walletId = object.walletId ?? 0;
    message.addressId = object.addressId ?? 0;
    message.address = object.address ?? "";
    message.currency = object.currency ?? "";
    message.signature = object.signature ?? "";
    message.error = object.error ?? "";
    message.currencyInfo = (object.currencyInfo !== undefined && object.currencyInfo !== null)
      ? Currency.fromPartial(object.currencyInfo)
      : undefined;
    return message;
  },
};

function createBaseGetAddressProofOfReserveRequest(): GetAddressProofOfReserveRequest {
  return { id: 0, challenge: "" };
}

export const GetAddressProofOfReserveRequest = {
  encode(message: GetAddressProofOfReserveRequest, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.id !== 0) {
      writer.uint32(8).uint64(message.id);
    }
    if (message.challenge !== "") {
      writer.uint32(18).string(message.challenge);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): GetAddressProofOfReserveRequest {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetAddressProofOfReserveRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.id = longToNumber(reader.uint64() as Long);
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.challenge = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetAddressProofOfReserveRequest {
    return {
      id: isSet(object.id) ? globalThis.Number(object.id) : 0,
      challenge: isSet(object.challenge) ? globalThis.String(object.challenge) : "",
    };
  },

  toJSON(message: GetAddressProofOfReserveRequest): unknown {
    const obj: any = {};
    if (message.id !== 0) {
      obj.id = Math.round(message.id);
    }
    if (message.challenge !== "") {
      obj.challenge = message.challenge;
    }
    return obj;
  },

  create(base?: DeepPartial<GetAddressProofOfReserveRequest>): GetAddressProofOfReserveRequest {
    return GetAddressProofOfReserveRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<GetAddressProofOfReserveRequest>): GetAddressProofOfReserveRequest {
    const message = createBaseGetAddressProofOfReserveRequest();
    message.id = object.id ?? 0;
    message.challenge = object.challenge ?? "";
    return message;
  },
};

function createBaseGetAddressProofOfReserveReply(): GetAddressProofOfReserveReply {
  return { result: undefined };
}

export const GetAddressProofOfReserveReply = {
  encode(message: GetAddressProofOfReserveReply, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.result !== undefined) {
      ProofOfReserve.encode(message.result, writer.uint32(10).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): GetAddressProofOfReserveReply {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetAddressProofOfReserveReply();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.result = ProofOfReserve.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetAddressProofOfReserveReply {
    return { result: isSet(object.result) ? ProofOfReserve.fromJSON(object.result) : undefined };
  },

  toJSON(message: GetAddressProofOfReserveReply): unknown {
    const obj: any = {};
    if (message.result !== undefined) {
      obj.result = ProofOfReserve.toJSON(message.result);
    }
    return obj;
  },

  create(base?: DeepPartial<GetAddressProofOfReserveReply>): GetAddressProofOfReserveReply {
    return GetAddressProofOfReserveReply.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<GetAddressProofOfReserveReply>): GetAddressProofOfReserveReply {
    const message = createBaseGetAddressProofOfReserveReply();
    message.result = (object.result !== undefined && object.result !== null)
      ? ProofOfReserve.fromPartial(object.result)
      : undefined;
    return message;
  },
};

function createBaseGetAddressesProofOfReserveRequest(): GetAddressesProofOfReserveRequest {
  return { addresses: [], blockchain: "", challenge: "", network: "" };
}

export const GetAddressesProofOfReserveRequest = {
  encode(message: GetAddressesProofOfReserveRequest, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    for (const v of message.addresses) {
      writer.uint32(10).string(v!);
    }
    if (message.blockchain !== "") {
      writer.uint32(18).string(message.blockchain);
    }
    if (message.challenge !== "") {
      writer.uint32(26).string(message.challenge);
    }
    if (message.network !== "") {
      writer.uint32(34).string(message.network);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): GetAddressesProofOfReserveRequest {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetAddressesProofOfReserveRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.addresses.push(reader.string());
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.blockchain = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.challenge = reader.string();
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.network = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetAddressesProofOfReserveRequest {
    return {
      addresses: globalThis.Array.isArray(object?.addresses)
        ? object.addresses.map((e: any) => globalThis.String(e))
        : [],
      blockchain: isSet(object.blockchain) ? globalThis.String(object.blockchain) : "",
      challenge: isSet(object.challenge) ? globalThis.String(object.challenge) : "",
      network: isSet(object.network) ? globalThis.String(object.network) : "",
    };
  },

  toJSON(message: GetAddressesProofOfReserveRequest): unknown {
    const obj: any = {};
    if (message.addresses?.length) {
      obj.addresses = message.addresses;
    }
    if (message.blockchain !== "") {
      obj.blockchain = message.blockchain;
    }
    if (message.challenge !== "") {
      obj.challenge = message.challenge;
    }
    if (message.network !== "") {
      obj.network = message.network;
    }
    return obj;
  },

  create(base?: DeepPartial<GetAddressesProofOfReserveRequest>): GetAddressesProofOfReserveRequest {
    return GetAddressesProofOfReserveRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<GetAddressesProofOfReserveRequest>): GetAddressesProofOfReserveRequest {
    const message = createBaseGetAddressesProofOfReserveRequest();
    message.addresses = object.addresses?.map((e) => e) || [];
    message.blockchain = object.blockchain ?? "";
    message.challenge = object.challenge ?? "";
    message.network = object.network ?? "";
    return message;
  },
};

function createBaseGetAddressesProofOfReserveReply(): GetAddressesProofOfReserveReply {
  return { result: [] };
}

export const GetAddressesProofOfReserveReply = {
  encode(message: GetAddressesProofOfReserveReply, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    for (const v of message.result) {
      ProofOfReserve.encode(v!, writer.uint32(10).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): GetAddressesProofOfReserveReply {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetAddressesProofOfReserveReply();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.result.push(ProofOfReserve.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetAddressesProofOfReserveReply {
    return {
      result: globalThis.Array.isArray(object?.result) ? object.result.map((e: any) => ProofOfReserve.fromJSON(e)) : [],
    };
  },

  toJSON(message: GetAddressesProofOfReserveReply): unknown {
    const obj: any = {};
    if (message.result?.length) {
      obj.result = message.result.map((e) => ProofOfReserve.toJSON(e));
    }
    return obj;
  },

  create(base?: DeepPartial<GetAddressesProofOfReserveReply>): GetAddressesProofOfReserveReply {
    return GetAddressesProofOfReserveReply.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<GetAddressesProofOfReserveReply>): GetAddressesProofOfReserveReply {
    const message = createBaseGetAddressesProofOfReserveReply();
    message.result = object.result?.map((e) => ProofOfReserve.fromPartial(e)) || [];
    return message;
  },
};

function createBaseBTCSignMessageRequest(): BTCSignMessageRequest {
  return { addressId: 0, message: "" };
}

export const BTCSignMessageRequest = {
  encode(message: BTCSignMessageRequest, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.addressId !== 0) {
      writer.uint32(8).uint64(message.addressId);
    }
    if (message.message !== "") {
      writer.uint32(18).string(message.message);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): BTCSignMessageRequest {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseBTCSignMessageRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.addressId = longToNumber(reader.uint64() as Long);
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.message = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): BTCSignMessageRequest {
    return {
      addressId: isSet(object.addressId) ? globalThis.Number(object.addressId) : 0,
      message: isSet(object.message) ? globalThis.String(object.message) : "",
    };
  },

  toJSON(message: BTCSignMessageRequest): unknown {
    const obj: any = {};
    if (message.addressId !== 0) {
      obj.addressId = Math.round(message.addressId);
    }
    if (message.message !== "") {
      obj.message = message.message;
    }
    return obj;
  },

  create(base?: DeepPartial<BTCSignMessageRequest>): BTCSignMessageRequest {
    return BTCSignMessageRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<BTCSignMessageRequest>): BTCSignMessageRequest {
    const message = createBaseBTCSignMessageRequest();
    message.addressId = object.addressId ?? 0;
    message.message = object.message ?? "";
    return message;
  },
};

function createBaseBTCSignMessageReply(): BTCSignMessageReply {
  return { address: "", message: "", signature: "" };
}

export const BTCSignMessageReply = {
  encode(message: BTCSignMessageReply, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.address !== "") {
      writer.uint32(10).string(message.address);
    }
    if (message.message !== "") {
      writer.uint32(18).string(message.message);
    }
    if (message.signature !== "") {
      writer.uint32(26).string(message.signature);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): BTCSignMessageReply {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseBTCSignMessageReply();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.address = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.message = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.signature = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): BTCSignMessageReply {
    return {
      address: isSet(object.address) ? globalThis.String(object.address) : "",
      message: isSet(object.message) ? globalThis.String(object.message) : "",
      signature: isSet(object.signature) ? globalThis.String(object.signature) : "",
    };
  },

  toJSON(message: BTCSignMessageReply): unknown {
    const obj: any = {};
    if (message.address !== "") {
      obj.address = message.address;
    }
    if (message.message !== "") {
      obj.message = message.message;
    }
    if (message.signature !== "") {
      obj.signature = message.signature;
    }
    return obj;
  },

  create(base?: DeepPartial<BTCSignMessageReply>): BTCSignMessageReply {
    return BTCSignMessageReply.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<BTCSignMessageReply>): BTCSignMessageReply {
    const message = createBaseBTCSignMessageReply();
    message.address = object.address ?? "";
    message.message = object.message ?? "";
    message.signature = object.signature ?? "";
    return message;
  },
};

function createBaseETHSignMessageRequest(): ETHSignMessageRequest {
  return { addressId: 0, message: "" };
}

export const ETHSignMessageRequest = {
  encode(message: ETHSignMessageRequest, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.addressId !== 0) {
      writer.uint32(8).uint64(message.addressId);
    }
    if (message.message !== "") {
      writer.uint32(18).string(message.message);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): ETHSignMessageRequest {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseETHSignMessageRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.addressId = longToNumber(reader.uint64() as Long);
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.message = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ETHSignMessageRequest {
    return {
      addressId: isSet(object.addressId) ? globalThis.Number(object.addressId) : 0,
      message: isSet(object.message) ? globalThis.String(object.message) : "",
    };
  },

  toJSON(message: ETHSignMessageRequest): unknown {
    const obj: any = {};
    if (message.addressId !== 0) {
      obj.addressId = Math.round(message.addressId);
    }
    if (message.message !== "") {
      obj.message = message.message;
    }
    return obj;
  },

  create(base?: DeepPartial<ETHSignMessageRequest>): ETHSignMessageRequest {
    return ETHSignMessageRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ETHSignMessageRequest>): ETHSignMessageRequest {
    const message = createBaseETHSignMessageRequest();
    message.addressId = object.addressId ?? 0;
    message.message = object.message ?? "";
    return message;
  },
};

function createBaseETHSignMessageReply(): ETHSignMessageReply {
  return { address: "", message: "", signature: "" };
}

export const ETHSignMessageReply = {
  encode(message: ETHSignMessageReply, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.address !== "") {
      writer.uint32(10).string(message.address);
    }
    if (message.message !== "") {
      writer.uint32(18).string(message.message);
    }
    if (message.signature !== "") {
      writer.uint32(26).string(message.signature);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): ETHSignMessageReply {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseETHSignMessageReply();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.address = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.message = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.signature = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ETHSignMessageReply {
    return {
      address: isSet(object.address) ? globalThis.String(object.address) : "",
      message: isSet(object.message) ? globalThis.String(object.message) : "",
      signature: isSet(object.signature) ? globalThis.String(object.signature) : "",
    };
  },

  toJSON(message: ETHSignMessageReply): unknown {
    const obj: any = {};
    if (message.address !== "") {
      obj.address = message.address;
    }
    if (message.message !== "") {
      obj.message = message.message;
    }
    if (message.signature !== "") {
      obj.signature = message.signature;
    }
    return obj;
  },

  create(base?: DeepPartial<ETHSignMessageReply>): ETHSignMessageReply {
    return ETHSignMessageReply.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ETHSignMessageReply>): ETHSignMessageReply {
    const message = createBaseETHSignMessageReply();
    message.address = object.address ?? "";
    message.message = object.message ?? "";
    message.signature = object.signature ?? "";
    return message;
  },
};

function createBaseExportAddressesRequest(): ExportAddressesRequest {
  return {
    walletId: 0,
    currency: "",
    format: "",
    query: "",
    scoreProvider: "",
    scoreInBelow: "",
    scoreOutBelow: "",
    scoreExclusive: false,
    customerId: "",
    coinfirmScoreGreater: "",
    chainalysisScoreGreater: "",
    scoreFilter: undefined,
    blockchain: "",
    network: "",
  };
}

export const ExportAddressesRequest = {
  encode(message: ExportAddressesRequest, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.walletId !== 0) {
      writer.uint32(8).uint64(message.walletId);
    }
    if (message.currency !== "") {
      writer.uint32(18).string(message.currency);
    }
    if (message.format !== "") {
      writer.uint32(26).string(message.format);
    }
    if (message.query !== "") {
      writer.uint32(34).string(message.query);
    }
    if (message.scoreProvider !== "") {
      writer.uint32(42).string(message.scoreProvider);
    }
    if (message.scoreInBelow !== "") {
      writer.uint32(50).string(message.scoreInBelow);
    }
    if (message.scoreOutBelow !== "") {
      writer.uint32(58).string(message.scoreOutBelow);
    }
    if (message.scoreExclusive !== false) {
      writer.uint32(64).bool(message.scoreExclusive);
    }
    if (message.customerId !== "") {
      writer.uint32(74).string(message.customerId);
    }
    if (message.coinfirmScoreGreater !== "") {
      writer.uint32(82).string(message.coinfirmScoreGreater);
    }
    if (message.chainalysisScoreGreater !== "") {
      writer.uint32(90).string(message.chainalysisScoreGreater);
    }
    if (message.scoreFilter !== undefined) {
      ScoreFilter.encode(message.scoreFilter, writer.uint32(98).fork()).ldelim();
    }
    if (message.blockchain !== "") {
      writer.uint32(106).string(message.blockchain);
    }
    if (message.network !== "") {
      writer.uint32(114).string(message.network);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): ExportAddressesRequest {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseExportAddressesRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.walletId = longToNumber(reader.uint64() as Long);
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.currency = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.format = reader.string();
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.query = reader.string();
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.scoreProvider = reader.string();
          continue;
        case 6:
          if (tag !== 50) {
            break;
          }

          message.scoreInBelow = reader.string();
          continue;
        case 7:
          if (tag !== 58) {
            break;
          }

          message.scoreOutBelow = reader.string();
          continue;
        case 8:
          if (tag !== 64) {
            break;
          }

          message.scoreExclusive = reader.bool();
          continue;
        case 9:
          if (tag !== 74) {
            break;
          }

          message.customerId = reader.string();
          continue;
        case 10:
          if (tag !== 82) {
            break;
          }

          message.coinfirmScoreGreater = reader.string();
          continue;
        case 11:
          if (tag !== 90) {
            break;
          }

          message.chainalysisScoreGreater = reader.string();
          continue;
        case 12:
          if (tag !== 98) {
            break;
          }

          message.scoreFilter = ScoreFilter.decode(reader, reader.uint32());
          continue;
        case 13:
          if (tag !== 106) {
            break;
          }

          message.blockchain = reader.string();
          continue;
        case 14:
          if (tag !== 114) {
            break;
          }

          message.network = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ExportAddressesRequest {
    return {
      walletId: isSet(object.walletId) ? globalThis.Number(object.walletId) : 0,
      currency: isSet(object.currency) ? globalThis.String(object.currency) : "",
      format: isSet(object.format) ? globalThis.String(object.format) : "",
      query: isSet(object.query) ? globalThis.String(object.query) : "",
      scoreProvider: isSet(object.scoreProvider) ? globalThis.String(object.scoreProvider) : "",
      scoreInBelow: isSet(object.scoreInBelow) ? globalThis.String(object.scoreInBelow) : "",
      scoreOutBelow: isSet(object.scoreOutBelow) ? globalThis.String(object.scoreOutBelow) : "",
      scoreExclusive: isSet(object.scoreExclusive) ? globalThis.Boolean(object.scoreExclusive) : false,
      customerId: isSet(object.customerId) ? globalThis.String(object.customerId) : "",
      coinfirmScoreGreater: isSet(object.coinfirmScoreGreater) ? globalThis.String(object.coinfirmScoreGreater) : "",
      chainalysisScoreGreater: isSet(object.chainalysisScoreGreater)
        ? globalThis.String(object.chainalysisScoreGreater)
        : "",
      scoreFilter: isSet(object.scoreFilter) ? ScoreFilter.fromJSON(object.scoreFilter) : undefined,
      blockchain: isSet(object.blockchain) ? globalThis.String(object.blockchain) : "",
      network: isSet(object.network) ? globalThis.String(object.network) : "",
    };
  },

  toJSON(message: ExportAddressesRequest): unknown {
    const obj: any = {};
    if (message.walletId !== 0) {
      obj.walletId = Math.round(message.walletId);
    }
    if (message.currency !== "") {
      obj.currency = message.currency;
    }
    if (message.format !== "") {
      obj.format = message.format;
    }
    if (message.query !== "") {
      obj.query = message.query;
    }
    if (message.scoreProvider !== "") {
      obj.scoreProvider = message.scoreProvider;
    }
    if (message.scoreInBelow !== "") {
      obj.scoreInBelow = message.scoreInBelow;
    }
    if (message.scoreOutBelow !== "") {
      obj.scoreOutBelow = message.scoreOutBelow;
    }
    if (message.scoreExclusive !== false) {
      obj.scoreExclusive = message.scoreExclusive;
    }
    if (message.customerId !== "") {
      obj.customerId = message.customerId;
    }
    if (message.coinfirmScoreGreater !== "") {
      obj.coinfirmScoreGreater = message.coinfirmScoreGreater;
    }
    if (message.chainalysisScoreGreater !== "") {
      obj.chainalysisScoreGreater = message.chainalysisScoreGreater;
    }
    if (message.scoreFilter !== undefined) {
      obj.scoreFilter = ScoreFilter.toJSON(message.scoreFilter);
    }
    if (message.blockchain !== "") {
      obj.blockchain = message.blockchain;
    }
    if (message.network !== "") {
      obj.network = message.network;
    }
    return obj;
  },

  create(base?: DeepPartial<ExportAddressesRequest>): ExportAddressesRequest {
    return ExportAddressesRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ExportAddressesRequest>): ExportAddressesRequest {
    const message = createBaseExportAddressesRequest();
    message.walletId = object.walletId ?? 0;
    message.currency = object.currency ?? "";
    message.format = object.format ?? "";
    message.query = object.query ?? "";
    message.scoreProvider = object.scoreProvider ?? "";
    message.scoreInBelow = object.scoreInBelow ?? "";
    message.scoreOutBelow = object.scoreOutBelow ?? "";
    message.scoreExclusive = object.scoreExclusive ?? false;
    message.customerId = object.customerId ?? "";
    message.coinfirmScoreGreater = object.coinfirmScoreGreater ?? "";
    message.chainalysisScoreGreater = object.chainalysisScoreGreater ?? "";
    message.scoreFilter = (object.scoreFilter !== undefined && object.scoreFilter !== null)
      ? ScoreFilter.fromPartial(object.scoreFilter)
      : undefined;
    message.blockchain = object.blockchain ?? "";
    message.network = object.network ?? "";
    return message;
  },
};

function createBaseExportAddressesReply(): ExportAddressesReply {
  return { result: "", totalItems: 0 };
}

export const ExportAddressesReply = {
  encode(message: ExportAddressesReply, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.result !== "") {
      writer.uint32(10).string(message.result);
    }
    if (message.totalItems !== 0) {
      writer.uint32(16).uint64(message.totalItems);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): ExportAddressesReply {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseExportAddressesReply();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.result = reader.string();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.totalItems = longToNumber(reader.uint64() as Long);
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ExportAddressesReply {
    return {
      result: isSet(object.result) ? globalThis.String(object.result) : "",
      totalItems: isSet(object.totalItems) ? globalThis.Number(object.totalItems) : 0,
    };
  },

  toJSON(message: ExportAddressesReply): unknown {
    const obj: any = {};
    if (message.result !== "") {
      obj.result = message.result;
    }
    if (message.totalItems !== 0) {
      obj.totalItems = Math.round(message.totalItems);
    }
    return obj;
  },

  create(base?: DeepPartial<ExportAddressesReply>): ExportAddressesReply {
    return ExportAddressesReply.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ExportAddressesReply>): ExportAddressesReply {
    const message = createBaseExportAddressesReply();
    message.result = object.result ?? "";
    message.totalItems = object.totalItems ?? 0;
    return message;
  },
};

function createBaseGetReservationsRequest(): GetReservationsRequest {
  return { kind: "", address: "", addressId: 0, cursor: undefined, kinds: [] };
}

export const GetReservationsRequest = {
  encode(message: GetReservationsRequest, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.kind !== "") {
      writer.uint32(10).string(message.kind);
    }
    if (message.address !== "") {
      writer.uint32(18).string(message.address);
    }
    if (message.addressId !== 0) {
      writer.uint32(24).uint64(message.addressId);
    }
    if (message.cursor !== undefined) {
      RequestCursor.encode(message.cursor, writer.uint32(34).fork()).ldelim();
    }
    for (const v of message.kinds) {
      writer.uint32(42).string(v!);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): GetReservationsRequest {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetReservationsRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.kind = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.address = reader.string();
          continue;
        case 3:
          if (tag !== 24) {
            break;
          }

          message.addressId = longToNumber(reader.uint64() as Long);
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.cursor = RequestCursor.decode(reader, reader.uint32());
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.kinds.push(reader.string());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetReservationsRequest {
    return {
      kind: isSet(object.kind) ? globalThis.String(object.kind) : "",
      address: isSet(object.address) ? globalThis.String(object.address) : "",
      addressId: isSet(object.addressId) ? globalThis.Number(object.addressId) : 0,
      cursor: isSet(object.cursor) ? RequestCursor.fromJSON(object.cursor) : undefined,
      kinds: globalThis.Array.isArray(object?.kinds) ? object.kinds.map((e: any) => globalThis.String(e)) : [],
    };
  },

  toJSON(message: GetReservationsRequest): unknown {
    const obj: any = {};
    if (message.kind !== "") {
      obj.kind = message.kind;
    }
    if (message.address !== "") {
      obj.address = message.address;
    }
    if (message.addressId !== 0) {
      obj.addressId = Math.round(message.addressId);
    }
    if (message.cursor !== undefined) {
      obj.cursor = RequestCursor.toJSON(message.cursor);
    }
    if (message.kinds?.length) {
      obj.kinds = message.kinds;
    }
    return obj;
  },

  create(base?: DeepPartial<GetReservationsRequest>): GetReservationsRequest {
    return GetReservationsRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<GetReservationsRequest>): GetReservationsRequest {
    const message = createBaseGetReservationsRequest();
    message.kind = object.kind ?? "";
    message.address = object.address ?? "";
    message.addressId = object.addressId ?? 0;
    message.cursor = (object.cursor !== undefined && object.cursor !== null)
      ? RequestCursor.fromPartial(object.cursor)
      : undefined;
    message.kinds = object.kinds?.map((e) => e) || [];
    return message;
  },
};

function createBaseGetReservationsReply(): GetReservationsReply {
  return { result: [], cursor: undefined };
}

export const GetReservationsReply = {
  encode(message: GetReservationsReply, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    for (const v of message.result) {
      Reservation.encode(v!, writer.uint32(10).fork()).ldelim();
    }
    if (message.cursor !== undefined) {
      ResponseCursor.encode(message.cursor, writer.uint32(18).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): GetReservationsReply {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetReservationsReply();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.result.push(Reservation.decode(reader, reader.uint32()));
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.cursor = ResponseCursor.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetReservationsReply {
    return {
      result: globalThis.Array.isArray(object?.result) ? object.result.map((e: any) => Reservation.fromJSON(e)) : [],
      cursor: isSet(object.cursor) ? ResponseCursor.fromJSON(object.cursor) : undefined,
    };
  },

  toJSON(message: GetReservationsReply): unknown {
    const obj: any = {};
    if (message.result?.length) {
      obj.result = message.result.map((e) => Reservation.toJSON(e));
    }
    if (message.cursor !== undefined) {
      obj.cursor = ResponseCursor.toJSON(message.cursor);
    }
    return obj;
  },

  create(base?: DeepPartial<GetReservationsReply>): GetReservationsReply {
    return GetReservationsReply.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<GetReservationsReply>): GetReservationsReply {
    const message = createBaseGetReservationsReply();
    message.result = object.result?.map((e) => Reservation.fromPartial(e)) || [];
    message.cursor = (object.cursor !== undefined && object.cursor !== null)
      ? ResponseCursor.fromPartial(object.cursor)
      : undefined;
    return message;
  },
};

function createBaseGetReservationRequest(): GetReservationRequest {
  return { id: 0 };
}

export const GetReservationRequest = {
  encode(message: GetReservationRequest, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.id !== 0) {
      writer.uint32(8).uint64(message.id);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): GetReservationRequest {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetReservationRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.id = longToNumber(reader.uint64() as Long);
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetReservationRequest {
    return { id: isSet(object.id) ? globalThis.Number(object.id) : 0 };
  },

  toJSON(message: GetReservationRequest): unknown {
    const obj: any = {};
    if (message.id !== 0) {
      obj.id = Math.round(message.id);
    }
    return obj;
  },

  create(base?: DeepPartial<GetReservationRequest>): GetReservationRequest {
    return GetReservationRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<GetReservationRequest>): GetReservationRequest {
    const message = createBaseGetReservationRequest();
    message.id = object.id ?? 0;
    return message;
  },
};

function createBaseGetReservationReply(): GetReservationReply {
  return { result: undefined };
}

export const GetReservationReply = {
  encode(message: GetReservationReply, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.result !== undefined) {
      Reservation.encode(message.result, writer.uint32(10).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): GetReservationReply {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetReservationReply();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.result = Reservation.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetReservationReply {
    return { result: isSet(object.result) ? Reservation.fromJSON(object.result) : undefined };
  },

  toJSON(message: GetReservationReply): unknown {
    const obj: any = {};
    if (message.result !== undefined) {
      obj.result = Reservation.toJSON(message.result);
    }
    return obj;
  },

  create(base?: DeepPartial<GetReservationReply>): GetReservationReply {
    return GetReservationReply.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<GetReservationReply>): GetReservationReply {
    const message = createBaseGetReservationReply();
    message.result = (object.result !== undefined && object.result !== null)
      ? Reservation.fromPartial(object.result)
      : undefined;
    return message;
  },
};

function createBaseGetReservationUTXORequest(): GetReservationUTXORequest {
  return { id: 0 };
}

export const GetReservationUTXORequest = {
  encode(message: GetReservationUTXORequest, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.id !== 0) {
      writer.uint32(8).uint64(message.id);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): GetReservationUTXORequest {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetReservationUTXORequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.id = longToNumber(reader.uint64() as Long);
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetReservationUTXORequest {
    return { id: isSet(object.id) ? globalThis.Number(object.id) : 0 };
  },

  toJSON(message: GetReservationUTXORequest): unknown {
    const obj: any = {};
    if (message.id !== 0) {
      obj.id = Math.round(message.id);
    }
    return obj;
  },

  create(base?: DeepPartial<GetReservationUTXORequest>): GetReservationUTXORequest {
    return GetReservationUTXORequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<GetReservationUTXORequest>): GetReservationUTXORequest {
    const message = createBaseGetReservationUTXORequest();
    message.id = object.id ?? 0;
    return message;
  },
};

function createBaseGetReservationUTXOReply(): GetReservationUTXOReply {
  return { result: undefined };
}

export const GetReservationUTXOReply = {
  encode(message: GetReservationUTXOReply, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.result !== undefined) {
      UTXO.encode(message.result, writer.uint32(10).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): GetReservationUTXOReply {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetReservationUTXOReply();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.result = UTXO.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetReservationUTXOReply {
    return { result: isSet(object.result) ? UTXO.fromJSON(object.result) : undefined };
  },

  toJSON(message: GetReservationUTXOReply): unknown {
    const obj: any = {};
    if (message.result !== undefined) {
      obj.result = UTXO.toJSON(message.result);
    }
    return obj;
  },

  create(base?: DeepPartial<GetReservationUTXOReply>): GetReservationUTXOReply {
    return GetReservationUTXOReply.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<GetReservationUTXOReply>): GetReservationUTXOReply {
    const message = createBaseGetReservationUTXOReply();
    message.result = (object.result !== undefined && object.result !== null)
      ? UTXO.fromPartial(object.result)
      : undefined;
    return message;
  },
};

export interface WalletService {
  /**
   * #######################3
   *
   * Currencies APIs
   *
   * #######################3
   */
  GetCurrencies(request: GetCurrenciesRequest): Promise<GetCurrenciesReply>;
  GetCurrency(request: GetCurrencyRequest): Promise<GetCurrencyReply>;
  GetBaseCurrency(request: Empty): Promise<GetBaseCurrencyReply>;
  /**
   * #######################3
   *
   * Addresess APIs
   *
   * #######################3
   */
  CreateAddressAttributes(request: CreateAddressAttributesRequest): Promise<CreateAddressAttributesReply>;
  DeleteAddressAttribute(request: DeleteAddressAttributeRequest): Promise<Empty>;
  GetAddress(request: GetAddressRequest): Promise<GetAddressReply>;
  GetAddressUTXOs(request: GetAddressUTXOsRequest): Promise<GetAddressUTXOsReply>;
  GetAddressBalanceHistory(request: GetAddressBalanceHistoryRequest): Promise<GetAddressBalanceHistoryReply>;
  ExportAddressBalanceHistory(request: ExportAddressBalanceHistoryRequest): Promise<ExportAddressBalanceHistoryReply>;
  GetAddressProofOfReserve(request: GetAddressProofOfReserveRequest): Promise<GetAddressProofOfReserveReply>;
  ETHSignMessage(request: ETHSignMessageRequest): Promise<ETHSignMessageReply>;
  BTCSignMessage(request: BTCSignMessageRequest): Promise<BTCSignMessageReply>;
  GetAddressesProofOfReserve(request: GetAddressesProofOfReserveRequest): Promise<GetAddressesProofOfReserveReply>;
  GetAddressTokens(request: GetAddressTokensRequest): Promise<GetAddressTokensReply>;
  GetAddresses(request: GetAddressesRequest): Promise<GetAddressesReply>;
  CreateAddress(request: CreateAddressRequest): Promise<CreateAddressReply>;
  GetLightAddresses(request: GetLightAddressesRequest): Promise<GetLightAddressesReply>;
  GetAddressesStatus(request: GetAddressesStatusRequest): Promise<GetAddressesStatusReply>;
  ExportAddresses(request: ExportAddressesRequest): Promise<ExportAddressesReply>;
  CreateAddressesBatch(request: CreateAddressesRequest): Promise<CreateAddressesReply>;
  ComputeAddressesSignature(request: ComputeAddressesSignatureRequest): Promise<ComputeAddressesSignatureReply>;
  /**
   * #######################3
   *
   * Assets APIs
   *
   * #######################3
   */
  GetAssetWallets(request: GetAssetWalletsRequest): Promise<GetAssetWalletsReply>;
  GetAssetAddresses(request: GetAssetAddressesRequest): Promise<GetAssetAddressesReply>;
  /**
   * #######################3
   *
   * Balances APIs
   *
   * #######################3
   */
  GetBalances(request: GetBalancesRequest): Promise<GetBalancesReply>;
  GetNFTCollectionBalances(request: GetNFTCollectionBalancesRequest): Promise<GetNFTCollectionBalancesReply>;
  /**
   * #######################3
   *
   * Wallets APIs
   *
   * #######################3
   * Deprecated - do NOT use this endpoint, use GetWalletV2 /api/rest/v2/wallets/{id} instead
   *
   * @deprecated
   */
  GetWallet(request: GetWalletRequest): Promise<GetWalletReply>;
  GetWalletV2(request: GetWalletRequest): Promise<GetWalletInfoReply>;
  CreateWalletAttributes(request: CreateWalletAttributesRequest): Promise<CreateWalletAttributesReply>;
  DeleteWalletAttribute(request: DeleteWalletAttributeRequest): Promise<Empty>;
  GetWalletTokens(request: GetWalletTokensRequest): Promise<GetWalletTokensReply>;
  GetWalletBalanceHistory(request: GetWalletBalanceHistoryRequest): Promise<GetWalletBalanceHistoryReply>;
  CreateWallet(request: CreateWalletRequest): Promise<CreateWalletReply>;
  /**
   * Deprecated - do NOT use this endpoint, use /api/rest/v1/wallets/info instead
   *
   * @deprecated
   */
  GetWallets(request: GetWalletsRequest): Promise<GetWalletsReply>;
  /**
   * Deprecated - do NOT use this endpoint, use /api/rest/v2/wallets instead
   * Better naming, and better REST route
   *
   * @deprecated
   */
  GetWalletsInfo(request: GetWalletsInfoRequest): Promise<GetWalletsInfoReply>;
  GetWalletsV2(request: GetWalletsInfoRequest): Promise<GetWalletsInfoReply>;
  /**
   * #######################3
   *
   * Reservations APIs
   *
   * #######################3
   */
  GetReservations(request: GetReservationsRequest): Promise<GetReservationsReply>;
  GetReservation(request: GetReservationRequest): Promise<GetReservationReply>;
  GetReservationUTXO(request: GetReservationUTXORequest): Promise<GetReservationUTXOReply>;
}

export const WalletServiceServiceName = "tgvalidatord.WalletService";
export class WalletServiceClientImpl implements WalletService {
  private readonly rpc: Rpc;
  private readonly service: string;
  constructor(rpc: Rpc, opts?: { service?: string }) {
    this.service = opts?.service || WalletServiceServiceName;
    this.rpc = rpc;
    this.GetCurrencies = this.GetCurrencies.bind(this);
    this.GetCurrency = this.GetCurrency.bind(this);
    this.GetBaseCurrency = this.GetBaseCurrency.bind(this);
    this.CreateAddressAttributes = this.CreateAddressAttributes.bind(this);
    this.DeleteAddressAttribute = this.DeleteAddressAttribute.bind(this);
    this.GetAddress = this.GetAddress.bind(this);
    this.GetAddressUTXOs = this.GetAddressUTXOs.bind(this);
    this.GetAddressBalanceHistory = this.GetAddressBalanceHistory.bind(this);
    this.ExportAddressBalanceHistory = this.ExportAddressBalanceHistory.bind(this);
    this.GetAddressProofOfReserve = this.GetAddressProofOfReserve.bind(this);
    this.ETHSignMessage = this.ETHSignMessage.bind(this);
    this.BTCSignMessage = this.BTCSignMessage.bind(this);
    this.GetAddressesProofOfReserve = this.GetAddressesProofOfReserve.bind(this);
    this.GetAddressTokens = this.GetAddressTokens.bind(this);
    this.GetAddresses = this.GetAddresses.bind(this);
    this.CreateAddress = this.CreateAddress.bind(this);
    this.GetLightAddresses = this.GetLightAddresses.bind(this);
    this.GetAddressesStatus = this.GetAddressesStatus.bind(this);
    this.ExportAddresses = this.ExportAddresses.bind(this);
    this.CreateAddressesBatch = this.CreateAddressesBatch.bind(this);
    this.ComputeAddressesSignature = this.ComputeAddressesSignature.bind(this);
    this.GetAssetWallets = this.GetAssetWallets.bind(this);
    this.GetAssetAddresses = this.GetAssetAddresses.bind(this);
    this.GetBalances = this.GetBalances.bind(this);
    this.GetNFTCollectionBalances = this.GetNFTCollectionBalances.bind(this);
    this.GetWallet = this.GetWallet.bind(this);
    this.GetWalletV2 = this.GetWalletV2.bind(this);
    this.CreateWalletAttributes = this.CreateWalletAttributes.bind(this);
    this.DeleteWalletAttribute = this.DeleteWalletAttribute.bind(this);
    this.GetWalletTokens = this.GetWalletTokens.bind(this);
    this.GetWalletBalanceHistory = this.GetWalletBalanceHistory.bind(this);
    this.CreateWallet = this.CreateWallet.bind(this);
    this.GetWallets = this.GetWallets.bind(this);
    this.GetWalletsInfo = this.GetWalletsInfo.bind(this);
    this.GetWalletsV2 = this.GetWalletsV2.bind(this);
    this.GetReservations = this.GetReservations.bind(this);
    this.GetReservation = this.GetReservation.bind(this);
    this.GetReservationUTXO = this.GetReservationUTXO.bind(this);
  }
  GetCurrencies(request: GetCurrenciesRequest): Promise<GetCurrenciesReply> {
    const data = GetCurrenciesRequest.encode(request).finish();
    const promise = this.rpc.request(this.service, "GetCurrencies", data);
    return promise.then((data) => GetCurrenciesReply.decode(_m0.Reader.create(data)));
  }

  GetCurrency(request: GetCurrencyRequest): Promise<GetCurrencyReply> {
    const data = GetCurrencyRequest.encode(request).finish();
    const promise = this.rpc.request(this.service, "GetCurrency", data);
    return promise.then((data) => GetCurrencyReply.decode(_m0.Reader.create(data)));
  }

  GetBaseCurrency(request: Empty): Promise<GetBaseCurrencyReply> {
    const data = Empty.encode(request).finish();
    const promise = this.rpc.request(this.service, "GetBaseCurrency", data);
    return promise.then((data) => GetBaseCurrencyReply.decode(_m0.Reader.create(data)));
  }

  CreateAddressAttributes(request: CreateAddressAttributesRequest): Promise<CreateAddressAttributesReply> {
    const data = CreateAddressAttributesRequest.encode(request).finish();
    const promise = this.rpc.request(this.service, "CreateAddressAttributes", data);
    return promise.then((data) => CreateAddressAttributesReply.decode(_m0.Reader.create(data)));
  }

  DeleteAddressAttribute(request: DeleteAddressAttributeRequest): Promise<Empty> {
    const data = DeleteAddressAttributeRequest.encode(request).finish();
    const promise = this.rpc.request(this.service, "DeleteAddressAttribute", data);
    return promise.then((data) => Empty.decode(_m0.Reader.create(data)));
  }

  GetAddress(request: GetAddressRequest): Promise<GetAddressReply> {
    const data = GetAddressRequest.encode(request).finish();
    const promise = this.rpc.request(this.service, "GetAddress", data);
    return promise.then((data) => GetAddressReply.decode(_m0.Reader.create(data)));
  }

  GetAddressUTXOs(request: GetAddressUTXOsRequest): Promise<GetAddressUTXOsReply> {
    const data = GetAddressUTXOsRequest.encode(request).finish();
    const promise = this.rpc.request(this.service, "GetAddressUTXOs", data);
    return promise.then((data) => GetAddressUTXOsReply.decode(_m0.Reader.create(data)));
  }

  GetAddressBalanceHistory(request: GetAddressBalanceHistoryRequest): Promise<GetAddressBalanceHistoryReply> {
    const data = GetAddressBalanceHistoryRequest.encode(request).finish();
    const promise = this.rpc.request(this.service, "GetAddressBalanceHistory", data);
    return promise.then((data) => GetAddressBalanceHistoryReply.decode(_m0.Reader.create(data)));
  }

  ExportAddressBalanceHistory(request: ExportAddressBalanceHistoryRequest): Promise<ExportAddressBalanceHistoryReply> {
    const data = ExportAddressBalanceHistoryRequest.encode(request).finish();
    const promise = this.rpc.request(this.service, "ExportAddressBalanceHistory", data);
    return promise.then((data) => ExportAddressBalanceHistoryReply.decode(_m0.Reader.create(data)));
  }

  GetAddressProofOfReserve(request: GetAddressProofOfReserveRequest): Promise<GetAddressProofOfReserveReply> {
    const data = GetAddressProofOfReserveRequest.encode(request).finish();
    const promise = this.rpc.request(this.service, "GetAddressProofOfReserve", data);
    return promise.then((data) => GetAddressProofOfReserveReply.decode(_m0.Reader.create(data)));
  }

  ETHSignMessage(request: ETHSignMessageRequest): Promise<ETHSignMessageReply> {
    const data = ETHSignMessageRequest.encode(request).finish();
    const promise = this.rpc.request(this.service, "ETHSignMessage", data);
    return promise.then((data) => ETHSignMessageReply.decode(_m0.Reader.create(data)));
  }

  BTCSignMessage(request: BTCSignMessageRequest): Promise<BTCSignMessageReply> {
    const data = BTCSignMessageRequest.encode(request).finish();
    const promise = this.rpc.request(this.service, "BTCSignMessage", data);
    return promise.then((data) => BTCSignMessageReply.decode(_m0.Reader.create(data)));
  }

  GetAddressesProofOfReserve(request: GetAddressesProofOfReserveRequest): Promise<GetAddressesProofOfReserveReply> {
    const data = GetAddressesProofOfReserveRequest.encode(request).finish();
    const promise = this.rpc.request(this.service, "GetAddressesProofOfReserve", data);
    return promise.then((data) => GetAddressesProofOfReserveReply.decode(_m0.Reader.create(data)));
  }

  GetAddressTokens(request: GetAddressTokensRequest): Promise<GetAddressTokensReply> {
    const data = GetAddressTokensRequest.encode(request).finish();
    const promise = this.rpc.request(this.service, "GetAddressTokens", data);
    return promise.then((data) => GetAddressTokensReply.decode(_m0.Reader.create(data)));
  }

  GetAddresses(request: GetAddressesRequest): Promise<GetAddressesReply> {
    const data = GetAddressesRequest.encode(request).finish();
    const promise = this.rpc.request(this.service, "GetAddresses", data);
    return promise.then((data) => GetAddressesReply.decode(_m0.Reader.create(data)));
  }

  CreateAddress(request: CreateAddressRequest): Promise<CreateAddressReply> {
    const data = CreateAddressRequest.encode(request).finish();
    const promise = this.rpc.request(this.service, "CreateAddress", data);
    return promise.then((data) => CreateAddressReply.decode(_m0.Reader.create(data)));
  }

  GetLightAddresses(request: GetLightAddressesRequest): Promise<GetLightAddressesReply> {
    const data = GetLightAddressesRequest.encode(request).finish();
    const promise = this.rpc.request(this.service, "GetLightAddresses", data);
    return promise.then((data) => GetLightAddressesReply.decode(_m0.Reader.create(data)));
  }

  GetAddressesStatus(request: GetAddressesStatusRequest): Promise<GetAddressesStatusReply> {
    const data = GetAddressesStatusRequest.encode(request).finish();
    const promise = this.rpc.request(this.service, "GetAddressesStatus", data);
    return promise.then((data) => GetAddressesStatusReply.decode(_m0.Reader.create(data)));
  }

  ExportAddresses(request: ExportAddressesRequest): Promise<ExportAddressesReply> {
    const data = ExportAddressesRequest.encode(request).finish();
    const promise = this.rpc.request(this.service, "ExportAddresses", data);
    return promise.then((data) => ExportAddressesReply.decode(_m0.Reader.create(data)));
  }

  CreateAddressesBatch(request: CreateAddressesRequest): Promise<CreateAddressesReply> {
    const data = CreateAddressesRequest.encode(request).finish();
    const promise = this.rpc.request(this.service, "CreateAddressesBatch", data);
    return promise.then((data) => CreateAddressesReply.decode(_m0.Reader.create(data)));
  }

  ComputeAddressesSignature(request: ComputeAddressesSignatureRequest): Promise<ComputeAddressesSignatureReply> {
    const data = ComputeAddressesSignatureRequest.encode(request).finish();
    const promise = this.rpc.request(this.service, "ComputeAddressesSignature", data);
    return promise.then((data) => ComputeAddressesSignatureReply.decode(_m0.Reader.create(data)));
  }

  GetAssetWallets(request: GetAssetWalletsRequest): Promise<GetAssetWalletsReply> {
    const data = GetAssetWalletsRequest.encode(request).finish();
    const promise = this.rpc.request(this.service, "GetAssetWallets", data);
    return promise.then((data) => GetAssetWalletsReply.decode(_m0.Reader.create(data)));
  }

  GetAssetAddresses(request: GetAssetAddressesRequest): Promise<GetAssetAddressesReply> {
    const data = GetAssetAddressesRequest.encode(request).finish();
    const promise = this.rpc.request(this.service, "GetAssetAddresses", data);
    return promise.then((data) => GetAssetAddressesReply.decode(_m0.Reader.create(data)));
  }

  GetBalances(request: GetBalancesRequest): Promise<GetBalancesReply> {
    const data = GetBalancesRequest.encode(request).finish();
    const promise = this.rpc.request(this.service, "GetBalances", data);
    return promise.then((data) => GetBalancesReply.decode(_m0.Reader.create(data)));
  }

  GetNFTCollectionBalances(request: GetNFTCollectionBalancesRequest): Promise<GetNFTCollectionBalancesReply> {
    const data = GetNFTCollectionBalancesRequest.encode(request).finish();
    const promise = this.rpc.request(this.service, "GetNFTCollectionBalances", data);
    return promise.then((data) => GetNFTCollectionBalancesReply.decode(_m0.Reader.create(data)));
  }

  GetWallet(request: GetWalletRequest): Promise<GetWalletReply> {
    const data = GetWalletRequest.encode(request).finish();
    const promise = this.rpc.request(this.service, "GetWallet", data);
    return promise.then((data) => GetWalletReply.decode(_m0.Reader.create(data)));
  }

  GetWalletV2(request: GetWalletRequest): Promise<GetWalletInfoReply> {
    const data = GetWalletRequest.encode(request).finish();
    const promise = this.rpc.request(this.service, "GetWalletV2", data);
    return promise.then((data) => GetWalletInfoReply.decode(_m0.Reader.create(data)));
  }

  CreateWalletAttributes(request: CreateWalletAttributesRequest): Promise<CreateWalletAttributesReply> {
    const data = CreateWalletAttributesRequest.encode(request).finish();
    const promise = this.rpc.request(this.service, "CreateWalletAttributes", data);
    return promise.then((data) => CreateWalletAttributesReply.decode(_m0.Reader.create(data)));
  }

  DeleteWalletAttribute(request: DeleteWalletAttributeRequest): Promise<Empty> {
    const data = DeleteWalletAttributeRequest.encode(request).finish();
    const promise = this.rpc.request(this.service, "DeleteWalletAttribute", data);
    return promise.then((data) => Empty.decode(_m0.Reader.create(data)));
  }

  GetWalletTokens(request: GetWalletTokensRequest): Promise<GetWalletTokensReply> {
    const data = GetWalletTokensRequest.encode(request).finish();
    const promise = this.rpc.request(this.service, "GetWalletTokens", data);
    return promise.then((data) => GetWalletTokensReply.decode(_m0.Reader.create(data)));
  }

  GetWalletBalanceHistory(request: GetWalletBalanceHistoryRequest): Promise<GetWalletBalanceHistoryReply> {
    const data = GetWalletBalanceHistoryRequest.encode(request).finish();
    const promise = this.rpc.request(this.service, "GetWalletBalanceHistory", data);
    return promise.then((data) => GetWalletBalanceHistoryReply.decode(_m0.Reader.create(data)));
  }

  CreateWallet(request: CreateWalletRequest): Promise<CreateWalletReply> {
    const data = CreateWalletRequest.encode(request).finish();
    const promise = this.rpc.request(this.service, "CreateWallet", data);
    return promise.then((data) => CreateWalletReply.decode(_m0.Reader.create(data)));
  }

  GetWallets(request: GetWalletsRequest): Promise<GetWalletsReply> {
    const data = GetWalletsRequest.encode(request).finish();
    const promise = this.rpc.request(this.service, "GetWallets", data);
    return promise.then((data) => GetWalletsReply.decode(_m0.Reader.create(data)));
  }

  GetWalletsInfo(request: GetWalletsInfoRequest): Promise<GetWalletsInfoReply> {
    const data = GetWalletsInfoRequest.encode(request).finish();
    const promise = this.rpc.request(this.service, "GetWalletsInfo", data);
    return promise.then((data) => GetWalletsInfoReply.decode(_m0.Reader.create(data)));
  }

  GetWalletsV2(request: GetWalletsInfoRequest): Promise<GetWalletsInfoReply> {
    const data = GetWalletsInfoRequest.encode(request).finish();
    const promise = this.rpc.request(this.service, "GetWalletsV2", data);
    return promise.then((data) => GetWalletsInfoReply.decode(_m0.Reader.create(data)));
  }

  GetReservations(request: GetReservationsRequest): Promise<GetReservationsReply> {
    const data = GetReservationsRequest.encode(request).finish();
    const promise = this.rpc.request(this.service, "GetReservations", data);
    return promise.then((data) => GetReservationsReply.decode(_m0.Reader.create(data)));
  }

  GetReservation(request: GetReservationRequest): Promise<GetReservationReply> {
    const data = GetReservationRequest.encode(request).finish();
    const promise = this.rpc.request(this.service, "GetReservation", data);
    return promise.then((data) => GetReservationReply.decode(_m0.Reader.create(data)));
  }

  GetReservationUTXO(request: GetReservationUTXORequest): Promise<GetReservationUTXOReply> {
    const data = GetReservationUTXORequest.encode(request).finish();
    const promise = this.rpc.request(this.service, "GetReservationUTXO", data);
    return promise.then((data) => GetReservationUTXOReply.decode(_m0.Reader.create(data)));
  }
}

interface Rpc {
  request(service: string, method: string, data: Uint8Array): Promise<Uint8Array>;
}

function bytesFromBase64(b64: string): Uint8Array {
  const bin = globalThis.atob(b64);
  const arr = new Uint8Array(bin.length);
  for (let i = 0; i < bin.length; ++i) {
    arr[i] = bin.charCodeAt(i);
  }
  return arr;
}

function base64FromBytes(arr: Uint8Array): string {
  const bin: string[] = [];
  arr.forEach((byte) => {
    bin.push(globalThis.String.fromCharCode(byte));
  });
  return globalThis.btoa(bin.join(""));
}

type Builtin = Date | Function | Uint8Array | string | number | boolean | undefined;

export type DeepPartial<T> = T extends Builtin ? T
  : T extends globalThis.Array<infer U> ? globalThis.Array<DeepPartial<U>>
  : T extends ReadonlyArray<infer U> ? ReadonlyArray<DeepPartial<U>>
  : T extends {} ? { [K in keyof T]?: DeepPartial<T[K]> }
  : Partial<T>;

function longToNumber(long: Long): number {
  if (long.gt(globalThis.Number.MAX_SAFE_INTEGER)) {
    throw new globalThis.Error("Value is larger than Number.MAX_SAFE_INTEGER");
  }
  if (long.lt(globalThis.Number.MIN_SAFE_INTEGER)) {
    throw new globalThis.Error("Value is smaller than Number.MIN_SAFE_INTEGER");
  }
  return long.toNumber();
}

if (_m0.util.Long !== Long) {
  _m0.util.Long = Long as any;
  _m0.configure();
}

function isSet(value: any): boolean {
  return value !== null && value !== undefined;
}
