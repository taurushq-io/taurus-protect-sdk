// Code generated by protoc-gen-ts_proto. DO NOT EDIT.
// versions:
//   protoc-gen-ts_proto  v1.181.2
//   protoc               v6.33.4
// source: asset-service.proto

/* eslint-disable */
import Long from "long";
import _m0 from "protobufjs/minimal";
import { AssetEvent, AssetHolder, AssetParams, AssetResource } from "./asset";
import { RequestCursor, ResponseCursor } from "./cursor";
import { Workflow } from "./workflow";

export const protobufPackage = "tgvalidatord";

export enum AssetHolderType {
  HolderTypeUnknown = 0,
  HolderTypeInternal = 1,
  HolderTypeWhitelisted = 2,
  HolderTypeExternal = 3,
  UNRECOGNIZED = -1,
}

export function assetHolderTypeFromJSON(object: any): AssetHolderType {
  switch (object) {
    case 0:
    case "HolderTypeUnknown":
      return AssetHolderType.HolderTypeUnknown;
    case 1:
    case "HolderTypeInternal":
      return AssetHolderType.HolderTypeInternal;
    case 2:
    case "HolderTypeWhitelisted":
      return AssetHolderType.HolderTypeWhitelisted;
    case 3:
    case "HolderTypeExternal":
      return AssetHolderType.HolderTypeExternal;
    case -1:
    case "UNRECOGNIZED":
    default:
      return AssetHolderType.UNRECOGNIZED;
  }
}

export function assetHolderTypeToJSON(object: AssetHolderType): string {
  switch (object) {
    case AssetHolderType.HolderTypeUnknown:
      return "HolderTypeUnknown";
    case AssetHolderType.HolderTypeInternal:
      return "HolderTypeInternal";
    case AssetHolderType.HolderTypeWhitelisted:
      return "HolderTypeWhitelisted";
    case AssetHolderType.HolderTypeExternal:
      return "HolderTypeExternal";
    case AssetHolderType.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

export interface CreateAssetRequest {
  fromAddressId: number;
  label: string;
  price: string;
  decimals: number;
  params: AssetParams | undefined;
}

export interface ImportAssetRequest {
  blockchain: string;
  network: string;
  label: string;
  price: string;
  decimals: number;
  address: string;
}

export interface MintAssetRequest {
  assetID: string;
  fromAddressId: number;
  toAddressId: number;
  toWhitelistedAddressId: number;
  amount: string;
  nftMetadata: Uint8Array[];
}

export interface BurnAssetRequest {
  assetID: string;
  fromAddressId: number;
  burnAddressId: number;
  burnWhitelistedAddressId: number;
  amount: string;
  nftTokenIDs: number[];
}

export interface PauseAssetRequest {
  assetID: string;
  fromAddressId: number;
}

export interface UnpauseAssetRequest {
  assetID: string;
  fromAddressId: number;
}

export interface PauseAssetAccountRequest {
  assetID: string;
  fromAddressId: number;
  targetAddressId: number;
  targetWhitelistedAddressId: number;
}

export interface UnpauseAssetAccountRequest {
  assetID: string;
  fromAddressId: number;
  targetAddressId: number;
  targetWhitelistedAddressId: number;
}

export interface ApproveAssetAddressKYCRequest {
  assetID: string;
  fromAddressId: number;
  targetAddressId: number;
  targetWhitelistedAddressId: number;
}

export interface RevokeAssetAddressKYCRequest {
  assetID: string;
  fromAddressId: number;
  targetAddressId: number;
  targetWhitelistedAddressId: number;
}

export interface AssociateAddressWithAssetRequest {
  assetID: string;
  fromAddressId: number;
}

export interface DissociateAddressFromAssetRequest {
  assetID: string;
  fromAddressId: number;
}

export interface GetAssetsRequest {
  cursor: RequestCursor | undefined;
  blockchain: string;
  network: string;
  symbol?: string | undefined;
  contractAddress?: string | undefined;
  label?: string | undefined;
  currencyName?: string | undefined;
}

export interface GetAssetRequest {
  id: string;
}

export interface GetAssetReply {
  result: AssetResource | undefined;
}

export interface GetAssetsReply {
  result: AssetResource[];
  cursor: ResponseCursor | undefined;
}

export interface GetAssetEventsByCurrencyRequest {
  cursor: RequestCursor | undefined;
  currencyID: string;
}

export interface GetAssetEventsReply {
  result: AssetEvent[];
  cursor: ResponseCursor | undefined;
}

export interface GetAssetHoldersByCurrencyRequest {
  cursor: RequestCursor | undefined;
  currencyID: string;
  holderType: AssetHolderType;
}

export interface GetAssetHoldersReply {
  result: AssetHolder[];
  cursor: ResponseCursor | undefined;
}

function createBaseCreateAssetRequest(): CreateAssetRequest {
  return { fromAddressId: 0, label: "", price: "", decimals: 0, params: undefined };
}

export const CreateAssetRequest = {
  encode(message: CreateAssetRequest, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.fromAddressId !== 0) {
      writer.uint32(8).uint64(message.fromAddressId);
    }
    if (message.label !== "") {
      writer.uint32(18).string(message.label);
    }
    if (message.price !== "") {
      writer.uint32(26).string(message.price);
    }
    if (message.decimals !== 0) {
      writer.uint32(32).uint64(message.decimals);
    }
    if (message.params !== undefined) {
      AssetParams.encode(message.params, writer.uint32(42).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CreateAssetRequest {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCreateAssetRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.fromAddressId = longToNumber(reader.uint64() as Long);
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.label = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.price = reader.string();
          continue;
        case 4:
          if (tag !== 32) {
            break;
          }

          message.decimals = longToNumber(reader.uint64() as Long);
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.params = AssetParams.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CreateAssetRequest {
    return {
      fromAddressId: isSet(object.fromAddressId) ? globalThis.Number(object.fromAddressId) : 0,
      label: isSet(object.label) ? globalThis.String(object.label) : "",
      price: isSet(object.price) ? globalThis.String(object.price) : "",
      decimals: isSet(object.decimals) ? globalThis.Number(object.decimals) : 0,
      params: isSet(object.params) ? AssetParams.fromJSON(object.params) : undefined,
    };
  },

  toJSON(message: CreateAssetRequest): unknown {
    const obj: any = {};
    if (message.fromAddressId !== 0) {
      obj.fromAddressId = Math.round(message.fromAddressId);
    }
    if (message.label !== "") {
      obj.label = message.label;
    }
    if (message.price !== "") {
      obj.price = message.price;
    }
    if (message.decimals !== 0) {
      obj.decimals = Math.round(message.decimals);
    }
    if (message.params !== undefined) {
      obj.params = AssetParams.toJSON(message.params);
    }
    return obj;
  },

  create(base?: DeepPartial<CreateAssetRequest>): CreateAssetRequest {
    return CreateAssetRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CreateAssetRequest>): CreateAssetRequest {
    const message = createBaseCreateAssetRequest();
    message.fromAddressId = object.fromAddressId ?? 0;
    message.label = object.label ?? "";
    message.price = object.price ?? "";
    message.decimals = object.decimals ?? 0;
    message.params = (object.params !== undefined && object.params !== null)
      ? AssetParams.fromPartial(object.params)
      : undefined;
    return message;
  },
};

function createBaseImportAssetRequest(): ImportAssetRequest {
  return { blockchain: "", network: "", label: "", price: "", decimals: 0, address: "" };
}

export const ImportAssetRequest = {
  encode(message: ImportAssetRequest, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.blockchain !== "") {
      writer.uint32(10).string(message.blockchain);
    }
    if (message.network !== "") {
      writer.uint32(18).string(message.network);
    }
    if (message.label !== "") {
      writer.uint32(26).string(message.label);
    }
    if (message.price !== "") {
      writer.uint32(34).string(message.price);
    }
    if (message.decimals !== 0) {
      writer.uint32(40).uint64(message.decimals);
    }
    if (message.address !== "") {
      writer.uint32(50).string(message.address);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): ImportAssetRequest {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseImportAssetRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.blockchain = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.network = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.label = reader.string();
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.price = reader.string();
          continue;
        case 5:
          if (tag !== 40) {
            break;
          }

          message.decimals = longToNumber(reader.uint64() as Long);
          continue;
        case 6:
          if (tag !== 50) {
            break;
          }

          message.address = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ImportAssetRequest {
    return {
      blockchain: isSet(object.blockchain) ? globalThis.String(object.blockchain) : "",
      network: isSet(object.network) ? globalThis.String(object.network) : "",
      label: isSet(object.label) ? globalThis.String(object.label) : "",
      price: isSet(object.price) ? globalThis.String(object.price) : "",
      decimals: isSet(object.decimals) ? globalThis.Number(object.decimals) : 0,
      address: isSet(object.address) ? globalThis.String(object.address) : "",
    };
  },

  toJSON(message: ImportAssetRequest): unknown {
    const obj: any = {};
    if (message.blockchain !== "") {
      obj.blockchain = message.blockchain;
    }
    if (message.network !== "") {
      obj.network = message.network;
    }
    if (message.label !== "") {
      obj.label = message.label;
    }
    if (message.price !== "") {
      obj.price = message.price;
    }
    if (message.decimals !== 0) {
      obj.decimals = Math.round(message.decimals);
    }
    if (message.address !== "") {
      obj.address = message.address;
    }
    return obj;
  },

  create(base?: DeepPartial<ImportAssetRequest>): ImportAssetRequest {
    return ImportAssetRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ImportAssetRequest>): ImportAssetRequest {
    const message = createBaseImportAssetRequest();
    message.blockchain = object.blockchain ?? "";
    message.network = object.network ?? "";
    message.label = object.label ?? "";
    message.price = object.price ?? "";
    message.decimals = object.decimals ?? 0;
    message.address = object.address ?? "";
    return message;
  },
};

function createBaseMintAssetRequest(): MintAssetRequest {
  return { assetID: "", fromAddressId: 0, toAddressId: 0, toWhitelistedAddressId: 0, amount: "", nftMetadata: [] };
}

export const MintAssetRequest = {
  encode(message: MintAssetRequest, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.assetID !== "") {
      writer.uint32(10).string(message.assetID);
    }
    if (message.fromAddressId !== 0) {
      writer.uint32(16).uint64(message.fromAddressId);
    }
    if (message.toAddressId !== 0) {
      writer.uint32(24).uint64(message.toAddressId);
    }
    if (message.toWhitelistedAddressId !== 0) {
      writer.uint32(32).uint64(message.toWhitelistedAddressId);
    }
    if (message.amount !== "") {
      writer.uint32(42).string(message.amount);
    }
    for (const v of message.nftMetadata) {
      writer.uint32(50).bytes(v!);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): MintAssetRequest {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMintAssetRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.assetID = reader.string();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.fromAddressId = longToNumber(reader.uint64() as Long);
          continue;
        case 3:
          if (tag !== 24) {
            break;
          }

          message.toAddressId = longToNumber(reader.uint64() as Long);
          continue;
        case 4:
          if (tag !== 32) {
            break;
          }

          message.toWhitelistedAddressId = longToNumber(reader.uint64() as Long);
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.amount = reader.string();
          continue;
        case 6:
          if (tag !== 50) {
            break;
          }

          message.nftMetadata.push(reader.bytes());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): MintAssetRequest {
    return {
      assetID: isSet(object.assetID) ? globalThis.String(object.assetID) : "",
      fromAddressId: isSet(object.fromAddressId) ? globalThis.Number(object.fromAddressId) : 0,
      toAddressId: isSet(object.toAddressId) ? globalThis.Number(object.toAddressId) : 0,
      toWhitelistedAddressId: isSet(object.toWhitelistedAddressId)
        ? globalThis.Number(object.toWhitelistedAddressId)
        : 0,
      amount: isSet(object.amount) ? globalThis.String(object.amount) : "",
      nftMetadata: globalThis.Array.isArray(object?.nftMetadata)
        ? object.nftMetadata.map((e: any) => bytesFromBase64(e))
        : [],
    };
  },

  toJSON(message: MintAssetRequest): unknown {
    const obj: any = {};
    if (message.assetID !== "") {
      obj.assetID = message.assetID;
    }
    if (message.fromAddressId !== 0) {
      obj.fromAddressId = Math.round(message.fromAddressId);
    }
    if (message.toAddressId !== 0) {
      obj.toAddressId = Math.round(message.toAddressId);
    }
    if (message.toWhitelistedAddressId !== 0) {
      obj.toWhitelistedAddressId = Math.round(message.toWhitelistedAddressId);
    }
    if (message.amount !== "") {
      obj.amount = message.amount;
    }
    if (message.nftMetadata?.length) {
      obj.nftMetadata = message.nftMetadata.map((e) => base64FromBytes(e));
    }
    return obj;
  },

  create(base?: DeepPartial<MintAssetRequest>): MintAssetRequest {
    return MintAssetRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<MintAssetRequest>): MintAssetRequest {
    const message = createBaseMintAssetRequest();
    message.assetID = object.assetID ?? "";
    message.fromAddressId = object.fromAddressId ?? 0;
    message.toAddressId = object.toAddressId ?? 0;
    message.toWhitelistedAddressId = object.toWhitelistedAddressId ?? 0;
    message.amount = object.amount ?? "";
    message.nftMetadata = object.nftMetadata?.map((e) => e) || [];
    return message;
  },
};

function createBaseBurnAssetRequest(): BurnAssetRequest {
  return { assetID: "", fromAddressId: 0, burnAddressId: 0, burnWhitelistedAddressId: 0, amount: "", nftTokenIDs: [] };
}

export const BurnAssetRequest = {
  encode(message: BurnAssetRequest, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.assetID !== "") {
      writer.uint32(10).string(message.assetID);
    }
    if (message.fromAddressId !== 0) {
      writer.uint32(16).uint64(message.fromAddressId);
    }
    if (message.burnAddressId !== 0) {
      writer.uint32(24).uint64(message.burnAddressId);
    }
    if (message.burnWhitelistedAddressId !== 0) {
      writer.uint32(32).uint64(message.burnWhitelistedAddressId);
    }
    if (message.amount !== "") {
      writer.uint32(42).string(message.amount);
    }
    writer.uint32(50).fork();
    for (const v of message.nftTokenIDs) {
      writer.uint64(v);
    }
    writer.ldelim();
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): BurnAssetRequest {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseBurnAssetRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.assetID = reader.string();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.fromAddressId = longToNumber(reader.uint64() as Long);
          continue;
        case 3:
          if (tag !== 24) {
            break;
          }

          message.burnAddressId = longToNumber(reader.uint64() as Long);
          continue;
        case 4:
          if (tag !== 32) {
            break;
          }

          message.burnWhitelistedAddressId = longToNumber(reader.uint64() as Long);
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.amount = reader.string();
          continue;
        case 6:
          if (tag === 48) {
            message.nftTokenIDs.push(longToNumber(reader.uint64() as Long));

            continue;
          }

          if (tag === 50) {
            const end2 = reader.uint32() + reader.pos;
            while (reader.pos < end2) {
              message.nftTokenIDs.push(longToNumber(reader.uint64() as Long));
            }

            continue;
          }

          break;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): BurnAssetRequest {
    return {
      assetID: isSet(object.assetID) ? globalThis.String(object.assetID) : "",
      fromAddressId: isSet(object.fromAddressId) ? globalThis.Number(object.fromAddressId) : 0,
      burnAddressId: isSet(object.burnAddressId) ? globalThis.Number(object.burnAddressId) : 0,
      burnWhitelistedAddressId: isSet(object.burnWhitelistedAddressId)
        ? globalThis.Number(object.burnWhitelistedAddressId)
        : 0,
      amount: isSet(object.amount) ? globalThis.String(object.amount) : "",
      nftTokenIDs: globalThis.Array.isArray(object?.nftTokenIDs)
        ? object.nftTokenIDs.map((e: any) => globalThis.Number(e))
        : [],
    };
  },

  toJSON(message: BurnAssetRequest): unknown {
    const obj: any = {};
    if (message.assetID !== "") {
      obj.assetID = message.assetID;
    }
    if (message.fromAddressId !== 0) {
      obj.fromAddressId = Math.round(message.fromAddressId);
    }
    if (message.burnAddressId !== 0) {
      obj.burnAddressId = Math.round(message.burnAddressId);
    }
    if (message.burnWhitelistedAddressId !== 0) {
      obj.burnWhitelistedAddressId = Math.round(message.burnWhitelistedAddressId);
    }
    if (message.amount !== "") {
      obj.amount = message.amount;
    }
    if (message.nftTokenIDs?.length) {
      obj.nftTokenIDs = message.nftTokenIDs.map((e) => Math.round(e));
    }
    return obj;
  },

  create(base?: DeepPartial<BurnAssetRequest>): BurnAssetRequest {
    return BurnAssetRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<BurnAssetRequest>): BurnAssetRequest {
    const message = createBaseBurnAssetRequest();
    message.assetID = object.assetID ?? "";
    message.fromAddressId = object.fromAddressId ?? 0;
    message.burnAddressId = object.burnAddressId ?? 0;
    message.burnWhitelistedAddressId = object.burnWhitelistedAddressId ?? 0;
    message.amount = object.amount ?? "";
    message.nftTokenIDs = object.nftTokenIDs?.map((e) => e) || [];
    return message;
  },
};

function createBasePauseAssetRequest(): PauseAssetRequest {
  return { assetID: "", fromAddressId: 0 };
}

export const PauseAssetRequest = {
  encode(message: PauseAssetRequest, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.assetID !== "") {
      writer.uint32(10).string(message.assetID);
    }
    if (message.fromAddressId !== 0) {
      writer.uint32(16).uint64(message.fromAddressId);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): PauseAssetRequest {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBasePauseAssetRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.assetID = reader.string();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.fromAddressId = longToNumber(reader.uint64() as Long);
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): PauseAssetRequest {
    return {
      assetID: isSet(object.assetID) ? globalThis.String(object.assetID) : "",
      fromAddressId: isSet(object.fromAddressId) ? globalThis.Number(object.fromAddressId) : 0,
    };
  },

  toJSON(message: PauseAssetRequest): unknown {
    const obj: any = {};
    if (message.assetID !== "") {
      obj.assetID = message.assetID;
    }
    if (message.fromAddressId !== 0) {
      obj.fromAddressId = Math.round(message.fromAddressId);
    }
    return obj;
  },

  create(base?: DeepPartial<PauseAssetRequest>): PauseAssetRequest {
    return PauseAssetRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<PauseAssetRequest>): PauseAssetRequest {
    const message = createBasePauseAssetRequest();
    message.assetID = object.assetID ?? "";
    message.fromAddressId = object.fromAddressId ?? 0;
    return message;
  },
};

function createBaseUnpauseAssetRequest(): UnpauseAssetRequest {
  return { assetID: "", fromAddressId: 0 };
}

export const UnpauseAssetRequest = {
  encode(message: UnpauseAssetRequest, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.assetID !== "") {
      writer.uint32(10).string(message.assetID);
    }
    if (message.fromAddressId !== 0) {
      writer.uint32(16).uint64(message.fromAddressId);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): UnpauseAssetRequest {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseUnpauseAssetRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.assetID = reader.string();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.fromAddressId = longToNumber(reader.uint64() as Long);
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): UnpauseAssetRequest {
    return {
      assetID: isSet(object.assetID) ? globalThis.String(object.assetID) : "",
      fromAddressId: isSet(object.fromAddressId) ? globalThis.Number(object.fromAddressId) : 0,
    };
  },

  toJSON(message: UnpauseAssetRequest): unknown {
    const obj: any = {};
    if (message.assetID !== "") {
      obj.assetID = message.assetID;
    }
    if (message.fromAddressId !== 0) {
      obj.fromAddressId = Math.round(message.fromAddressId);
    }
    return obj;
  },

  create(base?: DeepPartial<UnpauseAssetRequest>): UnpauseAssetRequest {
    return UnpauseAssetRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<UnpauseAssetRequest>): UnpauseAssetRequest {
    const message = createBaseUnpauseAssetRequest();
    message.assetID = object.assetID ?? "";
    message.fromAddressId = object.fromAddressId ?? 0;
    return message;
  },
};

function createBasePauseAssetAccountRequest(): PauseAssetAccountRequest {
  return { assetID: "", fromAddressId: 0, targetAddressId: 0, targetWhitelistedAddressId: 0 };
}

export const PauseAssetAccountRequest = {
  encode(message: PauseAssetAccountRequest, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.assetID !== "") {
      writer.uint32(10).string(message.assetID);
    }
    if (message.fromAddressId !== 0) {
      writer.uint32(16).uint64(message.fromAddressId);
    }
    if (message.targetAddressId !== 0) {
      writer.uint32(24).uint64(message.targetAddressId);
    }
    if (message.targetWhitelistedAddressId !== 0) {
      writer.uint32(32).uint64(message.targetWhitelistedAddressId);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): PauseAssetAccountRequest {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBasePauseAssetAccountRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.assetID = reader.string();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.fromAddressId = longToNumber(reader.uint64() as Long);
          continue;
        case 3:
          if (tag !== 24) {
            break;
          }

          message.targetAddressId = longToNumber(reader.uint64() as Long);
          continue;
        case 4:
          if (tag !== 32) {
            break;
          }

          message.targetWhitelistedAddressId = longToNumber(reader.uint64() as Long);
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): PauseAssetAccountRequest {
    return {
      assetID: isSet(object.assetID) ? globalThis.String(object.assetID) : "",
      fromAddressId: isSet(object.fromAddressId) ? globalThis.Number(object.fromAddressId) : 0,
      targetAddressId: isSet(object.targetAddressId) ? globalThis.Number(object.targetAddressId) : 0,
      targetWhitelistedAddressId: isSet(object.targetWhitelistedAddressId)
        ? globalThis.Number(object.targetWhitelistedAddressId)
        : 0,
    };
  },

  toJSON(message: PauseAssetAccountRequest): unknown {
    const obj: any = {};
    if (message.assetID !== "") {
      obj.assetID = message.assetID;
    }
    if (message.fromAddressId !== 0) {
      obj.fromAddressId = Math.round(message.fromAddressId);
    }
    if (message.targetAddressId !== 0) {
      obj.targetAddressId = Math.round(message.targetAddressId);
    }
    if (message.targetWhitelistedAddressId !== 0) {
      obj.targetWhitelistedAddressId = Math.round(message.targetWhitelistedAddressId);
    }
    return obj;
  },

  create(base?: DeepPartial<PauseAssetAccountRequest>): PauseAssetAccountRequest {
    return PauseAssetAccountRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<PauseAssetAccountRequest>): PauseAssetAccountRequest {
    const message = createBasePauseAssetAccountRequest();
    message.assetID = object.assetID ?? "";
    message.fromAddressId = object.fromAddressId ?? 0;
    message.targetAddressId = object.targetAddressId ?? 0;
    message.targetWhitelistedAddressId = object.targetWhitelistedAddressId ?? 0;
    return message;
  },
};

function createBaseUnpauseAssetAccountRequest(): UnpauseAssetAccountRequest {
  return { assetID: "", fromAddressId: 0, targetAddressId: 0, targetWhitelistedAddressId: 0 };
}

export const UnpauseAssetAccountRequest = {
  encode(message: UnpauseAssetAccountRequest, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.assetID !== "") {
      writer.uint32(10).string(message.assetID);
    }
    if (message.fromAddressId !== 0) {
      writer.uint32(16).uint64(message.fromAddressId);
    }
    if (message.targetAddressId !== 0) {
      writer.uint32(24).uint64(message.targetAddressId);
    }
    if (message.targetWhitelistedAddressId !== 0) {
      writer.uint32(32).uint64(message.targetWhitelistedAddressId);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): UnpauseAssetAccountRequest {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseUnpauseAssetAccountRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.assetID = reader.string();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.fromAddressId = longToNumber(reader.uint64() as Long);
          continue;
        case 3:
          if (tag !== 24) {
            break;
          }

          message.targetAddressId = longToNumber(reader.uint64() as Long);
          continue;
        case 4:
          if (tag !== 32) {
            break;
          }

          message.targetWhitelistedAddressId = longToNumber(reader.uint64() as Long);
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): UnpauseAssetAccountRequest {
    return {
      assetID: isSet(object.assetID) ? globalThis.String(object.assetID) : "",
      fromAddressId: isSet(object.fromAddressId) ? globalThis.Number(object.fromAddressId) : 0,
      targetAddressId: isSet(object.targetAddressId) ? globalThis.Number(object.targetAddressId) : 0,
      targetWhitelistedAddressId: isSet(object.targetWhitelistedAddressId)
        ? globalThis.Number(object.targetWhitelistedAddressId)
        : 0,
    };
  },

  toJSON(message: UnpauseAssetAccountRequest): unknown {
    const obj: any = {};
    if (message.assetID !== "") {
      obj.assetID = message.assetID;
    }
    if (message.fromAddressId !== 0) {
      obj.fromAddressId = Math.round(message.fromAddressId);
    }
    if (message.targetAddressId !== 0) {
      obj.targetAddressId = Math.round(message.targetAddressId);
    }
    if (message.targetWhitelistedAddressId !== 0) {
      obj.targetWhitelistedAddressId = Math.round(message.targetWhitelistedAddressId);
    }
    return obj;
  },

  create(base?: DeepPartial<UnpauseAssetAccountRequest>): UnpauseAssetAccountRequest {
    return UnpauseAssetAccountRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<UnpauseAssetAccountRequest>): UnpauseAssetAccountRequest {
    const message = createBaseUnpauseAssetAccountRequest();
    message.assetID = object.assetID ?? "";
    message.fromAddressId = object.fromAddressId ?? 0;
    message.targetAddressId = object.targetAddressId ?? 0;
    message.targetWhitelistedAddressId = object.targetWhitelistedAddressId ?? 0;
    return message;
  },
};

function createBaseApproveAssetAddressKYCRequest(): ApproveAssetAddressKYCRequest {
  return { assetID: "", fromAddressId: 0, targetAddressId: 0, targetWhitelistedAddressId: 0 };
}

export const ApproveAssetAddressKYCRequest = {
  encode(message: ApproveAssetAddressKYCRequest, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.assetID !== "") {
      writer.uint32(10).string(message.assetID);
    }
    if (message.fromAddressId !== 0) {
      writer.uint32(16).uint64(message.fromAddressId);
    }
    if (message.targetAddressId !== 0) {
      writer.uint32(24).uint64(message.targetAddressId);
    }
    if (message.targetWhitelistedAddressId !== 0) {
      writer.uint32(32).uint64(message.targetWhitelistedAddressId);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): ApproveAssetAddressKYCRequest {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseApproveAssetAddressKYCRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.assetID = reader.string();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.fromAddressId = longToNumber(reader.uint64() as Long);
          continue;
        case 3:
          if (tag !== 24) {
            break;
          }

          message.targetAddressId = longToNumber(reader.uint64() as Long);
          continue;
        case 4:
          if (tag !== 32) {
            break;
          }

          message.targetWhitelistedAddressId = longToNumber(reader.uint64() as Long);
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ApproveAssetAddressKYCRequest {
    return {
      assetID: isSet(object.assetID) ? globalThis.String(object.assetID) : "",
      fromAddressId: isSet(object.fromAddressId) ? globalThis.Number(object.fromAddressId) : 0,
      targetAddressId: isSet(object.targetAddressId) ? globalThis.Number(object.targetAddressId) : 0,
      targetWhitelistedAddressId: isSet(object.targetWhitelistedAddressId)
        ? globalThis.Number(object.targetWhitelistedAddressId)
        : 0,
    };
  },

  toJSON(message: ApproveAssetAddressKYCRequest): unknown {
    const obj: any = {};
    if (message.assetID !== "") {
      obj.assetID = message.assetID;
    }
    if (message.fromAddressId !== 0) {
      obj.fromAddressId = Math.round(message.fromAddressId);
    }
    if (message.targetAddressId !== 0) {
      obj.targetAddressId = Math.round(message.targetAddressId);
    }
    if (message.targetWhitelistedAddressId !== 0) {
      obj.targetWhitelistedAddressId = Math.round(message.targetWhitelistedAddressId);
    }
    return obj;
  },

  create(base?: DeepPartial<ApproveAssetAddressKYCRequest>): ApproveAssetAddressKYCRequest {
    return ApproveAssetAddressKYCRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ApproveAssetAddressKYCRequest>): ApproveAssetAddressKYCRequest {
    const message = createBaseApproveAssetAddressKYCRequest();
    message.assetID = object.assetID ?? "";
    message.fromAddressId = object.fromAddressId ?? 0;
    message.targetAddressId = object.targetAddressId ?? 0;
    message.targetWhitelistedAddressId = object.targetWhitelistedAddressId ?? 0;
    return message;
  },
};

function createBaseRevokeAssetAddressKYCRequest(): RevokeAssetAddressKYCRequest {
  return { assetID: "", fromAddressId: 0, targetAddressId: 0, targetWhitelistedAddressId: 0 };
}

export const RevokeAssetAddressKYCRequest = {
  encode(message: RevokeAssetAddressKYCRequest, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.assetID !== "") {
      writer.uint32(10).string(message.assetID);
    }
    if (message.fromAddressId !== 0) {
      writer.uint32(16).uint64(message.fromAddressId);
    }
    if (message.targetAddressId !== 0) {
      writer.uint32(24).uint64(message.targetAddressId);
    }
    if (message.targetWhitelistedAddressId !== 0) {
      writer.uint32(32).uint64(message.targetWhitelistedAddressId);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): RevokeAssetAddressKYCRequest {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseRevokeAssetAddressKYCRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.assetID = reader.string();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.fromAddressId = longToNumber(reader.uint64() as Long);
          continue;
        case 3:
          if (tag !== 24) {
            break;
          }

          message.targetAddressId = longToNumber(reader.uint64() as Long);
          continue;
        case 4:
          if (tag !== 32) {
            break;
          }

          message.targetWhitelistedAddressId = longToNumber(reader.uint64() as Long);
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): RevokeAssetAddressKYCRequest {
    return {
      assetID: isSet(object.assetID) ? globalThis.String(object.assetID) : "",
      fromAddressId: isSet(object.fromAddressId) ? globalThis.Number(object.fromAddressId) : 0,
      targetAddressId: isSet(object.targetAddressId) ? globalThis.Number(object.targetAddressId) : 0,
      targetWhitelistedAddressId: isSet(object.targetWhitelistedAddressId)
        ? globalThis.Number(object.targetWhitelistedAddressId)
        : 0,
    };
  },

  toJSON(message: RevokeAssetAddressKYCRequest): unknown {
    const obj: any = {};
    if (message.assetID !== "") {
      obj.assetID = message.assetID;
    }
    if (message.fromAddressId !== 0) {
      obj.fromAddressId = Math.round(message.fromAddressId);
    }
    if (message.targetAddressId !== 0) {
      obj.targetAddressId = Math.round(message.targetAddressId);
    }
    if (message.targetWhitelistedAddressId !== 0) {
      obj.targetWhitelistedAddressId = Math.round(message.targetWhitelistedAddressId);
    }
    return obj;
  },

  create(base?: DeepPartial<RevokeAssetAddressKYCRequest>): RevokeAssetAddressKYCRequest {
    return RevokeAssetAddressKYCRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<RevokeAssetAddressKYCRequest>): RevokeAssetAddressKYCRequest {
    const message = createBaseRevokeAssetAddressKYCRequest();
    message.assetID = object.assetID ?? "";
    message.fromAddressId = object.fromAddressId ?? 0;
    message.targetAddressId = object.targetAddressId ?? 0;
    message.targetWhitelistedAddressId = object.targetWhitelistedAddressId ?? 0;
    return message;
  },
};

function createBaseAssociateAddressWithAssetRequest(): AssociateAddressWithAssetRequest {
  return { assetID: "", fromAddressId: 0 };
}

export const AssociateAddressWithAssetRequest = {
  encode(message: AssociateAddressWithAssetRequest, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.assetID !== "") {
      writer.uint32(10).string(message.assetID);
    }
    if (message.fromAddressId !== 0) {
      writer.uint32(16).uint64(message.fromAddressId);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): AssociateAddressWithAssetRequest {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseAssociateAddressWithAssetRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.assetID = reader.string();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.fromAddressId = longToNumber(reader.uint64() as Long);
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): AssociateAddressWithAssetRequest {
    return {
      assetID: isSet(object.assetID) ? globalThis.String(object.assetID) : "",
      fromAddressId: isSet(object.fromAddressId) ? globalThis.Number(object.fromAddressId) : 0,
    };
  },

  toJSON(message: AssociateAddressWithAssetRequest): unknown {
    const obj: any = {};
    if (message.assetID !== "") {
      obj.assetID = message.assetID;
    }
    if (message.fromAddressId !== 0) {
      obj.fromAddressId = Math.round(message.fromAddressId);
    }
    return obj;
  },

  create(base?: DeepPartial<AssociateAddressWithAssetRequest>): AssociateAddressWithAssetRequest {
    return AssociateAddressWithAssetRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<AssociateAddressWithAssetRequest>): AssociateAddressWithAssetRequest {
    const message = createBaseAssociateAddressWithAssetRequest();
    message.assetID = object.assetID ?? "";
    message.fromAddressId = object.fromAddressId ?? 0;
    return message;
  },
};

function createBaseDissociateAddressFromAssetRequest(): DissociateAddressFromAssetRequest {
  return { assetID: "", fromAddressId: 0 };
}

export const DissociateAddressFromAssetRequest = {
  encode(message: DissociateAddressFromAssetRequest, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.assetID !== "") {
      writer.uint32(10).string(message.assetID);
    }
    if (message.fromAddressId !== 0) {
      writer.uint32(16).uint64(message.fromAddressId);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): DissociateAddressFromAssetRequest {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseDissociateAddressFromAssetRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.assetID = reader.string();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.fromAddressId = longToNumber(reader.uint64() as Long);
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): DissociateAddressFromAssetRequest {
    return {
      assetID: isSet(object.assetID) ? globalThis.String(object.assetID) : "",
      fromAddressId: isSet(object.fromAddressId) ? globalThis.Number(object.fromAddressId) : 0,
    };
  },

  toJSON(message: DissociateAddressFromAssetRequest): unknown {
    const obj: any = {};
    if (message.assetID !== "") {
      obj.assetID = message.assetID;
    }
    if (message.fromAddressId !== 0) {
      obj.fromAddressId = Math.round(message.fromAddressId);
    }
    return obj;
  },

  create(base?: DeepPartial<DissociateAddressFromAssetRequest>): DissociateAddressFromAssetRequest {
    return DissociateAddressFromAssetRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<DissociateAddressFromAssetRequest>): DissociateAddressFromAssetRequest {
    const message = createBaseDissociateAddressFromAssetRequest();
    message.assetID = object.assetID ?? "";
    message.fromAddressId = object.fromAddressId ?? 0;
    return message;
  },
};

function createBaseGetAssetsRequest(): GetAssetsRequest {
  return {
    cursor: undefined,
    blockchain: "",
    network: "",
    symbol: undefined,
    contractAddress: undefined,
    label: undefined,
    currencyName: undefined,
  };
}

export const GetAssetsRequest = {
  encode(message: GetAssetsRequest, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.cursor !== undefined) {
      RequestCursor.encode(message.cursor, writer.uint32(10).fork()).ldelim();
    }
    if (message.blockchain !== "") {
      writer.uint32(18).string(message.blockchain);
    }
    if (message.network !== "") {
      writer.uint32(26).string(message.network);
    }
    if (message.symbol !== undefined) {
      writer.uint32(34).string(message.symbol);
    }
    if (message.contractAddress !== undefined) {
      writer.uint32(42).string(message.contractAddress);
    }
    if (message.label !== undefined) {
      writer.uint32(50).string(message.label);
    }
    if (message.currencyName !== undefined) {
      writer.uint32(58).string(message.currencyName);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): GetAssetsRequest {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetAssetsRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.cursor = RequestCursor.decode(reader, reader.uint32());
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.blockchain = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.network = reader.string();
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.symbol = reader.string();
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.contractAddress = reader.string();
          continue;
        case 6:
          if (tag !== 50) {
            break;
          }

          message.label = reader.string();
          continue;
        case 7:
          if (tag !== 58) {
            break;
          }

          message.currencyName = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetAssetsRequest {
    return {
      cursor: isSet(object.cursor) ? RequestCursor.fromJSON(object.cursor) : undefined,
      blockchain: isSet(object.blockchain) ? globalThis.String(object.blockchain) : "",
      network: isSet(object.network) ? globalThis.String(object.network) : "",
      symbol: isSet(object.symbol) ? globalThis.String(object.symbol) : undefined,
      contractAddress: isSet(object.contractAddress) ? globalThis.String(object.contractAddress) : undefined,
      label: isSet(object.label) ? globalThis.String(object.label) : undefined,
      currencyName: isSet(object.currencyName) ? globalThis.String(object.currencyName) : undefined,
    };
  },

  toJSON(message: GetAssetsRequest): unknown {
    const obj: any = {};
    if (message.cursor !== undefined) {
      obj.cursor = RequestCursor.toJSON(message.cursor);
    }
    if (message.blockchain !== "") {
      obj.blockchain = message.blockchain;
    }
    if (message.network !== "") {
      obj.network = message.network;
    }
    if (message.symbol !== undefined) {
      obj.symbol = message.symbol;
    }
    if (message.contractAddress !== undefined) {
      obj.contractAddress = message.contractAddress;
    }
    if (message.label !== undefined) {
      obj.label = message.label;
    }
    if (message.currencyName !== undefined) {
      obj.currencyName = message.currencyName;
    }
    return obj;
  },

  create(base?: DeepPartial<GetAssetsRequest>): GetAssetsRequest {
    return GetAssetsRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<GetAssetsRequest>): GetAssetsRequest {
    const message = createBaseGetAssetsRequest();
    message.cursor = (object.cursor !== undefined && object.cursor !== null)
      ? RequestCursor.fromPartial(object.cursor)
      : undefined;
    message.blockchain = object.blockchain ?? "";
    message.network = object.network ?? "";
    message.symbol = object.symbol ?? undefined;
    message.contractAddress = object.contractAddress ?? undefined;
    message.label = object.label ?? undefined;
    message.currencyName = object.currencyName ?? undefined;
    return message;
  },
};

function createBaseGetAssetRequest(): GetAssetRequest {
  return { id: "" };
}

export const GetAssetRequest = {
  encode(message: GetAssetRequest, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.id !== "") {
      writer.uint32(10).string(message.id);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): GetAssetRequest {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetAssetRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.id = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetAssetRequest {
    return { id: isSet(object.id) ? globalThis.String(object.id) : "" };
  },

  toJSON(message: GetAssetRequest): unknown {
    const obj: any = {};
    if (message.id !== "") {
      obj.id = message.id;
    }
    return obj;
  },

  create(base?: DeepPartial<GetAssetRequest>): GetAssetRequest {
    return GetAssetRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<GetAssetRequest>): GetAssetRequest {
    const message = createBaseGetAssetRequest();
    message.id = object.id ?? "";
    return message;
  },
};

function createBaseGetAssetReply(): GetAssetReply {
  return { result: undefined };
}

export const GetAssetReply = {
  encode(message: GetAssetReply, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.result !== undefined) {
      AssetResource.encode(message.result, writer.uint32(10).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): GetAssetReply {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetAssetReply();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.result = AssetResource.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetAssetReply {
    return { result: isSet(object.result) ? AssetResource.fromJSON(object.result) : undefined };
  },

  toJSON(message: GetAssetReply): unknown {
    const obj: any = {};
    if (message.result !== undefined) {
      obj.result = AssetResource.toJSON(message.result);
    }
    return obj;
  },

  create(base?: DeepPartial<GetAssetReply>): GetAssetReply {
    return GetAssetReply.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<GetAssetReply>): GetAssetReply {
    const message = createBaseGetAssetReply();
    message.result = (object.result !== undefined && object.result !== null)
      ? AssetResource.fromPartial(object.result)
      : undefined;
    return message;
  },
};

function createBaseGetAssetsReply(): GetAssetsReply {
  return { result: [], cursor: undefined };
}

export const GetAssetsReply = {
  encode(message: GetAssetsReply, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    for (const v of message.result) {
      AssetResource.encode(v!, writer.uint32(10).fork()).ldelim();
    }
    if (message.cursor !== undefined) {
      ResponseCursor.encode(message.cursor, writer.uint32(18).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): GetAssetsReply {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetAssetsReply();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.result.push(AssetResource.decode(reader, reader.uint32()));
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.cursor = ResponseCursor.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetAssetsReply {
    return {
      result: globalThis.Array.isArray(object?.result) ? object.result.map((e: any) => AssetResource.fromJSON(e)) : [],
      cursor: isSet(object.cursor) ? ResponseCursor.fromJSON(object.cursor) : undefined,
    };
  },

  toJSON(message: GetAssetsReply): unknown {
    const obj: any = {};
    if (message.result?.length) {
      obj.result = message.result.map((e) => AssetResource.toJSON(e));
    }
    if (message.cursor !== undefined) {
      obj.cursor = ResponseCursor.toJSON(message.cursor);
    }
    return obj;
  },

  create(base?: DeepPartial<GetAssetsReply>): GetAssetsReply {
    return GetAssetsReply.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<GetAssetsReply>): GetAssetsReply {
    const message = createBaseGetAssetsReply();
    message.result = object.result?.map((e) => AssetResource.fromPartial(e)) || [];
    message.cursor = (object.cursor !== undefined && object.cursor !== null)
      ? ResponseCursor.fromPartial(object.cursor)
      : undefined;
    return message;
  },
};

function createBaseGetAssetEventsByCurrencyRequest(): GetAssetEventsByCurrencyRequest {
  return { cursor: undefined, currencyID: "" };
}

export const GetAssetEventsByCurrencyRequest = {
  encode(message: GetAssetEventsByCurrencyRequest, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.cursor !== undefined) {
      RequestCursor.encode(message.cursor, writer.uint32(10).fork()).ldelim();
    }
    if (message.currencyID !== "") {
      writer.uint32(18).string(message.currencyID);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): GetAssetEventsByCurrencyRequest {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetAssetEventsByCurrencyRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.cursor = RequestCursor.decode(reader, reader.uint32());
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.currencyID = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetAssetEventsByCurrencyRequest {
    return {
      cursor: isSet(object.cursor) ? RequestCursor.fromJSON(object.cursor) : undefined,
      currencyID: isSet(object.currencyID) ? globalThis.String(object.currencyID) : "",
    };
  },

  toJSON(message: GetAssetEventsByCurrencyRequest): unknown {
    const obj: any = {};
    if (message.cursor !== undefined) {
      obj.cursor = RequestCursor.toJSON(message.cursor);
    }
    if (message.currencyID !== "") {
      obj.currencyID = message.currencyID;
    }
    return obj;
  },

  create(base?: DeepPartial<GetAssetEventsByCurrencyRequest>): GetAssetEventsByCurrencyRequest {
    return GetAssetEventsByCurrencyRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<GetAssetEventsByCurrencyRequest>): GetAssetEventsByCurrencyRequest {
    const message = createBaseGetAssetEventsByCurrencyRequest();
    message.cursor = (object.cursor !== undefined && object.cursor !== null)
      ? RequestCursor.fromPartial(object.cursor)
      : undefined;
    message.currencyID = object.currencyID ?? "";
    return message;
  },
};

function createBaseGetAssetEventsReply(): GetAssetEventsReply {
  return { result: [], cursor: undefined };
}

export const GetAssetEventsReply = {
  encode(message: GetAssetEventsReply, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    for (const v of message.result) {
      AssetEvent.encode(v!, writer.uint32(10).fork()).ldelim();
    }
    if (message.cursor !== undefined) {
      ResponseCursor.encode(message.cursor, writer.uint32(18).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): GetAssetEventsReply {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetAssetEventsReply();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.result.push(AssetEvent.decode(reader, reader.uint32()));
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.cursor = ResponseCursor.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetAssetEventsReply {
    return {
      result: globalThis.Array.isArray(object?.result) ? object.result.map((e: any) => AssetEvent.fromJSON(e)) : [],
      cursor: isSet(object.cursor) ? ResponseCursor.fromJSON(object.cursor) : undefined,
    };
  },

  toJSON(message: GetAssetEventsReply): unknown {
    const obj: any = {};
    if (message.result?.length) {
      obj.result = message.result.map((e) => AssetEvent.toJSON(e));
    }
    if (message.cursor !== undefined) {
      obj.cursor = ResponseCursor.toJSON(message.cursor);
    }
    return obj;
  },

  create(base?: DeepPartial<GetAssetEventsReply>): GetAssetEventsReply {
    return GetAssetEventsReply.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<GetAssetEventsReply>): GetAssetEventsReply {
    const message = createBaseGetAssetEventsReply();
    message.result = object.result?.map((e) => AssetEvent.fromPartial(e)) || [];
    message.cursor = (object.cursor !== undefined && object.cursor !== null)
      ? ResponseCursor.fromPartial(object.cursor)
      : undefined;
    return message;
  },
};

function createBaseGetAssetHoldersByCurrencyRequest(): GetAssetHoldersByCurrencyRequest {
  return { cursor: undefined, currencyID: "", holderType: 0 };
}

export const GetAssetHoldersByCurrencyRequest = {
  encode(message: GetAssetHoldersByCurrencyRequest, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.cursor !== undefined) {
      RequestCursor.encode(message.cursor, writer.uint32(10).fork()).ldelim();
    }
    if (message.currencyID !== "") {
      writer.uint32(18).string(message.currencyID);
    }
    if (message.holderType !== 0) {
      writer.uint32(24).int32(message.holderType);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): GetAssetHoldersByCurrencyRequest {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetAssetHoldersByCurrencyRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.cursor = RequestCursor.decode(reader, reader.uint32());
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.currencyID = reader.string();
          continue;
        case 3:
          if (tag !== 24) {
            break;
          }

          message.holderType = reader.int32() as any;
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetAssetHoldersByCurrencyRequest {
    return {
      cursor: isSet(object.cursor) ? RequestCursor.fromJSON(object.cursor) : undefined,
      currencyID: isSet(object.currencyID) ? globalThis.String(object.currencyID) : "",
      holderType: isSet(object.holderType) ? assetHolderTypeFromJSON(object.holderType) : 0,
    };
  },

  toJSON(message: GetAssetHoldersByCurrencyRequest): unknown {
    const obj: any = {};
    if (message.cursor !== undefined) {
      obj.cursor = RequestCursor.toJSON(message.cursor);
    }
    if (message.currencyID !== "") {
      obj.currencyID = message.currencyID;
    }
    if (message.holderType !== 0) {
      obj.holderType = assetHolderTypeToJSON(message.holderType);
    }
    return obj;
  },

  create(base?: DeepPartial<GetAssetHoldersByCurrencyRequest>): GetAssetHoldersByCurrencyRequest {
    return GetAssetHoldersByCurrencyRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<GetAssetHoldersByCurrencyRequest>): GetAssetHoldersByCurrencyRequest {
    const message = createBaseGetAssetHoldersByCurrencyRequest();
    message.cursor = (object.cursor !== undefined && object.cursor !== null)
      ? RequestCursor.fromPartial(object.cursor)
      : undefined;
    message.currencyID = object.currencyID ?? "";
    message.holderType = object.holderType ?? 0;
    return message;
  },
};

function createBaseGetAssetHoldersReply(): GetAssetHoldersReply {
  return { result: [], cursor: undefined };
}

export const GetAssetHoldersReply = {
  encode(message: GetAssetHoldersReply, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    for (const v of message.result) {
      AssetHolder.encode(v!, writer.uint32(10).fork()).ldelim();
    }
    if (message.cursor !== undefined) {
      ResponseCursor.encode(message.cursor, writer.uint32(18).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): GetAssetHoldersReply {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetAssetHoldersReply();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.result.push(AssetHolder.decode(reader, reader.uint32()));
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.cursor = ResponseCursor.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetAssetHoldersReply {
    return {
      result: globalThis.Array.isArray(object?.result) ? object.result.map((e: any) => AssetHolder.fromJSON(e)) : [],
      cursor: isSet(object.cursor) ? ResponseCursor.fromJSON(object.cursor) : undefined,
    };
  },

  toJSON(message: GetAssetHoldersReply): unknown {
    const obj: any = {};
    if (message.result?.length) {
      obj.result = message.result.map((e) => AssetHolder.toJSON(e));
    }
    if (message.cursor !== undefined) {
      obj.cursor = ResponseCursor.toJSON(message.cursor);
    }
    return obj;
  },

  create(base?: DeepPartial<GetAssetHoldersReply>): GetAssetHoldersReply {
    return GetAssetHoldersReply.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<GetAssetHoldersReply>): GetAssetHoldersReply {
    const message = createBaseGetAssetHoldersReply();
    message.result = object.result?.map((e) => AssetHolder.fromPartial(e)) || [];
    message.cursor = (object.cursor !== undefined && object.cursor !== null)
      ? ResponseCursor.fromPartial(object.cursor)
      : undefined;
    return message;
  },
};

export interface AssetService {
  CreateAsset(request: CreateAssetRequest): Promise<Workflow>;
  ImportAsset(request: ImportAssetRequest): Promise<Workflow>;
  MintAsset(request: MintAssetRequest): Promise<Workflow>;
  BurnAsset(request: BurnAssetRequest): Promise<Workflow>;
  PauseAsset(request: PauseAssetRequest): Promise<Workflow>;
  UnpauseAsset(request: UnpauseAssetRequest): Promise<Workflow>;
  PauseAssetAccount(request: PauseAssetAccountRequest): Promise<Workflow>;
  UnpauseAssetAccount(request: UnpauseAssetAccountRequest): Promise<Workflow>;
  ApproveAddressKYC(request: ApproveAssetAddressKYCRequest): Promise<Workflow>;
  RevokeAddressKYC(request: RevokeAssetAddressKYCRequest): Promise<Workflow>;
  AssociateAddressWithAsset(request: AssociateAddressWithAssetRequest): Promise<Workflow>;
  DissociateAddressFromAsset(request: DissociateAddressFromAssetRequest): Promise<Workflow>;
  GetAsset(request: GetAssetRequest): Promise<GetAssetReply>;
  GetAssets(request: GetAssetsRequest): Promise<GetAssetsReply>;
  GetAssetEventsByCurrency(request: GetAssetEventsByCurrencyRequest): Promise<GetAssetEventsReply>;
  GetAssetHoldersByCurrency(request: GetAssetHoldersByCurrencyRequest): Promise<GetAssetHoldersReply>;
}

export const AssetServiceServiceName = "tgvalidatord.AssetService";
export class AssetServiceClientImpl implements AssetService {
  private readonly rpc: Rpc;
  private readonly service: string;
  constructor(rpc: Rpc, opts?: { service?: string }) {
    this.service = opts?.service || AssetServiceServiceName;
    this.rpc = rpc;
    this.CreateAsset = this.CreateAsset.bind(this);
    this.ImportAsset = this.ImportAsset.bind(this);
    this.MintAsset = this.MintAsset.bind(this);
    this.BurnAsset = this.BurnAsset.bind(this);
    this.PauseAsset = this.PauseAsset.bind(this);
    this.UnpauseAsset = this.UnpauseAsset.bind(this);
    this.PauseAssetAccount = this.PauseAssetAccount.bind(this);
    this.UnpauseAssetAccount = this.UnpauseAssetAccount.bind(this);
    this.ApproveAddressKYC = this.ApproveAddressKYC.bind(this);
    this.RevokeAddressKYC = this.RevokeAddressKYC.bind(this);
    this.AssociateAddressWithAsset = this.AssociateAddressWithAsset.bind(this);
    this.DissociateAddressFromAsset = this.DissociateAddressFromAsset.bind(this);
    this.GetAsset = this.GetAsset.bind(this);
    this.GetAssets = this.GetAssets.bind(this);
    this.GetAssetEventsByCurrency = this.GetAssetEventsByCurrency.bind(this);
    this.GetAssetHoldersByCurrency = this.GetAssetHoldersByCurrency.bind(this);
  }
  CreateAsset(request: CreateAssetRequest): Promise<Workflow> {
    const data = CreateAssetRequest.encode(request).finish();
    const promise = this.rpc.request(this.service, "CreateAsset", data);
    return promise.then((data) => Workflow.decode(_m0.Reader.create(data)));
  }

  ImportAsset(request: ImportAssetRequest): Promise<Workflow> {
    const data = ImportAssetRequest.encode(request).finish();
    const promise = this.rpc.request(this.service, "ImportAsset", data);
    return promise.then((data) => Workflow.decode(_m0.Reader.create(data)));
  }

  MintAsset(request: MintAssetRequest): Promise<Workflow> {
    const data = MintAssetRequest.encode(request).finish();
    const promise = this.rpc.request(this.service, "MintAsset", data);
    return promise.then((data) => Workflow.decode(_m0.Reader.create(data)));
  }

  BurnAsset(request: BurnAssetRequest): Promise<Workflow> {
    const data = BurnAssetRequest.encode(request).finish();
    const promise = this.rpc.request(this.service, "BurnAsset", data);
    return promise.then((data) => Workflow.decode(_m0.Reader.create(data)));
  }

  PauseAsset(request: PauseAssetRequest): Promise<Workflow> {
    const data = PauseAssetRequest.encode(request).finish();
    const promise = this.rpc.request(this.service, "PauseAsset", data);
    return promise.then((data) => Workflow.decode(_m0.Reader.create(data)));
  }

  UnpauseAsset(request: UnpauseAssetRequest): Promise<Workflow> {
    const data = UnpauseAssetRequest.encode(request).finish();
    const promise = this.rpc.request(this.service, "UnpauseAsset", data);
    return promise.then((data) => Workflow.decode(_m0.Reader.create(data)));
  }

  PauseAssetAccount(request: PauseAssetAccountRequest): Promise<Workflow> {
    const data = PauseAssetAccountRequest.encode(request).finish();
    const promise = this.rpc.request(this.service, "PauseAssetAccount", data);
    return promise.then((data) => Workflow.decode(_m0.Reader.create(data)));
  }

  UnpauseAssetAccount(request: UnpauseAssetAccountRequest): Promise<Workflow> {
    const data = UnpauseAssetAccountRequest.encode(request).finish();
    const promise = this.rpc.request(this.service, "UnpauseAssetAccount", data);
    return promise.then((data) => Workflow.decode(_m0.Reader.create(data)));
  }

  ApproveAddressKYC(request: ApproveAssetAddressKYCRequest): Promise<Workflow> {
    const data = ApproveAssetAddressKYCRequest.encode(request).finish();
    const promise = this.rpc.request(this.service, "ApproveAddressKYC", data);
    return promise.then((data) => Workflow.decode(_m0.Reader.create(data)));
  }

  RevokeAddressKYC(request: RevokeAssetAddressKYCRequest): Promise<Workflow> {
    const data = RevokeAssetAddressKYCRequest.encode(request).finish();
    const promise = this.rpc.request(this.service, "RevokeAddressKYC", data);
    return promise.then((data) => Workflow.decode(_m0.Reader.create(data)));
  }

  AssociateAddressWithAsset(request: AssociateAddressWithAssetRequest): Promise<Workflow> {
    const data = AssociateAddressWithAssetRequest.encode(request).finish();
    const promise = this.rpc.request(this.service, "AssociateAddressWithAsset", data);
    return promise.then((data) => Workflow.decode(_m0.Reader.create(data)));
  }

  DissociateAddressFromAsset(request: DissociateAddressFromAssetRequest): Promise<Workflow> {
    const data = DissociateAddressFromAssetRequest.encode(request).finish();
    const promise = this.rpc.request(this.service, "DissociateAddressFromAsset", data);
    return promise.then((data) => Workflow.decode(_m0.Reader.create(data)));
  }

  GetAsset(request: GetAssetRequest): Promise<GetAssetReply> {
    const data = GetAssetRequest.encode(request).finish();
    const promise = this.rpc.request(this.service, "GetAsset", data);
    return promise.then((data) => GetAssetReply.decode(_m0.Reader.create(data)));
  }

  GetAssets(request: GetAssetsRequest): Promise<GetAssetsReply> {
    const data = GetAssetsRequest.encode(request).finish();
    const promise = this.rpc.request(this.service, "GetAssets", data);
    return promise.then((data) => GetAssetsReply.decode(_m0.Reader.create(data)));
  }

  GetAssetEventsByCurrency(request: GetAssetEventsByCurrencyRequest): Promise<GetAssetEventsReply> {
    const data = GetAssetEventsByCurrencyRequest.encode(request).finish();
    const promise = this.rpc.request(this.service, "GetAssetEventsByCurrency", data);
    return promise.then((data) => GetAssetEventsReply.decode(_m0.Reader.create(data)));
  }

  GetAssetHoldersByCurrency(request: GetAssetHoldersByCurrencyRequest): Promise<GetAssetHoldersReply> {
    const data = GetAssetHoldersByCurrencyRequest.encode(request).finish();
    const promise = this.rpc.request(this.service, "GetAssetHoldersByCurrency", data);
    return promise.then((data) => GetAssetHoldersReply.decode(_m0.Reader.create(data)));
  }
}

interface Rpc {
  request(service: string, method: string, data: Uint8Array): Promise<Uint8Array>;
}

function bytesFromBase64(b64: string): Uint8Array {
  const bin = globalThis.atob(b64);
  const arr = new Uint8Array(bin.length);
  for (let i = 0; i < bin.length; ++i) {
    arr[i] = bin.charCodeAt(i);
  }
  return arr;
}

function base64FromBytes(arr: Uint8Array): string {
  const bin: string[] = [];
  arr.forEach((byte) => {
    bin.push(globalThis.String.fromCharCode(byte));
  });
  return globalThis.btoa(bin.join(""));
}

type Builtin = Date | Function | Uint8Array | string | number | boolean | undefined;

export type DeepPartial<T> = T extends Builtin ? T
  : T extends globalThis.Array<infer U> ? globalThis.Array<DeepPartial<U>>
  : T extends ReadonlyArray<infer U> ? ReadonlyArray<DeepPartial<U>>
  : T extends {} ? { [K in keyof T]?: DeepPartial<T[K]> }
  : Partial<T>;

function longToNumber(long: Long): number {
  if (long.gt(globalThis.Number.MAX_SAFE_INTEGER)) {
    throw new globalThis.Error("Value is larger than Number.MAX_SAFE_INTEGER");
  }
  if (long.lt(globalThis.Number.MIN_SAFE_INTEGER)) {
    throw new globalThis.Error("Value is smaller than Number.MIN_SAFE_INTEGER");
  }
  return long.toNumber();
}

if (_m0.util.Long !== Long) {
  _m0.util.Long = Long as any;
  _m0.configure();
}

function isSet(value: any): boolean {
  return value !== null && value !== undefined;
}
