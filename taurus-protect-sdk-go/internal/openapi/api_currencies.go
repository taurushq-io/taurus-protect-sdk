/*
Taurus-PROTECT APIs

Taurus-PROTECT APIs description

API version: 1.0
*/

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package openapi

import (
	"bytes"
	"context"
	"io"
	"net/http"
	"net/url"
)


// CurrenciesAPIService CurrenciesAPI service
type CurrenciesAPIService service

type ApiWalletServiceGetBaseCurrencyRequest struct {
	ctx context.Context
	ApiService *CurrenciesAPIService
}

func (r ApiWalletServiceGetBaseCurrencyRequest) Execute() (*TgvalidatordGetBaseCurrencyReply, *http.Response, error) {
	return r.ApiService.WalletServiceGetBaseCurrencyExecute(r)
}

/*
WalletServiceGetBaseCurrency Get base currency

This endpoint returns the configured base currency (CHF, EUR or USD...)

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiWalletServiceGetBaseCurrencyRequest
*/
func (a *CurrenciesAPIService) WalletServiceGetBaseCurrency(ctx context.Context) ApiWalletServiceGetBaseCurrencyRequest {
	return ApiWalletServiceGetBaseCurrencyRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return TgvalidatordGetBaseCurrencyReply
func (a *CurrenciesAPIService) WalletServiceGetBaseCurrencyExecute(r ApiWalletServiceGetBaseCurrencyRequest) (*TgvalidatordGetBaseCurrencyReply, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *TgvalidatordGetBaseCurrencyReply
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CurrenciesAPIService.WalletServiceGetBaseCurrency")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/rest/v1/currencies/base"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["ApiKeyTPV1"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v map[string]interface{}
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v map[string]interface{}
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v map[string]interface{}
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v map[string]interface{}
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v map[string]interface{}
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 503 {
			var v map[string]interface{}
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
			var v GooglerpcStatus
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiWalletServiceGetCurrenciesRequest struct {
	ctx context.Context
	ApiService *CurrenciesAPIService
	showDisabled *bool
	includeLogo *bool
}

// Set this parameter to true to get all currencies,Include currencies disabled by business rules.
func (r ApiWalletServiceGetCurrenciesRequest) ShowDisabled(showDisabled bool) ApiWalletServiceGetCurrenciesRequest {
	r.showDisabled = &showDisabled
	return r
}

// Currency logos are omitted by default. Set this to true to include them when applicable.
func (r ApiWalletServiceGetCurrenciesRequest) IncludeLogo(includeLogo bool) ApiWalletServiceGetCurrenciesRequest {
	r.includeLogo = &includeLogo
	return r
}

func (r ApiWalletServiceGetCurrenciesRequest) Execute() (*TgvalidatordGetCurrenciesReply, *http.Response, error) {
	return r.ApiService.WalletServiceGetCurrenciesExecute(r)
}

/*
WalletServiceGetCurrencies List currencies

This endpoint returns a list of currencies

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiWalletServiceGetCurrenciesRequest
*/
func (a *CurrenciesAPIService) WalletServiceGetCurrencies(ctx context.Context) ApiWalletServiceGetCurrenciesRequest {
	return ApiWalletServiceGetCurrenciesRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return TgvalidatordGetCurrenciesReply
func (a *CurrenciesAPIService) WalletServiceGetCurrenciesExecute(r ApiWalletServiceGetCurrenciesRequest) (*TgvalidatordGetCurrenciesReply, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *TgvalidatordGetCurrenciesReply
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CurrenciesAPIService.WalletServiceGetCurrencies")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/rest/v1/currencies"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.showDisabled != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "showDisabled", r.showDisabled, "", "")
	}
	if r.includeLogo != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "includeLogo", r.includeLogo, "", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["ApiKeyTPV1"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v map[string]interface{}
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v map[string]interface{}
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v map[string]interface{}
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v map[string]interface{}
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v map[string]interface{}
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 503 {
			var v map[string]interface{}
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
			var v GooglerpcStatus
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiWalletServiceGetCurrencyRequest struct {
	ctx context.Context
	ApiService *CurrenciesAPIService
	uniqueCurrencyFilterBlockchain *string
	uniqueCurrencyFilterNetwork *string
	showDisabled *bool
	uniqueCurrencyFilterTokenContractAddress *string
	uniqueCurrencyFilterTokenID *string
	currencyID *string
	includeLogo *bool
}

// Required: The Blockchain to filter by (e.g. ETH, BTC). Can be found using the blockchain endpoint &#x60;/api/rest/v1/blockchains&#x60;
func (r ApiWalletServiceGetCurrencyRequest) UniqueCurrencyFilterBlockchain(uniqueCurrencyFilterBlockchain string) ApiWalletServiceGetCurrencyRequest {
	r.uniqueCurrencyFilterBlockchain = &uniqueCurrencyFilterBlockchain
	return r
}

// Required: Network or environment the currency is used on (e.g. &#39;mainnet&#39;, &#39;testnet&#39;).
func (r ApiWalletServiceGetCurrencyRequest) UniqueCurrencyFilterNetwork(uniqueCurrencyFilterNetwork string) ApiWalletServiceGetCurrencyRequest {
	r.uniqueCurrencyFilterNetwork = &uniqueCurrencyFilterNetwork
	return r
}

// Set this parameter to true to get a currency even if it is disabled by business rules.
func (r ApiWalletServiceGetCurrencyRequest) ShowDisabled(showDisabled bool) ApiWalletServiceGetCurrencyRequest {
	r.showDisabled = &showDisabled
	return r
}

// If this parameter is set, the currency returned will be a token with the specified contract address. If not set, the currency returned will be the native currency of the blockchain.
func (r ApiWalletServiceGetCurrencyRequest) UniqueCurrencyFilterTokenContractAddress(uniqueCurrencyFilterTokenContractAddress string) ApiWalletServiceGetCurrencyRequest {
	r.uniqueCurrencyFilterTokenContractAddress = &uniqueCurrencyFilterTokenContractAddress
	return r
}

// For some blockchains (ex. ALGO, XTZ) a tokenContractAddress might contain multiple assets. The tokenID is used to differentiate between those assets. If not set, the currency returned won&#39;t have any tokenID defined.
func (r ApiWalletServiceGetCurrencyRequest) UniqueCurrencyFilterTokenID(uniqueCurrencyFilterTokenID string) ApiWalletServiceGetCurrencyRequest {
	r.uniqueCurrencyFilterTokenID = &uniqueCurrencyFilterTokenID
	return r
}

// The unique identifier of a currency to filter by.
func (r ApiWalletServiceGetCurrencyRequest) CurrencyID(currencyID string) ApiWalletServiceGetCurrencyRequest {
	r.currencyID = &currencyID
	return r
}

// Currency logos are omitted by default. Set this to true to include them when applicable.
func (r ApiWalletServiceGetCurrencyRequest) IncludeLogo(includeLogo bool) ApiWalletServiceGetCurrencyRequest {
	r.includeLogo = &includeLogo
	return r
}

func (r ApiWalletServiceGetCurrencyRequest) Execute() (*TgvalidatordGetCurrencyReply, *http.Response, error) {
	return r.ApiService.WalletServiceGetCurrencyExecute(r)
}

/*
WalletServiceGetCurrency Get currency

This endpoint returns a currency. The parameters need to point to a unique currency.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiWalletServiceGetCurrencyRequest
*/
func (a *CurrenciesAPIService) WalletServiceGetCurrency(ctx context.Context) ApiWalletServiceGetCurrencyRequest {
	return ApiWalletServiceGetCurrencyRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return TgvalidatordGetCurrencyReply
func (a *CurrenciesAPIService) WalletServiceGetCurrencyExecute(r ApiWalletServiceGetCurrencyRequest) (*TgvalidatordGetCurrencyReply, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *TgvalidatordGetCurrencyReply
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CurrenciesAPIService.WalletServiceGetCurrency")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/rest/v1/currency"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.uniqueCurrencyFilterBlockchain == nil {
		return localVarReturnValue, nil, reportError("uniqueCurrencyFilterBlockchain is required and must be specified")
	}
	if r.uniqueCurrencyFilterNetwork == nil {
		return localVarReturnValue, nil, reportError("uniqueCurrencyFilterNetwork is required and must be specified")
	}

	if r.showDisabled != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "showDisabled", r.showDisabled, "", "")
	}
	parameterAddToHeaderOrQuery(localVarQueryParams, "uniqueCurrencyFilter.blockchain", r.uniqueCurrencyFilterBlockchain, "", "")
	parameterAddToHeaderOrQuery(localVarQueryParams, "uniqueCurrencyFilter.network", r.uniqueCurrencyFilterNetwork, "", "")
	if r.uniqueCurrencyFilterTokenContractAddress != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "uniqueCurrencyFilter.tokenContractAddress", r.uniqueCurrencyFilterTokenContractAddress, "", "")
	}
	if r.uniqueCurrencyFilterTokenID != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "uniqueCurrencyFilter.tokenID", r.uniqueCurrencyFilterTokenID, "", "")
	}
	if r.currencyID != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "currencyID", r.currencyID, "", "")
	}
	if r.includeLogo != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "includeLogo", r.includeLogo, "", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["ApiKeyTPV1"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v map[string]interface{}
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v map[string]interface{}
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v map[string]interface{}
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v map[string]interface{}
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v map[string]interface{}
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 503 {
			var v map[string]interface{}
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
			var v GooglerpcStatus
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}
