// Code generated by protoc-gen-go. DO NOT EDIT.
// versions:
// 	protoc-gen-go v1.36.11
// 	protoc        v5.29.3
// source: whitelist.proto

package proto

import (
	_ "github.com/grpc-ecosystem/grpc-gateway/v2/protoc-gen-openapiv2/options"
	protoreflect "google.golang.org/protobuf/reflect/protoreflect"
	protoimpl "google.golang.org/protobuf/runtime/protoimpl"
	timestamppb "google.golang.org/protobuf/types/known/timestamppb"
	reflect "reflect"
	sync "sync"
	unsafe "unsafe"
)

const (
	// Verify that this generated code is sufficiently up-to-date.
	_ = protoimpl.EnforceVersion(20 - protoimpl.MinVersion)
	// Verify that runtime/protoimpl is sufficiently up-to-date.
	_ = protoimpl.EnforceVersion(protoimpl.MaxVersion - 20)
)

type WhitelistedContractAddressKind int32

const (
	// Default has an empty string as a representation
	WhitelistedContractAddressKind__default_   WhitelistedContractAddressKind = 0
	WhitelistedContractAddressKind_NFT_AUTO    WhitelistedContractAddressKind = 1 // Generic representation for NFTs. Upon receiving this, the backend will try to find the best match, and fill it with one of the types below.
	WhitelistedContractAddressKind_NFT_XTZ_FA2 WhitelistedContractAddressKind = 2
	// Deprecated: Marked as deprecated in whitelist.proto.
	WhitelistedContractAddressKind_NFT_ETH_ERC721 WhitelistedContractAddressKind = 3 // Use NFT_EVM_ERC721 or NFT_AUTO instead.
	// Deprecated: Marked as deprecated in whitelist.proto.
	WhitelistedContractAddressKind_NFT_ETH_ERC1155     WhitelistedContractAddressKind = 4 // Use NFT_EVM_ERC1155 or NFT_AUTO instead.
	WhitelistedContractAddressKind_NFT_EVM_ERC721      WhitelistedContractAddressKind = 5
	WhitelistedContractAddressKind_NFT_EVM_ERC1155     WhitelistedContractAddressKind = 6
	WhitelistedContractAddressKind_SOL_TOKEN           WhitelistedContractAddressKind = 7
	WhitelistedContractAddressKind_SOL_TOKEN2022       WhitelistedContractAddressKind = 8
	WhitelistedContractAddressKind_NFT_EVM_CRYPTOPUNKS WhitelistedContractAddressKind = 9
	WhitelistedContractAddressKind_HEDERA_NATIVE_TOKEN WhitelistedContractAddressKind = 10
	WhitelistedContractAddressKind_HEDERA_NATIVE_NFT   WhitelistedContractAddressKind = 11
)

// Enum value maps for WhitelistedContractAddressKind.
var (
	WhitelistedContractAddressKind_name = map[int32]string{
		0:  "_default_",
		1:  "NFT_AUTO",
		2:  "NFT_XTZ_FA2",
		3:  "NFT_ETH_ERC721",
		4:  "NFT_ETH_ERC1155",
		5:  "NFT_EVM_ERC721",
		6:  "NFT_EVM_ERC1155",
		7:  "SOL_TOKEN",
		8:  "SOL_TOKEN2022",
		9:  "NFT_EVM_CRYPTOPUNKS",
		10: "HEDERA_NATIVE_TOKEN",
		11: "HEDERA_NATIVE_NFT",
	}
	WhitelistedContractAddressKind_value = map[string]int32{
		"_default_":           0,
		"NFT_AUTO":            1,
		"NFT_XTZ_FA2":         2,
		"NFT_ETH_ERC721":      3,
		"NFT_ETH_ERC1155":     4,
		"NFT_EVM_ERC721":      5,
		"NFT_EVM_ERC1155":     6,
		"SOL_TOKEN":           7,
		"SOL_TOKEN2022":       8,
		"NFT_EVM_CRYPTOPUNKS": 9,
		"HEDERA_NATIVE_TOKEN": 10,
		"HEDERA_NATIVE_NFT":   11,
	}
)

func (x WhitelistedContractAddressKind) Enum() *WhitelistedContractAddressKind {
	p := new(WhitelistedContractAddressKind)
	*p = x
	return p
}

func (x WhitelistedContractAddressKind) String() string {
	return protoimpl.X.EnumStringOf(x.Descriptor(), protoreflect.EnumNumber(x))
}

func (WhitelistedContractAddressKind) Descriptor() protoreflect.EnumDescriptor {
	return file_whitelist_proto_enumTypes[0].Descriptor()
}

func (WhitelistedContractAddressKind) Type() protoreflect.EnumType {
	return &file_whitelist_proto_enumTypes[0]
}

func (x WhitelistedContractAddressKind) Number() protoreflect.EnumNumber {
	return protoreflect.EnumNumber(x)
}

// Deprecated: Use WhitelistedContractAddressKind.Descriptor instead.
func (WhitelistedContractAddressKind) EnumDescriptor() ([]byte, []int) {
	return file_whitelist_proto_rawDescGZIP(), []int{0}
}

type WhitelistedAddress_AddressType int32

const (
	WhitelistedAddress_individual   WhitelistedAddress_AddressType = 0
	WhitelistedAddress_exchange     WhitelistedAddress_AddressType = 1
	WhitelistedAddress_baker        WhitelistedAddress_AddressType = 2
	WhitelistedAddress_contract     WhitelistedAddress_AddressType = 3
	WhitelistedAddress_stakepool    WhitelistedAddress_AddressType = 4
	WhitelistedAddress_validator    WhitelistedAddress_AddressType = 5
	WhitelistedAddress_node         WhitelistedAddress_AddressType = 6
	WhitelistedAddress_fiatprovider WhitelistedAddress_AddressType = 7
)

// Enum value maps for WhitelistedAddress_AddressType.
var (
	WhitelistedAddress_AddressType_name = map[int32]string{
		0: "individual",
		1: "exchange",
		2: "baker",
		3: "contract",
		4: "stakepool",
		5: "validator",
		6: "node",
		7: "fiatprovider",
	}
	WhitelistedAddress_AddressType_value = map[string]int32{
		"individual":   0,
		"exchange":     1,
		"baker":        2,
		"contract":     3,
		"stakepool":    4,
		"validator":    5,
		"node":         6,
		"fiatprovider": 7,
	}
)

func (x WhitelistedAddress_AddressType) Enum() *WhitelistedAddress_AddressType {
	p := new(WhitelistedAddress_AddressType)
	*p = x
	return p
}

func (x WhitelistedAddress_AddressType) String() string {
	return protoimpl.X.EnumStringOf(x.Descriptor(), protoreflect.EnumNumber(x))
}

func (WhitelistedAddress_AddressType) Descriptor() protoreflect.EnumDescriptor {
	return file_whitelist_proto_enumTypes[1].Descriptor()
}

func (WhitelistedAddress_AddressType) Type() protoreflect.EnumType {
	return &file_whitelist_proto_enumTypes[1]
}

func (x WhitelistedAddress_AddressType) Number() protoreflect.EnumNumber {
	return protoreflect.EnumNumber(x)
}

// Deprecated: Use WhitelistedAddress_AddressType.Descriptor instead.
func (WhitelistedAddress_AddressType) EnumDescriptor() ([]byte, []int) {
	return file_whitelist_proto_rawDescGZIP(), []int{7, 0}
}

type WhitelistedAddressBatchSignature struct {
	state         protoimpl.MessageState                                          `protogen:"open.v1"`
	ID            uint64                                                          `protobuf:"varint,1,opt,name=ID,proto3" json:"ID,omitempty"`
	TenantID      uint64                                                          `protobuf:"varint,2,opt,name=TenantID,proto3" json:"TenantID,omitempty"`
	UserID        uint64                                                          `protobuf:"varint,3,opt,name=UserID,proto3" json:"UserID,omitempty"`
	Signature     string                                                          `protobuf:"bytes,4,opt,name=Signature,proto3" json:"Signature,omitempty"`
	Comment       string                                                          `protobuf:"bytes,5,opt,name=Comment,proto3" json:"Comment,omitempty"`
	Status        string                                                          `protobuf:"bytes,6,opt,name=Status,proto3" json:"Status,omitempty"`
	CreationDate  *timestamppb.Timestamp                                          `protobuf:"bytes,7,opt,name=CreationDate,proto3" json:"CreationDate,omitempty"`
	UpdateDate    *timestamppb.Timestamp                                          `protobuf:"bytes,8,opt,name=UpdateDate,proto3" json:"UpdateDate,omitempty"`
	Signatures    []*WhitelistedAddressBatchSignature_WhitelistedAddressSignature `protobuf:"bytes,9,rep,name=signatures,proto3" json:"signatures,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *WhitelistedAddressBatchSignature) Reset() {
	*x = WhitelistedAddressBatchSignature{}
	mi := &file_whitelist_proto_msgTypes[0]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *WhitelistedAddressBatchSignature) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*WhitelistedAddressBatchSignature) ProtoMessage() {}

func (x *WhitelistedAddressBatchSignature) ProtoReflect() protoreflect.Message {
	mi := &file_whitelist_proto_msgTypes[0]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use WhitelistedAddressBatchSignature.ProtoReflect.Descriptor instead.
func (*WhitelistedAddressBatchSignature) Descriptor() ([]byte, []int) {
	return file_whitelist_proto_rawDescGZIP(), []int{0}
}

func (x *WhitelistedAddressBatchSignature) GetID() uint64 {
	if x != nil {
		return x.ID
	}
	return 0
}

func (x *WhitelistedAddressBatchSignature) GetTenantID() uint64 {
	if x != nil {
		return x.TenantID
	}
	return 0
}

func (x *WhitelistedAddressBatchSignature) GetUserID() uint64 {
	if x != nil {
		return x.UserID
	}
	return 0
}

func (x *WhitelistedAddressBatchSignature) GetSignature() string {
	if x != nil {
		return x.Signature
	}
	return ""
}

func (x *WhitelistedAddressBatchSignature) GetComment() string {
	if x != nil {
		return x.Comment
	}
	return ""
}

func (x *WhitelistedAddressBatchSignature) GetStatus() string {
	if x != nil {
		return x.Status
	}
	return ""
}

func (x *WhitelistedAddressBatchSignature) GetCreationDate() *timestamppb.Timestamp {
	if x != nil {
		return x.CreationDate
	}
	return nil
}

func (x *WhitelistedAddressBatchSignature) GetUpdateDate() *timestamppb.Timestamp {
	if x != nil {
		return x.UpdateDate
	}
	return nil
}

func (x *WhitelistedAddressBatchSignature) GetSignatures() []*WhitelistedAddressBatchSignature_WhitelistedAddressSignature {
	if x != nil {
		return x.Signatures
	}
	return nil
}

type Trail struct {
	state          protoimpl.MessageState `protogen:"open.v1"`
	Id             uint64                 `protobuf:"varint,1,opt,name=id,proto3" json:"id,omitempty"`
	UserId         uint64                 `protobuf:"varint,2,opt,name=userId,proto3" json:"userId,omitempty"`
	ExternalUserId string                 `protobuf:"bytes,3,opt,name=externalUserId,proto3" json:"externalUserId,omitempty"`
	Action         string                 `protobuf:"bytes,4,opt,name=action,proto3" json:"action,omitempty"`
	Comment        string                 `protobuf:"bytes,5,opt,name=comment,proto3" json:"comment,omitempty"`
	Date           *timestamppb.Timestamp `protobuf:"bytes,6,opt,name=date,proto3" json:"date,omitempty"`
	unknownFields  protoimpl.UnknownFields
	sizeCache      protoimpl.SizeCache
}

func (x *Trail) Reset() {
	*x = Trail{}
	mi := &file_whitelist_proto_msgTypes[1]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *Trail) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*Trail) ProtoMessage() {}

func (x *Trail) ProtoReflect() protoreflect.Message {
	mi := &file_whitelist_proto_msgTypes[1]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use Trail.ProtoReflect.Descriptor instead.
func (*Trail) Descriptor() ([]byte, []int) {
	return file_whitelist_proto_rawDescGZIP(), []int{1}
}

func (x *Trail) GetId() uint64 {
	if x != nil {
		return x.Id
	}
	return 0
}

func (x *Trail) GetUserId() uint64 {
	if x != nil {
		return x.UserId
	}
	return 0
}

func (x *Trail) GetExternalUserId() string {
	if x != nil {
		return x.ExternalUserId
	}
	return ""
}

func (x *Trail) GetAction() string {
	if x != nil {
		return x.Action
	}
	return ""
}

func (x *Trail) GetComment() string {
	if x != nil {
		return x.Comment
	}
	return ""
}

func (x *Trail) GetDate() *timestamppb.Timestamp {
	if x != nil {
		return x.Date
	}
	return nil
}

type SignedWhitelistedAddressEnvelope struct {
	state              protoimpl.MessageState         `protogen:"open.v1"`
	Id                 uint64                         `protobuf:"varint,1,opt,name=id,proto3" json:"id,omitempty"`
	TenantId           uint64                         `protobuf:"varint,2,opt,name=tenantId,proto3" json:"tenantId,omitempty"`
	SignedAddress      *SignedWhitelistedAddress      `protobuf:"bytes,3,opt,name=signedAddress,proto3" json:"signedAddress,omitempty"`
	Metadata           *Metadata                      `protobuf:"bytes,4,opt,name=metadata,proto3" json:"metadata,omitempty"`
	Action             string                         `protobuf:"bytes,5,opt,name=action,proto3" json:"action,omitempty"`
	Scores             []*Score                       `protobuf:"bytes,6,rep,name=scores,proto3" json:"scores,omitempty"`
	Trails             []*Trail                       `protobuf:"bytes,7,rep,name=trails,proto3" json:"trails,omitempty"`
	RulesContainer     string                         `protobuf:"bytes,8,opt,name=rulesContainer,proto3" json:"rulesContainer,omitempty"`
	Rule               string                         `protobuf:"bytes,9,opt,name=rule,proto3" json:"rule,omitempty"`
	Approvers          *Approvers                     `protobuf:"bytes,10,opt,name=approvers,proto3" json:"approvers,omitempty"`
	Attributes         []*WhitelistedAddressAttribute `protobuf:"bytes,11,rep,name=attributes,proto3" json:"attributes,omitempty"`
	RulesContainerHash string                         `protobuf:"bytes,12,opt,name=rulesContainerHash,proto3" json:"rulesContainerHash,omitempty"`
	// Currency currencyInfo = 13;
	Blockchain        string `protobuf:"bytes,14,opt,name=blockchain,proto3" json:"blockchain,omitempty"`
	Status            string `protobuf:"bytes,15,opt,name=status,proto3" json:"status,omitempty"`
	Network           string `protobuf:"bytes,16,opt,name=network,proto3" json:"network,omitempty"`
	VisibilityGroupID string `protobuf:"bytes,17,opt,name=visibilityGroupID,proto3" json:"visibilityGroupID,omitempty"`
	TnParticipantID   string `protobuf:"bytes,18,opt,name=tnParticipantID,proto3" json:"tnParticipantID,omitempty"`
	RulesSignatures   string `protobuf:"bytes,19,opt,name=rulesSignatures,proto3" json:"rulesSignatures,omitempty"`
	unknownFields     protoimpl.UnknownFields
	sizeCache         protoimpl.SizeCache
}

func (x *SignedWhitelistedAddressEnvelope) Reset() {
	*x = SignedWhitelistedAddressEnvelope{}
	mi := &file_whitelist_proto_msgTypes[2]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *SignedWhitelistedAddressEnvelope) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*SignedWhitelistedAddressEnvelope) ProtoMessage() {}

func (x *SignedWhitelistedAddressEnvelope) ProtoReflect() protoreflect.Message {
	mi := &file_whitelist_proto_msgTypes[2]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use SignedWhitelistedAddressEnvelope.ProtoReflect.Descriptor instead.
func (*SignedWhitelistedAddressEnvelope) Descriptor() ([]byte, []int) {
	return file_whitelist_proto_rawDescGZIP(), []int{2}
}

func (x *SignedWhitelistedAddressEnvelope) GetId() uint64 {
	if x != nil {
		return x.Id
	}
	return 0
}

func (x *SignedWhitelistedAddressEnvelope) GetTenantId() uint64 {
	if x != nil {
		return x.TenantId
	}
	return 0
}

func (x *SignedWhitelistedAddressEnvelope) GetSignedAddress() *SignedWhitelistedAddress {
	if x != nil {
		return x.SignedAddress
	}
	return nil
}

func (x *SignedWhitelistedAddressEnvelope) GetMetadata() *Metadata {
	if x != nil {
		return x.Metadata
	}
	return nil
}

func (x *SignedWhitelistedAddressEnvelope) GetAction() string {
	if x != nil {
		return x.Action
	}
	return ""
}

func (x *SignedWhitelistedAddressEnvelope) GetScores() []*Score {
	if x != nil {
		return x.Scores
	}
	return nil
}

func (x *SignedWhitelistedAddressEnvelope) GetTrails() []*Trail {
	if x != nil {
		return x.Trails
	}
	return nil
}

func (x *SignedWhitelistedAddressEnvelope) GetRulesContainer() string {
	if x != nil {
		return x.RulesContainer
	}
	return ""
}

func (x *SignedWhitelistedAddressEnvelope) GetRule() string {
	if x != nil {
		return x.Rule
	}
	return ""
}

func (x *SignedWhitelistedAddressEnvelope) GetApprovers() *Approvers {
	if x != nil {
		return x.Approvers
	}
	return nil
}

func (x *SignedWhitelistedAddressEnvelope) GetAttributes() []*WhitelistedAddressAttribute {
	if x != nil {
		return x.Attributes
	}
	return nil
}

func (x *SignedWhitelistedAddressEnvelope) GetRulesContainerHash() string {
	if x != nil {
		return x.RulesContainerHash
	}
	return ""
}

func (x *SignedWhitelistedAddressEnvelope) GetBlockchain() string {
	if x != nil {
		return x.Blockchain
	}
	return ""
}

func (x *SignedWhitelistedAddressEnvelope) GetStatus() string {
	if x != nil {
		return x.Status
	}
	return ""
}

func (x *SignedWhitelistedAddressEnvelope) GetNetwork() string {
	if x != nil {
		return x.Network
	}
	return ""
}

func (x *SignedWhitelistedAddressEnvelope) GetVisibilityGroupID() string {
	if x != nil {
		return x.VisibilityGroupID
	}
	return ""
}

func (x *SignedWhitelistedAddressEnvelope) GetTnParticipantID() string {
	if x != nil {
		return x.TnParticipantID
	}
	return ""
}

func (x *SignedWhitelistedAddressEnvelope) GetRulesSignatures() string {
	if x != nil {
		return x.RulesSignatures
	}
	return ""
}

type SignedWhitelistedContractAddressEnvelope struct {
	state                 protoimpl.MessageState                 `protogen:"open.v1"`
	Id                    uint64                                 `protobuf:"varint,1,opt,name=id,proto3" json:"id,omitempty"`
	TenantId              uint64                                 `protobuf:"varint,2,opt,name=tenantId,proto3" json:"tenantId,omitempty"`
	SignedContractAddress *SignedWhitelistedContractAddress      `protobuf:"bytes,3,opt,name=signedContractAddress,proto3" json:"signedContractAddress,omitempty"`
	Metadata              *Metadata                              `protobuf:"bytes,4,opt,name=metadata,proto3" json:"metadata,omitempty"`
	Action                string                                 `protobuf:"bytes,5,opt,name=action,proto3" json:"action,omitempty"`
	Trails                []*Trail                               `protobuf:"bytes,6,rep,name=trails,proto3" json:"trails,omitempty"`
	RulesContainer        string                                 `protobuf:"bytes,8,opt,name=rulesContainer,proto3" json:"rulesContainer,omitempty"`
	Rule                  string                                 `protobuf:"bytes,9,opt,name=rule,proto3" json:"rule,omitempty"`
	Approvers             *Approvers                             `protobuf:"bytes,10,opt,name=approvers,proto3" json:"approvers,omitempty"`
	Attributes            []*WhitelistedContractAddressAttribute `protobuf:"bytes,11,rep,name=attributes,proto3" json:"attributes,omitempty"`
	Status                string                                 `protobuf:"bytes,12,opt,name=status,proto3" json:"status,omitempty"`
	Blockchain            string                                 `protobuf:"bytes,13,opt,name=blockchain,proto3" json:"blockchain,omitempty"`
	Network               string                                 `protobuf:"bytes,14,opt,name=network,proto3" json:"network,omitempty"`
	BusinessRuleEnabled   bool                                   `protobuf:"varint,15,opt,name=businessRuleEnabled,proto3" json:"businessRuleEnabled,omitempty"`
	RulesSignatures       string                                 `protobuf:"bytes,16,opt,name=rulesSignatures,proto3" json:"rulesSignatures,omitempty"`
	unknownFields         protoimpl.UnknownFields
	sizeCache             protoimpl.SizeCache
}

func (x *SignedWhitelistedContractAddressEnvelope) Reset() {
	*x = SignedWhitelistedContractAddressEnvelope{}
	mi := &file_whitelist_proto_msgTypes[3]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *SignedWhitelistedContractAddressEnvelope) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*SignedWhitelistedContractAddressEnvelope) ProtoMessage() {}

func (x *SignedWhitelistedContractAddressEnvelope) ProtoReflect() protoreflect.Message {
	mi := &file_whitelist_proto_msgTypes[3]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use SignedWhitelistedContractAddressEnvelope.ProtoReflect.Descriptor instead.
func (*SignedWhitelistedContractAddressEnvelope) Descriptor() ([]byte, []int) {
	return file_whitelist_proto_rawDescGZIP(), []int{3}
}

func (x *SignedWhitelistedContractAddressEnvelope) GetId() uint64 {
	if x != nil {
		return x.Id
	}
	return 0
}

func (x *SignedWhitelistedContractAddressEnvelope) GetTenantId() uint64 {
	if x != nil {
		return x.TenantId
	}
	return 0
}

func (x *SignedWhitelistedContractAddressEnvelope) GetSignedContractAddress() *SignedWhitelistedContractAddress {
	if x != nil {
		return x.SignedContractAddress
	}
	return nil
}

func (x *SignedWhitelistedContractAddressEnvelope) GetMetadata() *Metadata {
	if x != nil {
		return x.Metadata
	}
	return nil
}

func (x *SignedWhitelistedContractAddressEnvelope) GetAction() string {
	if x != nil {
		return x.Action
	}
	return ""
}

func (x *SignedWhitelistedContractAddressEnvelope) GetTrails() []*Trail {
	if x != nil {
		return x.Trails
	}
	return nil
}

func (x *SignedWhitelistedContractAddressEnvelope) GetRulesContainer() string {
	if x != nil {
		return x.RulesContainer
	}
	return ""
}

func (x *SignedWhitelistedContractAddressEnvelope) GetRule() string {
	if x != nil {
		return x.Rule
	}
	return ""
}

func (x *SignedWhitelistedContractAddressEnvelope) GetApprovers() *Approvers {
	if x != nil {
		return x.Approvers
	}
	return nil
}

func (x *SignedWhitelistedContractAddressEnvelope) GetAttributes() []*WhitelistedContractAddressAttribute {
	if x != nil {
		return x.Attributes
	}
	return nil
}

func (x *SignedWhitelistedContractAddressEnvelope) GetStatus() string {
	if x != nil {
		return x.Status
	}
	return ""
}

func (x *SignedWhitelistedContractAddressEnvelope) GetBlockchain() string {
	if x != nil {
		return x.Blockchain
	}
	return ""
}

func (x *SignedWhitelistedContractAddressEnvelope) GetNetwork() string {
	if x != nil {
		return x.Network
	}
	return ""
}

func (x *SignedWhitelistedContractAddressEnvelope) GetBusinessRuleEnabled() bool {
	if x != nil {
		return x.BusinessRuleEnabled
	}
	return false
}

func (x *SignedWhitelistedContractAddressEnvelope) GetRulesSignatures() string {
	if x != nil {
		return x.RulesSignatures
	}
	return ""
}

type WhitelistUserSignature struct {
	state         protoimpl.MessageState `protogen:"open.v1"`
	UserId        string                 `protobuf:"bytes,1,opt,name=userId,proto3" json:"userId,omitempty"`
	Signature     []byte                 `protobuf:"bytes,2,opt,name=signature,proto3" json:"signature,omitempty"`
	Comment       string                 `protobuf:"bytes,3,opt,name=comment,proto3" json:"comment,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *WhitelistUserSignature) Reset() {
	*x = WhitelistUserSignature{}
	mi := &file_whitelist_proto_msgTypes[4]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *WhitelistUserSignature) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*WhitelistUserSignature) ProtoMessage() {}

func (x *WhitelistUserSignature) ProtoReflect() protoreflect.Message {
	mi := &file_whitelist_proto_msgTypes[4]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use WhitelistUserSignature.ProtoReflect.Descriptor instead.
func (*WhitelistUserSignature) Descriptor() ([]byte, []int) {
	return file_whitelist_proto_rawDescGZIP(), []int{4}
}

func (x *WhitelistUserSignature) GetUserId() string {
	if x != nil {
		return x.UserId
	}
	return ""
}

func (x *WhitelistUserSignature) GetSignature() []byte {
	if x != nil {
		return x.Signature
	}
	return nil
}

func (x *WhitelistUserSignature) GetComment() string {
	if x != nil {
		return x.Comment
	}
	return ""
}

type WhitelistSignature struct {
	state         protoimpl.MessageState  `protogen:"open.v1"`
	Signature     *WhitelistUserSignature `protobuf:"bytes,1,opt,name=signature,proto3" json:"signature,omitempty"`
	Hashes        []string                `protobuf:"bytes,2,rep,name=hashes,proto3" json:"hashes,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *WhitelistSignature) Reset() {
	*x = WhitelistSignature{}
	mi := &file_whitelist_proto_msgTypes[5]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *WhitelistSignature) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*WhitelistSignature) ProtoMessage() {}

func (x *WhitelistSignature) ProtoReflect() protoreflect.Message {
	mi := &file_whitelist_proto_msgTypes[5]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use WhitelistSignature.ProtoReflect.Descriptor instead.
func (*WhitelistSignature) Descriptor() ([]byte, []int) {
	return file_whitelist_proto_rawDescGZIP(), []int{5}
}

func (x *WhitelistSignature) GetSignature() *WhitelistUserSignature {
	if x != nil {
		return x.Signature
	}
	return nil
}

func (x *WhitelistSignature) GetHashes() []string {
	if x != nil {
		return x.Hashes
	}
	return nil
}

type SignedWhitelistedAddress struct {
	state         protoimpl.MessageState `protogen:"open.v1"`
	Signatures    []*WhitelistSignature  `protobuf:"bytes,1,rep,name=signatures,proto3" json:"signatures,omitempty"`
	Payload       []byte                 `protobuf:"bytes,2,opt,name=payload,proto3" json:"payload,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *SignedWhitelistedAddress) Reset() {
	*x = SignedWhitelistedAddress{}
	mi := &file_whitelist_proto_msgTypes[6]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *SignedWhitelistedAddress) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*SignedWhitelistedAddress) ProtoMessage() {}

func (x *SignedWhitelistedAddress) ProtoReflect() protoreflect.Message {
	mi := &file_whitelist_proto_msgTypes[6]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use SignedWhitelistedAddress.ProtoReflect.Descriptor instead.
func (*SignedWhitelistedAddress) Descriptor() ([]byte, []int) {
	return file_whitelist_proto_rawDescGZIP(), []int{6}
}

func (x *SignedWhitelistedAddress) GetSignatures() []*WhitelistSignature {
	if x != nil {
		return x.Signatures
	}
	return nil
}

func (x *SignedWhitelistedAddress) GetPayload() []byte {
	if x != nil {
		return x.Payload
	}
	return nil
}

// This proto is used only to serialize an address into an envelope. It's not used in a JSON serialization
type WhitelistedAddress struct {
	state                   protoimpl.MessageState         `protogen:"open.v1"`
	Blockchain              string                         `protobuf:"bytes,1,opt,name=blockchain,proto3" json:"blockchain,omitempty"`
	AddressType             WhitelistedAddress_AddressType `protobuf:"varint,2,opt,name=addressType,proto3,enum=tgvalidatord.WhitelistedAddress_AddressType" json:"addressType,omitempty"`
	Address                 string                         `protobuf:"bytes,3,opt,name=address,proto3" json:"address,omitempty"`
	Memo                    string                         `protobuf:"bytes,4,opt,name=memo,proto3" json:"memo,omitempty"`             // stellar memo, ripple tag
	Label                   string                         `protobuf:"bytes,5,opt,name=label,proto3" json:"label,omitempty"`           // description of the whitelisted address
	CustomerId              string                         `protobuf:"bytes,6,opt,name=customerId,proto3" json:"customerId,omitempty"` // customer ID for external reconciliation
	ExchangeAccountId       uint64                         `protobuf:"varint,7,opt,name=exchangeAccountId,proto3" json:"exchangeAccountId,omitempty"`
	LinkedInternalAddresses []*InternalAddress             `protobuf:"bytes,8,rep,name=linkedInternalAddresses,proto3" json:"linkedInternalAddresses,omitempty"`
	ContractType            string                         `protobuf:"bytes,9,opt,name=contractType,proto3" json:"contractType,omitempty"` // CMTA20, ERC20 ...
	Attributes              []*WhitelistedAddressAttribute `protobuf:"bytes,10,rep,name=attributes,proto3" json:"attributes,omitempty"`
	LinkedWallets           []*InternalWallet              `protobuf:"bytes,11,rep,name=linkedWallets,proto3" json:"linkedWallets,omitempty"`
	// Currency currencyInfo = 12;
	Network         string `protobuf:"bytes,13,opt,name=network,proto3" json:"network,omitempty"`
	TnParticipantID string `protobuf:"bytes,14,opt,name=tnParticipantID,proto3" json:"tnParticipantID,omitempty"`
	unknownFields   protoimpl.UnknownFields
	sizeCache       protoimpl.SizeCache
}

func (x *WhitelistedAddress) Reset() {
	*x = WhitelistedAddress{}
	mi := &file_whitelist_proto_msgTypes[7]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *WhitelistedAddress) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*WhitelistedAddress) ProtoMessage() {}

func (x *WhitelistedAddress) ProtoReflect() protoreflect.Message {
	mi := &file_whitelist_proto_msgTypes[7]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use WhitelistedAddress.ProtoReflect.Descriptor instead.
func (*WhitelistedAddress) Descriptor() ([]byte, []int) {
	return file_whitelist_proto_rawDescGZIP(), []int{7}
}

func (x *WhitelistedAddress) GetBlockchain() string {
	if x != nil {
		return x.Blockchain
	}
	return ""
}

func (x *WhitelistedAddress) GetAddressType() WhitelistedAddress_AddressType {
	if x != nil {
		return x.AddressType
	}
	return WhitelistedAddress_individual
}

func (x *WhitelistedAddress) GetAddress() string {
	if x != nil {
		return x.Address
	}
	return ""
}

func (x *WhitelistedAddress) GetMemo() string {
	if x != nil {
		return x.Memo
	}
	return ""
}

func (x *WhitelistedAddress) GetLabel() string {
	if x != nil {
		return x.Label
	}
	return ""
}

func (x *WhitelistedAddress) GetCustomerId() string {
	if x != nil {
		return x.CustomerId
	}
	return ""
}

func (x *WhitelistedAddress) GetExchangeAccountId() uint64 {
	if x != nil {
		return x.ExchangeAccountId
	}
	return 0
}

func (x *WhitelistedAddress) GetLinkedInternalAddresses() []*InternalAddress {
	if x != nil {
		return x.LinkedInternalAddresses
	}
	return nil
}

func (x *WhitelistedAddress) GetContractType() string {
	if x != nil {
		return x.ContractType
	}
	return ""
}

func (x *WhitelistedAddress) GetAttributes() []*WhitelistedAddressAttribute {
	if x != nil {
		return x.Attributes
	}
	return nil
}

func (x *WhitelistedAddress) GetLinkedWallets() []*InternalWallet {
	if x != nil {
		return x.LinkedWallets
	}
	return nil
}

func (x *WhitelistedAddress) GetNetwork() string {
	if x != nil {
		return x.Network
	}
	return ""
}

func (x *WhitelistedAddress) GetTnParticipantID() string {
	if x != nil {
		return x.TnParticipantID
	}
	return ""
}

type WhitelistedAddressAttribute struct {
	state         protoimpl.MessageState `protogen:"open.v1"`
	Id            uint64                 `protobuf:"varint,1,opt,name=id,proto3" json:"id,omitempty"`
	Key           string                 `protobuf:"bytes,2,opt,name=key,proto3" json:"key,omitempty"`
	Value         string                 `protobuf:"bytes,3,opt,name=value,proto3" json:"value,omitempty"`
	ContentType   string                 `protobuf:"bytes,4,opt,name=contentType,proto3" json:"contentType,omitempty"`
	Owner         string                 `protobuf:"bytes,5,opt,name=owner,proto3" json:"owner,omitempty"`
	Type          string                 `protobuf:"bytes,6,opt,name=type,proto3" json:"type,omitempty"`
	Subtype       string                 `protobuf:"bytes,7,opt,name=subtype,proto3" json:"subtype,omitempty"`
	Isfile        bool                   `protobuf:"varint,8,opt,name=isfile,proto3" json:"isfile,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *WhitelistedAddressAttribute) Reset() {
	*x = WhitelistedAddressAttribute{}
	mi := &file_whitelist_proto_msgTypes[8]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *WhitelistedAddressAttribute) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*WhitelistedAddressAttribute) ProtoMessage() {}

func (x *WhitelistedAddressAttribute) ProtoReflect() protoreflect.Message {
	mi := &file_whitelist_proto_msgTypes[8]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use WhitelistedAddressAttribute.ProtoReflect.Descriptor instead.
func (*WhitelistedAddressAttribute) Descriptor() ([]byte, []int) {
	return file_whitelist_proto_rawDescGZIP(), []int{8}
}

func (x *WhitelistedAddressAttribute) GetId() uint64 {
	if x != nil {
		return x.Id
	}
	return 0
}

func (x *WhitelistedAddressAttribute) GetKey() string {
	if x != nil {
		return x.Key
	}
	return ""
}

func (x *WhitelistedAddressAttribute) GetValue() string {
	if x != nil {
		return x.Value
	}
	return ""
}

func (x *WhitelistedAddressAttribute) GetContentType() string {
	if x != nil {
		return x.ContentType
	}
	return ""
}

func (x *WhitelistedAddressAttribute) GetOwner() string {
	if x != nil {
		return x.Owner
	}
	return ""
}

func (x *WhitelistedAddressAttribute) GetType() string {
	if x != nil {
		return x.Type
	}
	return ""
}

func (x *WhitelistedAddressAttribute) GetSubtype() string {
	if x != nil {
		return x.Subtype
	}
	return ""
}

func (x *WhitelistedAddressAttribute) GetIsfile() bool {
	if x != nil {
		return x.Isfile
	}
	return false
}

type WhitelistedContractAddressAttribute struct {
	state         protoimpl.MessageState `protogen:"open.v1"`
	Id            uint64                 `protobuf:"varint,1,opt,name=id,proto3" json:"id,omitempty"`
	Key           string                 `protobuf:"bytes,2,opt,name=key,proto3" json:"key,omitempty"`
	Value         string                 `protobuf:"bytes,3,opt,name=value,proto3" json:"value,omitempty"`
	ContentType   string                 `protobuf:"bytes,4,opt,name=contentType,proto3" json:"contentType,omitempty"`
	Owner         string                 `protobuf:"bytes,5,opt,name=owner,proto3" json:"owner,omitempty"`
	Type          string                 `protobuf:"bytes,6,opt,name=type,proto3" json:"type,omitempty"`
	Subtype       string                 `protobuf:"bytes,7,opt,name=subtype,proto3" json:"subtype,omitempty"`
	Isfile        bool                   `protobuf:"varint,8,opt,name=isfile,proto3" json:"isfile,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *WhitelistedContractAddressAttribute) Reset() {
	*x = WhitelistedContractAddressAttribute{}
	mi := &file_whitelist_proto_msgTypes[9]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *WhitelistedContractAddressAttribute) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*WhitelistedContractAddressAttribute) ProtoMessage() {}

func (x *WhitelistedContractAddressAttribute) ProtoReflect() protoreflect.Message {
	mi := &file_whitelist_proto_msgTypes[9]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use WhitelistedContractAddressAttribute.ProtoReflect.Descriptor instead.
func (*WhitelistedContractAddressAttribute) Descriptor() ([]byte, []int) {
	return file_whitelist_proto_rawDescGZIP(), []int{9}
}

func (x *WhitelistedContractAddressAttribute) GetId() uint64 {
	if x != nil {
		return x.Id
	}
	return 0
}

func (x *WhitelistedContractAddressAttribute) GetKey() string {
	if x != nil {
		return x.Key
	}
	return ""
}

func (x *WhitelistedContractAddressAttribute) GetValue() string {
	if x != nil {
		return x.Value
	}
	return ""
}

func (x *WhitelistedContractAddressAttribute) GetContentType() string {
	if x != nil {
		return x.ContentType
	}
	return ""
}

func (x *WhitelistedContractAddressAttribute) GetOwner() string {
	if x != nil {
		return x.Owner
	}
	return ""
}

func (x *WhitelistedContractAddressAttribute) GetType() string {
	if x != nil {
		return x.Type
	}
	return ""
}

func (x *WhitelistedContractAddressAttribute) GetSubtype() string {
	if x != nil {
		return x.Subtype
	}
	return ""
}

func (x *WhitelistedContractAddressAttribute) GetIsfile() bool {
	if x != nil {
		return x.Isfile
	}
	return false
}

type InternalAddress struct {
	state         protoimpl.MessageState `protogen:"open.v1"`
	Id            uint64                 `protobuf:"varint,1,opt,name=id,proto3" json:"id,omitempty"`
	Address       string                 `protobuf:"bytes,2,opt,name=address,proto3" json:"address,omitempty"`
	Label         string                 `protobuf:"bytes,3,opt,name=label,proto3" json:"label,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *InternalAddress) Reset() {
	*x = InternalAddress{}
	mi := &file_whitelist_proto_msgTypes[10]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *InternalAddress) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*InternalAddress) ProtoMessage() {}

func (x *InternalAddress) ProtoReflect() protoreflect.Message {
	mi := &file_whitelist_proto_msgTypes[10]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use InternalAddress.ProtoReflect.Descriptor instead.
func (*InternalAddress) Descriptor() ([]byte, []int) {
	return file_whitelist_proto_rawDescGZIP(), []int{10}
}

func (x *InternalAddress) GetId() uint64 {
	if x != nil {
		return x.Id
	}
	return 0
}

func (x *InternalAddress) GetAddress() string {
	if x != nil {
		return x.Address
	}
	return ""
}

func (x *InternalAddress) GetLabel() string {
	if x != nil {
		return x.Label
	}
	return ""
}

type InternalWallet struct {
	state         protoimpl.MessageState `protogen:"open.v1"`
	Id            uint64                 `protobuf:"varint,1,opt,name=id,proto3" json:"id,omitempty"`
	Name          string                 `protobuf:"bytes,2,opt,name=name,proto3" json:"name,omitempty"`
	Path          string                 `protobuf:"bytes,3,opt,name=path,proto3" json:"path,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *InternalWallet) Reset() {
	*x = InternalWallet{}
	mi := &file_whitelist_proto_msgTypes[11]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *InternalWallet) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*InternalWallet) ProtoMessage() {}

func (x *InternalWallet) ProtoReflect() protoreflect.Message {
	mi := &file_whitelist_proto_msgTypes[11]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use InternalWallet.ProtoReflect.Descriptor instead.
func (*InternalWallet) Descriptor() ([]byte, []int) {
	return file_whitelist_proto_rawDescGZIP(), []int{11}
}

func (x *InternalWallet) GetId() uint64 {
	if x != nil {
		return x.Id
	}
	return 0
}

func (x *InternalWallet) GetName() string {
	if x != nil {
		return x.Name
	}
	return ""
}

func (x *InternalWallet) GetPath() string {
	if x != nil {
		return x.Path
	}
	return ""
}

type SignedWhitelistedContractAddress struct {
	state         protoimpl.MessageState `protogen:"open.v1"`
	Signatures    []*WhitelistSignature  `protobuf:"bytes,1,rep,name=signatures,proto3" json:"signatures,omitempty"`
	Payload       []byte                 `protobuf:"bytes,2,opt,name=payload,proto3" json:"payload,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *SignedWhitelistedContractAddress) Reset() {
	*x = SignedWhitelistedContractAddress{}
	mi := &file_whitelist_proto_msgTypes[12]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *SignedWhitelistedContractAddress) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*SignedWhitelistedContractAddress) ProtoMessage() {}

func (x *SignedWhitelistedContractAddress) ProtoReflect() protoreflect.Message {
	mi := &file_whitelist_proto_msgTypes[12]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use SignedWhitelistedContractAddress.ProtoReflect.Descriptor instead.
func (*SignedWhitelistedContractAddress) Descriptor() ([]byte, []int) {
	return file_whitelist_proto_rawDescGZIP(), []int{12}
}

func (x *SignedWhitelistedContractAddress) GetSignatures() []*WhitelistSignature {
	if x != nil {
		return x.Signatures
	}
	return nil
}

func (x *SignedWhitelistedContractAddress) GetPayload() []byte {
	if x != nil {
		return x.Payload
	}
	return nil
}

type WhitelistedContractAddress struct {
	state           protoimpl.MessageState `protogen:"open.v1"`
	Blockchain      string                 `protobuf:"bytes,1,opt,name=blockchain,proto3" json:"blockchain,omitempty"`
	Name            string                 `protobuf:"bytes,2,opt,name=name,proto3" json:"name,omitempty"`
	Symbol          string                 `protobuf:"bytes,3,opt,name=symbol,proto3" json:"symbol,omitempty"`
	Decimals        uint64                 `protobuf:"varint,4,opt,name=decimals,proto3" json:"decimals,omitempty"`
	ContractAddress string                 `protobuf:"bytes,5,opt,name=contractAddress,proto3" json:"contractAddress,omitempty"`
	TokenId         string                 `protobuf:"bytes,6,opt,name=tokenId,proto3" json:"tokenId,omitempty"` // XTZ FA2, ERC721, ERC1155
	Kind            string                 `protobuf:"bytes,7,opt,name=kind,proto3" json:"kind,omitempty"`
	Network         string                 `protobuf:"bytes,8,opt,name=network,proto3" json:"network,omitempty"`
	unknownFields   protoimpl.UnknownFields
	sizeCache       protoimpl.SizeCache
}

func (x *WhitelistedContractAddress) Reset() {
	*x = WhitelistedContractAddress{}
	mi := &file_whitelist_proto_msgTypes[13]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *WhitelistedContractAddress) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*WhitelistedContractAddress) ProtoMessage() {}

func (x *WhitelistedContractAddress) ProtoReflect() protoreflect.Message {
	mi := &file_whitelist_proto_msgTypes[13]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use WhitelistedContractAddress.ProtoReflect.Descriptor instead.
func (*WhitelistedContractAddress) Descriptor() ([]byte, []int) {
	return file_whitelist_proto_rawDescGZIP(), []int{13}
}

func (x *WhitelistedContractAddress) GetBlockchain() string {
	if x != nil {
		return x.Blockchain
	}
	return ""
}

func (x *WhitelistedContractAddress) GetName() string {
	if x != nil {
		return x.Name
	}
	return ""
}

func (x *WhitelistedContractAddress) GetSymbol() string {
	if x != nil {
		return x.Symbol
	}
	return ""
}

func (x *WhitelistedContractAddress) GetDecimals() uint64 {
	if x != nil {
		return x.Decimals
	}
	return 0
}

func (x *WhitelistedContractAddress) GetContractAddress() string {
	if x != nil {
		return x.ContractAddress
	}
	return ""
}

func (x *WhitelistedContractAddress) GetTokenId() string {
	if x != nil {
		return x.TokenId
	}
	return ""
}

func (x *WhitelistedContractAddress) GetKind() string {
	if x != nil {
		return x.Kind
	}
	return ""
}

func (x *WhitelistedContractAddress) GetNetwork() string {
	if x != nil {
		return x.Network
	}
	return ""
}

type WhitelistedAddressBatchSignature_WhitelistedAddressSignature struct {
	state                protoimpl.MessageState `protogen:"open.v1"`
	ID                   uint64                 `protobuf:"varint,1,opt,name=ID,proto3" json:"ID,omitempty"`
	TenantID             uint64                 `protobuf:"varint,2,opt,name=TenantID,proto3" json:"TenantID,omitempty"`
	BatchSignatureID     uint64                 `protobuf:"varint,3,opt,name=BatchSignatureID,proto3" json:"BatchSignatureID,omitempty"`
	WhitelistedAddressID uint64                 `protobuf:"varint,4,opt,name=WhitelistedAddressID,proto3" json:"WhitelistedAddressID,omitempty"`
	MetadataHash         string                 `protobuf:"bytes,5,opt,name=MetadataHash,proto3" json:"MetadataHash,omitempty"`
	Status               string                 `protobuf:"bytes,6,opt,name=Status,proto3" json:"Status,omitempty"`
	Message              string                 `protobuf:"bytes,7,opt,name=Message,proto3" json:"Message,omitempty"`
	CreationDate         *timestamppb.Timestamp `protobuf:"bytes,8,opt,name=CreationDate,proto3" json:"CreationDate,omitempty"`
	UpdateDate           *timestamppb.Timestamp `protobuf:"bytes,9,opt,name=UpdateDate,proto3" json:"UpdateDate,omitempty"`
	unknownFields        protoimpl.UnknownFields
	sizeCache            protoimpl.SizeCache
}

func (x *WhitelistedAddressBatchSignature_WhitelistedAddressSignature) Reset() {
	*x = WhitelistedAddressBatchSignature_WhitelistedAddressSignature{}
	mi := &file_whitelist_proto_msgTypes[14]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *WhitelistedAddressBatchSignature_WhitelistedAddressSignature) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*WhitelistedAddressBatchSignature_WhitelistedAddressSignature) ProtoMessage() {}

func (x *WhitelistedAddressBatchSignature_WhitelistedAddressSignature) ProtoReflect() protoreflect.Message {
	mi := &file_whitelist_proto_msgTypes[14]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use WhitelistedAddressBatchSignature_WhitelistedAddressSignature.ProtoReflect.Descriptor instead.
func (*WhitelistedAddressBatchSignature_WhitelistedAddressSignature) Descriptor() ([]byte, []int) {
	return file_whitelist_proto_rawDescGZIP(), []int{0, 0}
}

func (x *WhitelistedAddressBatchSignature_WhitelistedAddressSignature) GetID() uint64 {
	if x != nil {
		return x.ID
	}
	return 0
}

func (x *WhitelistedAddressBatchSignature_WhitelistedAddressSignature) GetTenantID() uint64 {
	if x != nil {
		return x.TenantID
	}
	return 0
}

func (x *WhitelistedAddressBatchSignature_WhitelistedAddressSignature) GetBatchSignatureID() uint64 {
	if x != nil {
		return x.BatchSignatureID
	}
	return 0
}

func (x *WhitelistedAddressBatchSignature_WhitelistedAddressSignature) GetWhitelistedAddressID() uint64 {
	if x != nil {
		return x.WhitelistedAddressID
	}
	return 0
}

func (x *WhitelistedAddressBatchSignature_WhitelistedAddressSignature) GetMetadataHash() string {
	if x != nil {
		return x.MetadataHash
	}
	return ""
}

func (x *WhitelistedAddressBatchSignature_WhitelistedAddressSignature) GetStatus() string {
	if x != nil {
		return x.Status
	}
	return ""
}

func (x *WhitelistedAddressBatchSignature_WhitelistedAddressSignature) GetMessage() string {
	if x != nil {
		return x.Message
	}
	return ""
}

func (x *WhitelistedAddressBatchSignature_WhitelistedAddressSignature) GetCreationDate() *timestamppb.Timestamp {
	if x != nil {
		return x.CreationDate
	}
	return nil
}

func (x *WhitelistedAddressBatchSignature_WhitelistedAddressSignature) GetUpdateDate() *timestamppb.Timestamp {
	if x != nil {
		return x.UpdateDate
	}
	return nil
}

var File_whitelist_proto protoreflect.FileDescriptor

const file_whitelist_proto_rawDesc = "" +
	"\n" +
	"\x0fwhitelist.proto\x12\ftgvalidatord\x1a\x0fapprovers.proto\x1a\x0ecurrency.proto\x1a\x0emetadata.proto\x1a\vscore.proto\x1a\x1fgoogle/protobuf/timestamp.proto\x1a.protoc-gen-openapiv2/options/annotations.proto\"\x9c\x06\n" +
	" WhitelistedAddressBatchSignature\x12\x0e\n" +
	"\x02ID\x18\x01 \x01(\x04R\x02ID\x12\x1a\n" +
	"\bTenantID\x18\x02 \x01(\x04R\bTenantID\x12\x16\n" +
	"\x06UserID\x18\x03 \x01(\x04R\x06UserID\x12\x1c\n" +
	"\tSignature\x18\x04 \x01(\tR\tSignature\x12\x18\n" +
	"\aComment\x18\x05 \x01(\tR\aComment\x12\x16\n" +
	"\x06Status\x18\x06 \x01(\tR\x06Status\x12>\n" +
	"\fCreationDate\x18\a \x01(\v2\x1a.google.protobuf.TimestampR\fCreationDate\x12:\n" +
	"\n" +
	"UpdateDate\x18\b \x01(\v2\x1a.google.protobuf.TimestampR\n" +
	"UpdateDate\x12j\n" +
	"\n" +
	"signatures\x18\t \x03(\v2J.tgvalidatord.WhitelistedAddressBatchSignature.WhitelistedAddressSignatureR\n" +
	"signatures\x1a\xfb\x02\n" +
	"\x1bWhitelistedAddressSignature\x12\x0e\n" +
	"\x02ID\x18\x01 \x01(\x04R\x02ID\x12\x1a\n" +
	"\bTenantID\x18\x02 \x01(\x04R\bTenantID\x12*\n" +
	"\x10BatchSignatureID\x18\x03 \x01(\x04R\x10BatchSignatureID\x122\n" +
	"\x14WhitelistedAddressID\x18\x04 \x01(\x04R\x14WhitelistedAddressID\x12\"\n" +
	"\fMetadataHash\x18\x05 \x01(\tR\fMetadataHash\x12\x16\n" +
	"\x06Status\x18\x06 \x01(\tR\x06Status\x12\x18\n" +
	"\aMessage\x18\a \x01(\tR\aMessage\x12>\n" +
	"\fCreationDate\x18\b \x01(\v2\x1a.google.protobuf.TimestampR\fCreationDate\x12:\n" +
	"\n" +
	"UpdateDate\x18\t \x01(\v2\x1a.google.protobuf.TimestampR\n" +
	"UpdateDate\"\xb9\x01\n" +
	"\x05Trail\x12\x0e\n" +
	"\x02id\x18\x01 \x01(\x04R\x02id\x12\x16\n" +
	"\x06userId\x18\x02 \x01(\x04R\x06userId\x12&\n" +
	"\x0eexternalUserId\x18\x03 \x01(\tR\x0eexternalUserId\x12\x16\n" +
	"\x06action\x18\x04 \x01(\tR\x06action\x12\x18\n" +
	"\acomment\x18\x05 \x01(\tR\acomment\x12.\n" +
	"\x04date\x18\x06 \x01(\v2\x1a.google.protobuf.TimestampR\x04date\"\xca\x06\n" +
	" SignedWhitelistedAddressEnvelope\x12\x0e\n" +
	"\x02id\x18\x01 \x01(\x04R\x02id\x12\x1a\n" +
	"\btenantId\x18\x02 \x01(\x04R\btenantId\x12L\n" +
	"\rsignedAddress\x18\x03 \x01(\v2&.tgvalidatord.SignedWhitelistedAddressR\rsignedAddress\x122\n" +
	"\bmetadata\x18\x04 \x01(\v2\x16.tgvalidatord.MetadataR\bmetadata\x12\x16\n" +
	"\x06action\x18\x05 \x01(\tR\x06action\x12+\n" +
	"\x06scores\x18\x06 \x03(\v2\x13.tgvalidatord.ScoreR\x06scores\x12+\n" +
	"\x06trails\x18\a \x03(\v2\x13.tgvalidatord.TrailR\x06trails\x12&\n" +
	"\x0erulesContainer\x18\b \x01(\tR\x0erulesContainer\x12\x12\n" +
	"\x04rule\x18\t \x01(\tR\x04rule\x125\n" +
	"\tapprovers\x18\n" +
	" \x01(\v2\x17.tgvalidatord.ApproversR\tapprovers\x12I\n" +
	"\n" +
	"attributes\x18\v \x03(\v2).tgvalidatord.WhitelistedAddressAttributeR\n" +
	"attributes\x12.\n" +
	"\x12rulesContainerHash\x18\f \x01(\tR\x12rulesContainerHash\x12\x1e\n" +
	"\n" +
	"blockchain\x18\x0e \x01(\tR\n" +
	"blockchain\x12\x16\n" +
	"\x06status\x18\x0f \x01(\tR\x06status\x12\x18\n" +
	"\anetwork\x18\x10 \x01(\tR\anetwork\x12,\n" +
	"\x11visibilityGroupID\x18\x11 \x01(\tR\x11visibilityGroupID\x12(\n" +
	"\x0ftnParticipantID\x18\x12 \x01(\tR\x0ftnParticipantID\x12n\n" +
	"\x0frulesSignatures\x18\x13 \x01(\tBD\x92AA2?(super-admin) Signature of rule container used for verificationR\x0frulesSignatures\"\xe9\x06\n" +
	"(SignedWhitelistedContractAddressEnvelope\x12\x0e\n" +
	"\x02id\x18\x01 \x01(\x04R\x02id\x12\x1a\n" +
	"\btenantId\x18\x02 \x01(\x04R\btenantId\x12d\n" +
	"\x15signedContractAddress\x18\x03 \x01(\v2..tgvalidatord.SignedWhitelistedContractAddressR\x15signedContractAddress\x122\n" +
	"\bmetadata\x18\x04 \x01(\v2\x16.tgvalidatord.MetadataR\bmetadata\x12\x16\n" +
	"\x06action\x18\x05 \x01(\tR\x06action\x12+\n" +
	"\x06trails\x18\x06 \x03(\v2\x13.tgvalidatord.TrailR\x06trails\x12&\n" +
	"\x0erulesContainer\x18\b \x01(\tR\x0erulesContainer\x12\x12\n" +
	"\x04rule\x18\t \x01(\tR\x04rule\x125\n" +
	"\tapprovers\x18\n" +
	" \x01(\v2\x17.tgvalidatord.ApproversR\tapprovers\x12Q\n" +
	"\n" +
	"attributes\x18\v \x03(\v21.tgvalidatord.WhitelistedContractAddressAttributeR\n" +
	"attributes\x12\x16\n" +
	"\x06status\x18\f \x01(\tR\x06status\x12\x1e\n" +
	"\n" +
	"blockchain\x18\r \x01(\tR\n" +
	"blockchain\x12\x18\n" +
	"\anetwork\x18\x0e \x01(\tR\anetwork\x12\xa9\x01\n" +
	"\x13businessRuleEnabled\x18\x0f \x01(\bBw\x92At2rcurrency business rule status: set to true/false if the related currency is enabled/disabled in the business rulesR\x13businessRuleEnabled\x12n\n" +
	"\x0frulesSignatures\x18\x10 \x01(\tBD\x92AA2?(super-admin) Signature of rule container used for verificationR\x0frulesSignatures\"h\n" +
	"\x16WhitelistUserSignature\x12\x16\n" +
	"\x06userId\x18\x01 \x01(\tR\x06userId\x12\x1c\n" +
	"\tsignature\x18\x02 \x01(\fR\tsignature\x12\x18\n" +
	"\acomment\x18\x03 \x01(\tR\acomment\"p\n" +
	"\x12WhitelistSignature\x12B\n" +
	"\tsignature\x18\x01 \x01(\v2$.tgvalidatord.WhitelistUserSignatureR\tsignature\x12\x16\n" +
	"\x06hashes\x18\x02 \x03(\tR\x06hashes\"v\n" +
	"\x18SignedWhitelistedAddress\x12@\n" +
	"\n" +
	"signatures\x18\x01 \x03(\v2 .tgvalidatord.WhitelistSignatureR\n" +
	"signatures\x12\x18\n" +
	"\apayload\x18\x02 \x01(\fR\apayload\"\xe6\x05\n" +
	"\x12WhitelistedAddress\x12\x1e\n" +
	"\n" +
	"blockchain\x18\x01 \x01(\tR\n" +
	"blockchain\x12N\n" +
	"\vaddressType\x18\x02 \x01(\x0e2,.tgvalidatord.WhitelistedAddress.AddressTypeR\vaddressType\x12\x18\n" +
	"\aaddress\x18\x03 \x01(\tR\aaddress\x12\x12\n" +
	"\x04memo\x18\x04 \x01(\tR\x04memo\x12\x14\n" +
	"\x05label\x18\x05 \x01(\tR\x05label\x12\x1e\n" +
	"\n" +
	"customerId\x18\x06 \x01(\tR\n" +
	"customerId\x12,\n" +
	"\x11exchangeAccountId\x18\a \x01(\x04R\x11exchangeAccountId\x12W\n" +
	"\x17linkedInternalAddresses\x18\b \x03(\v2\x1d.tgvalidatord.InternalAddressR\x17linkedInternalAddresses\x12\"\n" +
	"\fcontractType\x18\t \x01(\tR\fcontractType\x12I\n" +
	"\n" +
	"attributes\x18\n" +
	" \x03(\v2).tgvalidatord.WhitelistedAddressAttributeR\n" +
	"attributes\x12B\n" +
	"\rlinkedWallets\x18\v \x03(\v2\x1c.tgvalidatord.InternalWalletR\rlinkedWallets\x12\x18\n" +
	"\anetwork\x18\r \x01(\tR\anetwork\x12(\n" +
	"\x0ftnParticipantID\x18\x0e \x01(\tR\x0ftnParticipantID\"~\n" +
	"\vAddressType\x12\x0e\n" +
	"\n" +
	"individual\x10\x00\x12\f\n" +
	"\bexchange\x10\x01\x12\t\n" +
	"\x05baker\x10\x02\x12\f\n" +
	"\bcontract\x10\x03\x12\r\n" +
	"\tstakepool\x10\x04\x12\r\n" +
	"\tvalidator\x10\x05\x12\b\n" +
	"\x04node\x10\x06\x12\x10\n" +
	"\ffiatprovider\x10\a\"\xd3\x01\n" +
	"\x1bWhitelistedAddressAttribute\x12\x0e\n" +
	"\x02id\x18\x01 \x01(\x04R\x02id\x12\x10\n" +
	"\x03key\x18\x02 \x01(\tR\x03key\x12\x14\n" +
	"\x05value\x18\x03 \x01(\tR\x05value\x12 \n" +
	"\vcontentType\x18\x04 \x01(\tR\vcontentType\x12\x14\n" +
	"\x05owner\x18\x05 \x01(\tR\x05owner\x12\x12\n" +
	"\x04type\x18\x06 \x01(\tR\x04type\x12\x18\n" +
	"\asubtype\x18\a \x01(\tR\asubtype\x12\x16\n" +
	"\x06isfile\x18\b \x01(\bR\x06isfile\"\xdb\x01\n" +
	"#WhitelistedContractAddressAttribute\x12\x0e\n" +
	"\x02id\x18\x01 \x01(\x04R\x02id\x12\x10\n" +
	"\x03key\x18\x02 \x01(\tR\x03key\x12\x14\n" +
	"\x05value\x18\x03 \x01(\tR\x05value\x12 \n" +
	"\vcontentType\x18\x04 \x01(\tR\vcontentType\x12\x14\n" +
	"\x05owner\x18\x05 \x01(\tR\x05owner\x12\x12\n" +
	"\x04type\x18\x06 \x01(\tR\x04type\x12\x18\n" +
	"\asubtype\x18\a \x01(\tR\asubtype\x12\x16\n" +
	"\x06isfile\x18\b \x01(\bR\x06isfile\"Q\n" +
	"\x0fInternalAddress\x12\x0e\n" +
	"\x02id\x18\x01 \x01(\x04R\x02id\x12\x18\n" +
	"\aaddress\x18\x02 \x01(\tR\aaddress\x12\x14\n" +
	"\x05label\x18\x03 \x01(\tR\x05label\"H\n" +
	"\x0eInternalWallet\x12\x0e\n" +
	"\x02id\x18\x01 \x01(\x04R\x02id\x12\x12\n" +
	"\x04name\x18\x02 \x01(\tR\x04name\x12\x12\n" +
	"\x04path\x18\x03 \x01(\tR\x04path\"~\n" +
	" SignedWhitelistedContractAddress\x12@\n" +
	"\n" +
	"signatures\x18\x01 \x03(\v2 .tgvalidatord.WhitelistSignatureR\n" +
	"signatures\x12\x18\n" +
	"\apayload\x18\x02 \x01(\fR\apayload\"\xf6\x01\n" +
	"\x1aWhitelistedContractAddress\x12\x1e\n" +
	"\n" +
	"blockchain\x18\x01 \x01(\tR\n" +
	"blockchain\x12\x12\n" +
	"\x04name\x18\x02 \x01(\tR\x04name\x12\x16\n" +
	"\x06symbol\x18\x03 \x01(\tR\x06symbol\x12\x1a\n" +
	"\bdecimals\x18\x04 \x01(\x04R\bdecimals\x12(\n" +
	"\x0fcontractAddress\x18\x05 \x01(\tR\x0fcontractAddress\x12\x18\n" +
	"\atokenId\x18\x06 \x01(\tR\atokenId\x12\x12\n" +
	"\x04kind\x18\a \x01(\tR\x04kind\x12\x18\n" +
	"\anetwork\x18\b \x01(\tR\anetwork*\x93\x02\n" +
	"\x1eWhitelistedContractAddressKind\x12\r\n" +
	"\t_default_\x10\x00\x12\f\n" +
	"\bNFT_AUTO\x10\x01\x12\x0f\n" +
	"\vNFT_XTZ_FA2\x10\x02\x12\x16\n" +
	"\x0eNFT_ETH_ERC721\x10\x03\x1a\x02\b\x01\x12\x17\n" +
	"\x0fNFT_ETH_ERC1155\x10\x04\x1a\x02\b\x01\x12\x12\n" +
	"\x0eNFT_EVM_ERC721\x10\x05\x12\x13\n" +
	"\x0fNFT_EVM_ERC1155\x10\x06\x12\r\n" +
	"\tSOL_TOKEN\x10\a\x12\x11\n" +
	"\rSOL_TOKEN2022\x10\b\x12\x17\n" +
	"\x13NFT_EVM_CRYPTOPUNKS\x10\t\x12\x17\n" +
	"\x13HEDERA_NATIVE_TOKEN\x10\n" +
	"\x12\x15\n" +
	"\x11HEDERA_NATIVE_NFT\x10\vB#\n" +
	"!com.taurushq.sdk.protect.proto.v1b\x06proto3"

var (
	file_whitelist_proto_rawDescOnce sync.Once
	file_whitelist_proto_rawDescData []byte
)

func file_whitelist_proto_rawDescGZIP() []byte {
	file_whitelist_proto_rawDescOnce.Do(func() {
		file_whitelist_proto_rawDescData = protoimpl.X.CompressGZIP(unsafe.Slice(unsafe.StringData(file_whitelist_proto_rawDesc), len(file_whitelist_proto_rawDesc)))
	})
	return file_whitelist_proto_rawDescData
}

var file_whitelist_proto_enumTypes = make([]protoimpl.EnumInfo, 2)
var file_whitelist_proto_msgTypes = make([]protoimpl.MessageInfo, 15)
var file_whitelist_proto_goTypes = []any{
	(WhitelistedContractAddressKind)(0),                                  // 0: tgvalidatord.WhitelistedContractAddressKind
	(WhitelistedAddress_AddressType)(0),                                  // 1: tgvalidatord.WhitelistedAddress.AddressType
	(*WhitelistedAddressBatchSignature)(nil),                             // 2: tgvalidatord.WhitelistedAddressBatchSignature
	(*Trail)(nil),                                                        // 3: tgvalidatord.Trail
	(*SignedWhitelistedAddressEnvelope)(nil),                             // 4: tgvalidatord.SignedWhitelistedAddressEnvelope
	(*SignedWhitelistedContractAddressEnvelope)(nil),                     // 5: tgvalidatord.SignedWhitelistedContractAddressEnvelope
	(*WhitelistUserSignature)(nil),                                       // 6: tgvalidatord.WhitelistUserSignature
	(*WhitelistSignature)(nil),                                           // 7: tgvalidatord.WhitelistSignature
	(*SignedWhitelistedAddress)(nil),                                     // 8: tgvalidatord.SignedWhitelistedAddress
	(*WhitelistedAddress)(nil),                                           // 9: tgvalidatord.WhitelistedAddress
	(*WhitelistedAddressAttribute)(nil),                                  // 10: tgvalidatord.WhitelistedAddressAttribute
	(*WhitelistedContractAddressAttribute)(nil),                          // 11: tgvalidatord.WhitelistedContractAddressAttribute
	(*InternalAddress)(nil),                                              // 12: tgvalidatord.InternalAddress
	(*InternalWallet)(nil),                                               // 13: tgvalidatord.InternalWallet
	(*SignedWhitelistedContractAddress)(nil),                             // 14: tgvalidatord.SignedWhitelistedContractAddress
	(*WhitelistedContractAddress)(nil),                                   // 15: tgvalidatord.WhitelistedContractAddress
	(*WhitelistedAddressBatchSignature_WhitelistedAddressSignature)(nil), // 16: tgvalidatord.WhitelistedAddressBatchSignature.WhitelistedAddressSignature
	(*timestamppb.Timestamp)(nil),                                        // 17: google.protobuf.Timestamp
	(*Metadata)(nil),                                                     // 18: tgvalidatord.Metadata
	(*Score)(nil),                                                        // 19: tgvalidatord.Score
	(*Approvers)(nil),                                                    // 20: tgvalidatord.Approvers
}
var file_whitelist_proto_depIdxs = []int32{
	17, // 0: tgvalidatord.WhitelistedAddressBatchSignature.CreationDate:type_name -> google.protobuf.Timestamp
	17, // 1: tgvalidatord.WhitelistedAddressBatchSignature.UpdateDate:type_name -> google.protobuf.Timestamp
	16, // 2: tgvalidatord.WhitelistedAddressBatchSignature.signatures:type_name -> tgvalidatord.WhitelistedAddressBatchSignature.WhitelistedAddressSignature
	17, // 3: tgvalidatord.Trail.date:type_name -> google.protobuf.Timestamp
	8,  // 4: tgvalidatord.SignedWhitelistedAddressEnvelope.signedAddress:type_name -> tgvalidatord.SignedWhitelistedAddress
	18, // 5: tgvalidatord.SignedWhitelistedAddressEnvelope.metadata:type_name -> tgvalidatord.Metadata
	19, // 6: tgvalidatord.SignedWhitelistedAddressEnvelope.scores:type_name -> tgvalidatord.Score
	3,  // 7: tgvalidatord.SignedWhitelistedAddressEnvelope.trails:type_name -> tgvalidatord.Trail
	20, // 8: tgvalidatord.SignedWhitelistedAddressEnvelope.approvers:type_name -> tgvalidatord.Approvers
	10, // 9: tgvalidatord.SignedWhitelistedAddressEnvelope.attributes:type_name -> tgvalidatord.WhitelistedAddressAttribute
	14, // 10: tgvalidatord.SignedWhitelistedContractAddressEnvelope.signedContractAddress:type_name -> tgvalidatord.SignedWhitelistedContractAddress
	18, // 11: tgvalidatord.SignedWhitelistedContractAddressEnvelope.metadata:type_name -> tgvalidatord.Metadata
	3,  // 12: tgvalidatord.SignedWhitelistedContractAddressEnvelope.trails:type_name -> tgvalidatord.Trail
	20, // 13: tgvalidatord.SignedWhitelistedContractAddressEnvelope.approvers:type_name -> tgvalidatord.Approvers
	11, // 14: tgvalidatord.SignedWhitelistedContractAddressEnvelope.attributes:type_name -> tgvalidatord.WhitelistedContractAddressAttribute
	6,  // 15: tgvalidatord.WhitelistSignature.signature:type_name -> tgvalidatord.WhitelistUserSignature
	7,  // 16: tgvalidatord.SignedWhitelistedAddress.signatures:type_name -> tgvalidatord.WhitelistSignature
	1,  // 17: tgvalidatord.WhitelistedAddress.addressType:type_name -> tgvalidatord.WhitelistedAddress.AddressType
	12, // 18: tgvalidatord.WhitelistedAddress.linkedInternalAddresses:type_name -> tgvalidatord.InternalAddress
	10, // 19: tgvalidatord.WhitelistedAddress.attributes:type_name -> tgvalidatord.WhitelistedAddressAttribute
	13, // 20: tgvalidatord.WhitelistedAddress.linkedWallets:type_name -> tgvalidatord.InternalWallet
	7,  // 21: tgvalidatord.SignedWhitelistedContractAddress.signatures:type_name -> tgvalidatord.WhitelistSignature
	17, // 22: tgvalidatord.WhitelistedAddressBatchSignature.WhitelistedAddressSignature.CreationDate:type_name -> google.protobuf.Timestamp
	17, // 23: tgvalidatord.WhitelistedAddressBatchSignature.WhitelistedAddressSignature.UpdateDate:type_name -> google.protobuf.Timestamp
	24, // [24:24] is the sub-list for method output_type
	24, // [24:24] is the sub-list for method input_type
	24, // [24:24] is the sub-list for extension type_name
	24, // [24:24] is the sub-list for extension extendee
	0,  // [0:24] is the sub-list for field type_name
}

func init() { file_whitelist_proto_init() }
func file_whitelist_proto_init() {
	if File_whitelist_proto != nil {
		return
	}
	file_approvers_proto_init()
	file_currency_proto_init()
	file_metadata_proto_init()
	file_score_proto_init()
	type x struct{}
	out := protoimpl.TypeBuilder{
		File: protoimpl.DescBuilder{
			GoPackagePath: reflect.TypeOf(x{}).PkgPath(),
			RawDescriptor: unsafe.Slice(unsafe.StringData(file_whitelist_proto_rawDesc), len(file_whitelist_proto_rawDesc)),
			NumEnums:      2,
			NumMessages:   15,
			NumExtensions: 0,
			NumServices:   0,
		},
		GoTypes:           file_whitelist_proto_goTypes,
		DependencyIndexes: file_whitelist_proto_depIdxs,
		EnumInfos:         file_whitelist_proto_enumTypes,
		MessageInfos:      file_whitelist_proto_msgTypes,
	}.Build()
	File_whitelist_proto = out.File
	file_whitelist_proto_goTypes = nil
	file_whitelist_proto_depIdxs = nil
}
