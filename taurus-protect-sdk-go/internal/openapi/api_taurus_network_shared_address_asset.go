/*
Taurus-PROTECT APIs

Taurus-PROTECT APIs description

API version: 1.0
*/

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package openapi

import (
	"bytes"
	"context"
	"io"
	"net/http"
	"net/url"
	"strings"
	"reflect"
)


// TaurusNetworkSharedAddressAssetAPIService TaurusNetworkSharedAddressAssetAPI service
type TaurusNetworkSharedAddressAssetAPIService service

type ApiTaurusNetworkServiceGetSharedAddressesRequest struct {
	ctx context.Context
	ApiService *TaurusNetworkSharedAddressAssetAPIService
	participantID *string
	ownerParticipantID *string
	targetParticipantID *string
	blockchain *string
	network *string
	ids *[]string
	sortOrder *string
	cursorCurrentPage *string
	cursorPageRequest *string
	cursorPageSize *string
	statuses *[]string
}

// Get all the shared addresses where the participantID is either the owner or the target of the shared address.
func (r ApiTaurusNetworkServiceGetSharedAddressesRequest) ParticipantID(participantID string) ApiTaurusNetworkServiceGetSharedAddressesRequest {
	r.participantID = &participantID
	return r
}

// Filter shared addresses by specifying who is the owner of the shared addresses (your participant or the counterparty)
func (r ApiTaurusNetworkServiceGetSharedAddressesRequest) OwnerParticipantID(ownerParticipantID string) ApiTaurusNetworkServiceGetSharedAddressesRequest {
	r.ownerParticipantID = &ownerParticipantID
	return r
}

// Filter shared addresses by specifying who is the target of the shared addresses (your participant or the counterparty)
func (r ApiTaurusNetworkServiceGetSharedAddressesRequest) TargetParticipantID(targetParticipantID string) ApiTaurusNetworkServiceGetSharedAddressesRequest {
	r.targetParticipantID = &targetParticipantID
	return r
}

// Filter shared addresses by specifying the blockchain of the shared addresses
func (r ApiTaurusNetworkServiceGetSharedAddressesRequest) Blockchain(blockchain string) ApiTaurusNetworkServiceGetSharedAddressesRequest {
	r.blockchain = &blockchain
	return r
}

// Filter shared addresses by specifying the network of the shared addresses. It must be used in combination with the blockchain filter.
func (r ApiTaurusNetworkServiceGetSharedAddressesRequest) Network(network string) ApiTaurusNetworkServiceGetSharedAddressesRequest {
	r.network = &network
	return r
}

// Filter shared addresses by specifying the shared address IDs
func (r ApiTaurusNetworkServiceGetSharedAddressesRequest) Ids(ids []string) ApiTaurusNetworkServiceGetSharedAddressesRequest {
	r.ids = &ids
	return r
}

// Set this parameter to ASC to get the id sorted in ASC order or DESC to get them in descending order. By default, the order is DESC.
func (r ApiTaurusNetworkServiceGetSharedAddressesRequest) SortOrder(sortOrder string) ApiTaurusNetworkServiceGetSharedAddressesRequest {
	r.sortOrder = &sortOrder
	return r
}

// Base64-encoded string representing the current window of data
func (r ApiTaurusNetworkServiceGetSharedAddressesRequest) CursorCurrentPage(cursorCurrentPage string) ApiTaurusNetworkServiceGetSharedAddressesRequest {
	r.cursorCurrentPage = &cursorCurrentPage
	return r
}

// The page to request, w.r.t the current page. Can be one of &#x60;FIRST&#x60;, &#x60;PREVIOUS&#x60;, &#x60;NEXT&#x60;, &#x60;LAST&#x60;
func (r ApiTaurusNetworkServiceGetSharedAddressesRequest) CursorPageRequest(cursorPageRequest string) ApiTaurusNetworkServiceGetSharedAddressesRequest {
	r.cursorPageRequest = &cursorPageRequest
	return r
}

// The size of the page requested. The handling service should impose a hard limit on this
func (r ApiTaurusNetworkServiceGetSharedAddressesRequest) CursorPageSize(cursorPageSize string) ApiTaurusNetworkServiceGetSharedAddressesRequest {
	r.cursorPageSize = &cursorPageSize
	return r
}

// Filter shared addresses by specifying a list of statuses. Accepted status values:  &#39;new&#39;, &#39;pending&#39;, &#39;rejected&#39;, &#39;accepted&#39;, &#39;unshared&#39;
func (r ApiTaurusNetworkServiceGetSharedAddressesRequest) Statuses(statuses []string) ApiTaurusNetworkServiceGetSharedAddressesRequest {
	r.statuses = &statuses
	return r
}

func (r ApiTaurusNetworkServiceGetSharedAddressesRequest) Execute() (*TgvalidatordGetSharedAddressesReply, *http.Response, error) {
	return r.ApiService.TaurusNetworkServiceGetSharedAddressesExecute(r)
}

/*
TaurusNetworkServiceGetSharedAddresses List shared addresses

This endpoint returns a list of addresses that you shared or that are shared to you via Taurus-NETWORK. You can filter the results by specifying the owner or the target of the shared addresses.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiTaurusNetworkServiceGetSharedAddressesRequest
*/
func (a *TaurusNetworkSharedAddressAssetAPIService) TaurusNetworkServiceGetSharedAddresses(ctx context.Context) ApiTaurusNetworkServiceGetSharedAddressesRequest {
	return ApiTaurusNetworkServiceGetSharedAddressesRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return TgvalidatordGetSharedAddressesReply
func (a *TaurusNetworkSharedAddressAssetAPIService) TaurusNetworkServiceGetSharedAddressesExecute(r ApiTaurusNetworkServiceGetSharedAddressesRequest) (*TgvalidatordGetSharedAddressesReply, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *TgvalidatordGetSharedAddressesReply
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "TaurusNetworkSharedAddressAssetAPIService.TaurusNetworkServiceGetSharedAddresses")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/rest/v1/tn/shared_addresses"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.participantID != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "participantID", r.participantID, "", "")
	}
	if r.ownerParticipantID != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "ownerParticipantID", r.ownerParticipantID, "", "")
	}
	if r.targetParticipantID != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "targetParticipantID", r.targetParticipantID, "", "")
	}
	if r.blockchain != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "blockchain", r.blockchain, "", "")
	}
	if r.network != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "network", r.network, "", "")
	}
	if r.ids != nil {
		t := *r.ids
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "ids", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "ids", t, "form", "multi")
		}
	}
	if r.sortOrder != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "sortOrder", r.sortOrder, "", "")
	}
	if r.cursorCurrentPage != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "cursor.currentPage", r.cursorCurrentPage, "", "")
	}
	if r.cursorPageRequest != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "cursor.pageRequest", r.cursorPageRequest, "", "")
	}
	if r.cursorPageSize != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "cursor.pageSize", r.cursorPageSize, "", "")
	}
	if r.statuses != nil {
		t := *r.statuses
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "statuses", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "statuses", t, "form", "multi")
		}
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["ApiKeyTPV1"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v map[string]interface{}
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v map[string]interface{}
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v map[string]interface{}
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v map[string]interface{}
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v map[string]interface{}
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 503 {
			var v map[string]interface{}
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
			var v GooglerpcStatus
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiTaurusNetworkServiceGetSharedAssetsRequest struct {
	ctx context.Context
	ApiService *TaurusNetworkSharedAddressAssetAPIService
	participantID *string
	ownerParticipantID *string
	targetParticipantID *string
	blockchain *string
	network *string
	ids *[]string
	sortOrder *string
	cursorCurrentPage *string
	cursorPageRequest *string
	cursorPageSize *string
	statuses *[]string
}

// Get all the shared assets where the participantID is either the owner or the target of the shared assets.
func (r ApiTaurusNetworkServiceGetSharedAssetsRequest) ParticipantID(participantID string) ApiTaurusNetworkServiceGetSharedAssetsRequest {
	r.participantID = &participantID
	return r
}

// Filter shared assets by specifying who is the owner of the shared assets (your participant or the counterparty)
func (r ApiTaurusNetworkServiceGetSharedAssetsRequest) OwnerParticipantID(ownerParticipantID string) ApiTaurusNetworkServiceGetSharedAssetsRequest {
	r.ownerParticipantID = &ownerParticipantID
	return r
}

// Filter shared assets by specifying who is the target of the shared assets (your participant or the counterparty)
func (r ApiTaurusNetworkServiceGetSharedAssetsRequest) TargetParticipantID(targetParticipantID string) ApiTaurusNetworkServiceGetSharedAssetsRequest {
	r.targetParticipantID = &targetParticipantID
	return r
}

// Filter shared assets by specifying the blockchain of the shared assets
func (r ApiTaurusNetworkServiceGetSharedAssetsRequest) Blockchain(blockchain string) ApiTaurusNetworkServiceGetSharedAssetsRequest {
	r.blockchain = &blockchain
	return r
}

// Filter shared assets by specifying the network of the shared assets. It must be used in combination with the blockchain filter.
func (r ApiTaurusNetworkServiceGetSharedAssetsRequest) Network(network string) ApiTaurusNetworkServiceGetSharedAssetsRequest {
	r.network = &network
	return r
}

// Filter shared addresses by specifying the shared asset IDs
func (r ApiTaurusNetworkServiceGetSharedAssetsRequest) Ids(ids []string) ApiTaurusNetworkServiceGetSharedAssetsRequest {
	r.ids = &ids
	return r
}

// Set this parameter to ASC to get the id sorted in ASC order or DESC to get them in descending order. By default, the order is DESC.
func (r ApiTaurusNetworkServiceGetSharedAssetsRequest) SortOrder(sortOrder string) ApiTaurusNetworkServiceGetSharedAssetsRequest {
	r.sortOrder = &sortOrder
	return r
}

// Base64-encoded string representing the current window of data
func (r ApiTaurusNetworkServiceGetSharedAssetsRequest) CursorCurrentPage(cursorCurrentPage string) ApiTaurusNetworkServiceGetSharedAssetsRequest {
	r.cursorCurrentPage = &cursorCurrentPage
	return r
}

// The page to request, w.r.t the current page. Can be one of &#x60;FIRST&#x60;, &#x60;PREVIOUS&#x60;, &#x60;NEXT&#x60;, &#x60;LAST&#x60;
func (r ApiTaurusNetworkServiceGetSharedAssetsRequest) CursorPageRequest(cursorPageRequest string) ApiTaurusNetworkServiceGetSharedAssetsRequest {
	r.cursorPageRequest = &cursorPageRequest
	return r
}

// The size of the page requested. The handling service should impose a hard limit on this
func (r ApiTaurusNetworkServiceGetSharedAssetsRequest) CursorPageSize(cursorPageSize string) ApiTaurusNetworkServiceGetSharedAssetsRequest {
	r.cursorPageSize = &cursorPageSize
	return r
}

// Filter shared assets by specifying a list of statuses. Accepted status values:  &#39;new&#39;, &#39;pending&#39;, &#39;rejected&#39;, &#39;accepted&#39;, &#39;unshared&#39;
func (r ApiTaurusNetworkServiceGetSharedAssetsRequest) Statuses(statuses []string) ApiTaurusNetworkServiceGetSharedAssetsRequest {
	r.statuses = &statuses
	return r
}

func (r ApiTaurusNetworkServiceGetSharedAssetsRequest) Execute() (*TgvalidatordGetSharedAssetsReply, *http.Response, error) {
	return r.ApiService.TaurusNetworkServiceGetSharedAssetsExecute(r)
}

/*
TaurusNetworkServiceGetSharedAssets List shared assets

This endpoint returns a list of whitelisted assets that you shared or that are shared to you via Taurus-NETWORK. You can filter the results by specifying the owner or the target of the shared assets.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiTaurusNetworkServiceGetSharedAssetsRequest
*/
func (a *TaurusNetworkSharedAddressAssetAPIService) TaurusNetworkServiceGetSharedAssets(ctx context.Context) ApiTaurusNetworkServiceGetSharedAssetsRequest {
	return ApiTaurusNetworkServiceGetSharedAssetsRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return TgvalidatordGetSharedAssetsReply
func (a *TaurusNetworkSharedAddressAssetAPIService) TaurusNetworkServiceGetSharedAssetsExecute(r ApiTaurusNetworkServiceGetSharedAssetsRequest) (*TgvalidatordGetSharedAssetsReply, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *TgvalidatordGetSharedAssetsReply
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "TaurusNetworkSharedAddressAssetAPIService.TaurusNetworkServiceGetSharedAssets")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/rest/v1/tn/shared_assets"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.participantID != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "participantID", r.participantID, "", "")
	}
	if r.ownerParticipantID != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "ownerParticipantID", r.ownerParticipantID, "", "")
	}
	if r.targetParticipantID != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "targetParticipantID", r.targetParticipantID, "", "")
	}
	if r.blockchain != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "blockchain", r.blockchain, "", "")
	}
	if r.network != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "network", r.network, "", "")
	}
	if r.ids != nil {
		t := *r.ids
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "ids", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "ids", t, "form", "multi")
		}
	}
	if r.sortOrder != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "sortOrder", r.sortOrder, "", "")
	}
	if r.cursorCurrentPage != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "cursor.currentPage", r.cursorCurrentPage, "", "")
	}
	if r.cursorPageRequest != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "cursor.pageRequest", r.cursorPageRequest, "", "")
	}
	if r.cursorPageSize != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "cursor.pageSize", r.cursorPageSize, "", "")
	}
	if r.statuses != nil {
		t := *r.statuses
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "statuses", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "statuses", t, "form", "multi")
		}
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["ApiKeyTPV1"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v map[string]interface{}
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v map[string]interface{}
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v map[string]interface{}
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v map[string]interface{}
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v map[string]interface{}
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 503 {
			var v map[string]interface{}
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
			var v GooglerpcStatus
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiTaurusNetworkServiceShareAddressRequest struct {
	ctx context.Context
	ApiService *TaurusNetworkSharedAddressAssetAPIService
	body *TgvalidatordShareAddressRequest
}

func (r ApiTaurusNetworkServiceShareAddressRequest) Body(body TgvalidatordShareAddressRequest) ApiTaurusNetworkServiceShareAddressRequest {
	r.body = &body
	return r
}

func (r ApiTaurusNetworkServiceShareAddressRequest) Execute() (map[string]interface{}, *http.Response, error) {
	return r.ApiService.TaurusNetworkServiceShareAddressExecute(r)
}

/*
TaurusNetworkServiceShareAddress Share an address

This endpoint shares an internal address with a Taurus-NETWORK participant. It will automatically create a whitelisted address to be approved/rejected on the target participant side.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiTaurusNetworkServiceShareAddressRequest
*/
func (a *TaurusNetworkSharedAddressAssetAPIService) TaurusNetworkServiceShareAddress(ctx context.Context) ApiTaurusNetworkServiceShareAddressRequest {
	return ApiTaurusNetworkServiceShareAddressRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return map[string]interface{}
func (a *TaurusNetworkSharedAddressAssetAPIService) TaurusNetworkServiceShareAddressExecute(r ApiTaurusNetworkServiceShareAddressRequest) (map[string]interface{}, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  map[string]interface{}
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "TaurusNetworkSharedAddressAssetAPIService.TaurusNetworkServiceShareAddress")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/rest/v1/tn/shared_addresses"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.body == nil {
		return localVarReturnValue, nil, reportError("body is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["ApiKeyTPV1"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v map[string]interface{}
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v map[string]interface{}
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v map[string]interface{}
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v map[string]interface{}
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v map[string]interface{}
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 503 {
			var v map[string]interface{}
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
			var v GooglerpcStatus
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiTaurusNetworkServiceShareWhitelistedAssetRequest struct {
	ctx context.Context
	ApiService *TaurusNetworkSharedAddressAssetAPIService
	body *TgvalidatordShareWhitelistedAssetRequest
}

func (r ApiTaurusNetworkServiceShareWhitelistedAssetRequest) Body(body TgvalidatordShareWhitelistedAssetRequest) ApiTaurusNetworkServiceShareWhitelistedAssetRequest {
	r.body = &body
	return r
}

func (r ApiTaurusNetworkServiceShareWhitelistedAssetRequest) Execute() (map[string]interface{}, *http.Response, error) {
	return r.ApiService.TaurusNetworkServiceShareWhitelistedAssetExecute(r)
}

/*
TaurusNetworkServiceShareWhitelistedAsset Share an asset

This endpoint shares an asset with a Taurus-NETWORK participant. It will automatically create a whitelisted asset to be approved/rejected on the target participant side.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiTaurusNetworkServiceShareWhitelistedAssetRequest
*/
func (a *TaurusNetworkSharedAddressAssetAPIService) TaurusNetworkServiceShareWhitelistedAsset(ctx context.Context) ApiTaurusNetworkServiceShareWhitelistedAssetRequest {
	return ApiTaurusNetworkServiceShareWhitelistedAssetRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return map[string]interface{}
func (a *TaurusNetworkSharedAddressAssetAPIService) TaurusNetworkServiceShareWhitelistedAssetExecute(r ApiTaurusNetworkServiceShareWhitelistedAssetRequest) (map[string]interface{}, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  map[string]interface{}
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "TaurusNetworkSharedAddressAssetAPIService.TaurusNetworkServiceShareWhitelistedAsset")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/rest/v1/tn/shared_assets"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.body == nil {
		return localVarReturnValue, nil, reportError("body is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["ApiKeyTPV1"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v map[string]interface{}
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v map[string]interface{}
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v map[string]interface{}
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v map[string]interface{}
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v map[string]interface{}
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 503 {
			var v map[string]interface{}
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
			var v GooglerpcStatus
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiTaurusNetworkServiceUnshareAddressRequest struct {
	ctx context.Context
	ApiService *TaurusNetworkSharedAddressAssetAPIService
	tnSharedAddressID string
	body *map[string]interface{}
}

func (r ApiTaurusNetworkServiceUnshareAddressRequest) Body(body map[string]interface{}) ApiTaurusNetworkServiceUnshareAddressRequest {
	r.body = &body
	return r
}

func (r ApiTaurusNetworkServiceUnshareAddressRequest) Execute() (map[string]interface{}, *http.Response, error) {
	return r.ApiService.TaurusNetworkServiceUnshareAddressExecute(r)
}

/*
TaurusNetworkServiceUnshareAddress Unshare an address

This endpoint unshares an address with a Taurus-NETWORK participant. The address must be shared with the participant to be unshared. Unsharing an address will not delete shared address in the participant registry, it will update the status of the shared address.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param tnSharedAddressID The ID of the shared address to unshare.
 @return ApiTaurusNetworkServiceUnshareAddressRequest
*/
func (a *TaurusNetworkSharedAddressAssetAPIService) TaurusNetworkServiceUnshareAddress(ctx context.Context, tnSharedAddressID string) ApiTaurusNetworkServiceUnshareAddressRequest {
	return ApiTaurusNetworkServiceUnshareAddressRequest{
		ApiService: a,
		ctx: ctx,
		tnSharedAddressID: tnSharedAddressID,
	}
}

// Execute executes the request
//  @return map[string]interface{}
func (a *TaurusNetworkSharedAddressAssetAPIService) TaurusNetworkServiceUnshareAddressExecute(r ApiTaurusNetworkServiceUnshareAddressRequest) (map[string]interface{}, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  map[string]interface{}
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "TaurusNetworkSharedAddressAssetAPIService.TaurusNetworkServiceUnshareAddress")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/rest/v1/tn/shared_addresses/{tnSharedAddressID}/unshare"
	localVarPath = strings.Replace(localVarPath, "{"+"tnSharedAddressID"+"}", url.PathEscape(parameterValueToString(r.tnSharedAddressID, "tnSharedAddressID")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.body == nil {
		return localVarReturnValue, nil, reportError("body is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["ApiKeyTPV1"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v map[string]interface{}
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v map[string]interface{}
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v map[string]interface{}
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v map[string]interface{}
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v map[string]interface{}
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 503 {
			var v map[string]interface{}
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
			var v GooglerpcStatus
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiTaurusNetworkServiceUnshareWhitelistedAssetRequest struct {
	ctx context.Context
	ApiService *TaurusNetworkSharedAddressAssetAPIService
	tnSharedAssetID string
	body *map[string]interface{}
}

func (r ApiTaurusNetworkServiceUnshareWhitelistedAssetRequest) Body(body map[string]interface{}) ApiTaurusNetworkServiceUnshareWhitelistedAssetRequest {
	r.body = &body
	return r
}

func (r ApiTaurusNetworkServiceUnshareWhitelistedAssetRequest) Execute() (map[string]interface{}, *http.Response, error) {
	return r.ApiService.TaurusNetworkServiceUnshareWhitelistedAssetExecute(r)
}

/*
TaurusNetworkServiceUnshareWhitelistedAsset Unshare an asset

This endpoint unshares an asset with a Taurus-NETWORK participant. The asset must be shared with the participant to be unshared. Unsharing an asset will not delete shared asset in the participant registry, it will update the status of the shared address.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param tnSharedAssetID
 @return ApiTaurusNetworkServiceUnshareWhitelistedAssetRequest
*/
func (a *TaurusNetworkSharedAddressAssetAPIService) TaurusNetworkServiceUnshareWhitelistedAsset(ctx context.Context, tnSharedAssetID string) ApiTaurusNetworkServiceUnshareWhitelistedAssetRequest {
	return ApiTaurusNetworkServiceUnshareWhitelistedAssetRequest{
		ApiService: a,
		ctx: ctx,
		tnSharedAssetID: tnSharedAssetID,
	}
}

// Execute executes the request
//  @return map[string]interface{}
func (a *TaurusNetworkSharedAddressAssetAPIService) TaurusNetworkServiceUnshareWhitelistedAssetExecute(r ApiTaurusNetworkServiceUnshareWhitelistedAssetRequest) (map[string]interface{}, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  map[string]interface{}
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "TaurusNetworkSharedAddressAssetAPIService.TaurusNetworkServiceUnshareWhitelistedAsset")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/rest/v1/tn/shared_assets/{tnSharedAssetID}/unshare"
	localVarPath = strings.Replace(localVarPath, "{"+"tnSharedAssetID"+"}", url.PathEscape(parameterValueToString(r.tnSharedAssetID, "tnSharedAssetID")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.body == nil {
		return localVarReturnValue, nil, reportError("body is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["ApiKeyTPV1"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v map[string]interface{}
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v map[string]interface{}
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v map[string]interface{}
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v map[string]interface{}
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v map[string]interface{}
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 503 {
			var v map[string]interface{}
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
			var v GooglerpcStatus
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}
