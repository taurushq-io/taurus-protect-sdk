// Code generated by protoc-gen-ts_proto. DO NOT EDIT.
// versions:
//   protoc-gen-ts_proto  v1.181.2
//   protoc               v6.33.4
// source: request.proto

/* eslint-disable */
import Long from "long";
import _m0 from "protobufjs/minimal";
import { Approvers } from "./approvers";
import { Currency } from "./currency";
import { Timestamp } from "./google/protobuf/timestamp";
import { Metadata } from "./metadata";

export const protobufPackage = "tgvalidatord";

export interface AutoTransferEventHandler {
  id: string;
  monitoredWalletId: number;
  payerAddressId: number;
  triggerType: string;
  lastTriggeredAtBlock: string;
  lastProccessedAtBlock: string;
  attributes: AutoTransferEventHandlerAttribute[];
  status: string;
  blockchain: string;
  network: string;
  createdAt: Date | undefined;
  updatedAt: Date | undefined;
}

export interface AutoTransferEventHandlerAttribute {
  id: string;
  handlerId: string;
  key: string;
  value: string;
  contentType: string;
  owner: string;
  type: string;
  subType: string;
}

export interface CompanyTravelRuleData {
  department: string;
  buildingNumber: string;
  street: string;
  city: string;
  province: string;
  postalCode: string;
  country: string;
  legalEntityIdentifier: string;
  businessName: string;
  accountNumber: string;
}

export interface PersonTravelRuleData {
  name: string;
  houseNumber: string;
  street: string;
  city: string;
  province: string;
  postalCode: string;
  country: string;
  idNumber: string;
  externalCustomerID: string;
  birthdate: string;
  birthPlace: string;
  accountNumber: string;
}

export interface TravelRuleDataInput {
  originatorPersonTravelRuleData?: PersonTravelRuleData | undefined;
  originatorCompanyTravelRuleData?: CompanyTravelRuleData | undefined;
  beneficiaryCompanyTravelRuleData?: CompanyTravelRuleData | undefined;
  beneficiaryPersonTravelRuleData?: PersonTravelRuleData | undefined;
  provider: string;
}

export interface RequestBatchSignature {
  ID: number;
  TenantID: number;
  UserID: number;
  Signature: string;
  Comment: string;
  Status: string;
  CreationDate: Date | undefined;
  UpdateDate: Date | undefined;
  signatures: RequestBatchSignature_RequestSignature[];
}

export interface RequestBatchSignature_RequestSignature {
  ID: number;
  TenantID: number;
  BatchSignatureID: number;
  RequestID: number;
  MetadataHash: string;
  Status: string;
  Message: string;
  CreationDate: Date | undefined;
  UpdateDate: Date | undefined;
}

export interface RequestBundleDetailsSource {
  totalSources: number;
  fromWalletId: number;
  fromAddressId: number;
}

export interface RequestBundleDetailsDestination {
  totalDestinations: number;
  toAddressId: number;
  toWhitelistedAddressId: number;
}

export interface RequestBundleDetails {
  error: string;
  amount: string;
  source: RequestBundleDetailsSource | undefined;
  destination: RequestBundleDetailsDestination | undefined;
}

export interface RequestAttribute {
  id: number;
  key: string;
  value: string;
  contentType: string;
}

export interface SignedRequestAttribute {
  id: number;
  key: string;
  value: string;
  contentType: string;
}

export interface RequestBundle {
  id: number;
  tenantId: number;
  blockchain: string;
  details: RequestBundleDetails | undefined;
  status: string;
  creationDate: Date | undefined;
  updateDate:
    | Date
    | undefined;
  /** This field is not always filled in, as there can be many associated requests. */
  requests: Request[];
  network: string;
  signedRequestBundles: RequestBundle_SignedRequestBundle[];
}

export interface RequestBundle_SignedRequestBundle {
  id: number;
  status: string;
  transaction: string;
  hash: string;
  details: string;
  creationDate: Date | undefined;
  updateDate: Date | undefined;
  broadcastDate: Date | undefined;
  confirmationDate: Date | undefined;
}

export interface Request {
  id: number;
  tenantId: number;
  currency: string;
  envelope: string;
  status: string;
  trails: Request_Trail[];
  signedRequests: Request_SignedRequest[];
  creationDate: Date | undefined;
  updateDate: Date | undefined;
  metadata: Metadata | undefined;
  attributes: RequestAttribute[];
  rule: string;
  approvers: Approvers | undefined;
  type: string;
  currencyInfo: Currency | undefined;
  needsApprovalFrom: string[];
  requestBundleId: number;
  externalRequestId: string;
  travelRuleDataInput: TravelRuleDataInput | undefined;
}

export interface Request_Trail {
  id: number;
  userId: number;
  externalUserId: string;
  action: string;
  comment: string;
  date: Date | undefined;
  requestStatus: string;
}

export interface Request_SignedRequest {
  id: number;
  signedRequest: string;
  status: string;
  hash: string;
  block: number;
  details: string;
  creationDate: Date | undefined;
  updateDate: Date | undefined;
  broadcastDate: Date | undefined;
  confirmationDate: Date | undefined;
  attributes: SignedRequestAttribute[];
}

export interface ContractArgValue {
  primitive: string;
  composite: ContractArgValue[];
}

export interface ContractArg {
  name: string;
  type: string;
  value: ContractArgValue | undefined;
}

export interface ContractCall {
  functionSignature: string;
  args: ContractArg[];
}

export interface GenericContractCall {
  blockchain: string;
  /** @deprecated */
  eth: ContractCall | undefined;
  xtz: XTZContractCall | undefined;
  evm: ContractCall | undefined;
}

export interface GenericCreateContract {
  blockchain: string;
  /** @deprecated */
  eth: GenericCreateContract_EVMContract | undefined;
  xtz: GenericCreateContract_XTZContract | undefined;
  evm: GenericCreateContract_EVMContract | undefined;
}

export interface GenericCreateContract_EVMContract {
  bytecode: Uint8Array;
  constructor: ContractCall | undefined;
}

export interface GenericCreateContract_XTZContract {
  code: string;
  storage: XTZContractArg | undefined;
  delegate: GenericCreateContract_XTZContract_Delegate | undefined;
}

export interface GenericCreateContract_XTZContract_Delegate {
  toAddressId: number;
  toWhitelistedAddressId: number;
}

export interface CosmosMessageValue {
  kind: string;
  name: string;
  fieldId: number;
  value: CosmosMessageValue_Value | undefined;
}

export enum CosmosMessageValue_Kind {
  None = 0,
  Source = 1,
  Destination = 2,
  String = 3,
  Int = 4,
  Bytes = 5,
  Message = 6,
  Array = 7,
  UNRECOGNIZED = -1,
}

export function cosmosMessageValue_KindFromJSON(object: any): CosmosMessageValue_Kind {
  switch (object) {
    case 0:
    case "None":
      return CosmosMessageValue_Kind.None;
    case 1:
    case "Source":
      return CosmosMessageValue_Kind.Source;
    case 2:
    case "Destination":
      return CosmosMessageValue_Kind.Destination;
    case 3:
    case "String":
      return CosmosMessageValue_Kind.String;
    case 4:
    case "Int":
      return CosmosMessageValue_Kind.Int;
    case 5:
    case "Bytes":
      return CosmosMessageValue_Kind.Bytes;
    case 6:
    case "Message":
      return CosmosMessageValue_Kind.Message;
    case 7:
    case "Array":
      return CosmosMessageValue_Kind.Array;
    case -1:
    case "UNRECOGNIZED":
    default:
      return CosmosMessageValue_Kind.UNRECOGNIZED;
  }
}

export function cosmosMessageValue_KindToJSON(object: CosmosMessageValue_Kind): string {
  switch (object) {
    case CosmosMessageValue_Kind.None:
      return "None";
    case CosmosMessageValue_Kind.Source:
      return "Source";
    case CosmosMessageValue_Kind.Destination:
      return "Destination";
    case CosmosMessageValue_Kind.String:
      return "String";
    case CosmosMessageValue_Kind.Int:
      return "Int";
    case CosmosMessageValue_Kind.Bytes:
      return "Bytes";
    case CosmosMessageValue_Kind.Message:
      return "Message";
    case CosmosMessageValue_Kind.Array:
      return "Array";
    case CosmosMessageValue_Kind.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

export interface CosmosMessageValue_Source {
  addressId: number;
}

export interface CosmosMessageValue_Destination {
  addressId: number;
  whitelistedAddressId: number;
}

export interface CosmosMessageValue_Array {
  kind: string;
  elems: CosmosMessageValue_Value[];
}

export interface CosmosMessageValue_Value {
  source: CosmosMessageValue_Source | undefined;
  destination: CosmosMessageValue_Destination | undefined;
  string: string;
  int: string;
  bytes: Uint8Array;
  message: CosmosMessageValue[];
  array: CosmosMessageValue_Array | undefined;
}

export interface CosmosMessageCall {
  url: string;
  message: CosmosMessageValue[];
}

export interface XTZContractCall {
  entrypoint: string;
  arg: XTZContractArg | undefined;
}

export interface XTZContractArg {
  kind: string;
  prim: string;
  args: XTZContractArg[];
  source: XTZContractArg_Source | undefined;
  destination: XTZContractArg_Destination | undefined;
  string: string;
  int: string;
  bytes: Uint8Array;
  annotations: string[];
}

export enum XTZContractArg_Kind {
  None = 0,
  Source = 1,
  Destination = 2,
  String = 3,
  Int = 4,
  Bytes = 5,
  Primitive = 6,
  UNRECOGNIZED = -1,
}

export function xTZContractArg_KindFromJSON(object: any): XTZContractArg_Kind {
  switch (object) {
    case 0:
    case "None":
      return XTZContractArg_Kind.None;
    case 1:
    case "Source":
      return XTZContractArg_Kind.Source;
    case 2:
    case "Destination":
      return XTZContractArg_Kind.Destination;
    case 3:
    case "String":
      return XTZContractArg_Kind.String;
    case 4:
    case "Int":
      return XTZContractArg_Kind.Int;
    case 5:
    case "Bytes":
      return XTZContractArg_Kind.Bytes;
    case 6:
    case "Primitive":
      return XTZContractArg_Kind.Primitive;
    case -1:
    case "UNRECOGNIZED":
    default:
      return XTZContractArg_Kind.UNRECOGNIZED;
  }
}

export function xTZContractArg_KindToJSON(object: XTZContractArg_Kind): string {
  switch (object) {
    case XTZContractArg_Kind.None:
      return "None";
    case XTZContractArg_Kind.Source:
      return "Source";
    case XTZContractArg_Kind.Destination:
      return "Destination";
    case XTZContractArg_Kind.String:
      return "String";
    case XTZContractArg_Kind.Int:
      return "Int";
    case XTZContractArg_Kind.Bytes:
      return "Bytes";
    case XTZContractArg_Kind.Primitive:
      return "Primitive";
    case XTZContractArg_Kind.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

export interface XTZContractArg_Source {
  fromAddressId: number;
}

export interface XTZContractArg_Destination {
  toAddressId: number;
  toWhitelistedAddressId: number;
}

function createBaseAutoTransferEventHandler(): AutoTransferEventHandler {
  return {
    id: "",
    monitoredWalletId: 0,
    payerAddressId: 0,
    triggerType: "",
    lastTriggeredAtBlock: "",
    lastProccessedAtBlock: "",
    attributes: [],
    status: "",
    blockchain: "",
    network: "",
    createdAt: undefined,
    updatedAt: undefined,
  };
}

export const AutoTransferEventHandler = {
  encode(message: AutoTransferEventHandler, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.id !== "") {
      writer.uint32(10).string(message.id);
    }
    if (message.monitoredWalletId !== 0) {
      writer.uint32(16).uint64(message.monitoredWalletId);
    }
    if (message.payerAddressId !== 0) {
      writer.uint32(24).uint64(message.payerAddressId);
    }
    if (message.triggerType !== "") {
      writer.uint32(34).string(message.triggerType);
    }
    if (message.lastTriggeredAtBlock !== "") {
      writer.uint32(42).string(message.lastTriggeredAtBlock);
    }
    if (message.lastProccessedAtBlock !== "") {
      writer.uint32(50).string(message.lastProccessedAtBlock);
    }
    for (const v of message.attributes) {
      AutoTransferEventHandlerAttribute.encode(v!, writer.uint32(58).fork()).ldelim();
    }
    if (message.status !== "") {
      writer.uint32(66).string(message.status);
    }
    if (message.blockchain !== "") {
      writer.uint32(74).string(message.blockchain);
    }
    if (message.network !== "") {
      writer.uint32(82).string(message.network);
    }
    if (message.createdAt !== undefined) {
      Timestamp.encode(toTimestamp(message.createdAt), writer.uint32(90).fork()).ldelim();
    }
    if (message.updatedAt !== undefined) {
      Timestamp.encode(toTimestamp(message.updatedAt), writer.uint32(98).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): AutoTransferEventHandler {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseAutoTransferEventHandler();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.id = reader.string();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.monitoredWalletId = longToNumber(reader.uint64() as Long);
          continue;
        case 3:
          if (tag !== 24) {
            break;
          }

          message.payerAddressId = longToNumber(reader.uint64() as Long);
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.triggerType = reader.string();
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.lastTriggeredAtBlock = reader.string();
          continue;
        case 6:
          if (tag !== 50) {
            break;
          }

          message.lastProccessedAtBlock = reader.string();
          continue;
        case 7:
          if (tag !== 58) {
            break;
          }

          message.attributes.push(AutoTransferEventHandlerAttribute.decode(reader, reader.uint32()));
          continue;
        case 8:
          if (tag !== 66) {
            break;
          }

          message.status = reader.string();
          continue;
        case 9:
          if (tag !== 74) {
            break;
          }

          message.blockchain = reader.string();
          continue;
        case 10:
          if (tag !== 82) {
            break;
          }

          message.network = reader.string();
          continue;
        case 11:
          if (tag !== 90) {
            break;
          }

          message.createdAt = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        case 12:
          if (tag !== 98) {
            break;
          }

          message.updatedAt = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): AutoTransferEventHandler {
    return {
      id: isSet(object.id) ? globalThis.String(object.id) : "",
      monitoredWalletId: isSet(object.monitoredWalletId) ? globalThis.Number(object.monitoredWalletId) : 0,
      payerAddressId: isSet(object.payerAddressId) ? globalThis.Number(object.payerAddressId) : 0,
      triggerType: isSet(object.triggerType) ? globalThis.String(object.triggerType) : "",
      lastTriggeredAtBlock: isSet(object.lastTriggeredAtBlock) ? globalThis.String(object.lastTriggeredAtBlock) : "",
      lastProccessedAtBlock: isSet(object.lastProccessedAtBlock) ? globalThis.String(object.lastProccessedAtBlock) : "",
      attributes: globalThis.Array.isArray(object?.attributes)
        ? object.attributes.map((e: any) => AutoTransferEventHandlerAttribute.fromJSON(e))
        : [],
      status: isSet(object.status) ? globalThis.String(object.status) : "",
      blockchain: isSet(object.blockchain) ? globalThis.String(object.blockchain) : "",
      network: isSet(object.network) ? globalThis.String(object.network) : "",
      createdAt: isSet(object.createdAt) ? fromJsonTimestamp(object.createdAt) : undefined,
      updatedAt: isSet(object.updatedAt) ? fromJsonTimestamp(object.updatedAt) : undefined,
    };
  },

  toJSON(message: AutoTransferEventHandler): unknown {
    const obj: any = {};
    if (message.id !== "") {
      obj.id = message.id;
    }
    if (message.monitoredWalletId !== 0) {
      obj.monitoredWalletId = Math.round(message.monitoredWalletId);
    }
    if (message.payerAddressId !== 0) {
      obj.payerAddressId = Math.round(message.payerAddressId);
    }
    if (message.triggerType !== "") {
      obj.triggerType = message.triggerType;
    }
    if (message.lastTriggeredAtBlock !== "") {
      obj.lastTriggeredAtBlock = message.lastTriggeredAtBlock;
    }
    if (message.lastProccessedAtBlock !== "") {
      obj.lastProccessedAtBlock = message.lastProccessedAtBlock;
    }
    if (message.attributes?.length) {
      obj.attributes = message.attributes.map((e) => AutoTransferEventHandlerAttribute.toJSON(e));
    }
    if (message.status !== "") {
      obj.status = message.status;
    }
    if (message.blockchain !== "") {
      obj.blockchain = message.blockchain;
    }
    if (message.network !== "") {
      obj.network = message.network;
    }
    if (message.createdAt !== undefined) {
      obj.createdAt = message.createdAt.toISOString();
    }
    if (message.updatedAt !== undefined) {
      obj.updatedAt = message.updatedAt.toISOString();
    }
    return obj;
  },

  create(base?: DeepPartial<AutoTransferEventHandler>): AutoTransferEventHandler {
    return AutoTransferEventHandler.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<AutoTransferEventHandler>): AutoTransferEventHandler {
    const message = createBaseAutoTransferEventHandler();
    message.id = object.id ?? "";
    message.monitoredWalletId = object.monitoredWalletId ?? 0;
    message.payerAddressId = object.payerAddressId ?? 0;
    message.triggerType = object.triggerType ?? "";
    message.lastTriggeredAtBlock = object.lastTriggeredAtBlock ?? "";
    message.lastProccessedAtBlock = object.lastProccessedAtBlock ?? "";
    message.attributes = object.attributes?.map((e) => AutoTransferEventHandlerAttribute.fromPartial(e)) || [];
    message.status = object.status ?? "";
    message.blockchain = object.blockchain ?? "";
    message.network = object.network ?? "";
    message.createdAt = object.createdAt ?? undefined;
    message.updatedAt = object.updatedAt ?? undefined;
    return message;
  },
};

function createBaseAutoTransferEventHandlerAttribute(): AutoTransferEventHandlerAttribute {
  return { id: "", handlerId: "", key: "", value: "", contentType: "", owner: "", type: "", subType: "" };
}

export const AutoTransferEventHandlerAttribute = {
  encode(message: AutoTransferEventHandlerAttribute, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.id !== "") {
      writer.uint32(10).string(message.id);
    }
    if (message.handlerId !== "") {
      writer.uint32(18).string(message.handlerId);
    }
    if (message.key !== "") {
      writer.uint32(26).string(message.key);
    }
    if (message.value !== "") {
      writer.uint32(34).string(message.value);
    }
    if (message.contentType !== "") {
      writer.uint32(42).string(message.contentType);
    }
    if (message.owner !== "") {
      writer.uint32(50).string(message.owner);
    }
    if (message.type !== "") {
      writer.uint32(58).string(message.type);
    }
    if (message.subType !== "") {
      writer.uint32(66).string(message.subType);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): AutoTransferEventHandlerAttribute {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseAutoTransferEventHandlerAttribute();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.id = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.handlerId = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.key = reader.string();
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.value = reader.string();
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.contentType = reader.string();
          continue;
        case 6:
          if (tag !== 50) {
            break;
          }

          message.owner = reader.string();
          continue;
        case 7:
          if (tag !== 58) {
            break;
          }

          message.type = reader.string();
          continue;
        case 8:
          if (tag !== 66) {
            break;
          }

          message.subType = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): AutoTransferEventHandlerAttribute {
    return {
      id: isSet(object.id) ? globalThis.String(object.id) : "",
      handlerId: isSet(object.handlerId) ? globalThis.String(object.handlerId) : "",
      key: isSet(object.key) ? globalThis.String(object.key) : "",
      value: isSet(object.value) ? globalThis.String(object.value) : "",
      contentType: isSet(object.contentType) ? globalThis.String(object.contentType) : "",
      owner: isSet(object.owner) ? globalThis.String(object.owner) : "",
      type: isSet(object.type) ? globalThis.String(object.type) : "",
      subType: isSet(object.subType) ? globalThis.String(object.subType) : "",
    };
  },

  toJSON(message: AutoTransferEventHandlerAttribute): unknown {
    const obj: any = {};
    if (message.id !== "") {
      obj.id = message.id;
    }
    if (message.handlerId !== "") {
      obj.handlerId = message.handlerId;
    }
    if (message.key !== "") {
      obj.key = message.key;
    }
    if (message.value !== "") {
      obj.value = message.value;
    }
    if (message.contentType !== "") {
      obj.contentType = message.contentType;
    }
    if (message.owner !== "") {
      obj.owner = message.owner;
    }
    if (message.type !== "") {
      obj.type = message.type;
    }
    if (message.subType !== "") {
      obj.subType = message.subType;
    }
    return obj;
  },

  create(base?: DeepPartial<AutoTransferEventHandlerAttribute>): AutoTransferEventHandlerAttribute {
    return AutoTransferEventHandlerAttribute.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<AutoTransferEventHandlerAttribute>): AutoTransferEventHandlerAttribute {
    const message = createBaseAutoTransferEventHandlerAttribute();
    message.id = object.id ?? "";
    message.handlerId = object.handlerId ?? "";
    message.key = object.key ?? "";
    message.value = object.value ?? "";
    message.contentType = object.contentType ?? "";
    message.owner = object.owner ?? "";
    message.type = object.type ?? "";
    message.subType = object.subType ?? "";
    return message;
  },
};

function createBaseCompanyTravelRuleData(): CompanyTravelRuleData {
  return {
    department: "",
    buildingNumber: "",
    street: "",
    city: "",
    province: "",
    postalCode: "",
    country: "",
    legalEntityIdentifier: "",
    businessName: "",
    accountNumber: "",
  };
}

export const CompanyTravelRuleData = {
  encode(message: CompanyTravelRuleData, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.department !== "") {
      writer.uint32(10).string(message.department);
    }
    if (message.buildingNumber !== "") {
      writer.uint32(18).string(message.buildingNumber);
    }
    if (message.street !== "") {
      writer.uint32(26).string(message.street);
    }
    if (message.city !== "") {
      writer.uint32(34).string(message.city);
    }
    if (message.province !== "") {
      writer.uint32(42).string(message.province);
    }
    if (message.postalCode !== "") {
      writer.uint32(50).string(message.postalCode);
    }
    if (message.country !== "") {
      writer.uint32(58).string(message.country);
    }
    if (message.legalEntityIdentifier !== "") {
      writer.uint32(66).string(message.legalEntityIdentifier);
    }
    if (message.businessName !== "") {
      writer.uint32(74).string(message.businessName);
    }
    if (message.accountNumber !== "") {
      writer.uint32(82).string(message.accountNumber);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CompanyTravelRuleData {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCompanyTravelRuleData();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.department = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.buildingNumber = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.street = reader.string();
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.city = reader.string();
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.province = reader.string();
          continue;
        case 6:
          if (tag !== 50) {
            break;
          }

          message.postalCode = reader.string();
          continue;
        case 7:
          if (tag !== 58) {
            break;
          }

          message.country = reader.string();
          continue;
        case 8:
          if (tag !== 66) {
            break;
          }

          message.legalEntityIdentifier = reader.string();
          continue;
        case 9:
          if (tag !== 74) {
            break;
          }

          message.businessName = reader.string();
          continue;
        case 10:
          if (tag !== 82) {
            break;
          }

          message.accountNumber = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CompanyTravelRuleData {
    return {
      department: isSet(object.department) ? globalThis.String(object.department) : "",
      buildingNumber: isSet(object.buildingNumber) ? globalThis.String(object.buildingNumber) : "",
      street: isSet(object.street) ? globalThis.String(object.street) : "",
      city: isSet(object.city) ? globalThis.String(object.city) : "",
      province: isSet(object.province) ? globalThis.String(object.province) : "",
      postalCode: isSet(object.postalCode) ? globalThis.String(object.postalCode) : "",
      country: isSet(object.country) ? globalThis.String(object.country) : "",
      legalEntityIdentifier: isSet(object.legalEntityIdentifier) ? globalThis.String(object.legalEntityIdentifier) : "",
      businessName: isSet(object.businessName) ? globalThis.String(object.businessName) : "",
      accountNumber: isSet(object.accountNumber) ? globalThis.String(object.accountNumber) : "",
    };
  },

  toJSON(message: CompanyTravelRuleData): unknown {
    const obj: any = {};
    if (message.department !== "") {
      obj.department = message.department;
    }
    if (message.buildingNumber !== "") {
      obj.buildingNumber = message.buildingNumber;
    }
    if (message.street !== "") {
      obj.street = message.street;
    }
    if (message.city !== "") {
      obj.city = message.city;
    }
    if (message.province !== "") {
      obj.province = message.province;
    }
    if (message.postalCode !== "") {
      obj.postalCode = message.postalCode;
    }
    if (message.country !== "") {
      obj.country = message.country;
    }
    if (message.legalEntityIdentifier !== "") {
      obj.legalEntityIdentifier = message.legalEntityIdentifier;
    }
    if (message.businessName !== "") {
      obj.businessName = message.businessName;
    }
    if (message.accountNumber !== "") {
      obj.accountNumber = message.accountNumber;
    }
    return obj;
  },

  create(base?: DeepPartial<CompanyTravelRuleData>): CompanyTravelRuleData {
    return CompanyTravelRuleData.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CompanyTravelRuleData>): CompanyTravelRuleData {
    const message = createBaseCompanyTravelRuleData();
    message.department = object.department ?? "";
    message.buildingNumber = object.buildingNumber ?? "";
    message.street = object.street ?? "";
    message.city = object.city ?? "";
    message.province = object.province ?? "";
    message.postalCode = object.postalCode ?? "";
    message.country = object.country ?? "";
    message.legalEntityIdentifier = object.legalEntityIdentifier ?? "";
    message.businessName = object.businessName ?? "";
    message.accountNumber = object.accountNumber ?? "";
    return message;
  },
};

function createBasePersonTravelRuleData(): PersonTravelRuleData {
  return {
    name: "",
    houseNumber: "",
    street: "",
    city: "",
    province: "",
    postalCode: "",
    country: "",
    idNumber: "",
    externalCustomerID: "",
    birthdate: "",
    birthPlace: "",
    accountNumber: "",
  };
}

export const PersonTravelRuleData = {
  encode(message: PersonTravelRuleData, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    if (message.houseNumber !== "") {
      writer.uint32(18).string(message.houseNumber);
    }
    if (message.street !== "") {
      writer.uint32(26).string(message.street);
    }
    if (message.city !== "") {
      writer.uint32(34).string(message.city);
    }
    if (message.province !== "") {
      writer.uint32(42).string(message.province);
    }
    if (message.postalCode !== "") {
      writer.uint32(50).string(message.postalCode);
    }
    if (message.country !== "") {
      writer.uint32(58).string(message.country);
    }
    if (message.idNumber !== "") {
      writer.uint32(66).string(message.idNumber);
    }
    if (message.externalCustomerID !== "") {
      writer.uint32(74).string(message.externalCustomerID);
    }
    if (message.birthdate !== "") {
      writer.uint32(82).string(message.birthdate);
    }
    if (message.birthPlace !== "") {
      writer.uint32(90).string(message.birthPlace);
    }
    if (message.accountNumber !== "") {
      writer.uint32(98).string(message.accountNumber);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): PersonTravelRuleData {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBasePersonTravelRuleData();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.houseNumber = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.street = reader.string();
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.city = reader.string();
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.province = reader.string();
          continue;
        case 6:
          if (tag !== 50) {
            break;
          }

          message.postalCode = reader.string();
          continue;
        case 7:
          if (tag !== 58) {
            break;
          }

          message.country = reader.string();
          continue;
        case 8:
          if (tag !== 66) {
            break;
          }

          message.idNumber = reader.string();
          continue;
        case 9:
          if (tag !== 74) {
            break;
          }

          message.externalCustomerID = reader.string();
          continue;
        case 10:
          if (tag !== 82) {
            break;
          }

          message.birthdate = reader.string();
          continue;
        case 11:
          if (tag !== 90) {
            break;
          }

          message.birthPlace = reader.string();
          continue;
        case 12:
          if (tag !== 98) {
            break;
          }

          message.accountNumber = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): PersonTravelRuleData {
    return {
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      houseNumber: isSet(object.houseNumber) ? globalThis.String(object.houseNumber) : "",
      street: isSet(object.street) ? globalThis.String(object.street) : "",
      city: isSet(object.city) ? globalThis.String(object.city) : "",
      province: isSet(object.province) ? globalThis.String(object.province) : "",
      postalCode: isSet(object.postalCode) ? globalThis.String(object.postalCode) : "",
      country: isSet(object.country) ? globalThis.String(object.country) : "",
      idNumber: isSet(object.idNumber) ? globalThis.String(object.idNumber) : "",
      externalCustomerID: isSet(object.externalCustomerID) ? globalThis.String(object.externalCustomerID) : "",
      birthdate: isSet(object.birthdate) ? globalThis.String(object.birthdate) : "",
      birthPlace: isSet(object.birthPlace) ? globalThis.String(object.birthPlace) : "",
      accountNumber: isSet(object.accountNumber) ? globalThis.String(object.accountNumber) : "",
    };
  },

  toJSON(message: PersonTravelRuleData): unknown {
    const obj: any = {};
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.houseNumber !== "") {
      obj.houseNumber = message.houseNumber;
    }
    if (message.street !== "") {
      obj.street = message.street;
    }
    if (message.city !== "") {
      obj.city = message.city;
    }
    if (message.province !== "") {
      obj.province = message.province;
    }
    if (message.postalCode !== "") {
      obj.postalCode = message.postalCode;
    }
    if (message.country !== "") {
      obj.country = message.country;
    }
    if (message.idNumber !== "") {
      obj.idNumber = message.idNumber;
    }
    if (message.externalCustomerID !== "") {
      obj.externalCustomerID = message.externalCustomerID;
    }
    if (message.birthdate !== "") {
      obj.birthdate = message.birthdate;
    }
    if (message.birthPlace !== "") {
      obj.birthPlace = message.birthPlace;
    }
    if (message.accountNumber !== "") {
      obj.accountNumber = message.accountNumber;
    }
    return obj;
  },

  create(base?: DeepPartial<PersonTravelRuleData>): PersonTravelRuleData {
    return PersonTravelRuleData.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<PersonTravelRuleData>): PersonTravelRuleData {
    const message = createBasePersonTravelRuleData();
    message.name = object.name ?? "";
    message.houseNumber = object.houseNumber ?? "";
    message.street = object.street ?? "";
    message.city = object.city ?? "";
    message.province = object.province ?? "";
    message.postalCode = object.postalCode ?? "";
    message.country = object.country ?? "";
    message.idNumber = object.idNumber ?? "";
    message.externalCustomerID = object.externalCustomerID ?? "";
    message.birthdate = object.birthdate ?? "";
    message.birthPlace = object.birthPlace ?? "";
    message.accountNumber = object.accountNumber ?? "";
    return message;
  },
};

function createBaseTravelRuleDataInput(): TravelRuleDataInput {
  return {
    originatorPersonTravelRuleData: undefined,
    originatorCompanyTravelRuleData: undefined,
    beneficiaryCompanyTravelRuleData: undefined,
    beneficiaryPersonTravelRuleData: undefined,
    provider: "",
  };
}

export const TravelRuleDataInput = {
  encode(message: TravelRuleDataInput, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.originatorPersonTravelRuleData !== undefined) {
      PersonTravelRuleData.encode(message.originatorPersonTravelRuleData, writer.uint32(10).fork()).ldelim();
    }
    if (message.originatorCompanyTravelRuleData !== undefined) {
      CompanyTravelRuleData.encode(message.originatorCompanyTravelRuleData, writer.uint32(18).fork()).ldelim();
    }
    if (message.beneficiaryCompanyTravelRuleData !== undefined) {
      CompanyTravelRuleData.encode(message.beneficiaryCompanyTravelRuleData, writer.uint32(26).fork()).ldelim();
    }
    if (message.beneficiaryPersonTravelRuleData !== undefined) {
      PersonTravelRuleData.encode(message.beneficiaryPersonTravelRuleData, writer.uint32(34).fork()).ldelim();
    }
    if (message.provider !== "") {
      writer.uint32(42).string(message.provider);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): TravelRuleDataInput {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseTravelRuleDataInput();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.originatorPersonTravelRuleData = PersonTravelRuleData.decode(reader, reader.uint32());
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.originatorCompanyTravelRuleData = CompanyTravelRuleData.decode(reader, reader.uint32());
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.beneficiaryCompanyTravelRuleData = CompanyTravelRuleData.decode(reader, reader.uint32());
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.beneficiaryPersonTravelRuleData = PersonTravelRuleData.decode(reader, reader.uint32());
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.provider = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): TravelRuleDataInput {
    return {
      originatorPersonTravelRuleData: isSet(object.originatorPersonTravelRuleData)
        ? PersonTravelRuleData.fromJSON(object.originatorPersonTravelRuleData)
        : undefined,
      originatorCompanyTravelRuleData: isSet(object.originatorCompanyTravelRuleData)
        ? CompanyTravelRuleData.fromJSON(object.originatorCompanyTravelRuleData)
        : undefined,
      beneficiaryCompanyTravelRuleData: isSet(object.beneficiaryCompanyTravelRuleData)
        ? CompanyTravelRuleData.fromJSON(object.beneficiaryCompanyTravelRuleData)
        : undefined,
      beneficiaryPersonTravelRuleData: isSet(object.beneficiaryPersonTravelRuleData)
        ? PersonTravelRuleData.fromJSON(object.beneficiaryPersonTravelRuleData)
        : undefined,
      provider: isSet(object.provider) ? globalThis.String(object.provider) : "",
    };
  },

  toJSON(message: TravelRuleDataInput): unknown {
    const obj: any = {};
    if (message.originatorPersonTravelRuleData !== undefined) {
      obj.originatorPersonTravelRuleData = PersonTravelRuleData.toJSON(message.originatorPersonTravelRuleData);
    }
    if (message.originatorCompanyTravelRuleData !== undefined) {
      obj.originatorCompanyTravelRuleData = CompanyTravelRuleData.toJSON(message.originatorCompanyTravelRuleData);
    }
    if (message.beneficiaryCompanyTravelRuleData !== undefined) {
      obj.beneficiaryCompanyTravelRuleData = CompanyTravelRuleData.toJSON(message.beneficiaryCompanyTravelRuleData);
    }
    if (message.beneficiaryPersonTravelRuleData !== undefined) {
      obj.beneficiaryPersonTravelRuleData = PersonTravelRuleData.toJSON(message.beneficiaryPersonTravelRuleData);
    }
    if (message.provider !== "") {
      obj.provider = message.provider;
    }
    return obj;
  },

  create(base?: DeepPartial<TravelRuleDataInput>): TravelRuleDataInput {
    return TravelRuleDataInput.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<TravelRuleDataInput>): TravelRuleDataInput {
    const message = createBaseTravelRuleDataInput();
    message.originatorPersonTravelRuleData =
      (object.originatorPersonTravelRuleData !== undefined && object.originatorPersonTravelRuleData !== null)
        ? PersonTravelRuleData.fromPartial(object.originatorPersonTravelRuleData)
        : undefined;
    message.originatorCompanyTravelRuleData =
      (object.originatorCompanyTravelRuleData !== undefined && object.originatorCompanyTravelRuleData !== null)
        ? CompanyTravelRuleData.fromPartial(object.originatorCompanyTravelRuleData)
        : undefined;
    message.beneficiaryCompanyTravelRuleData =
      (object.beneficiaryCompanyTravelRuleData !== undefined && object.beneficiaryCompanyTravelRuleData !== null)
        ? CompanyTravelRuleData.fromPartial(object.beneficiaryCompanyTravelRuleData)
        : undefined;
    message.beneficiaryPersonTravelRuleData =
      (object.beneficiaryPersonTravelRuleData !== undefined && object.beneficiaryPersonTravelRuleData !== null)
        ? PersonTravelRuleData.fromPartial(object.beneficiaryPersonTravelRuleData)
        : undefined;
    message.provider = object.provider ?? "";
    return message;
  },
};

function createBaseRequestBatchSignature(): RequestBatchSignature {
  return {
    ID: 0,
    TenantID: 0,
    UserID: 0,
    Signature: "",
    Comment: "",
    Status: "",
    CreationDate: undefined,
    UpdateDate: undefined,
    signatures: [],
  };
}

export const RequestBatchSignature = {
  encode(message: RequestBatchSignature, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.ID !== 0) {
      writer.uint32(8).uint64(message.ID);
    }
    if (message.TenantID !== 0) {
      writer.uint32(16).uint64(message.TenantID);
    }
    if (message.UserID !== 0) {
      writer.uint32(24).uint64(message.UserID);
    }
    if (message.Signature !== "") {
      writer.uint32(34).string(message.Signature);
    }
    if (message.Comment !== "") {
      writer.uint32(42).string(message.Comment);
    }
    if (message.Status !== "") {
      writer.uint32(50).string(message.Status);
    }
    if (message.CreationDate !== undefined) {
      Timestamp.encode(toTimestamp(message.CreationDate), writer.uint32(58).fork()).ldelim();
    }
    if (message.UpdateDate !== undefined) {
      Timestamp.encode(toTimestamp(message.UpdateDate), writer.uint32(66).fork()).ldelim();
    }
    for (const v of message.signatures) {
      RequestBatchSignature_RequestSignature.encode(v!, writer.uint32(74).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): RequestBatchSignature {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseRequestBatchSignature();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.ID = longToNumber(reader.uint64() as Long);
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.TenantID = longToNumber(reader.uint64() as Long);
          continue;
        case 3:
          if (tag !== 24) {
            break;
          }

          message.UserID = longToNumber(reader.uint64() as Long);
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.Signature = reader.string();
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.Comment = reader.string();
          continue;
        case 6:
          if (tag !== 50) {
            break;
          }

          message.Status = reader.string();
          continue;
        case 7:
          if (tag !== 58) {
            break;
          }

          message.CreationDate = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        case 8:
          if (tag !== 66) {
            break;
          }

          message.UpdateDate = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        case 9:
          if (tag !== 74) {
            break;
          }

          message.signatures.push(RequestBatchSignature_RequestSignature.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): RequestBatchSignature {
    return {
      ID: isSet(object.ID) ? globalThis.Number(object.ID) : 0,
      TenantID: isSet(object.TenantID) ? globalThis.Number(object.TenantID) : 0,
      UserID: isSet(object.UserID) ? globalThis.Number(object.UserID) : 0,
      Signature: isSet(object.Signature) ? globalThis.String(object.Signature) : "",
      Comment: isSet(object.Comment) ? globalThis.String(object.Comment) : "",
      Status: isSet(object.Status) ? globalThis.String(object.Status) : "",
      CreationDate: isSet(object.CreationDate) ? fromJsonTimestamp(object.CreationDate) : undefined,
      UpdateDate: isSet(object.UpdateDate) ? fromJsonTimestamp(object.UpdateDate) : undefined,
      signatures: globalThis.Array.isArray(object?.signatures)
        ? object.signatures.map((e: any) => RequestBatchSignature_RequestSignature.fromJSON(e))
        : [],
    };
  },

  toJSON(message: RequestBatchSignature): unknown {
    const obj: any = {};
    if (message.ID !== 0) {
      obj.ID = Math.round(message.ID);
    }
    if (message.TenantID !== 0) {
      obj.TenantID = Math.round(message.TenantID);
    }
    if (message.UserID !== 0) {
      obj.UserID = Math.round(message.UserID);
    }
    if (message.Signature !== "") {
      obj.Signature = message.Signature;
    }
    if (message.Comment !== "") {
      obj.Comment = message.Comment;
    }
    if (message.Status !== "") {
      obj.Status = message.Status;
    }
    if (message.CreationDate !== undefined) {
      obj.CreationDate = message.CreationDate.toISOString();
    }
    if (message.UpdateDate !== undefined) {
      obj.UpdateDate = message.UpdateDate.toISOString();
    }
    if (message.signatures?.length) {
      obj.signatures = message.signatures.map((e) => RequestBatchSignature_RequestSignature.toJSON(e));
    }
    return obj;
  },

  create(base?: DeepPartial<RequestBatchSignature>): RequestBatchSignature {
    return RequestBatchSignature.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<RequestBatchSignature>): RequestBatchSignature {
    const message = createBaseRequestBatchSignature();
    message.ID = object.ID ?? 0;
    message.TenantID = object.TenantID ?? 0;
    message.UserID = object.UserID ?? 0;
    message.Signature = object.Signature ?? "";
    message.Comment = object.Comment ?? "";
    message.Status = object.Status ?? "";
    message.CreationDate = object.CreationDate ?? undefined;
    message.UpdateDate = object.UpdateDate ?? undefined;
    message.signatures = object.signatures?.map((e) => RequestBatchSignature_RequestSignature.fromPartial(e)) || [];
    return message;
  },
};

function createBaseRequestBatchSignature_RequestSignature(): RequestBatchSignature_RequestSignature {
  return {
    ID: 0,
    TenantID: 0,
    BatchSignatureID: 0,
    RequestID: 0,
    MetadataHash: "",
    Status: "",
    Message: "",
    CreationDate: undefined,
    UpdateDate: undefined,
  };
}

export const RequestBatchSignature_RequestSignature = {
  encode(message: RequestBatchSignature_RequestSignature, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.ID !== 0) {
      writer.uint32(8).uint64(message.ID);
    }
    if (message.TenantID !== 0) {
      writer.uint32(16).uint64(message.TenantID);
    }
    if (message.BatchSignatureID !== 0) {
      writer.uint32(24).uint64(message.BatchSignatureID);
    }
    if (message.RequestID !== 0) {
      writer.uint32(32).uint64(message.RequestID);
    }
    if (message.MetadataHash !== "") {
      writer.uint32(42).string(message.MetadataHash);
    }
    if (message.Status !== "") {
      writer.uint32(50).string(message.Status);
    }
    if (message.Message !== "") {
      writer.uint32(58).string(message.Message);
    }
    if (message.CreationDate !== undefined) {
      Timestamp.encode(toTimestamp(message.CreationDate), writer.uint32(66).fork()).ldelim();
    }
    if (message.UpdateDate !== undefined) {
      Timestamp.encode(toTimestamp(message.UpdateDate), writer.uint32(74).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): RequestBatchSignature_RequestSignature {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseRequestBatchSignature_RequestSignature();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.ID = longToNumber(reader.uint64() as Long);
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.TenantID = longToNumber(reader.uint64() as Long);
          continue;
        case 3:
          if (tag !== 24) {
            break;
          }

          message.BatchSignatureID = longToNumber(reader.uint64() as Long);
          continue;
        case 4:
          if (tag !== 32) {
            break;
          }

          message.RequestID = longToNumber(reader.uint64() as Long);
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.MetadataHash = reader.string();
          continue;
        case 6:
          if (tag !== 50) {
            break;
          }

          message.Status = reader.string();
          continue;
        case 7:
          if (tag !== 58) {
            break;
          }

          message.Message = reader.string();
          continue;
        case 8:
          if (tag !== 66) {
            break;
          }

          message.CreationDate = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        case 9:
          if (tag !== 74) {
            break;
          }

          message.UpdateDate = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): RequestBatchSignature_RequestSignature {
    return {
      ID: isSet(object.ID) ? globalThis.Number(object.ID) : 0,
      TenantID: isSet(object.TenantID) ? globalThis.Number(object.TenantID) : 0,
      BatchSignatureID: isSet(object.BatchSignatureID) ? globalThis.Number(object.BatchSignatureID) : 0,
      RequestID: isSet(object.RequestID) ? globalThis.Number(object.RequestID) : 0,
      MetadataHash: isSet(object.MetadataHash) ? globalThis.String(object.MetadataHash) : "",
      Status: isSet(object.Status) ? globalThis.String(object.Status) : "",
      Message: isSet(object.Message) ? globalThis.String(object.Message) : "",
      CreationDate: isSet(object.CreationDate) ? fromJsonTimestamp(object.CreationDate) : undefined,
      UpdateDate: isSet(object.UpdateDate) ? fromJsonTimestamp(object.UpdateDate) : undefined,
    };
  },

  toJSON(message: RequestBatchSignature_RequestSignature): unknown {
    const obj: any = {};
    if (message.ID !== 0) {
      obj.ID = Math.round(message.ID);
    }
    if (message.TenantID !== 0) {
      obj.TenantID = Math.round(message.TenantID);
    }
    if (message.BatchSignatureID !== 0) {
      obj.BatchSignatureID = Math.round(message.BatchSignatureID);
    }
    if (message.RequestID !== 0) {
      obj.RequestID = Math.round(message.RequestID);
    }
    if (message.MetadataHash !== "") {
      obj.MetadataHash = message.MetadataHash;
    }
    if (message.Status !== "") {
      obj.Status = message.Status;
    }
    if (message.Message !== "") {
      obj.Message = message.Message;
    }
    if (message.CreationDate !== undefined) {
      obj.CreationDate = message.CreationDate.toISOString();
    }
    if (message.UpdateDate !== undefined) {
      obj.UpdateDate = message.UpdateDate.toISOString();
    }
    return obj;
  },

  create(base?: DeepPartial<RequestBatchSignature_RequestSignature>): RequestBatchSignature_RequestSignature {
    return RequestBatchSignature_RequestSignature.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<RequestBatchSignature_RequestSignature>): RequestBatchSignature_RequestSignature {
    const message = createBaseRequestBatchSignature_RequestSignature();
    message.ID = object.ID ?? 0;
    message.TenantID = object.TenantID ?? 0;
    message.BatchSignatureID = object.BatchSignatureID ?? 0;
    message.RequestID = object.RequestID ?? 0;
    message.MetadataHash = object.MetadataHash ?? "";
    message.Status = object.Status ?? "";
    message.Message = object.Message ?? "";
    message.CreationDate = object.CreationDate ?? undefined;
    message.UpdateDate = object.UpdateDate ?? undefined;
    return message;
  },
};

function createBaseRequestBundleDetailsSource(): RequestBundleDetailsSource {
  return { totalSources: 0, fromWalletId: 0, fromAddressId: 0 };
}

export const RequestBundleDetailsSource = {
  encode(message: RequestBundleDetailsSource, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.totalSources !== 0) {
      writer.uint32(8).uint64(message.totalSources);
    }
    if (message.fromWalletId !== 0) {
      writer.uint32(16).uint64(message.fromWalletId);
    }
    if (message.fromAddressId !== 0) {
      writer.uint32(24).uint64(message.fromAddressId);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): RequestBundleDetailsSource {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseRequestBundleDetailsSource();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.totalSources = longToNumber(reader.uint64() as Long);
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.fromWalletId = longToNumber(reader.uint64() as Long);
          continue;
        case 3:
          if (tag !== 24) {
            break;
          }

          message.fromAddressId = longToNumber(reader.uint64() as Long);
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): RequestBundleDetailsSource {
    return {
      totalSources: isSet(object.totalSources) ? globalThis.Number(object.totalSources) : 0,
      fromWalletId: isSet(object.fromWalletId) ? globalThis.Number(object.fromWalletId) : 0,
      fromAddressId: isSet(object.fromAddressId) ? globalThis.Number(object.fromAddressId) : 0,
    };
  },

  toJSON(message: RequestBundleDetailsSource): unknown {
    const obj: any = {};
    if (message.totalSources !== 0) {
      obj.totalSources = Math.round(message.totalSources);
    }
    if (message.fromWalletId !== 0) {
      obj.fromWalletId = Math.round(message.fromWalletId);
    }
    if (message.fromAddressId !== 0) {
      obj.fromAddressId = Math.round(message.fromAddressId);
    }
    return obj;
  },

  create(base?: DeepPartial<RequestBundleDetailsSource>): RequestBundleDetailsSource {
    return RequestBundleDetailsSource.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<RequestBundleDetailsSource>): RequestBundleDetailsSource {
    const message = createBaseRequestBundleDetailsSource();
    message.totalSources = object.totalSources ?? 0;
    message.fromWalletId = object.fromWalletId ?? 0;
    message.fromAddressId = object.fromAddressId ?? 0;
    return message;
  },
};

function createBaseRequestBundleDetailsDestination(): RequestBundleDetailsDestination {
  return { totalDestinations: 0, toAddressId: 0, toWhitelistedAddressId: 0 };
}

export const RequestBundleDetailsDestination = {
  encode(message: RequestBundleDetailsDestination, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.totalDestinations !== 0) {
      writer.uint32(8).uint64(message.totalDestinations);
    }
    if (message.toAddressId !== 0) {
      writer.uint32(16).uint64(message.toAddressId);
    }
    if (message.toWhitelistedAddressId !== 0) {
      writer.uint32(24).uint64(message.toWhitelistedAddressId);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): RequestBundleDetailsDestination {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseRequestBundleDetailsDestination();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.totalDestinations = longToNumber(reader.uint64() as Long);
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.toAddressId = longToNumber(reader.uint64() as Long);
          continue;
        case 3:
          if (tag !== 24) {
            break;
          }

          message.toWhitelistedAddressId = longToNumber(reader.uint64() as Long);
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): RequestBundleDetailsDestination {
    return {
      totalDestinations: isSet(object.totalDestinations) ? globalThis.Number(object.totalDestinations) : 0,
      toAddressId: isSet(object.toAddressId) ? globalThis.Number(object.toAddressId) : 0,
      toWhitelistedAddressId: isSet(object.toWhitelistedAddressId)
        ? globalThis.Number(object.toWhitelistedAddressId)
        : 0,
    };
  },

  toJSON(message: RequestBundleDetailsDestination): unknown {
    const obj: any = {};
    if (message.totalDestinations !== 0) {
      obj.totalDestinations = Math.round(message.totalDestinations);
    }
    if (message.toAddressId !== 0) {
      obj.toAddressId = Math.round(message.toAddressId);
    }
    if (message.toWhitelistedAddressId !== 0) {
      obj.toWhitelistedAddressId = Math.round(message.toWhitelistedAddressId);
    }
    return obj;
  },

  create(base?: DeepPartial<RequestBundleDetailsDestination>): RequestBundleDetailsDestination {
    return RequestBundleDetailsDestination.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<RequestBundleDetailsDestination>): RequestBundleDetailsDestination {
    const message = createBaseRequestBundleDetailsDestination();
    message.totalDestinations = object.totalDestinations ?? 0;
    message.toAddressId = object.toAddressId ?? 0;
    message.toWhitelistedAddressId = object.toWhitelistedAddressId ?? 0;
    return message;
  },
};

function createBaseRequestBundleDetails(): RequestBundleDetails {
  return { error: "", amount: "", source: undefined, destination: undefined };
}

export const RequestBundleDetails = {
  encode(message: RequestBundleDetails, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.error !== "") {
      writer.uint32(10).string(message.error);
    }
    if (message.amount !== "") {
      writer.uint32(18).string(message.amount);
    }
    if (message.source !== undefined) {
      RequestBundleDetailsSource.encode(message.source, writer.uint32(26).fork()).ldelim();
    }
    if (message.destination !== undefined) {
      RequestBundleDetailsDestination.encode(message.destination, writer.uint32(34).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): RequestBundleDetails {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseRequestBundleDetails();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.error = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.amount = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.source = RequestBundleDetailsSource.decode(reader, reader.uint32());
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.destination = RequestBundleDetailsDestination.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): RequestBundleDetails {
    return {
      error: isSet(object.error) ? globalThis.String(object.error) : "",
      amount: isSet(object.amount) ? globalThis.String(object.amount) : "",
      source: isSet(object.source) ? RequestBundleDetailsSource.fromJSON(object.source) : undefined,
      destination: isSet(object.destination) ? RequestBundleDetailsDestination.fromJSON(object.destination) : undefined,
    };
  },

  toJSON(message: RequestBundleDetails): unknown {
    const obj: any = {};
    if (message.error !== "") {
      obj.error = message.error;
    }
    if (message.amount !== "") {
      obj.amount = message.amount;
    }
    if (message.source !== undefined) {
      obj.source = RequestBundleDetailsSource.toJSON(message.source);
    }
    if (message.destination !== undefined) {
      obj.destination = RequestBundleDetailsDestination.toJSON(message.destination);
    }
    return obj;
  },

  create(base?: DeepPartial<RequestBundleDetails>): RequestBundleDetails {
    return RequestBundleDetails.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<RequestBundleDetails>): RequestBundleDetails {
    const message = createBaseRequestBundleDetails();
    message.error = object.error ?? "";
    message.amount = object.amount ?? "";
    message.source = (object.source !== undefined && object.source !== null)
      ? RequestBundleDetailsSource.fromPartial(object.source)
      : undefined;
    message.destination = (object.destination !== undefined && object.destination !== null)
      ? RequestBundleDetailsDestination.fromPartial(object.destination)
      : undefined;
    return message;
  },
};

function createBaseRequestAttribute(): RequestAttribute {
  return { id: 0, key: "", value: "", contentType: "" };
}

export const RequestAttribute = {
  encode(message: RequestAttribute, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.id !== 0) {
      writer.uint32(8).uint64(message.id);
    }
    if (message.key !== "") {
      writer.uint32(18).string(message.key);
    }
    if (message.value !== "") {
      writer.uint32(26).string(message.value);
    }
    if (message.contentType !== "") {
      writer.uint32(34).string(message.contentType);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): RequestAttribute {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseRequestAttribute();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.id = longToNumber(reader.uint64() as Long);
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.key = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.value = reader.string();
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.contentType = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): RequestAttribute {
    return {
      id: isSet(object.id) ? globalThis.Number(object.id) : 0,
      key: isSet(object.key) ? globalThis.String(object.key) : "",
      value: isSet(object.value) ? globalThis.String(object.value) : "",
      contentType: isSet(object.contentType) ? globalThis.String(object.contentType) : "",
    };
  },

  toJSON(message: RequestAttribute): unknown {
    const obj: any = {};
    if (message.id !== 0) {
      obj.id = Math.round(message.id);
    }
    if (message.key !== "") {
      obj.key = message.key;
    }
    if (message.value !== "") {
      obj.value = message.value;
    }
    if (message.contentType !== "") {
      obj.contentType = message.contentType;
    }
    return obj;
  },

  create(base?: DeepPartial<RequestAttribute>): RequestAttribute {
    return RequestAttribute.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<RequestAttribute>): RequestAttribute {
    const message = createBaseRequestAttribute();
    message.id = object.id ?? 0;
    message.key = object.key ?? "";
    message.value = object.value ?? "";
    message.contentType = object.contentType ?? "";
    return message;
  },
};

function createBaseSignedRequestAttribute(): SignedRequestAttribute {
  return { id: 0, key: "", value: "", contentType: "" };
}

export const SignedRequestAttribute = {
  encode(message: SignedRequestAttribute, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.id !== 0) {
      writer.uint32(8).uint64(message.id);
    }
    if (message.key !== "") {
      writer.uint32(18).string(message.key);
    }
    if (message.value !== "") {
      writer.uint32(26).string(message.value);
    }
    if (message.contentType !== "") {
      writer.uint32(34).string(message.contentType);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): SignedRequestAttribute {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSignedRequestAttribute();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.id = longToNumber(reader.uint64() as Long);
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.key = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.value = reader.string();
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.contentType = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): SignedRequestAttribute {
    return {
      id: isSet(object.id) ? globalThis.Number(object.id) : 0,
      key: isSet(object.key) ? globalThis.String(object.key) : "",
      value: isSet(object.value) ? globalThis.String(object.value) : "",
      contentType: isSet(object.contentType) ? globalThis.String(object.contentType) : "",
    };
  },

  toJSON(message: SignedRequestAttribute): unknown {
    const obj: any = {};
    if (message.id !== 0) {
      obj.id = Math.round(message.id);
    }
    if (message.key !== "") {
      obj.key = message.key;
    }
    if (message.value !== "") {
      obj.value = message.value;
    }
    if (message.contentType !== "") {
      obj.contentType = message.contentType;
    }
    return obj;
  },

  create(base?: DeepPartial<SignedRequestAttribute>): SignedRequestAttribute {
    return SignedRequestAttribute.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<SignedRequestAttribute>): SignedRequestAttribute {
    const message = createBaseSignedRequestAttribute();
    message.id = object.id ?? 0;
    message.key = object.key ?? "";
    message.value = object.value ?? "";
    message.contentType = object.contentType ?? "";
    return message;
  },
};

function createBaseRequestBundle(): RequestBundle {
  return {
    id: 0,
    tenantId: 0,
    blockchain: "",
    details: undefined,
    status: "",
    creationDate: undefined,
    updateDate: undefined,
    requests: [],
    network: "",
    signedRequestBundles: [],
  };
}

export const RequestBundle = {
  encode(message: RequestBundle, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.id !== 0) {
      writer.uint32(8).uint64(message.id);
    }
    if (message.tenantId !== 0) {
      writer.uint32(16).uint64(message.tenantId);
    }
    if (message.blockchain !== "") {
      writer.uint32(26).string(message.blockchain);
    }
    if (message.details !== undefined) {
      RequestBundleDetails.encode(message.details, writer.uint32(34).fork()).ldelim();
    }
    if (message.status !== "") {
      writer.uint32(42).string(message.status);
    }
    if (message.creationDate !== undefined) {
      Timestamp.encode(toTimestamp(message.creationDate), writer.uint32(50).fork()).ldelim();
    }
    if (message.updateDate !== undefined) {
      Timestamp.encode(toTimestamp(message.updateDate), writer.uint32(58).fork()).ldelim();
    }
    for (const v of message.requests) {
      Request.encode(v!, writer.uint32(66).fork()).ldelim();
    }
    if (message.network !== "") {
      writer.uint32(74).string(message.network);
    }
    for (const v of message.signedRequestBundles) {
      RequestBundle_SignedRequestBundle.encode(v!, writer.uint32(82).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): RequestBundle {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseRequestBundle();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.id = longToNumber(reader.uint64() as Long);
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.tenantId = longToNumber(reader.uint64() as Long);
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.blockchain = reader.string();
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.details = RequestBundleDetails.decode(reader, reader.uint32());
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.status = reader.string();
          continue;
        case 6:
          if (tag !== 50) {
            break;
          }

          message.creationDate = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        case 7:
          if (tag !== 58) {
            break;
          }

          message.updateDate = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        case 8:
          if (tag !== 66) {
            break;
          }

          message.requests.push(Request.decode(reader, reader.uint32()));
          continue;
        case 9:
          if (tag !== 74) {
            break;
          }

          message.network = reader.string();
          continue;
        case 10:
          if (tag !== 82) {
            break;
          }

          message.signedRequestBundles.push(RequestBundle_SignedRequestBundle.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): RequestBundle {
    return {
      id: isSet(object.id) ? globalThis.Number(object.id) : 0,
      tenantId: isSet(object.tenantId) ? globalThis.Number(object.tenantId) : 0,
      blockchain: isSet(object.blockchain) ? globalThis.String(object.blockchain) : "",
      details: isSet(object.details) ? RequestBundleDetails.fromJSON(object.details) : undefined,
      status: isSet(object.status) ? globalThis.String(object.status) : "",
      creationDate: isSet(object.creationDate) ? fromJsonTimestamp(object.creationDate) : undefined,
      updateDate: isSet(object.updateDate) ? fromJsonTimestamp(object.updateDate) : undefined,
      requests: globalThis.Array.isArray(object?.requests) ? object.requests.map((e: any) => Request.fromJSON(e)) : [],
      network: isSet(object.network) ? globalThis.String(object.network) : "",
      signedRequestBundles: globalThis.Array.isArray(object?.signedRequestBundles)
        ? object.signedRequestBundles.map((e: any) => RequestBundle_SignedRequestBundle.fromJSON(e))
        : [],
    };
  },

  toJSON(message: RequestBundle): unknown {
    const obj: any = {};
    if (message.id !== 0) {
      obj.id = Math.round(message.id);
    }
    if (message.tenantId !== 0) {
      obj.tenantId = Math.round(message.tenantId);
    }
    if (message.blockchain !== "") {
      obj.blockchain = message.blockchain;
    }
    if (message.details !== undefined) {
      obj.details = RequestBundleDetails.toJSON(message.details);
    }
    if (message.status !== "") {
      obj.status = message.status;
    }
    if (message.creationDate !== undefined) {
      obj.creationDate = message.creationDate.toISOString();
    }
    if (message.updateDate !== undefined) {
      obj.updateDate = message.updateDate.toISOString();
    }
    if (message.requests?.length) {
      obj.requests = message.requests.map((e) => Request.toJSON(e));
    }
    if (message.network !== "") {
      obj.network = message.network;
    }
    if (message.signedRequestBundles?.length) {
      obj.signedRequestBundles = message.signedRequestBundles.map((e) => RequestBundle_SignedRequestBundle.toJSON(e));
    }
    return obj;
  },

  create(base?: DeepPartial<RequestBundle>): RequestBundle {
    return RequestBundle.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<RequestBundle>): RequestBundle {
    const message = createBaseRequestBundle();
    message.id = object.id ?? 0;
    message.tenantId = object.tenantId ?? 0;
    message.blockchain = object.blockchain ?? "";
    message.details = (object.details !== undefined && object.details !== null)
      ? RequestBundleDetails.fromPartial(object.details)
      : undefined;
    message.status = object.status ?? "";
    message.creationDate = object.creationDate ?? undefined;
    message.updateDate = object.updateDate ?? undefined;
    message.requests = object.requests?.map((e) => Request.fromPartial(e)) || [];
    message.network = object.network ?? "";
    message.signedRequestBundles =
      object.signedRequestBundles?.map((e) => RequestBundle_SignedRequestBundle.fromPartial(e)) || [];
    return message;
  },
};

function createBaseRequestBundle_SignedRequestBundle(): RequestBundle_SignedRequestBundle {
  return {
    id: 0,
    status: "",
    transaction: "",
    hash: "",
    details: "",
    creationDate: undefined,
    updateDate: undefined,
    broadcastDate: undefined,
    confirmationDate: undefined,
  };
}

export const RequestBundle_SignedRequestBundle = {
  encode(message: RequestBundle_SignedRequestBundle, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.id !== 0) {
      writer.uint32(8).uint64(message.id);
    }
    if (message.status !== "") {
      writer.uint32(18).string(message.status);
    }
    if (message.transaction !== "") {
      writer.uint32(26).string(message.transaction);
    }
    if (message.hash !== "") {
      writer.uint32(34).string(message.hash);
    }
    if (message.details !== "") {
      writer.uint32(42).string(message.details);
    }
    if (message.creationDate !== undefined) {
      Timestamp.encode(toTimestamp(message.creationDate), writer.uint32(50).fork()).ldelim();
    }
    if (message.updateDate !== undefined) {
      Timestamp.encode(toTimestamp(message.updateDate), writer.uint32(58).fork()).ldelim();
    }
    if (message.broadcastDate !== undefined) {
      Timestamp.encode(toTimestamp(message.broadcastDate), writer.uint32(66).fork()).ldelim();
    }
    if (message.confirmationDate !== undefined) {
      Timestamp.encode(toTimestamp(message.confirmationDate), writer.uint32(74).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): RequestBundle_SignedRequestBundle {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseRequestBundle_SignedRequestBundle();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.id = longToNumber(reader.uint64() as Long);
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.status = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.transaction = reader.string();
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.hash = reader.string();
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.details = reader.string();
          continue;
        case 6:
          if (tag !== 50) {
            break;
          }

          message.creationDate = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        case 7:
          if (tag !== 58) {
            break;
          }

          message.updateDate = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        case 8:
          if (tag !== 66) {
            break;
          }

          message.broadcastDate = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        case 9:
          if (tag !== 74) {
            break;
          }

          message.confirmationDate = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): RequestBundle_SignedRequestBundle {
    return {
      id: isSet(object.id) ? globalThis.Number(object.id) : 0,
      status: isSet(object.status) ? globalThis.String(object.status) : "",
      transaction: isSet(object.transaction) ? globalThis.String(object.transaction) : "",
      hash: isSet(object.hash) ? globalThis.String(object.hash) : "",
      details: isSet(object.details) ? globalThis.String(object.details) : "",
      creationDate: isSet(object.creationDate) ? fromJsonTimestamp(object.creationDate) : undefined,
      updateDate: isSet(object.updateDate) ? fromJsonTimestamp(object.updateDate) : undefined,
      broadcastDate: isSet(object.broadcastDate) ? fromJsonTimestamp(object.broadcastDate) : undefined,
      confirmationDate: isSet(object.confirmationDate) ? fromJsonTimestamp(object.confirmationDate) : undefined,
    };
  },

  toJSON(message: RequestBundle_SignedRequestBundle): unknown {
    const obj: any = {};
    if (message.id !== 0) {
      obj.id = Math.round(message.id);
    }
    if (message.status !== "") {
      obj.status = message.status;
    }
    if (message.transaction !== "") {
      obj.transaction = message.transaction;
    }
    if (message.hash !== "") {
      obj.hash = message.hash;
    }
    if (message.details !== "") {
      obj.details = message.details;
    }
    if (message.creationDate !== undefined) {
      obj.creationDate = message.creationDate.toISOString();
    }
    if (message.updateDate !== undefined) {
      obj.updateDate = message.updateDate.toISOString();
    }
    if (message.broadcastDate !== undefined) {
      obj.broadcastDate = message.broadcastDate.toISOString();
    }
    if (message.confirmationDate !== undefined) {
      obj.confirmationDate = message.confirmationDate.toISOString();
    }
    return obj;
  },

  create(base?: DeepPartial<RequestBundle_SignedRequestBundle>): RequestBundle_SignedRequestBundle {
    return RequestBundle_SignedRequestBundle.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<RequestBundle_SignedRequestBundle>): RequestBundle_SignedRequestBundle {
    const message = createBaseRequestBundle_SignedRequestBundle();
    message.id = object.id ?? 0;
    message.status = object.status ?? "";
    message.transaction = object.transaction ?? "";
    message.hash = object.hash ?? "";
    message.details = object.details ?? "";
    message.creationDate = object.creationDate ?? undefined;
    message.updateDate = object.updateDate ?? undefined;
    message.broadcastDate = object.broadcastDate ?? undefined;
    message.confirmationDate = object.confirmationDate ?? undefined;
    return message;
  },
};

function createBaseRequest(): Request {
  return {
    id: 0,
    tenantId: 0,
    currency: "",
    envelope: "",
    status: "",
    trails: [],
    signedRequests: [],
    creationDate: undefined,
    updateDate: undefined,
    metadata: undefined,
    attributes: [],
    rule: "",
    approvers: undefined,
    type: "",
    currencyInfo: undefined,
    needsApprovalFrom: [],
    requestBundleId: 0,
    externalRequestId: "",
    travelRuleDataInput: undefined,
  };
}

export const Request = {
  encode(message: Request, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.id !== 0) {
      writer.uint32(8).uint64(message.id);
    }
    if (message.tenantId !== 0) {
      writer.uint32(16).uint64(message.tenantId);
    }
    if (message.currency !== "") {
      writer.uint32(26).string(message.currency);
    }
    if (message.envelope !== "") {
      writer.uint32(34).string(message.envelope);
    }
    if (message.status !== "") {
      writer.uint32(42).string(message.status);
    }
    for (const v of message.trails) {
      Request_Trail.encode(v!, writer.uint32(50).fork()).ldelim();
    }
    for (const v of message.signedRequests) {
      Request_SignedRequest.encode(v!, writer.uint32(58).fork()).ldelim();
    }
    if (message.creationDate !== undefined) {
      Timestamp.encode(toTimestamp(message.creationDate), writer.uint32(66).fork()).ldelim();
    }
    if (message.updateDate !== undefined) {
      Timestamp.encode(toTimestamp(message.updateDate), writer.uint32(74).fork()).ldelim();
    }
    if (message.metadata !== undefined) {
      Metadata.encode(message.metadata, writer.uint32(82).fork()).ldelim();
    }
    for (const v of message.attributes) {
      RequestAttribute.encode(v!, writer.uint32(90).fork()).ldelim();
    }
    if (message.rule !== "") {
      writer.uint32(98).string(message.rule);
    }
    if (message.approvers !== undefined) {
      Approvers.encode(message.approvers, writer.uint32(106).fork()).ldelim();
    }
    if (message.type !== "") {
      writer.uint32(114).string(message.type);
    }
    if (message.currencyInfo !== undefined) {
      Currency.encode(message.currencyInfo, writer.uint32(122).fork()).ldelim();
    }
    for (const v of message.needsApprovalFrom) {
      writer.uint32(130).string(v!);
    }
    if (message.requestBundleId !== 0) {
      writer.uint32(136).uint64(message.requestBundleId);
    }
    if (message.externalRequestId !== "") {
      writer.uint32(146).string(message.externalRequestId);
    }
    if (message.travelRuleDataInput !== undefined) {
      TravelRuleDataInput.encode(message.travelRuleDataInput, writer.uint32(154).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): Request {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.id = longToNumber(reader.uint64() as Long);
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.tenantId = longToNumber(reader.uint64() as Long);
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.currency = reader.string();
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.envelope = reader.string();
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.status = reader.string();
          continue;
        case 6:
          if (tag !== 50) {
            break;
          }

          message.trails.push(Request_Trail.decode(reader, reader.uint32()));
          continue;
        case 7:
          if (tag !== 58) {
            break;
          }

          message.signedRequests.push(Request_SignedRequest.decode(reader, reader.uint32()));
          continue;
        case 8:
          if (tag !== 66) {
            break;
          }

          message.creationDate = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        case 9:
          if (tag !== 74) {
            break;
          }

          message.updateDate = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        case 10:
          if (tag !== 82) {
            break;
          }

          message.metadata = Metadata.decode(reader, reader.uint32());
          continue;
        case 11:
          if (tag !== 90) {
            break;
          }

          message.attributes.push(RequestAttribute.decode(reader, reader.uint32()));
          continue;
        case 12:
          if (tag !== 98) {
            break;
          }

          message.rule = reader.string();
          continue;
        case 13:
          if (tag !== 106) {
            break;
          }

          message.approvers = Approvers.decode(reader, reader.uint32());
          continue;
        case 14:
          if (tag !== 114) {
            break;
          }

          message.type = reader.string();
          continue;
        case 15:
          if (tag !== 122) {
            break;
          }

          message.currencyInfo = Currency.decode(reader, reader.uint32());
          continue;
        case 16:
          if (tag !== 130) {
            break;
          }

          message.needsApprovalFrom.push(reader.string());
          continue;
        case 17:
          if (tag !== 136) {
            break;
          }

          message.requestBundleId = longToNumber(reader.uint64() as Long);
          continue;
        case 18:
          if (tag !== 146) {
            break;
          }

          message.externalRequestId = reader.string();
          continue;
        case 19:
          if (tag !== 154) {
            break;
          }

          message.travelRuleDataInput = TravelRuleDataInput.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Request {
    return {
      id: isSet(object.id) ? globalThis.Number(object.id) : 0,
      tenantId: isSet(object.tenantId) ? globalThis.Number(object.tenantId) : 0,
      currency: isSet(object.currency) ? globalThis.String(object.currency) : "",
      envelope: isSet(object.envelope) ? globalThis.String(object.envelope) : "",
      status: isSet(object.status) ? globalThis.String(object.status) : "",
      trails: globalThis.Array.isArray(object?.trails) ? object.trails.map((e: any) => Request_Trail.fromJSON(e)) : [],
      signedRequests: globalThis.Array.isArray(object?.signedRequests)
        ? object.signedRequests.map((e: any) => Request_SignedRequest.fromJSON(e))
        : [],
      creationDate: isSet(object.creationDate) ? fromJsonTimestamp(object.creationDate) : undefined,
      updateDate: isSet(object.updateDate) ? fromJsonTimestamp(object.updateDate) : undefined,
      metadata: isSet(object.metadata) ? Metadata.fromJSON(object.metadata) : undefined,
      attributes: globalThis.Array.isArray(object?.attributes)
        ? object.attributes.map((e: any) => RequestAttribute.fromJSON(e))
        : [],
      rule: isSet(object.rule) ? globalThis.String(object.rule) : "",
      approvers: isSet(object.approvers) ? Approvers.fromJSON(object.approvers) : undefined,
      type: isSet(object.type) ? globalThis.String(object.type) : "",
      currencyInfo: isSet(object.currencyInfo) ? Currency.fromJSON(object.currencyInfo) : undefined,
      needsApprovalFrom: globalThis.Array.isArray(object?.needsApprovalFrom)
        ? object.needsApprovalFrom.map((e: any) => globalThis.String(e))
        : [],
      requestBundleId: isSet(object.requestBundleId) ? globalThis.Number(object.requestBundleId) : 0,
      externalRequestId: isSet(object.externalRequestId) ? globalThis.String(object.externalRequestId) : "",
      travelRuleDataInput: isSet(object.travelRuleDataInput)
        ? TravelRuleDataInput.fromJSON(object.travelRuleDataInput)
        : undefined,
    };
  },

  toJSON(message: Request): unknown {
    const obj: any = {};
    if (message.id !== 0) {
      obj.id = Math.round(message.id);
    }
    if (message.tenantId !== 0) {
      obj.tenantId = Math.round(message.tenantId);
    }
    if (message.currency !== "") {
      obj.currency = message.currency;
    }
    if (message.envelope !== "") {
      obj.envelope = message.envelope;
    }
    if (message.status !== "") {
      obj.status = message.status;
    }
    if (message.trails?.length) {
      obj.trails = message.trails.map((e) => Request_Trail.toJSON(e));
    }
    if (message.signedRequests?.length) {
      obj.signedRequests = message.signedRequests.map((e) => Request_SignedRequest.toJSON(e));
    }
    if (message.creationDate !== undefined) {
      obj.creationDate = message.creationDate.toISOString();
    }
    if (message.updateDate !== undefined) {
      obj.updateDate = message.updateDate.toISOString();
    }
    if (message.metadata !== undefined) {
      obj.metadata = Metadata.toJSON(message.metadata);
    }
    if (message.attributes?.length) {
      obj.attributes = message.attributes.map((e) => RequestAttribute.toJSON(e));
    }
    if (message.rule !== "") {
      obj.rule = message.rule;
    }
    if (message.approvers !== undefined) {
      obj.approvers = Approvers.toJSON(message.approvers);
    }
    if (message.type !== "") {
      obj.type = message.type;
    }
    if (message.currencyInfo !== undefined) {
      obj.currencyInfo = Currency.toJSON(message.currencyInfo);
    }
    if (message.needsApprovalFrom?.length) {
      obj.needsApprovalFrom = message.needsApprovalFrom;
    }
    if (message.requestBundleId !== 0) {
      obj.requestBundleId = Math.round(message.requestBundleId);
    }
    if (message.externalRequestId !== "") {
      obj.externalRequestId = message.externalRequestId;
    }
    if (message.travelRuleDataInput !== undefined) {
      obj.travelRuleDataInput = TravelRuleDataInput.toJSON(message.travelRuleDataInput);
    }
    return obj;
  },

  create(base?: DeepPartial<Request>): Request {
    return Request.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<Request>): Request {
    const message = createBaseRequest();
    message.id = object.id ?? 0;
    message.tenantId = object.tenantId ?? 0;
    message.currency = object.currency ?? "";
    message.envelope = object.envelope ?? "";
    message.status = object.status ?? "";
    message.trails = object.trails?.map((e) => Request_Trail.fromPartial(e)) || [];
    message.signedRequests = object.signedRequests?.map((e) => Request_SignedRequest.fromPartial(e)) || [];
    message.creationDate = object.creationDate ?? undefined;
    message.updateDate = object.updateDate ?? undefined;
    message.metadata = (object.metadata !== undefined && object.metadata !== null)
      ? Metadata.fromPartial(object.metadata)
      : undefined;
    message.attributes = object.attributes?.map((e) => RequestAttribute.fromPartial(e)) || [];
    message.rule = object.rule ?? "";
    message.approvers = (object.approvers !== undefined && object.approvers !== null)
      ? Approvers.fromPartial(object.approvers)
      : undefined;
    message.type = object.type ?? "";
    message.currencyInfo = (object.currencyInfo !== undefined && object.currencyInfo !== null)
      ? Currency.fromPartial(object.currencyInfo)
      : undefined;
    message.needsApprovalFrom = object.needsApprovalFrom?.map((e) => e) || [];
    message.requestBundleId = object.requestBundleId ?? 0;
    message.externalRequestId = object.externalRequestId ?? "";
    message.travelRuleDataInput = (object.travelRuleDataInput !== undefined && object.travelRuleDataInput !== null)
      ? TravelRuleDataInput.fromPartial(object.travelRuleDataInput)
      : undefined;
    return message;
  },
};

function createBaseRequest_Trail(): Request_Trail {
  return { id: 0, userId: 0, externalUserId: "", action: "", comment: "", date: undefined, requestStatus: "" };
}

export const Request_Trail = {
  encode(message: Request_Trail, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.id !== 0) {
      writer.uint32(8).uint64(message.id);
    }
    if (message.userId !== 0) {
      writer.uint32(16).uint64(message.userId);
    }
    if (message.externalUserId !== "") {
      writer.uint32(26).string(message.externalUserId);
    }
    if (message.action !== "") {
      writer.uint32(34).string(message.action);
    }
    if (message.comment !== "") {
      writer.uint32(42).string(message.comment);
    }
    if (message.date !== undefined) {
      Timestamp.encode(toTimestamp(message.date), writer.uint32(50).fork()).ldelim();
    }
    if (message.requestStatus !== "") {
      writer.uint32(58).string(message.requestStatus);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): Request_Trail {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseRequest_Trail();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.id = longToNumber(reader.uint64() as Long);
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.userId = longToNumber(reader.uint64() as Long);
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.externalUserId = reader.string();
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.action = reader.string();
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.comment = reader.string();
          continue;
        case 6:
          if (tag !== 50) {
            break;
          }

          message.date = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        case 7:
          if (tag !== 58) {
            break;
          }

          message.requestStatus = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Request_Trail {
    return {
      id: isSet(object.id) ? globalThis.Number(object.id) : 0,
      userId: isSet(object.userId) ? globalThis.Number(object.userId) : 0,
      externalUserId: isSet(object.externalUserId) ? globalThis.String(object.externalUserId) : "",
      action: isSet(object.action) ? globalThis.String(object.action) : "",
      comment: isSet(object.comment) ? globalThis.String(object.comment) : "",
      date: isSet(object.date) ? fromJsonTimestamp(object.date) : undefined,
      requestStatus: isSet(object.requestStatus) ? globalThis.String(object.requestStatus) : "",
    };
  },

  toJSON(message: Request_Trail): unknown {
    const obj: any = {};
    if (message.id !== 0) {
      obj.id = Math.round(message.id);
    }
    if (message.userId !== 0) {
      obj.userId = Math.round(message.userId);
    }
    if (message.externalUserId !== "") {
      obj.externalUserId = message.externalUserId;
    }
    if (message.action !== "") {
      obj.action = message.action;
    }
    if (message.comment !== "") {
      obj.comment = message.comment;
    }
    if (message.date !== undefined) {
      obj.date = message.date.toISOString();
    }
    if (message.requestStatus !== "") {
      obj.requestStatus = message.requestStatus;
    }
    return obj;
  },

  create(base?: DeepPartial<Request_Trail>): Request_Trail {
    return Request_Trail.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<Request_Trail>): Request_Trail {
    const message = createBaseRequest_Trail();
    message.id = object.id ?? 0;
    message.userId = object.userId ?? 0;
    message.externalUserId = object.externalUserId ?? "";
    message.action = object.action ?? "";
    message.comment = object.comment ?? "";
    message.date = object.date ?? undefined;
    message.requestStatus = object.requestStatus ?? "";
    return message;
  },
};

function createBaseRequest_SignedRequest(): Request_SignedRequest {
  return {
    id: 0,
    signedRequest: "",
    status: "",
    hash: "",
    block: 0,
    details: "",
    creationDate: undefined,
    updateDate: undefined,
    broadcastDate: undefined,
    confirmationDate: undefined,
    attributes: [],
  };
}

export const Request_SignedRequest = {
  encode(message: Request_SignedRequest, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.id !== 0) {
      writer.uint32(8).uint64(message.id);
    }
    if (message.signedRequest !== "") {
      writer.uint32(18).string(message.signedRequest);
    }
    if (message.status !== "") {
      writer.uint32(26).string(message.status);
    }
    if (message.hash !== "") {
      writer.uint32(34).string(message.hash);
    }
    if (message.block !== 0) {
      writer.uint32(40).uint32(message.block);
    }
    if (message.details !== "") {
      writer.uint32(50).string(message.details);
    }
    if (message.creationDate !== undefined) {
      Timestamp.encode(toTimestamp(message.creationDate), writer.uint32(58).fork()).ldelim();
    }
    if (message.updateDate !== undefined) {
      Timestamp.encode(toTimestamp(message.updateDate), writer.uint32(66).fork()).ldelim();
    }
    if (message.broadcastDate !== undefined) {
      Timestamp.encode(toTimestamp(message.broadcastDate), writer.uint32(74).fork()).ldelim();
    }
    if (message.confirmationDate !== undefined) {
      Timestamp.encode(toTimestamp(message.confirmationDate), writer.uint32(82).fork()).ldelim();
    }
    for (const v of message.attributes) {
      SignedRequestAttribute.encode(v!, writer.uint32(90).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): Request_SignedRequest {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseRequest_SignedRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.id = longToNumber(reader.uint64() as Long);
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.signedRequest = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.status = reader.string();
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.hash = reader.string();
          continue;
        case 5:
          if (tag !== 40) {
            break;
          }

          message.block = reader.uint32();
          continue;
        case 6:
          if (tag !== 50) {
            break;
          }

          message.details = reader.string();
          continue;
        case 7:
          if (tag !== 58) {
            break;
          }

          message.creationDate = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        case 8:
          if (tag !== 66) {
            break;
          }

          message.updateDate = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        case 9:
          if (tag !== 74) {
            break;
          }

          message.broadcastDate = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        case 10:
          if (tag !== 82) {
            break;
          }

          message.confirmationDate = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        case 11:
          if (tag !== 90) {
            break;
          }

          message.attributes.push(SignedRequestAttribute.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Request_SignedRequest {
    return {
      id: isSet(object.id) ? globalThis.Number(object.id) : 0,
      signedRequest: isSet(object.signedRequest) ? globalThis.String(object.signedRequest) : "",
      status: isSet(object.status) ? globalThis.String(object.status) : "",
      hash: isSet(object.hash) ? globalThis.String(object.hash) : "",
      block: isSet(object.block) ? globalThis.Number(object.block) : 0,
      details: isSet(object.details) ? globalThis.String(object.details) : "",
      creationDate: isSet(object.creationDate) ? fromJsonTimestamp(object.creationDate) : undefined,
      updateDate: isSet(object.updateDate) ? fromJsonTimestamp(object.updateDate) : undefined,
      broadcastDate: isSet(object.broadcastDate) ? fromJsonTimestamp(object.broadcastDate) : undefined,
      confirmationDate: isSet(object.confirmationDate) ? fromJsonTimestamp(object.confirmationDate) : undefined,
      attributes: globalThis.Array.isArray(object?.attributes)
        ? object.attributes.map((e: any) => SignedRequestAttribute.fromJSON(e))
        : [],
    };
  },

  toJSON(message: Request_SignedRequest): unknown {
    const obj: any = {};
    if (message.id !== 0) {
      obj.id = Math.round(message.id);
    }
    if (message.signedRequest !== "") {
      obj.signedRequest = message.signedRequest;
    }
    if (message.status !== "") {
      obj.status = message.status;
    }
    if (message.hash !== "") {
      obj.hash = message.hash;
    }
    if (message.block !== 0) {
      obj.block = Math.round(message.block);
    }
    if (message.details !== "") {
      obj.details = message.details;
    }
    if (message.creationDate !== undefined) {
      obj.creationDate = message.creationDate.toISOString();
    }
    if (message.updateDate !== undefined) {
      obj.updateDate = message.updateDate.toISOString();
    }
    if (message.broadcastDate !== undefined) {
      obj.broadcastDate = message.broadcastDate.toISOString();
    }
    if (message.confirmationDate !== undefined) {
      obj.confirmationDate = message.confirmationDate.toISOString();
    }
    if (message.attributes?.length) {
      obj.attributes = message.attributes.map((e) => SignedRequestAttribute.toJSON(e));
    }
    return obj;
  },

  create(base?: DeepPartial<Request_SignedRequest>): Request_SignedRequest {
    return Request_SignedRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<Request_SignedRequest>): Request_SignedRequest {
    const message = createBaseRequest_SignedRequest();
    message.id = object.id ?? 0;
    message.signedRequest = object.signedRequest ?? "";
    message.status = object.status ?? "";
    message.hash = object.hash ?? "";
    message.block = object.block ?? 0;
    message.details = object.details ?? "";
    message.creationDate = object.creationDate ?? undefined;
    message.updateDate = object.updateDate ?? undefined;
    message.broadcastDate = object.broadcastDate ?? undefined;
    message.confirmationDate = object.confirmationDate ?? undefined;
    message.attributes = object.attributes?.map((e) => SignedRequestAttribute.fromPartial(e)) || [];
    return message;
  },
};

function createBaseContractArgValue(): ContractArgValue {
  return { primitive: "", composite: [] };
}

export const ContractArgValue = {
  encode(message: ContractArgValue, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.primitive !== "") {
      writer.uint32(10).string(message.primitive);
    }
    for (const v of message.composite) {
      ContractArgValue.encode(v!, writer.uint32(18).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): ContractArgValue {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseContractArgValue();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.primitive = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.composite.push(ContractArgValue.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ContractArgValue {
    return {
      primitive: isSet(object.primitive) ? globalThis.String(object.primitive) : "",
      composite: globalThis.Array.isArray(object?.composite)
        ? object.composite.map((e: any) => ContractArgValue.fromJSON(e))
        : [],
    };
  },

  toJSON(message: ContractArgValue): unknown {
    const obj: any = {};
    if (message.primitive !== "") {
      obj.primitive = message.primitive;
    }
    if (message.composite?.length) {
      obj.composite = message.composite.map((e) => ContractArgValue.toJSON(e));
    }
    return obj;
  },

  create(base?: DeepPartial<ContractArgValue>): ContractArgValue {
    return ContractArgValue.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ContractArgValue>): ContractArgValue {
    const message = createBaseContractArgValue();
    message.primitive = object.primitive ?? "";
    message.composite = object.composite?.map((e) => ContractArgValue.fromPartial(e)) || [];
    return message;
  },
};

function createBaseContractArg(): ContractArg {
  return { name: "", type: "", value: undefined };
}

export const ContractArg = {
  encode(message: ContractArg, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    if (message.type !== "") {
      writer.uint32(18).string(message.type);
    }
    if (message.value !== undefined) {
      ContractArgValue.encode(message.value, writer.uint32(26).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): ContractArg {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseContractArg();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.type = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.value = ContractArgValue.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ContractArg {
    return {
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      type: isSet(object.type) ? globalThis.String(object.type) : "",
      value: isSet(object.value) ? ContractArgValue.fromJSON(object.value) : undefined,
    };
  },

  toJSON(message: ContractArg): unknown {
    const obj: any = {};
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.type !== "") {
      obj.type = message.type;
    }
    if (message.value !== undefined) {
      obj.value = ContractArgValue.toJSON(message.value);
    }
    return obj;
  },

  create(base?: DeepPartial<ContractArg>): ContractArg {
    return ContractArg.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ContractArg>): ContractArg {
    const message = createBaseContractArg();
    message.name = object.name ?? "";
    message.type = object.type ?? "";
    message.value = (object.value !== undefined && object.value !== null)
      ? ContractArgValue.fromPartial(object.value)
      : undefined;
    return message;
  },
};

function createBaseContractCall(): ContractCall {
  return { functionSignature: "", args: [] };
}

export const ContractCall = {
  encode(message: ContractCall, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.functionSignature !== "") {
      writer.uint32(10).string(message.functionSignature);
    }
    for (const v of message.args) {
      ContractArg.encode(v!, writer.uint32(18).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): ContractCall {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseContractCall();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.functionSignature = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.args.push(ContractArg.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ContractCall {
    return {
      functionSignature: isSet(object.functionSignature) ? globalThis.String(object.functionSignature) : "",
      args: globalThis.Array.isArray(object?.args) ? object.args.map((e: any) => ContractArg.fromJSON(e)) : [],
    };
  },

  toJSON(message: ContractCall): unknown {
    const obj: any = {};
    if (message.functionSignature !== "") {
      obj.functionSignature = message.functionSignature;
    }
    if (message.args?.length) {
      obj.args = message.args.map((e) => ContractArg.toJSON(e));
    }
    return obj;
  },

  create(base?: DeepPartial<ContractCall>): ContractCall {
    return ContractCall.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ContractCall>): ContractCall {
    const message = createBaseContractCall();
    message.functionSignature = object.functionSignature ?? "";
    message.args = object.args?.map((e) => ContractArg.fromPartial(e)) || [];
    return message;
  },
};

function createBaseGenericContractCall(): GenericContractCall {
  return { blockchain: "", eth: undefined, xtz: undefined, evm: undefined };
}

export const GenericContractCall = {
  encode(message: GenericContractCall, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.blockchain !== "") {
      writer.uint32(10).string(message.blockchain);
    }
    if (message.eth !== undefined) {
      ContractCall.encode(message.eth, writer.uint32(18).fork()).ldelim();
    }
    if (message.xtz !== undefined) {
      XTZContractCall.encode(message.xtz, writer.uint32(26).fork()).ldelim();
    }
    if (message.evm !== undefined) {
      ContractCall.encode(message.evm, writer.uint32(34).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): GenericContractCall {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGenericContractCall();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.blockchain = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.eth = ContractCall.decode(reader, reader.uint32());
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.xtz = XTZContractCall.decode(reader, reader.uint32());
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.evm = ContractCall.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GenericContractCall {
    return {
      blockchain: isSet(object.blockchain) ? globalThis.String(object.blockchain) : "",
      eth: isSet(object.eth) ? ContractCall.fromJSON(object.eth) : undefined,
      xtz: isSet(object.xtz) ? XTZContractCall.fromJSON(object.xtz) : undefined,
      evm: isSet(object.evm) ? ContractCall.fromJSON(object.evm) : undefined,
    };
  },

  toJSON(message: GenericContractCall): unknown {
    const obj: any = {};
    if (message.blockchain !== "") {
      obj.blockchain = message.blockchain;
    }
    if (message.eth !== undefined) {
      obj.eth = ContractCall.toJSON(message.eth);
    }
    if (message.xtz !== undefined) {
      obj.xtz = XTZContractCall.toJSON(message.xtz);
    }
    if (message.evm !== undefined) {
      obj.evm = ContractCall.toJSON(message.evm);
    }
    return obj;
  },

  create(base?: DeepPartial<GenericContractCall>): GenericContractCall {
    return GenericContractCall.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<GenericContractCall>): GenericContractCall {
    const message = createBaseGenericContractCall();
    message.blockchain = object.blockchain ?? "";
    message.eth = (object.eth !== undefined && object.eth !== null) ? ContractCall.fromPartial(object.eth) : undefined;
    message.xtz = (object.xtz !== undefined && object.xtz !== null)
      ? XTZContractCall.fromPartial(object.xtz)
      : undefined;
    message.evm = (object.evm !== undefined && object.evm !== null) ? ContractCall.fromPartial(object.evm) : undefined;
    return message;
  },
};

function createBaseGenericCreateContract(): GenericCreateContract {
  return { blockchain: "", eth: undefined, xtz: undefined, evm: undefined };
}

export const GenericCreateContract = {
  encode(message: GenericCreateContract, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.blockchain !== "") {
      writer.uint32(10).string(message.blockchain);
    }
    if (message.eth !== undefined) {
      GenericCreateContract_EVMContract.encode(message.eth, writer.uint32(18).fork()).ldelim();
    }
    if (message.xtz !== undefined) {
      GenericCreateContract_XTZContract.encode(message.xtz, writer.uint32(26).fork()).ldelim();
    }
    if (message.evm !== undefined) {
      GenericCreateContract_EVMContract.encode(message.evm, writer.uint32(34).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): GenericCreateContract {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGenericCreateContract();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.blockchain = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.eth = GenericCreateContract_EVMContract.decode(reader, reader.uint32());
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.xtz = GenericCreateContract_XTZContract.decode(reader, reader.uint32());
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.evm = GenericCreateContract_EVMContract.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GenericCreateContract {
    return {
      blockchain: isSet(object.blockchain) ? globalThis.String(object.blockchain) : "",
      eth: isSet(object.eth) ? GenericCreateContract_EVMContract.fromJSON(object.eth) : undefined,
      xtz: isSet(object.xtz) ? GenericCreateContract_XTZContract.fromJSON(object.xtz) : undefined,
      evm: isSet(object.evm) ? GenericCreateContract_EVMContract.fromJSON(object.evm) : undefined,
    };
  },

  toJSON(message: GenericCreateContract): unknown {
    const obj: any = {};
    if (message.blockchain !== "") {
      obj.blockchain = message.blockchain;
    }
    if (message.eth !== undefined) {
      obj.eth = GenericCreateContract_EVMContract.toJSON(message.eth);
    }
    if (message.xtz !== undefined) {
      obj.xtz = GenericCreateContract_XTZContract.toJSON(message.xtz);
    }
    if (message.evm !== undefined) {
      obj.evm = GenericCreateContract_EVMContract.toJSON(message.evm);
    }
    return obj;
  },

  create(base?: DeepPartial<GenericCreateContract>): GenericCreateContract {
    return GenericCreateContract.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<GenericCreateContract>): GenericCreateContract {
    const message = createBaseGenericCreateContract();
    message.blockchain = object.blockchain ?? "";
    message.eth = (object.eth !== undefined && object.eth !== null)
      ? GenericCreateContract_EVMContract.fromPartial(object.eth)
      : undefined;
    message.xtz = (object.xtz !== undefined && object.xtz !== null)
      ? GenericCreateContract_XTZContract.fromPartial(object.xtz)
      : undefined;
    message.evm = (object.evm !== undefined && object.evm !== null)
      ? GenericCreateContract_EVMContract.fromPartial(object.evm)
      : undefined;
    return message;
  },
};

function createBaseGenericCreateContract_EVMContract(): GenericCreateContract_EVMContract {
  return { bytecode: new Uint8Array(0), constructor: undefined };
}

export const GenericCreateContract_EVMContract = {
  encode(message: GenericCreateContract_EVMContract, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.bytecode.length !== 0) {
      writer.uint32(10).bytes(message.bytecode);
    }
    if (message.constructor !== undefined) {
      ContractCall.encode(message.constructor, writer.uint32(18).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): GenericCreateContract_EVMContract {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGenericCreateContract_EVMContract();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.bytecode = reader.bytes();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.constructor = ContractCall.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GenericCreateContract_EVMContract {
    return {
      bytecode: isSet(object.bytecode) ? bytesFromBase64(object.bytecode) : new Uint8Array(0),
      constructor: isSet(object.constructor) ? ContractCall.fromJSON(object.constructor) : undefined,
    };
  },

  toJSON(message: GenericCreateContract_EVMContract): unknown {
    const obj: any = {};
    if (message.bytecode.length !== 0) {
      obj.bytecode = base64FromBytes(message.bytecode);
    }
    if (message.constructor !== undefined) {
      obj.constructor = ContractCall.toJSON(message.constructor);
    }
    return obj;
  },

  create(base?: DeepPartial<GenericCreateContract_EVMContract>): GenericCreateContract_EVMContract {
    return GenericCreateContract_EVMContract.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<GenericCreateContract_EVMContract>): GenericCreateContract_EVMContract {
    const message = createBaseGenericCreateContract_EVMContract();
    message.bytecode = object.bytecode ?? new Uint8Array(0);
    message.constructor = (object.constructor !== undefined && object.constructor !== null)
      ? ContractCall.fromPartial(object.constructor)
      : undefined;
    return message;
  },
};

function createBaseGenericCreateContract_XTZContract(): GenericCreateContract_XTZContract {
  return { code: "", storage: undefined, delegate: undefined };
}

export const GenericCreateContract_XTZContract = {
  encode(message: GenericCreateContract_XTZContract, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.code !== "") {
      writer.uint32(10).string(message.code);
    }
    if (message.storage !== undefined) {
      XTZContractArg.encode(message.storage, writer.uint32(18).fork()).ldelim();
    }
    if (message.delegate !== undefined) {
      GenericCreateContract_XTZContract_Delegate.encode(message.delegate, writer.uint32(26).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): GenericCreateContract_XTZContract {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGenericCreateContract_XTZContract();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.code = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.storage = XTZContractArg.decode(reader, reader.uint32());
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.delegate = GenericCreateContract_XTZContract_Delegate.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GenericCreateContract_XTZContract {
    return {
      code: isSet(object.code) ? globalThis.String(object.code) : "",
      storage: isSet(object.storage) ? XTZContractArg.fromJSON(object.storage) : undefined,
      delegate: isSet(object.delegate)
        ? GenericCreateContract_XTZContract_Delegate.fromJSON(object.delegate)
        : undefined,
    };
  },

  toJSON(message: GenericCreateContract_XTZContract): unknown {
    const obj: any = {};
    if (message.code !== "") {
      obj.code = message.code;
    }
    if (message.storage !== undefined) {
      obj.storage = XTZContractArg.toJSON(message.storage);
    }
    if (message.delegate !== undefined) {
      obj.delegate = GenericCreateContract_XTZContract_Delegate.toJSON(message.delegate);
    }
    return obj;
  },

  create(base?: DeepPartial<GenericCreateContract_XTZContract>): GenericCreateContract_XTZContract {
    return GenericCreateContract_XTZContract.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<GenericCreateContract_XTZContract>): GenericCreateContract_XTZContract {
    const message = createBaseGenericCreateContract_XTZContract();
    message.code = object.code ?? "";
    message.storage = (object.storage !== undefined && object.storage !== null)
      ? XTZContractArg.fromPartial(object.storage)
      : undefined;
    message.delegate = (object.delegate !== undefined && object.delegate !== null)
      ? GenericCreateContract_XTZContract_Delegate.fromPartial(object.delegate)
      : undefined;
    return message;
  },
};

function createBaseGenericCreateContract_XTZContract_Delegate(): GenericCreateContract_XTZContract_Delegate {
  return { toAddressId: 0, toWhitelistedAddressId: 0 };
}

export const GenericCreateContract_XTZContract_Delegate = {
  encode(message: GenericCreateContract_XTZContract_Delegate, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.toAddressId !== 0) {
      writer.uint32(8).uint64(message.toAddressId);
    }
    if (message.toWhitelistedAddressId !== 0) {
      writer.uint32(16).uint64(message.toWhitelistedAddressId);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): GenericCreateContract_XTZContract_Delegate {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGenericCreateContract_XTZContract_Delegate();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.toAddressId = longToNumber(reader.uint64() as Long);
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.toWhitelistedAddressId = longToNumber(reader.uint64() as Long);
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GenericCreateContract_XTZContract_Delegate {
    return {
      toAddressId: isSet(object.toAddressId) ? globalThis.Number(object.toAddressId) : 0,
      toWhitelistedAddressId: isSet(object.toWhitelistedAddressId)
        ? globalThis.Number(object.toWhitelistedAddressId)
        : 0,
    };
  },

  toJSON(message: GenericCreateContract_XTZContract_Delegate): unknown {
    const obj: any = {};
    if (message.toAddressId !== 0) {
      obj.toAddressId = Math.round(message.toAddressId);
    }
    if (message.toWhitelistedAddressId !== 0) {
      obj.toWhitelistedAddressId = Math.round(message.toWhitelistedAddressId);
    }
    return obj;
  },

  create(base?: DeepPartial<GenericCreateContract_XTZContract_Delegate>): GenericCreateContract_XTZContract_Delegate {
    return GenericCreateContract_XTZContract_Delegate.fromPartial(base ?? {});
  },
  fromPartial(
    object: DeepPartial<GenericCreateContract_XTZContract_Delegate>,
  ): GenericCreateContract_XTZContract_Delegate {
    const message = createBaseGenericCreateContract_XTZContract_Delegate();
    message.toAddressId = object.toAddressId ?? 0;
    message.toWhitelistedAddressId = object.toWhitelistedAddressId ?? 0;
    return message;
  },
};

function createBaseCosmosMessageValue(): CosmosMessageValue {
  return { kind: "", name: "", fieldId: 0, value: undefined };
}

export const CosmosMessageValue = {
  encode(message: CosmosMessageValue, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.kind !== "") {
      writer.uint32(10).string(message.kind);
    }
    if (message.name !== "") {
      writer.uint32(18).string(message.name);
    }
    if (message.fieldId !== 0) {
      writer.uint32(24).uint64(message.fieldId);
    }
    if (message.value !== undefined) {
      CosmosMessageValue_Value.encode(message.value, writer.uint32(34).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CosmosMessageValue {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCosmosMessageValue();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.kind = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.name = reader.string();
          continue;
        case 3:
          if (tag !== 24) {
            break;
          }

          message.fieldId = longToNumber(reader.uint64() as Long);
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.value = CosmosMessageValue_Value.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CosmosMessageValue {
    return {
      kind: isSet(object.kind) ? globalThis.String(object.kind) : "",
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      fieldId: isSet(object.fieldId) ? globalThis.Number(object.fieldId) : 0,
      value: isSet(object.value) ? CosmosMessageValue_Value.fromJSON(object.value) : undefined,
    };
  },

  toJSON(message: CosmosMessageValue): unknown {
    const obj: any = {};
    if (message.kind !== "") {
      obj.kind = message.kind;
    }
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.fieldId !== 0) {
      obj.fieldId = Math.round(message.fieldId);
    }
    if (message.value !== undefined) {
      obj.value = CosmosMessageValue_Value.toJSON(message.value);
    }
    return obj;
  },

  create(base?: DeepPartial<CosmosMessageValue>): CosmosMessageValue {
    return CosmosMessageValue.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CosmosMessageValue>): CosmosMessageValue {
    const message = createBaseCosmosMessageValue();
    message.kind = object.kind ?? "";
    message.name = object.name ?? "";
    message.fieldId = object.fieldId ?? 0;
    message.value = (object.value !== undefined && object.value !== null)
      ? CosmosMessageValue_Value.fromPartial(object.value)
      : undefined;
    return message;
  },
};

function createBaseCosmosMessageValue_Source(): CosmosMessageValue_Source {
  return { addressId: 0 };
}

export const CosmosMessageValue_Source = {
  encode(message: CosmosMessageValue_Source, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.addressId !== 0) {
      writer.uint32(8).uint64(message.addressId);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CosmosMessageValue_Source {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCosmosMessageValue_Source();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.addressId = longToNumber(reader.uint64() as Long);
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CosmosMessageValue_Source {
    return { addressId: isSet(object.addressId) ? globalThis.Number(object.addressId) : 0 };
  },

  toJSON(message: CosmosMessageValue_Source): unknown {
    const obj: any = {};
    if (message.addressId !== 0) {
      obj.addressId = Math.round(message.addressId);
    }
    return obj;
  },

  create(base?: DeepPartial<CosmosMessageValue_Source>): CosmosMessageValue_Source {
    return CosmosMessageValue_Source.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CosmosMessageValue_Source>): CosmosMessageValue_Source {
    const message = createBaseCosmosMessageValue_Source();
    message.addressId = object.addressId ?? 0;
    return message;
  },
};

function createBaseCosmosMessageValue_Destination(): CosmosMessageValue_Destination {
  return { addressId: 0, whitelistedAddressId: 0 };
}

export const CosmosMessageValue_Destination = {
  encode(message: CosmosMessageValue_Destination, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.addressId !== 0) {
      writer.uint32(8).uint64(message.addressId);
    }
    if (message.whitelistedAddressId !== 0) {
      writer.uint32(16).uint64(message.whitelistedAddressId);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CosmosMessageValue_Destination {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCosmosMessageValue_Destination();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.addressId = longToNumber(reader.uint64() as Long);
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.whitelistedAddressId = longToNumber(reader.uint64() as Long);
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CosmosMessageValue_Destination {
    return {
      addressId: isSet(object.addressId) ? globalThis.Number(object.addressId) : 0,
      whitelistedAddressId: isSet(object.whitelistedAddressId) ? globalThis.Number(object.whitelistedAddressId) : 0,
    };
  },

  toJSON(message: CosmosMessageValue_Destination): unknown {
    const obj: any = {};
    if (message.addressId !== 0) {
      obj.addressId = Math.round(message.addressId);
    }
    if (message.whitelistedAddressId !== 0) {
      obj.whitelistedAddressId = Math.round(message.whitelistedAddressId);
    }
    return obj;
  },

  create(base?: DeepPartial<CosmosMessageValue_Destination>): CosmosMessageValue_Destination {
    return CosmosMessageValue_Destination.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CosmosMessageValue_Destination>): CosmosMessageValue_Destination {
    const message = createBaseCosmosMessageValue_Destination();
    message.addressId = object.addressId ?? 0;
    message.whitelistedAddressId = object.whitelistedAddressId ?? 0;
    return message;
  },
};

function createBaseCosmosMessageValue_Array(): CosmosMessageValue_Array {
  return { kind: "", elems: [] };
}

export const CosmosMessageValue_Array = {
  encode(message: CosmosMessageValue_Array, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.kind !== "") {
      writer.uint32(10).string(message.kind);
    }
    for (const v of message.elems) {
      CosmosMessageValue_Value.encode(v!, writer.uint32(18).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CosmosMessageValue_Array {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCosmosMessageValue_Array();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.kind = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.elems.push(CosmosMessageValue_Value.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CosmosMessageValue_Array {
    return {
      kind: isSet(object.kind) ? globalThis.String(object.kind) : "",
      elems: globalThis.Array.isArray(object?.elems)
        ? object.elems.map((e: any) => CosmosMessageValue_Value.fromJSON(e))
        : [],
    };
  },

  toJSON(message: CosmosMessageValue_Array): unknown {
    const obj: any = {};
    if (message.kind !== "") {
      obj.kind = message.kind;
    }
    if (message.elems?.length) {
      obj.elems = message.elems.map((e) => CosmosMessageValue_Value.toJSON(e));
    }
    return obj;
  },

  create(base?: DeepPartial<CosmosMessageValue_Array>): CosmosMessageValue_Array {
    return CosmosMessageValue_Array.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CosmosMessageValue_Array>): CosmosMessageValue_Array {
    const message = createBaseCosmosMessageValue_Array();
    message.kind = object.kind ?? "";
    message.elems = object.elems?.map((e) => CosmosMessageValue_Value.fromPartial(e)) || [];
    return message;
  },
};

function createBaseCosmosMessageValue_Value(): CosmosMessageValue_Value {
  return {
    source: undefined,
    destination: undefined,
    string: "",
    int: "",
    bytes: new Uint8Array(0),
    message: [],
    array: undefined,
  };
}

export const CosmosMessageValue_Value = {
  encode(message: CosmosMessageValue_Value, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.source !== undefined) {
      CosmosMessageValue_Source.encode(message.source, writer.uint32(10).fork()).ldelim();
    }
    if (message.destination !== undefined) {
      CosmosMessageValue_Destination.encode(message.destination, writer.uint32(18).fork()).ldelim();
    }
    if (message.string !== "") {
      writer.uint32(26).string(message.string);
    }
    if (message.int !== "") {
      writer.uint32(34).string(message.int);
    }
    if (message.bytes.length !== 0) {
      writer.uint32(42).bytes(message.bytes);
    }
    for (const v of message.message) {
      CosmosMessageValue.encode(v!, writer.uint32(50).fork()).ldelim();
    }
    if (message.array !== undefined) {
      CosmosMessageValue_Array.encode(message.array, writer.uint32(58).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CosmosMessageValue_Value {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCosmosMessageValue_Value();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.source = CosmosMessageValue_Source.decode(reader, reader.uint32());
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.destination = CosmosMessageValue_Destination.decode(reader, reader.uint32());
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.string = reader.string();
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.int = reader.string();
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.bytes = reader.bytes();
          continue;
        case 6:
          if (tag !== 50) {
            break;
          }

          message.message.push(CosmosMessageValue.decode(reader, reader.uint32()));
          continue;
        case 7:
          if (tag !== 58) {
            break;
          }

          message.array = CosmosMessageValue_Array.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CosmosMessageValue_Value {
    return {
      source: isSet(object.source) ? CosmosMessageValue_Source.fromJSON(object.source) : undefined,
      destination: isSet(object.destination) ? CosmosMessageValue_Destination.fromJSON(object.destination) : undefined,
      string: isSet(object.string) ? globalThis.String(object.string) : "",
      int: isSet(object.int) ? globalThis.String(object.int) : "",
      bytes: isSet(object.bytes) ? bytesFromBase64(object.bytes) : new Uint8Array(0),
      message: globalThis.Array.isArray(object?.message)
        ? object.message.map((e: any) => CosmosMessageValue.fromJSON(e))
        : [],
      array: isSet(object.array) ? CosmosMessageValue_Array.fromJSON(object.array) : undefined,
    };
  },

  toJSON(message: CosmosMessageValue_Value): unknown {
    const obj: any = {};
    if (message.source !== undefined) {
      obj.source = CosmosMessageValue_Source.toJSON(message.source);
    }
    if (message.destination !== undefined) {
      obj.destination = CosmosMessageValue_Destination.toJSON(message.destination);
    }
    if (message.string !== "") {
      obj.string = message.string;
    }
    if (message.int !== "") {
      obj.int = message.int;
    }
    if (message.bytes.length !== 0) {
      obj.bytes = base64FromBytes(message.bytes);
    }
    if (message.message?.length) {
      obj.message = message.message.map((e) => CosmosMessageValue.toJSON(e));
    }
    if (message.array !== undefined) {
      obj.array = CosmosMessageValue_Array.toJSON(message.array);
    }
    return obj;
  },

  create(base?: DeepPartial<CosmosMessageValue_Value>): CosmosMessageValue_Value {
    return CosmosMessageValue_Value.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CosmosMessageValue_Value>): CosmosMessageValue_Value {
    const message = createBaseCosmosMessageValue_Value();
    message.source = (object.source !== undefined && object.source !== null)
      ? CosmosMessageValue_Source.fromPartial(object.source)
      : undefined;
    message.destination = (object.destination !== undefined && object.destination !== null)
      ? CosmosMessageValue_Destination.fromPartial(object.destination)
      : undefined;
    message.string = object.string ?? "";
    message.int = object.int ?? "";
    message.bytes = object.bytes ?? new Uint8Array(0);
    message.message = object.message?.map((e) => CosmosMessageValue.fromPartial(e)) || [];
    message.array = (object.array !== undefined && object.array !== null)
      ? CosmosMessageValue_Array.fromPartial(object.array)
      : undefined;
    return message;
  },
};

function createBaseCosmosMessageCall(): CosmosMessageCall {
  return { url: "", message: [] };
}

export const CosmosMessageCall = {
  encode(message: CosmosMessageCall, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.url !== "") {
      writer.uint32(10).string(message.url);
    }
    for (const v of message.message) {
      CosmosMessageValue.encode(v!, writer.uint32(18).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CosmosMessageCall {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCosmosMessageCall();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.url = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.message.push(CosmosMessageValue.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CosmosMessageCall {
    return {
      url: isSet(object.url) ? globalThis.String(object.url) : "",
      message: globalThis.Array.isArray(object?.message)
        ? object.message.map((e: any) => CosmosMessageValue.fromJSON(e))
        : [],
    };
  },

  toJSON(message: CosmosMessageCall): unknown {
    const obj: any = {};
    if (message.url !== "") {
      obj.url = message.url;
    }
    if (message.message?.length) {
      obj.message = message.message.map((e) => CosmosMessageValue.toJSON(e));
    }
    return obj;
  },

  create(base?: DeepPartial<CosmosMessageCall>): CosmosMessageCall {
    return CosmosMessageCall.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CosmosMessageCall>): CosmosMessageCall {
    const message = createBaseCosmosMessageCall();
    message.url = object.url ?? "";
    message.message = object.message?.map((e) => CosmosMessageValue.fromPartial(e)) || [];
    return message;
  },
};

function createBaseXTZContractCall(): XTZContractCall {
  return { entrypoint: "", arg: undefined };
}

export const XTZContractCall = {
  encode(message: XTZContractCall, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.entrypoint !== "") {
      writer.uint32(10).string(message.entrypoint);
    }
    if (message.arg !== undefined) {
      XTZContractArg.encode(message.arg, writer.uint32(18).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): XTZContractCall {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseXTZContractCall();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.entrypoint = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.arg = XTZContractArg.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): XTZContractCall {
    return {
      entrypoint: isSet(object.entrypoint) ? globalThis.String(object.entrypoint) : "",
      arg: isSet(object.arg) ? XTZContractArg.fromJSON(object.arg) : undefined,
    };
  },

  toJSON(message: XTZContractCall): unknown {
    const obj: any = {};
    if (message.entrypoint !== "") {
      obj.entrypoint = message.entrypoint;
    }
    if (message.arg !== undefined) {
      obj.arg = XTZContractArg.toJSON(message.arg);
    }
    return obj;
  },

  create(base?: DeepPartial<XTZContractCall>): XTZContractCall {
    return XTZContractCall.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<XTZContractCall>): XTZContractCall {
    const message = createBaseXTZContractCall();
    message.entrypoint = object.entrypoint ?? "";
    message.arg = (object.arg !== undefined && object.arg !== null)
      ? XTZContractArg.fromPartial(object.arg)
      : undefined;
    return message;
  },
};

function createBaseXTZContractArg(): XTZContractArg {
  return {
    kind: "",
    prim: "",
    args: [],
    source: undefined,
    destination: undefined,
    string: "",
    int: "",
    bytes: new Uint8Array(0),
    annotations: [],
  };
}

export const XTZContractArg = {
  encode(message: XTZContractArg, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.kind !== "") {
      writer.uint32(10).string(message.kind);
    }
    if (message.prim !== "") {
      writer.uint32(18).string(message.prim);
    }
    for (const v of message.args) {
      XTZContractArg.encode(v!, writer.uint32(26).fork()).ldelim();
    }
    if (message.source !== undefined) {
      XTZContractArg_Source.encode(message.source, writer.uint32(34).fork()).ldelim();
    }
    if (message.destination !== undefined) {
      XTZContractArg_Destination.encode(message.destination, writer.uint32(42).fork()).ldelim();
    }
    if (message.string !== "") {
      writer.uint32(50).string(message.string);
    }
    if (message.int !== "") {
      writer.uint32(58).string(message.int);
    }
    if (message.bytes.length !== 0) {
      writer.uint32(66).bytes(message.bytes);
    }
    for (const v of message.annotations) {
      writer.uint32(74).string(v!);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): XTZContractArg {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseXTZContractArg();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.kind = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.prim = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.args.push(XTZContractArg.decode(reader, reader.uint32()));
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.source = XTZContractArg_Source.decode(reader, reader.uint32());
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.destination = XTZContractArg_Destination.decode(reader, reader.uint32());
          continue;
        case 6:
          if (tag !== 50) {
            break;
          }

          message.string = reader.string();
          continue;
        case 7:
          if (tag !== 58) {
            break;
          }

          message.int = reader.string();
          continue;
        case 8:
          if (tag !== 66) {
            break;
          }

          message.bytes = reader.bytes();
          continue;
        case 9:
          if (tag !== 74) {
            break;
          }

          message.annotations.push(reader.string());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): XTZContractArg {
    return {
      kind: isSet(object.kind) ? globalThis.String(object.kind) : "",
      prim: isSet(object.prim) ? globalThis.String(object.prim) : "",
      args: globalThis.Array.isArray(object?.args) ? object.args.map((e: any) => XTZContractArg.fromJSON(e)) : [],
      source: isSet(object.source) ? XTZContractArg_Source.fromJSON(object.source) : undefined,
      destination: isSet(object.destination) ? XTZContractArg_Destination.fromJSON(object.destination) : undefined,
      string: isSet(object.string) ? globalThis.String(object.string) : "",
      int: isSet(object.int) ? globalThis.String(object.int) : "",
      bytes: isSet(object.bytes) ? bytesFromBase64(object.bytes) : new Uint8Array(0),
      annotations: globalThis.Array.isArray(object?.annotations)
        ? object.annotations.map((e: any) => globalThis.String(e))
        : [],
    };
  },

  toJSON(message: XTZContractArg): unknown {
    const obj: any = {};
    if (message.kind !== "") {
      obj.kind = message.kind;
    }
    if (message.prim !== "") {
      obj.prim = message.prim;
    }
    if (message.args?.length) {
      obj.args = message.args.map((e) => XTZContractArg.toJSON(e));
    }
    if (message.source !== undefined) {
      obj.source = XTZContractArg_Source.toJSON(message.source);
    }
    if (message.destination !== undefined) {
      obj.destination = XTZContractArg_Destination.toJSON(message.destination);
    }
    if (message.string !== "") {
      obj.string = message.string;
    }
    if (message.int !== "") {
      obj.int = message.int;
    }
    if (message.bytes.length !== 0) {
      obj.bytes = base64FromBytes(message.bytes);
    }
    if (message.annotations?.length) {
      obj.annotations = message.annotations;
    }
    return obj;
  },

  create(base?: DeepPartial<XTZContractArg>): XTZContractArg {
    return XTZContractArg.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<XTZContractArg>): XTZContractArg {
    const message = createBaseXTZContractArg();
    message.kind = object.kind ?? "";
    message.prim = object.prim ?? "";
    message.args = object.args?.map((e) => XTZContractArg.fromPartial(e)) || [];
    message.source = (object.source !== undefined && object.source !== null)
      ? XTZContractArg_Source.fromPartial(object.source)
      : undefined;
    message.destination = (object.destination !== undefined && object.destination !== null)
      ? XTZContractArg_Destination.fromPartial(object.destination)
      : undefined;
    message.string = object.string ?? "";
    message.int = object.int ?? "";
    message.bytes = object.bytes ?? new Uint8Array(0);
    message.annotations = object.annotations?.map((e) => e) || [];
    return message;
  },
};

function createBaseXTZContractArg_Source(): XTZContractArg_Source {
  return { fromAddressId: 0 };
}

export const XTZContractArg_Source = {
  encode(message: XTZContractArg_Source, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.fromAddressId !== 0) {
      writer.uint32(8).uint64(message.fromAddressId);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): XTZContractArg_Source {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseXTZContractArg_Source();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.fromAddressId = longToNumber(reader.uint64() as Long);
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): XTZContractArg_Source {
    return { fromAddressId: isSet(object.fromAddressId) ? globalThis.Number(object.fromAddressId) : 0 };
  },

  toJSON(message: XTZContractArg_Source): unknown {
    const obj: any = {};
    if (message.fromAddressId !== 0) {
      obj.fromAddressId = Math.round(message.fromAddressId);
    }
    return obj;
  },

  create(base?: DeepPartial<XTZContractArg_Source>): XTZContractArg_Source {
    return XTZContractArg_Source.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<XTZContractArg_Source>): XTZContractArg_Source {
    const message = createBaseXTZContractArg_Source();
    message.fromAddressId = object.fromAddressId ?? 0;
    return message;
  },
};

function createBaseXTZContractArg_Destination(): XTZContractArg_Destination {
  return { toAddressId: 0, toWhitelistedAddressId: 0 };
}

export const XTZContractArg_Destination = {
  encode(message: XTZContractArg_Destination, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.toAddressId !== 0) {
      writer.uint32(8).uint64(message.toAddressId);
    }
    if (message.toWhitelistedAddressId !== 0) {
      writer.uint32(16).uint64(message.toWhitelistedAddressId);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): XTZContractArg_Destination {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseXTZContractArg_Destination();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.toAddressId = longToNumber(reader.uint64() as Long);
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.toWhitelistedAddressId = longToNumber(reader.uint64() as Long);
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): XTZContractArg_Destination {
    return {
      toAddressId: isSet(object.toAddressId) ? globalThis.Number(object.toAddressId) : 0,
      toWhitelistedAddressId: isSet(object.toWhitelistedAddressId)
        ? globalThis.Number(object.toWhitelistedAddressId)
        : 0,
    };
  },

  toJSON(message: XTZContractArg_Destination): unknown {
    const obj: any = {};
    if (message.toAddressId !== 0) {
      obj.toAddressId = Math.round(message.toAddressId);
    }
    if (message.toWhitelistedAddressId !== 0) {
      obj.toWhitelistedAddressId = Math.round(message.toWhitelistedAddressId);
    }
    return obj;
  },

  create(base?: DeepPartial<XTZContractArg_Destination>): XTZContractArg_Destination {
    return XTZContractArg_Destination.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<XTZContractArg_Destination>): XTZContractArg_Destination {
    const message = createBaseXTZContractArg_Destination();
    message.toAddressId = object.toAddressId ?? 0;
    message.toWhitelistedAddressId = object.toWhitelistedAddressId ?? 0;
    return message;
  },
};

function bytesFromBase64(b64: string): Uint8Array {
  const bin = globalThis.atob(b64);
  const arr = new Uint8Array(bin.length);
  for (let i = 0; i < bin.length; ++i) {
    arr[i] = bin.charCodeAt(i);
  }
  return arr;
}

function base64FromBytes(arr: Uint8Array): string {
  const bin: string[] = [];
  arr.forEach((byte) => {
    bin.push(globalThis.String.fromCharCode(byte));
  });
  return globalThis.btoa(bin.join(""));
}

type Builtin = Date | Function | Uint8Array | string | number | boolean | undefined;

export type DeepPartial<T> = T extends Builtin ? T
  : T extends globalThis.Array<infer U> ? globalThis.Array<DeepPartial<U>>
  : T extends ReadonlyArray<infer U> ? ReadonlyArray<DeepPartial<U>>
  : T extends {} ? { [K in keyof T]?: DeepPartial<T[K]> }
  : Partial<T>;

function toTimestamp(date: Date): Timestamp {
  const seconds = Math.trunc(date.getTime() / 1_000);
  const nanos = (date.getTime() % 1_000) * 1_000_000;
  return { seconds, nanos };
}

function fromTimestamp(t: Timestamp): Date {
  let millis = (t.seconds || 0) * 1_000;
  millis += (t.nanos || 0) / 1_000_000;
  return new globalThis.Date(millis);
}

function fromJsonTimestamp(o: any): Date {
  if (o instanceof globalThis.Date) {
    return o;
  } else if (typeof o === "string") {
    return new globalThis.Date(o);
  } else {
    return fromTimestamp(Timestamp.fromJSON(o));
  }
}

function longToNumber(long: Long): number {
  if (long.gt(globalThis.Number.MAX_SAFE_INTEGER)) {
    throw new globalThis.Error("Value is larger than Number.MAX_SAFE_INTEGER");
  }
  if (long.lt(globalThis.Number.MIN_SAFE_INTEGER)) {
    throw new globalThis.Error("Value is smaller than Number.MIN_SAFE_INTEGER");
  }
  return long.toNumber();
}

if (_m0.util.Long !== Long) {
  _m0.util.Long = Long as any;
  _m0.configure();
}

function isSet(value: any): boolean {
  return value !== null && value !== undefined;
}
