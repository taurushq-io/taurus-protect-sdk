/* tslint:disable */
/* eslint-disable */
/**
 * Taurus-PROTECT APIs
 * Taurus-PROTECT APIs description
 *
 * The version of the OpenAPI document: 1.0
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import * as runtime from '../runtime';
import type {
  ApiHttpBody,
  GooglerpcStatus,
  TgvalidatordBTCSignMessageReply,
  TgvalidatordComputeAddressesSignatureReply,
  TgvalidatordComputeAddressesSignatureRequest,
  TgvalidatordCreateAddressAttributesReply,
  TgvalidatordCreateAddressReply,
  TgvalidatordCreateAddressRequest,
  TgvalidatordCreateAddressesReply,
  TgvalidatordCreateAddressesRequest,
  TgvalidatordETHSignMessageReply,
  TgvalidatordExportAddressBalanceHistoryReply,
  TgvalidatordExportAddressesReply,
  TgvalidatordGetAddressBalanceHistoryReply,
  TgvalidatordGetAddressProofOfReserveReply,
  TgvalidatordGetAddressReply,
  TgvalidatordGetAddressTokensReply,
  TgvalidatordGetAddressUTXOsReply,
  TgvalidatordGetAddressesProofOfReserveReply,
  TgvalidatordGetAddressesReply,
  TgvalidatordGetAddressesStatusReply,
  TgvalidatordGetLightAddressesReply,
  WalletServiceCreateAddressAttributesBody,
} from '../models/index';
import {
    ApiHttpBodyFromJSON,
    ApiHttpBodyToJSON,
    GooglerpcStatusFromJSON,
    GooglerpcStatusToJSON,
    TgvalidatordBTCSignMessageReplyFromJSON,
    TgvalidatordBTCSignMessageReplyToJSON,
    TgvalidatordComputeAddressesSignatureReplyFromJSON,
    TgvalidatordComputeAddressesSignatureReplyToJSON,
    TgvalidatordComputeAddressesSignatureRequestFromJSON,
    TgvalidatordComputeAddressesSignatureRequestToJSON,
    TgvalidatordCreateAddressAttributesReplyFromJSON,
    TgvalidatordCreateAddressAttributesReplyToJSON,
    TgvalidatordCreateAddressReplyFromJSON,
    TgvalidatordCreateAddressReplyToJSON,
    TgvalidatordCreateAddressRequestFromJSON,
    TgvalidatordCreateAddressRequestToJSON,
    TgvalidatordCreateAddressesReplyFromJSON,
    TgvalidatordCreateAddressesReplyToJSON,
    TgvalidatordCreateAddressesRequestFromJSON,
    TgvalidatordCreateAddressesRequestToJSON,
    TgvalidatordETHSignMessageReplyFromJSON,
    TgvalidatordETHSignMessageReplyToJSON,
    TgvalidatordExportAddressBalanceHistoryReplyFromJSON,
    TgvalidatordExportAddressBalanceHistoryReplyToJSON,
    TgvalidatordExportAddressesReplyFromJSON,
    TgvalidatordExportAddressesReplyToJSON,
    TgvalidatordGetAddressBalanceHistoryReplyFromJSON,
    TgvalidatordGetAddressBalanceHistoryReplyToJSON,
    TgvalidatordGetAddressProofOfReserveReplyFromJSON,
    TgvalidatordGetAddressProofOfReserveReplyToJSON,
    TgvalidatordGetAddressReplyFromJSON,
    TgvalidatordGetAddressReplyToJSON,
    TgvalidatordGetAddressTokensReplyFromJSON,
    TgvalidatordGetAddressTokensReplyToJSON,
    TgvalidatordGetAddressUTXOsReplyFromJSON,
    TgvalidatordGetAddressUTXOsReplyToJSON,
    TgvalidatordGetAddressesProofOfReserveReplyFromJSON,
    TgvalidatordGetAddressesProofOfReserveReplyToJSON,
    TgvalidatordGetAddressesReplyFromJSON,
    TgvalidatordGetAddressesReplyToJSON,
    TgvalidatordGetAddressesStatusReplyFromJSON,
    TgvalidatordGetAddressesStatusReplyToJSON,
    TgvalidatordGetLightAddressesReplyFromJSON,
    TgvalidatordGetLightAddressesReplyToJSON,
    WalletServiceCreateAddressAttributesBodyFromJSON,
    WalletServiceCreateAddressAttributesBodyToJSON,
} from '../models/index';

export interface ReportServiceSwiftMT535BalanceReportRequest {
    blockchain?: string;
    blockchainaddress?: string;
    forDate?: Date;
    network?: string;
}

export interface ReportServiceSwiftMT536TransactionsReportRequest {
    blockchain?: string;
    blockchainaddress?: string;
    forDate?: Date;
    network?: string;
}

export interface WalletServiceBTCSignMessageRequest {
    addressId: string;
    message?: string;
}

export interface WalletServiceComputeAddressesSignatureRequest {
    body: TgvalidatordComputeAddressesSignatureRequest;
}

export interface WalletServiceCreateAddressRequest {
    body: TgvalidatordCreateAddressRequest;
}

export interface WalletServiceCreateAddressAttributesRequest {
    addressId: string;
    body: WalletServiceCreateAddressAttributesBody;
}

export interface WalletServiceCreateAddressesBatchRequest {
    body: TgvalidatordCreateAddressesRequest;
}

export interface WalletServiceDeleteAddressAttributeRequest {
    addressId: string;
    id: string;
}

export interface WalletServiceETHSignMessageRequest {
    addressId: string;
    message?: string;
}

export interface WalletServiceExportAddressBalanceHistoryRequest {
    id: string;
    intervalHours?: string;
    format?: string;
}

export interface WalletServiceExportAddressesRequest {
    walletId?: string;
    currency?: string;
    format?: string;
    query?: string;
    scoreProvider?: string;
    scoreInBelow?: string;
    scoreOutBelow?: string;
    scoreExclusive?: boolean;
    customerId?: string;
    coinfirmScoreGreater?: string;
    chainalysisScoreGreater?: string;
    scoreFilterScoreProvider?: string;
    scoreFilterScorechainFiltersScoreInBelow?: string;
    scoreFilterScorechainFiltersScoreOutBelow?: string;
    scoreFilterScorechainFiltersScoreExclusive?: boolean;
    scoreFilterCoinfirmFiltersScoreGreater?: string;
    scoreFilterChainalysisFiltersScoreGreater?: string;
    scoreFilterEllipticFiltersScoreGreater?: string;
    scoreFilterTrmlabsFiltersScoreGreater?: string;
    blockchain?: string;
    network?: string;
}

export interface WalletServiceGetAddressRequest {
    id: string;
}

export interface WalletServiceGetAddressBalanceHistoryRequest {
    id: string;
    intervalHours?: string;
}

export interface WalletServiceGetAddressProofOfReserveRequest {
    id: string;
    challenge?: string;
}

export interface WalletServiceGetAddressTokensRequest {
    id: string;
    limit?: string;
    cursor?: string;
}

export interface WalletServiceGetAddressUTXOsRequest {
    id: string;
}

export interface WalletServiceGetAddressesRequest {
    currency?: string;
    query?: string;
    limit?: string;
    offset?: string;
    scoreProvider?: string;
    scoreInBelow?: string;
    scoreOutBelow?: string;
    scoreExclusive?: boolean;
    onlyPositiveBalance?: boolean;
    sortBy?: string;
    sortOrder?: string;
    balanceBelow?: string;
    balanceAbove?: string;
    walletId?: string;
    customerId?: string;
    coinfirmScoreGreater?: string;
    chainalysisScoreGreater?: string;
    tagIDs?: Array<string>;
    blockchain?: string;
    network?: string;
    addressIds?: Array<string>;
    nfts?: string;
    addresses?: Array<string>;
    scoreFilterScoreProvider?: string;
    scoreFilterScorechainFiltersScoreInBelow?: string;
    scoreFilterScorechainFiltersScoreOutBelow?: string;
    scoreFilterScorechainFiltersScoreExclusive?: boolean;
    scoreFilterCoinfirmFiltersScoreGreater?: string;
    scoreFilterChainalysisFiltersScoreGreater?: string;
    scoreFilterEllipticFiltersScoreGreater?: string;
    scoreFilterTrmlabsFiltersScoreGreater?: string;
    attributeFiltersJson?: string;
    attributeFiltersOperator?: string;
}

export interface WalletServiceGetAddressesProofOfReserveRequest {
    blockchain: string;
    addresses?: Array<string>;
    challenge?: string;
    network?: string;
}

export interface WalletServiceGetAddressesStatusRequest {
    walletIds?: Array<string>;
    addressIds?: Array<string>;
    currencyIds?: Array<string>;
    sortingSortOrder?: WalletServiceGetAddressesStatusSortingSortOrderEnum;
    cursorCurrentPage?: string;
    cursorPageRequest?: string;
    cursorPageSize?: string;
}

export interface WalletServiceGetLightAddressesRequest {
    uniqueCurrencyFilterBlockchain: string;
    uniqueCurrencyFilterNetwork: string;
    currencyID?: string;
    uniqueCurrencyFilterTokenContractAddress?: string;
    uniqueCurrencyFilterTokenID?: string;
    addresses?: Array<string>;
}

/**
 * AddressesApi - interface
 * 
 * @export
 * @interface AddressesApiInterface
 */
export interface AddressesApiInterface {
    /**
     * Returns the MT535 statement of holdings for the address. By default, the response is a JSON, with the swift content formatted in base64. To get the plain swift as a response, use the request header **\'Accept: text/plain\'**. A date can be passed to get the balance at a particular date. If no date is given, the last closing date is used.
     * @summary Get the balance of the address
     * @param {string} [blockchain] 
     * @param {string} [blockchainaddress] 
     * @param {Date} [forDate] 
     * @param {string} [network] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AddressesApiInterface
     */
    reportServiceSwiftMT535BalanceReportRaw(requestParameters: ReportServiceSwiftMT535BalanceReportRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<ApiHttpBody>>;

    /**
     * Returns the MT535 statement of holdings for the address. By default, the response is a JSON, with the swift content formatted in base64. To get the plain swift as a response, use the request header **\'Accept: text/plain\'**. A date can be passed to get the balance at a particular date. If no date is given, the last closing date is used.
     * Get the balance of the address
     */
    reportServiceSwiftMT535BalanceReport(requestParameters: ReportServiceSwiftMT535BalanceReportRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<ApiHttpBody>;

    /**
     * Returns the MT536 statement of transactions for the address. By default, the response is a JSON, with the swift content formatted in base64. To get the plain swift as a response, use the request header **\'Accept: text/plain\'**. A date can be passed to get the transactions of a particular day. If no date is given, the last day is used.
     * @summary Get the daily transactions of the address
     * @param {string} [blockchain] 
     * @param {string} [blockchainaddress] 
     * @param {Date} [forDate] 
     * @param {string} [network] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AddressesApiInterface
     */
    reportServiceSwiftMT536TransactionsReportRaw(requestParameters: ReportServiceSwiftMT536TransactionsReportRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<ApiHttpBody>>;

    /**
     * Returns the MT536 statement of transactions for the address. By default, the response is a JSON, with the swift content formatted in base64. To get the plain swift as a response, use the request header **\'Accept: text/plain\'**. A date can be passed to get the transactions of a particular day. If no date is given, the last day is used.
     * Get the daily transactions of the address
     */
    reportServiceSwiftMT536TransactionsReport(requestParameters: ReportServiceSwiftMT536TransactionsReportRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<ApiHttpBody>;

    /**
     * This endpoint returns a BTC specific signature from a given message and address as input.
     * @summary Calculate a BTC specific signature of a message
     * @param {string} addressId 
     * @param {string} [message] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AddressesApiInterface
     */
    walletServiceBTCSignMessageRaw(requestParameters: WalletServiceBTCSignMessageRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<TgvalidatordBTCSignMessageReply>>;

    /**
     * This endpoint returns a BTC specific signature from a given message and address as input.
     * Calculate a BTC specific signature of a message
     */
    walletServiceBTCSignMessage(requestParameters: WalletServiceBTCSignMessageRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<TgvalidatordBTCSignMessageReply>;

    /**
     * This endpoint forces a recompute of all addresses signatures.  Required role: **Admin**.
     * @summary Recompute addresses signatures
     * @param {TgvalidatordComputeAddressesSignatureRequest} body 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AddressesApiInterface
     */
    walletServiceComputeAddressesSignatureRaw(requestParameters: WalletServiceComputeAddressesSignatureRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<TgvalidatordComputeAddressesSignatureReply>>;

    /**
     * This endpoint forces a recompute of all addresses signatures.  Required role: **Admin**.
     * Recompute addresses signatures
     */
    walletServiceComputeAddressesSignature(requestParameters: WalletServiceComputeAddressesSignatureRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<TgvalidatordComputeAddressesSignatureReply>;

    /**
     * This endpoint creates a new address within a specified Wallet. All addresses _must_ be associated with a parent wallet. Addresses created with this endpoint are internal to Protect. To create an external address, you need to create a [whitelisted address request](https://docs.taurushq.com/protect-capital/reference/whitelistservice_createwhitelistedaddress).  For more information about whitelisted assets, see our [user guides](https://docs.taurushq.com/user-and-technical-guides/docs/smart-contracts).  Address creation requires HSM signature, which makes it synchronous. Therefore, address creation can be slow, and failures may occur if the HSM is either unavailable or takes too long to process. If this happens, the API can be safely called again.  **Required role:** AccountCreator.
     * @summary Create an address
     * @param {TgvalidatordCreateAddressRequest} body 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AddressesApiInterface
     */
    walletServiceCreateAddressRaw(requestParameters: WalletServiceCreateAddressRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<TgvalidatordCreateAddressReply>>;

    /**
     * This endpoint creates a new address within a specified Wallet. All addresses _must_ be associated with a parent wallet. Addresses created with this endpoint are internal to Protect. To create an external address, you need to create a [whitelisted address request](https://docs.taurushq.com/protect-capital/reference/whitelistservice_createwhitelistedaddress).  For more information about whitelisted assets, see our [user guides](https://docs.taurushq.com/user-and-technical-guides/docs/smart-contracts).  Address creation requires HSM signature, which makes it synchronous. Therefore, address creation can be slow, and failures may occur if the HSM is either unavailable or takes too long to process. If this happens, the API can be safely called again.  **Required role:** AccountCreator.
     * Create an address
     */
    walletServiceCreateAddress(requestParameters: WalletServiceCreateAddressRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<TgvalidatordCreateAddressReply>;

    /**
     * This endpoint creates attributes for a given address.   Required role: **AccountCreator**.
     * @summary Create attributes
     * @param {string} addressId 
     * @param {WalletServiceCreateAddressAttributesBody} body 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AddressesApiInterface
     */
    walletServiceCreateAddressAttributesRaw(requestParameters: WalletServiceCreateAddressAttributesRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<TgvalidatordCreateAddressAttributesReply>>;

    /**
     * This endpoint creates attributes for a given address.   Required role: **AccountCreator**.
     * Create attributes
     */
    walletServiceCreateAddressAttributes(requestParameters: WalletServiceCreateAddressAttributesRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<TgvalidatordCreateAddressAttributesReply>;

    /**
     * Required role: **AccountCreator**.   This endpoint creates a batch of addresses.   Address created from this endpoint will start with a **created** and will not be ready to use until the HSM process them. 
     * @summary Create a batch of addresses
     * @param {TgvalidatordCreateAddressesRequest} body 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AddressesApiInterface
     */
    walletServiceCreateAddressesBatchRaw(requestParameters: WalletServiceCreateAddressesBatchRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<TgvalidatordCreateAddressesReply>>;

    /**
     * Required role: **AccountCreator**.   This endpoint creates a batch of addresses.   Address created from this endpoint will start with a **created** and will not be ready to use until the HSM process them. 
     * Create a batch of addresses
     */
    walletServiceCreateAddressesBatch(requestParameters: WalletServiceCreateAddressesBatchRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<TgvalidatordCreateAddressesReply>;

    /**
     * This endpoint deletes an attribute of a given address.   Required role: **AccountCreator**.
     * @summary Delete an attribute
     * @param {string} addressId 
     * @param {string} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AddressesApiInterface
     */
    walletServiceDeleteAddressAttributeRaw(requestParameters: WalletServiceDeleteAddressAttributeRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<object>>;

    /**
     * This endpoint deletes an attribute of a given address.   Required role: **AccountCreator**.
     * Delete an attribute
     */
    walletServiceDeleteAddressAttribute(requestParameters: WalletServiceDeleteAddressAttributeRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<object>;

    /**
     * This endpoint returns an ETH specific signature from a given message and address as input.
     * @summary Calculate an ETH specific signature of a message
     * @param {string} addressId 
     * @param {string} [message] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AddressesApiInterface
     */
    walletServiceETHSignMessageRaw(requestParameters: WalletServiceETHSignMessageRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<TgvalidatordETHSignMessageReply>>;

    /**
     * This endpoint returns an ETH specific signature from a given message and address as input.
     * Calculate an ETH specific signature of a message
     */
    walletServiceETHSignMessage(requestParameters: WalletServiceETHSignMessageRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<TgvalidatordETHSignMessageReply>;

    /**
     * This endpoint exports a list of address\' balances history
     * @summary Export address\' balances history
     * @param {string} id Desired address ID
     * @param {string} [intervalHours] 
     * @param {string} [format] Desired file format, can be csv or json.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AddressesApiInterface
     */
    walletServiceExportAddressBalanceHistoryRaw(requestParameters: WalletServiceExportAddressBalanceHistoryRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<TgvalidatordExportAddressBalanceHistoryReply>>;

    /**
     * This endpoint exports a list of address\' balances history
     * Export address\' balances history
     */
    walletServiceExportAddressBalanceHistory(requestParameters: WalletServiceExportAddressBalanceHistoryRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<TgvalidatordExportAddressBalanceHistoryReply>;

    /**
     * This endpoint exports a list of addresses
     * @summary Export addresses
     * @param {string} [walletId] 
     * @param {string} [currency] Filter on ID or symbol of the currency
     * @param {string} [format] Desired file format, can be csv or json.
     * @param {string} [query] 
     * @param {string} [scoreProvider] Deprecated. Use scoreFilter instead.
     * @param {string} [scoreInBelow] Deprecated. Use scoreFilter instead.
     * @param {string} [scoreOutBelow] Deprecated. Use scoreFilter instead.
     * @param {boolean} [scoreExclusive] Deprecated. Use scoreFilter instead.
     * @param {string} [customerId] 
     * @param {string} [coinfirmScoreGreater] Deprecated. Use scoreFilter instead.
     * @param {string} [chainalysisScoreGreater] Deprecated. Use scoreFilter instead.
     * @param {string} [scoreFilterScoreProvider] Specify the score provider to filter on, or empty.Each provider has associated filter parameters that can be set.Supported values: &#x60;scorechain&#x60;, &#x60;coinfirm&#x60;, &#x60;chainalysis&#x60;, &#x60;elliptic&#x60;, &#x60;trmlabs&#x60;
     * @param {string} [scoreFilterScorechainFiltersScoreInBelow] Filter addresses under a Scorechain incoming score threshold.
     * @param {string} [scoreFilterScorechainFiltersScoreOutBelow] Filter addresses under a Scorechain outgoing score threshold.
     * @param {boolean} [scoreFilterScorechainFiltersScoreExclusive] By default when both Scorechain scores scoreInBelow and scoreOutBelow are provided, it returns the addresses matching (scoreInBelow AND scoreOutBelow). When scoreExclusive is set to true, it will return the addresses matching (scoreInBelow OR scoreOutBelow).
     * @param {string} [scoreFilterCoinfirmFiltersScoreGreater] Filter addresses with a Coinfirm C-score above threshold.
     * @param {string} [scoreFilterChainalysisFiltersScoreGreater] Filter addresses with a Chainalysis risk score above threshold.
     * @param {string} [scoreFilterEllipticFiltersScoreGreater] Filter addresses with an Elliptic risk score above threshold.
     * @param {string} [scoreFilterTrmlabsFiltersScoreGreater] Filter addresses with an TRM Labs risk score above threshold.
     * @param {string} [blockchain] 
     * @param {string} [network] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AddressesApiInterface
     */
    walletServiceExportAddressesRaw(requestParameters: WalletServiceExportAddressesRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<TgvalidatordExportAddressesReply>>;

    /**
     * This endpoint exports a list of addresses
     * Export addresses
     */
    walletServiceExportAddresses(requestParameters: WalletServiceExportAddressesRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<TgvalidatordExportAddressesReply>;

    /**
     * This endpoint accepts a unique address ID and returns the address alongside related information including:  * additional risk score data (if applicable). * information about the related wallet and currency. * related whitelisted address IDs.  To search across all addresses with query parameters, use the [List Addresses](https://docs.taurushq.com/protect-capital/reference/walletservice_getaddresses) endpoint.
     * @summary Get an address
     * @param {string} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AddressesApiInterface
     */
    walletServiceGetAddressRaw(requestParameters: WalletServiceGetAddressRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<TgvalidatordGetAddressReply>>;

    /**
     * This endpoint accepts a unique address ID and returns the address alongside related information including:  * additional risk score data (if applicable). * information about the related wallet and currency. * related whitelisted address IDs.  To search across all addresses with query parameters, use the [List Addresses](https://docs.taurushq.com/protect-capital/reference/walletservice_getaddresses) endpoint.
     * Get an address
     */
    walletServiceGetAddress(requestParameters: WalletServiceGetAddressRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<TgvalidatordGetAddressReply>;

    /**
     * This endpoint returns the balances history of a given address
     * @summary List address\' balances history
     * @param {string} id 
     * @param {string} [intervalHours] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AddressesApiInterface
     */
    walletServiceGetAddressBalanceHistoryRaw(requestParameters: WalletServiceGetAddressBalanceHistoryRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<TgvalidatordGetAddressBalanceHistoryReply>>;

    /**
     * This endpoint returns the balances history of a given address
     * List address\' balances history
     */
    walletServiceGetAddressBalanceHistory(requestParameters: WalletServiceGetAddressBalanceHistoryRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<TgvalidatordGetAddressBalanceHistoryReply>;

    /**
     * This endpoint returns the proof of reserve of an address. The relevance of response fields is specific to the request type.
     * @summary Get the proof of reserve of an address
     * @param {string} id 
     * @param {string} [challenge] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AddressesApiInterface
     */
    walletServiceGetAddressProofOfReserveRaw(requestParameters: WalletServiceGetAddressProofOfReserveRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<TgvalidatordGetAddressProofOfReserveReply>>;

    /**
     * This endpoint returns the proof of reserve of an address. The relevance of response fields is specific to the request type.
     * Get the proof of reserve of an address
     */
    walletServiceGetAddressProofOfReserve(requestParameters: WalletServiceGetAddressProofOfReserveRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<TgvalidatordGetAddressProofOfReserveReply>;

    /**
     * This endpoint returns the list of tokens with their balances held by a given address.
     * @summary Get the list of tokens for an address
     * @param {string} id 
     * @param {string} [limit] 
     * @param {string} [cursor] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AddressesApiInterface
     */
    walletServiceGetAddressTokensRaw(requestParameters: WalletServiceGetAddressTokensRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<TgvalidatordGetAddressTokensReply>>;

    /**
     * This endpoint returns the list of tokens with their balances held by a given address.
     * Get the list of tokens for an address
     */
    walletServiceGetAddressTokens(requestParameters: WalletServiceGetAddressTokensRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<TgvalidatordGetAddressTokensReply>;

    /**
     * This endpoint returns a list of UTXOs of a given address. In the case of the ADA blockchain, the value returned is the one from the native currency. Result is sorted by (address, id) DESC.
     * @summary List UTXOs of an address
     * @param {string} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AddressesApiInterface
     */
    walletServiceGetAddressUTXOsRaw(requestParameters: WalletServiceGetAddressUTXOsRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<TgvalidatordGetAddressUTXOsReply>>;

    /**
     * This endpoint returns a list of UTXOs of a given address. In the case of the ADA blockchain, the value returned is the one from the native currency. Result is sorted by (address, id) DESC.
     * List UTXOs of an address
     */
    walletServiceGetAddressUTXOs(requestParameters: WalletServiceGetAddressUTXOsRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<TgvalidatordGetAddressUTXOsReply>;

    /**
     * This endpoint returns a list of addresses
     * @summary List addresses
     * @param {string} [currency] Filter on IDs or symbols of the currency
     * @param {string} [query] 
     * @param {string} [limit] 
     * @param {string} [offset] 
     * @param {string} [scoreProvider] Deprecated. Use scoreFilter instead.
     * @param {string} [scoreInBelow] Deprecated. Use scoreFilter instead.
     * @param {string} [scoreOutBelow] Deprecated. Use scoreFilter instead.
     * @param {boolean} [scoreExclusive] Deprecated. Use scoreFilter instead.
     * @param {boolean} [onlyPositiveBalance] Set this parameter to true to get only addresses with a positive unconfirmed balance
     * @param {string} [sortBy] Set this parameter to select the type on which you want to sort.The types accepted yet are: BALANCE and ADDRESSID
     * @param {string} [sortOrder] Set this parameter to ASC to get the addresses sorted in ascending order or DESC to get them in descending order.
     * @param {string} [balanceBelow] Filter addresses and keep only addresses with a balance below the threshold.
     * @param {string} [balanceAbove] Filter addresses and keep only addresses with a balance above the threshold.
     * @param {string} [walletId] 
     * @param {string} [customerId] 
     * @param {string} [coinfirmScoreGreater] Deprecated. Use scoreFilter instead.
     * @param {string} [chainalysisScoreGreater] Deprecated. Use scoreFilter instead.
     * @param {Array<string>} [tagIDs] Filter addresses with a \&#39;OR\&#39; combination of tag IDs
     * @param {string} [blockchain] 
     * @param {string} [network] 
     * @param {Array<string>} [addressIds] Filter addresses with a list of address IDs.
     * @param {string} [nfts] One of include / exclude / only depending on whether you want to include addresses of type NFTs (or you want only those)
     * @param {Array<string>} [addresses] Filter addresses with a list of blockchain addresses (hashes).The blockchain needs to be specified when using this filter.
     * @param {string} [scoreFilterScoreProvider] Specify the score provider to filter on, or empty.Each provider has associated filter parameters that can be set.Supported values: &#x60;scorechain&#x60;, &#x60;coinfirm&#x60;, &#x60;chainalysis&#x60;, &#x60;elliptic&#x60;, &#x60;trmlabs&#x60;
     * @param {string} [scoreFilterScorechainFiltersScoreInBelow] Filter addresses under a Scorechain incoming score threshold.
     * @param {string} [scoreFilterScorechainFiltersScoreOutBelow] Filter addresses under a Scorechain outgoing score threshold.
     * @param {boolean} [scoreFilterScorechainFiltersScoreExclusive] By default when both Scorechain scores scoreInBelow and scoreOutBelow are provided, it returns the addresses matching (scoreInBelow AND scoreOutBelow). When scoreExclusive is set to true, it will return the addresses matching (scoreInBelow OR scoreOutBelow).
     * @param {string} [scoreFilterCoinfirmFiltersScoreGreater] Filter addresses with a Coinfirm C-score above threshold.
     * @param {string} [scoreFilterChainalysisFiltersScoreGreater] Filter addresses with a Chainalysis risk score above threshold.
     * @param {string} [scoreFilterEllipticFiltersScoreGreater] Filter addresses with an Elliptic risk score above threshold.
     * @param {string} [scoreFilterTrmlabsFiltersScoreGreater] Filter addresses with an TRM Labs risk score above threshold.
     * @param {string} [attributeFiltersJson] A JSON representation of a list of AttributeFilter objects. The filters are combined with an attributeFiltersOperator (\&#39;OR\&#39; by default). Each AttributeFilter can use different comparison operators: &#x60;&#x3D;&#x60; (default if not specified), &#x60;&lt;&gt;&#x60; (not equal), &#x60;&gt;&#x60; (greater than), &#x60;&gt;&#x3D;&#x60; (greater than or equal), &#x60;&lt;&#x60; (less than), &#x60;&lt;&#x3D;&#x60; (less than or equal)
     * @param {string} [attributeFiltersOperator] Specifies how attribute filters are combined. Accepted values: \&#39;OR\&#39; (default), \&#39;AND\&#39;.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AddressesApiInterface
     */
    walletServiceGetAddressesRaw(requestParameters: WalletServiceGetAddressesRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<TgvalidatordGetAddressesReply>>;

    /**
     * This endpoint returns a list of addresses
     * List addresses
     */
    walletServiceGetAddresses(requestParameters: WalletServiceGetAddressesRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<TgvalidatordGetAddressesReply>;

    /**
     * This endpoint returns the proof of reserve for a list of addresses.  The relevance of response fields is specific to the request type.
     * @summary Get the proof of reserve of a list of addresses
     * @param {string} blockchain 
     * @param {Array<string>} [addresses] 
     * @param {string} [challenge] 
     * @param {string} [network] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AddressesApiInterface
     */
    walletServiceGetAddressesProofOfReserveRaw(requestParameters: WalletServiceGetAddressesProofOfReserveRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<TgvalidatordGetAddressesProofOfReserveReply>>;

    /**
     * This endpoint returns the proof of reserve for a list of addresses.  The relevance of response fields is specific to the request type.
     * Get the proof of reserve of a list of addresses
     */
    walletServiceGetAddressesProofOfReserve(requestParameters: WalletServiceGetAddressesProofOfReserveRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<TgvalidatordGetAddressesProofOfReserveReply>;

    /**
     * This endpoint returns a list of addresses with their status
     * @summary List addresses\'s status
     * @param {Array<string>} [walletIds] 
     * @param {Array<string>} [addressIds] 
     * @param {Array<string>} [currencyIds] 
     * @param {'DESC'} [sortingSortOrder] 
     * @param {string} [cursorCurrentPage] Base64-encoded string representing the current window of data
     * @param {string} [cursorPageRequest] The page to request, w.r.t the current page. Can be one of &#x60;FIRST&#x60;, &#x60;PREVIOUS&#x60;, &#x60;NEXT&#x60;, &#x60;LAST&#x60;
     * @param {string} [cursorPageSize] The size of the page requested. The handling service should impose a hard limit on this
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AddressesApiInterface
     */
    walletServiceGetAddressesStatusRaw(requestParameters: WalletServiceGetAddressesStatusRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<TgvalidatordGetAddressesStatusReply>>;

    /**
     * This endpoint returns a list of addresses with their status
     * List addresses\'s status
     */
    walletServiceGetAddressesStatus(requestParameters: WalletServiceGetAddressesStatusRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<TgvalidatordGetAddressesStatusReply>;

    /**
     * This endpoint returns a list of addresses with light information filtered by a unique currency and a list of addresses. The light address information mainly contains the identifiers. There is no balance, risk score or attributes.
     * @summary List light addresses
     * @param {string} uniqueCurrencyFilterBlockchain Required: The Blockchain to filter by (e.g. ETH, BTC). Can be found using the blockchain endpoint &#x60;/api/rest/v1/blockchains&#x60;
     * @param {string} uniqueCurrencyFilterNetwork Required: Network or environment the currency is used on (e.g. \&#39;mainnet\&#39;, \&#39;testnet\&#39;).
     * @param {string} [currencyID] One of the currencyID or uniqueCurrencyFilter fields must be provided
     * @param {string} [uniqueCurrencyFilterTokenContractAddress] If this parameter is set, the currency returned will be a token with the specified contract address. If not set, the currency returned will be the native currency of the blockchain.
     * @param {string} [uniqueCurrencyFilterTokenID] For some blockchains (ex. ALGO, XTZ) a tokenContractAddress might contain multiple assets. The tokenID is used to differentiate between those assets. If not set, the currency returned won\&#39;t have any tokenID defined.
     * @param {Array<string>} [addresses] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AddressesApiInterface
     */
    walletServiceGetLightAddressesRaw(requestParameters: WalletServiceGetLightAddressesRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<TgvalidatordGetLightAddressesReply>>;

    /**
     * This endpoint returns a list of addresses with light information filtered by a unique currency and a list of addresses. The light address information mainly contains the identifiers. There is no balance, risk score or attributes.
     * List light addresses
     */
    walletServiceGetLightAddresses(requestParameters: WalletServiceGetLightAddressesRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<TgvalidatordGetLightAddressesReply>;

}

/**
 * 
 */
export class AddressesApi extends runtime.BaseAPI implements AddressesApiInterface {

    /**
     * Returns the MT535 statement of holdings for the address. By default, the response is a JSON, with the swift content formatted in base64. To get the plain swift as a response, use the request header **\'Accept: text/plain\'**. A date can be passed to get the balance at a particular date. If no date is given, the last closing date is used.
     * Get the balance of the address
     */
    async reportServiceSwiftMT535BalanceReportRaw(requestParameters: ReportServiceSwiftMT535BalanceReportRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<ApiHttpBody>> {
        const queryParameters: any = {};

        if (requestParameters['blockchain'] != null) {
            queryParameters['blockchain'] = requestParameters['blockchain'];
        }

        if (requestParameters['blockchainaddress'] != null) {
            queryParameters['blockchainaddress'] = requestParameters['blockchainaddress'];
        }

        if (requestParameters['forDate'] != null) {
            queryParameters['forDate'] = (requestParameters['forDate'] as any).toISOString();
        }

        if (requestParameters['network'] != null) {
            queryParameters['network'] = requestParameters['network'];
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = await this.configuration.apiKey("Authorization"); // ApiKeyTPV1 authentication
        }

        const response = await this.request({
            path: `/api/rest/v1/reports/mt535`,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => ApiHttpBodyFromJSON(jsonValue));
    }

    /**
     * Returns the MT535 statement of holdings for the address. By default, the response is a JSON, with the swift content formatted in base64. To get the plain swift as a response, use the request header **\'Accept: text/plain\'**. A date can be passed to get the balance at a particular date. If no date is given, the last closing date is used.
     * Get the balance of the address
     */
    async reportServiceSwiftMT535BalanceReport(requestParameters: ReportServiceSwiftMT535BalanceReportRequest = {}, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<ApiHttpBody> {
        const response = await this.reportServiceSwiftMT535BalanceReportRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Returns the MT536 statement of transactions for the address. By default, the response is a JSON, with the swift content formatted in base64. To get the plain swift as a response, use the request header **\'Accept: text/plain\'**. A date can be passed to get the transactions of a particular day. If no date is given, the last day is used.
     * Get the daily transactions of the address
     */
    async reportServiceSwiftMT536TransactionsReportRaw(requestParameters: ReportServiceSwiftMT536TransactionsReportRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<ApiHttpBody>> {
        const queryParameters: any = {};

        if (requestParameters['blockchain'] != null) {
            queryParameters['blockchain'] = requestParameters['blockchain'];
        }

        if (requestParameters['blockchainaddress'] != null) {
            queryParameters['blockchainaddress'] = requestParameters['blockchainaddress'];
        }

        if (requestParameters['forDate'] != null) {
            queryParameters['forDate'] = (requestParameters['forDate'] as any).toISOString();
        }

        if (requestParameters['network'] != null) {
            queryParameters['network'] = requestParameters['network'];
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = await this.configuration.apiKey("Authorization"); // ApiKeyTPV1 authentication
        }

        const response = await this.request({
            path: `/api/rest/v1/reports/mt536`,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => ApiHttpBodyFromJSON(jsonValue));
    }

    /**
     * Returns the MT536 statement of transactions for the address. By default, the response is a JSON, with the swift content formatted in base64. To get the plain swift as a response, use the request header **\'Accept: text/plain\'**. A date can be passed to get the transactions of a particular day. If no date is given, the last day is used.
     * Get the daily transactions of the address
     */
    async reportServiceSwiftMT536TransactionsReport(requestParameters: ReportServiceSwiftMT536TransactionsReportRequest = {}, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<ApiHttpBody> {
        const response = await this.reportServiceSwiftMT536TransactionsReportRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * This endpoint returns a BTC specific signature from a given message and address as input.
     * Calculate a BTC specific signature of a message
     */
    async walletServiceBTCSignMessageRaw(requestParameters: WalletServiceBTCSignMessageRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<TgvalidatordBTCSignMessageReply>> {
        if (requestParameters['addressId'] == null) {
            throw new runtime.RequiredError(
                'addressId',
                'Required parameter "addressId" was null or undefined when calling walletServiceBTCSignMessage().'
            );
        }

        const queryParameters: any = {};

        if (requestParameters['message'] != null) {
            queryParameters['message'] = requestParameters['message'];
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = await this.configuration.apiKey("Authorization"); // ApiKeyTPV1 authentication
        }

        const response = await this.request({
            path: `/api/rest/v1/addresses/{addressId}/btc_sign`.replace(`{${"addressId"}}`, encodeURIComponent(String(requestParameters['addressId']))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => TgvalidatordBTCSignMessageReplyFromJSON(jsonValue));
    }

    /**
     * This endpoint returns a BTC specific signature from a given message and address as input.
     * Calculate a BTC specific signature of a message
     */
    async walletServiceBTCSignMessage(requestParameters: WalletServiceBTCSignMessageRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<TgvalidatordBTCSignMessageReply> {
        const response = await this.walletServiceBTCSignMessageRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * This endpoint forces a recompute of all addresses signatures.  Required role: **Admin**.
     * Recompute addresses signatures
     */
    async walletServiceComputeAddressesSignatureRaw(requestParameters: WalletServiceComputeAddressesSignatureRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<TgvalidatordComputeAddressesSignatureReply>> {
        if (requestParameters['body'] == null) {
            throw new runtime.RequiredError(
                'body',
                'Required parameter "body" was null or undefined when calling walletServiceComputeAddressesSignature().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = await this.configuration.apiKey("Authorization"); // ApiKeyTPV1 authentication
        }

        const response = await this.request({
            path: `/api/rest/v1/addresses/signature/compute`,
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: TgvalidatordComputeAddressesSignatureRequestToJSON(requestParameters['body']),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => TgvalidatordComputeAddressesSignatureReplyFromJSON(jsonValue));
    }

    /**
     * This endpoint forces a recompute of all addresses signatures.  Required role: **Admin**.
     * Recompute addresses signatures
     */
    async walletServiceComputeAddressesSignature(requestParameters: WalletServiceComputeAddressesSignatureRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<TgvalidatordComputeAddressesSignatureReply> {
        const response = await this.walletServiceComputeAddressesSignatureRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * This endpoint creates a new address within a specified Wallet. All addresses _must_ be associated with a parent wallet. Addresses created with this endpoint are internal to Protect. To create an external address, you need to create a [whitelisted address request](https://docs.taurushq.com/protect-capital/reference/whitelistservice_createwhitelistedaddress).  For more information about whitelisted assets, see our [user guides](https://docs.taurushq.com/user-and-technical-guides/docs/smart-contracts).  Address creation requires HSM signature, which makes it synchronous. Therefore, address creation can be slow, and failures may occur if the HSM is either unavailable or takes too long to process. If this happens, the API can be safely called again.  **Required role:** AccountCreator.
     * Create an address
     */
    async walletServiceCreateAddressRaw(requestParameters: WalletServiceCreateAddressRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<TgvalidatordCreateAddressReply>> {
        if (requestParameters['body'] == null) {
            throw new runtime.RequiredError(
                'body',
                'Required parameter "body" was null or undefined when calling walletServiceCreateAddress().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = await this.configuration.apiKey("Authorization"); // ApiKeyTPV1 authentication
        }

        const response = await this.request({
            path: `/api/rest/v1/addresses`,
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: TgvalidatordCreateAddressRequestToJSON(requestParameters['body']),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => TgvalidatordCreateAddressReplyFromJSON(jsonValue));
    }

    /**
     * This endpoint creates a new address within a specified Wallet. All addresses _must_ be associated with a parent wallet. Addresses created with this endpoint are internal to Protect. To create an external address, you need to create a [whitelisted address request](https://docs.taurushq.com/protect-capital/reference/whitelistservice_createwhitelistedaddress).  For more information about whitelisted assets, see our [user guides](https://docs.taurushq.com/user-and-technical-guides/docs/smart-contracts).  Address creation requires HSM signature, which makes it synchronous. Therefore, address creation can be slow, and failures may occur if the HSM is either unavailable or takes too long to process. If this happens, the API can be safely called again.  **Required role:** AccountCreator.
     * Create an address
     */
    async walletServiceCreateAddress(requestParameters: WalletServiceCreateAddressRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<TgvalidatordCreateAddressReply> {
        const response = await this.walletServiceCreateAddressRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * This endpoint creates attributes for a given address.   Required role: **AccountCreator**.
     * Create attributes
     */
    async walletServiceCreateAddressAttributesRaw(requestParameters: WalletServiceCreateAddressAttributesRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<TgvalidatordCreateAddressAttributesReply>> {
        if (requestParameters['addressId'] == null) {
            throw new runtime.RequiredError(
                'addressId',
                'Required parameter "addressId" was null or undefined when calling walletServiceCreateAddressAttributes().'
            );
        }

        if (requestParameters['body'] == null) {
            throw new runtime.RequiredError(
                'body',
                'Required parameter "body" was null or undefined when calling walletServiceCreateAddressAttributes().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = await this.configuration.apiKey("Authorization"); // ApiKeyTPV1 authentication
        }

        const response = await this.request({
            path: `/api/rest/v1/addresses/{addressId}/attributes`.replace(`{${"addressId"}}`, encodeURIComponent(String(requestParameters['addressId']))),
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: WalletServiceCreateAddressAttributesBodyToJSON(requestParameters['body']),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => TgvalidatordCreateAddressAttributesReplyFromJSON(jsonValue));
    }

    /**
     * This endpoint creates attributes for a given address.   Required role: **AccountCreator**.
     * Create attributes
     */
    async walletServiceCreateAddressAttributes(requestParameters: WalletServiceCreateAddressAttributesRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<TgvalidatordCreateAddressAttributesReply> {
        const response = await this.walletServiceCreateAddressAttributesRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Required role: **AccountCreator**.   This endpoint creates a batch of addresses.   Address created from this endpoint will start with a **created** and will not be ready to use until the HSM process them. 
     * Create a batch of addresses
     */
    async walletServiceCreateAddressesBatchRaw(requestParameters: WalletServiceCreateAddressesBatchRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<TgvalidatordCreateAddressesReply>> {
        if (requestParameters['body'] == null) {
            throw new runtime.RequiredError(
                'body',
                'Required parameter "body" was null or undefined when calling walletServiceCreateAddressesBatch().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = await this.configuration.apiKey("Authorization"); // ApiKeyTPV1 authentication
        }

        const response = await this.request({
            path: `/api/rest/v1/addresses/batch`,
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: TgvalidatordCreateAddressesRequestToJSON(requestParameters['body']),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => TgvalidatordCreateAddressesReplyFromJSON(jsonValue));
    }

    /**
     * Required role: **AccountCreator**.   This endpoint creates a batch of addresses.   Address created from this endpoint will start with a **created** and will not be ready to use until the HSM process them. 
     * Create a batch of addresses
     */
    async walletServiceCreateAddressesBatch(requestParameters: WalletServiceCreateAddressesBatchRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<TgvalidatordCreateAddressesReply> {
        const response = await this.walletServiceCreateAddressesBatchRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * This endpoint deletes an attribute of a given address.   Required role: **AccountCreator**.
     * Delete an attribute
     */
    async walletServiceDeleteAddressAttributeRaw(requestParameters: WalletServiceDeleteAddressAttributeRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<object>> {
        if (requestParameters['addressId'] == null) {
            throw new runtime.RequiredError(
                'addressId',
                'Required parameter "addressId" was null or undefined when calling walletServiceDeleteAddressAttribute().'
            );
        }

        if (requestParameters['id'] == null) {
            throw new runtime.RequiredError(
                'id',
                'Required parameter "id" was null or undefined when calling walletServiceDeleteAddressAttribute().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = await this.configuration.apiKey("Authorization"); // ApiKeyTPV1 authentication
        }

        const response = await this.request({
            path: `/api/rest/v1/addresses/{addressId}/attributes/{id}`.replace(`{${"addressId"}}`, encodeURIComponent(String(requestParameters['addressId']))).replace(`{${"id"}}`, encodeURIComponent(String(requestParameters['id']))),
            method: 'DELETE',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse<any>(response);
    }

    /**
     * This endpoint deletes an attribute of a given address.   Required role: **AccountCreator**.
     * Delete an attribute
     */
    async walletServiceDeleteAddressAttribute(requestParameters: WalletServiceDeleteAddressAttributeRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<object> {
        const response = await this.walletServiceDeleteAddressAttributeRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * This endpoint returns an ETH specific signature from a given message and address as input.
     * Calculate an ETH specific signature of a message
     */
    async walletServiceETHSignMessageRaw(requestParameters: WalletServiceETHSignMessageRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<TgvalidatordETHSignMessageReply>> {
        if (requestParameters['addressId'] == null) {
            throw new runtime.RequiredError(
                'addressId',
                'Required parameter "addressId" was null or undefined when calling walletServiceETHSignMessage().'
            );
        }

        const queryParameters: any = {};

        if (requestParameters['message'] != null) {
            queryParameters['message'] = requestParameters['message'];
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = await this.configuration.apiKey("Authorization"); // ApiKeyTPV1 authentication
        }

        const response = await this.request({
            path: `/api/rest/v1/addresses/{addressId}/eth_sign`.replace(`{${"addressId"}}`, encodeURIComponent(String(requestParameters['addressId']))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => TgvalidatordETHSignMessageReplyFromJSON(jsonValue));
    }

    /**
     * This endpoint returns an ETH specific signature from a given message and address as input.
     * Calculate an ETH specific signature of a message
     */
    async walletServiceETHSignMessage(requestParameters: WalletServiceETHSignMessageRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<TgvalidatordETHSignMessageReply> {
        const response = await this.walletServiceETHSignMessageRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * This endpoint exports a list of address\' balances history
     * Export address\' balances history
     */
    async walletServiceExportAddressBalanceHistoryRaw(requestParameters: WalletServiceExportAddressBalanceHistoryRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<TgvalidatordExportAddressBalanceHistoryReply>> {
        if (requestParameters['id'] == null) {
            throw new runtime.RequiredError(
                'id',
                'Required parameter "id" was null or undefined when calling walletServiceExportAddressBalanceHistory().'
            );
        }

        const queryParameters: any = {};

        if (requestParameters['intervalHours'] != null) {
            queryParameters['intervalHours'] = requestParameters['intervalHours'];
        }

        if (requestParameters['format'] != null) {
            queryParameters['format'] = requestParameters['format'];
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = await this.configuration.apiKey("Authorization"); // ApiKeyTPV1 authentication
        }

        const response = await this.request({
            path: `/api/rest/v1/addresses/{id}/balances/history/export`.replace(`{${"id"}}`, encodeURIComponent(String(requestParameters['id']))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => TgvalidatordExportAddressBalanceHistoryReplyFromJSON(jsonValue));
    }

    /**
     * This endpoint exports a list of address\' balances history
     * Export address\' balances history
     */
    async walletServiceExportAddressBalanceHistory(requestParameters: WalletServiceExportAddressBalanceHistoryRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<TgvalidatordExportAddressBalanceHistoryReply> {
        const response = await this.walletServiceExportAddressBalanceHistoryRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * This endpoint exports a list of addresses
     * Export addresses
     */
    async walletServiceExportAddressesRaw(requestParameters: WalletServiceExportAddressesRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<TgvalidatordExportAddressesReply>> {
        const queryParameters: any = {};

        if (requestParameters['walletId'] != null) {
            queryParameters['walletId'] = requestParameters['walletId'];
        }

        if (requestParameters['currency'] != null) {
            queryParameters['currency'] = requestParameters['currency'];
        }

        if (requestParameters['format'] != null) {
            queryParameters['format'] = requestParameters['format'];
        }

        if (requestParameters['query'] != null) {
            queryParameters['query'] = requestParameters['query'];
        }

        if (requestParameters['scoreProvider'] != null) {
            queryParameters['scoreProvider'] = requestParameters['scoreProvider'];
        }

        if (requestParameters['scoreInBelow'] != null) {
            queryParameters['scoreInBelow'] = requestParameters['scoreInBelow'];
        }

        if (requestParameters['scoreOutBelow'] != null) {
            queryParameters['scoreOutBelow'] = requestParameters['scoreOutBelow'];
        }

        if (requestParameters['scoreExclusive'] != null) {
            queryParameters['scoreExclusive'] = requestParameters['scoreExclusive'];
        }

        if (requestParameters['customerId'] != null) {
            queryParameters['customerId'] = requestParameters['customerId'];
        }

        if (requestParameters['coinfirmScoreGreater'] != null) {
            queryParameters['coinfirmScoreGreater'] = requestParameters['coinfirmScoreGreater'];
        }

        if (requestParameters['chainalysisScoreGreater'] != null) {
            queryParameters['chainalysisScoreGreater'] = requestParameters['chainalysisScoreGreater'];
        }

        if (requestParameters['scoreFilterScoreProvider'] != null) {
            queryParameters['scoreFilter.scoreProvider'] = requestParameters['scoreFilterScoreProvider'];
        }

        if (requestParameters['scoreFilterScorechainFiltersScoreInBelow'] != null) {
            queryParameters['scoreFilter.scorechainFilters.scoreInBelow'] = requestParameters['scoreFilterScorechainFiltersScoreInBelow'];
        }

        if (requestParameters['scoreFilterScorechainFiltersScoreOutBelow'] != null) {
            queryParameters['scoreFilter.scorechainFilters.scoreOutBelow'] = requestParameters['scoreFilterScorechainFiltersScoreOutBelow'];
        }

        if (requestParameters['scoreFilterScorechainFiltersScoreExclusive'] != null) {
            queryParameters['scoreFilter.scorechainFilters.scoreExclusive'] = requestParameters['scoreFilterScorechainFiltersScoreExclusive'];
        }

        if (requestParameters['scoreFilterCoinfirmFiltersScoreGreater'] != null) {
            queryParameters['scoreFilter.coinfirmFilters.scoreGreater'] = requestParameters['scoreFilterCoinfirmFiltersScoreGreater'];
        }

        if (requestParameters['scoreFilterChainalysisFiltersScoreGreater'] != null) {
            queryParameters['scoreFilter.chainalysisFilters.scoreGreater'] = requestParameters['scoreFilterChainalysisFiltersScoreGreater'];
        }

        if (requestParameters['scoreFilterEllipticFiltersScoreGreater'] != null) {
            queryParameters['scoreFilter.ellipticFilters.scoreGreater'] = requestParameters['scoreFilterEllipticFiltersScoreGreater'];
        }

        if (requestParameters['scoreFilterTrmlabsFiltersScoreGreater'] != null) {
            queryParameters['scoreFilter.trmlabsFilters.scoreGreater'] = requestParameters['scoreFilterTrmlabsFiltersScoreGreater'];
        }

        if (requestParameters['blockchain'] != null) {
            queryParameters['blockchain'] = requestParameters['blockchain'];
        }

        if (requestParameters['network'] != null) {
            queryParameters['network'] = requestParameters['network'];
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = await this.configuration.apiKey("Authorization"); // ApiKeyTPV1 authentication
        }

        const response = await this.request({
            path: `/api/rest/v1/addresses/export`,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => TgvalidatordExportAddressesReplyFromJSON(jsonValue));
    }

    /**
     * This endpoint exports a list of addresses
     * Export addresses
     */
    async walletServiceExportAddresses(requestParameters: WalletServiceExportAddressesRequest = {}, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<TgvalidatordExportAddressesReply> {
        const response = await this.walletServiceExportAddressesRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * This endpoint accepts a unique address ID and returns the address alongside related information including:  * additional risk score data (if applicable). * information about the related wallet and currency. * related whitelisted address IDs.  To search across all addresses with query parameters, use the [List Addresses](https://docs.taurushq.com/protect-capital/reference/walletservice_getaddresses) endpoint.
     * Get an address
     */
    async walletServiceGetAddressRaw(requestParameters: WalletServiceGetAddressRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<TgvalidatordGetAddressReply>> {
        if (requestParameters['id'] == null) {
            throw new runtime.RequiredError(
                'id',
                'Required parameter "id" was null or undefined when calling walletServiceGetAddress().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = await this.configuration.apiKey("Authorization"); // ApiKeyTPV1 authentication
        }

        const response = await this.request({
            path: `/api/rest/v1/addresses/{id}`.replace(`{${"id"}}`, encodeURIComponent(String(requestParameters['id']))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => TgvalidatordGetAddressReplyFromJSON(jsonValue));
    }

    /**
     * This endpoint accepts a unique address ID and returns the address alongside related information including:  * additional risk score data (if applicable). * information about the related wallet and currency. * related whitelisted address IDs.  To search across all addresses with query parameters, use the [List Addresses](https://docs.taurushq.com/protect-capital/reference/walletservice_getaddresses) endpoint.
     * Get an address
     */
    async walletServiceGetAddress(requestParameters: WalletServiceGetAddressRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<TgvalidatordGetAddressReply> {
        const response = await this.walletServiceGetAddressRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * This endpoint returns the balances history of a given address
     * List address\' balances history
     */
    async walletServiceGetAddressBalanceHistoryRaw(requestParameters: WalletServiceGetAddressBalanceHistoryRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<TgvalidatordGetAddressBalanceHistoryReply>> {
        if (requestParameters['id'] == null) {
            throw new runtime.RequiredError(
                'id',
                'Required parameter "id" was null or undefined when calling walletServiceGetAddressBalanceHistory().'
            );
        }

        const queryParameters: any = {};

        if (requestParameters['intervalHours'] != null) {
            queryParameters['intervalHours'] = requestParameters['intervalHours'];
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = await this.configuration.apiKey("Authorization"); // ApiKeyTPV1 authentication
        }

        const response = await this.request({
            path: `/api/rest/v1/addresses/{id}/balances/history`.replace(`{${"id"}}`, encodeURIComponent(String(requestParameters['id']))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => TgvalidatordGetAddressBalanceHistoryReplyFromJSON(jsonValue));
    }

    /**
     * This endpoint returns the balances history of a given address
     * List address\' balances history
     */
    async walletServiceGetAddressBalanceHistory(requestParameters: WalletServiceGetAddressBalanceHistoryRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<TgvalidatordGetAddressBalanceHistoryReply> {
        const response = await this.walletServiceGetAddressBalanceHistoryRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * This endpoint returns the proof of reserve of an address. The relevance of response fields is specific to the request type.
     * Get the proof of reserve of an address
     */
    async walletServiceGetAddressProofOfReserveRaw(requestParameters: WalletServiceGetAddressProofOfReserveRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<TgvalidatordGetAddressProofOfReserveReply>> {
        if (requestParameters['id'] == null) {
            throw new runtime.RequiredError(
                'id',
                'Required parameter "id" was null or undefined when calling walletServiceGetAddressProofOfReserve().'
            );
        }

        const queryParameters: any = {};

        if (requestParameters['challenge'] != null) {
            queryParameters['challenge'] = requestParameters['challenge'];
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = await this.configuration.apiKey("Authorization"); // ApiKeyTPV1 authentication
        }

        const response = await this.request({
            path: `/api/rest/v1/addresses/{id}/proofofreserve`.replace(`{${"id"}}`, encodeURIComponent(String(requestParameters['id']))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => TgvalidatordGetAddressProofOfReserveReplyFromJSON(jsonValue));
    }

    /**
     * This endpoint returns the proof of reserve of an address. The relevance of response fields is specific to the request type.
     * Get the proof of reserve of an address
     */
    async walletServiceGetAddressProofOfReserve(requestParameters: WalletServiceGetAddressProofOfReserveRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<TgvalidatordGetAddressProofOfReserveReply> {
        const response = await this.walletServiceGetAddressProofOfReserveRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * This endpoint returns the list of tokens with their balances held by a given address.
     * Get the list of tokens for an address
     */
    async walletServiceGetAddressTokensRaw(requestParameters: WalletServiceGetAddressTokensRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<TgvalidatordGetAddressTokensReply>> {
        if (requestParameters['id'] == null) {
            throw new runtime.RequiredError(
                'id',
                'Required parameter "id" was null or undefined when calling walletServiceGetAddressTokens().'
            );
        }

        const queryParameters: any = {};

        if (requestParameters['limit'] != null) {
            queryParameters['limit'] = requestParameters['limit'];
        }

        if (requestParameters['cursor'] != null) {
            queryParameters['cursor'] = requestParameters['cursor'];
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = await this.configuration.apiKey("Authorization"); // ApiKeyTPV1 authentication
        }

        const response = await this.request({
            path: `/api/rest/v1/addresses/{id}/tokens`.replace(`{${"id"}}`, encodeURIComponent(String(requestParameters['id']))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => TgvalidatordGetAddressTokensReplyFromJSON(jsonValue));
    }

    /**
     * This endpoint returns the list of tokens with their balances held by a given address.
     * Get the list of tokens for an address
     */
    async walletServiceGetAddressTokens(requestParameters: WalletServiceGetAddressTokensRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<TgvalidatordGetAddressTokensReply> {
        const response = await this.walletServiceGetAddressTokensRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * This endpoint returns a list of UTXOs of a given address. In the case of the ADA blockchain, the value returned is the one from the native currency. Result is sorted by (address, id) DESC.
     * List UTXOs of an address
     */
    async walletServiceGetAddressUTXOsRaw(requestParameters: WalletServiceGetAddressUTXOsRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<TgvalidatordGetAddressUTXOsReply>> {
        if (requestParameters['id'] == null) {
            throw new runtime.RequiredError(
                'id',
                'Required parameter "id" was null or undefined when calling walletServiceGetAddressUTXOs().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = await this.configuration.apiKey("Authorization"); // ApiKeyTPV1 authentication
        }

        const response = await this.request({
            path: `/api/rest/v1/addresses/{id}/utxos`.replace(`{${"id"}}`, encodeURIComponent(String(requestParameters['id']))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => TgvalidatordGetAddressUTXOsReplyFromJSON(jsonValue));
    }

    /**
     * This endpoint returns a list of UTXOs of a given address. In the case of the ADA blockchain, the value returned is the one from the native currency. Result is sorted by (address, id) DESC.
     * List UTXOs of an address
     */
    async walletServiceGetAddressUTXOs(requestParameters: WalletServiceGetAddressUTXOsRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<TgvalidatordGetAddressUTXOsReply> {
        const response = await this.walletServiceGetAddressUTXOsRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * This endpoint returns a list of addresses
     * List addresses
     */
    async walletServiceGetAddressesRaw(requestParameters: WalletServiceGetAddressesRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<TgvalidatordGetAddressesReply>> {
        const queryParameters: any = {};

        if (requestParameters['currency'] != null) {
            queryParameters['currency'] = requestParameters['currency'];
        }

        if (requestParameters['query'] != null) {
            queryParameters['query'] = requestParameters['query'];
        }

        if (requestParameters['limit'] != null) {
            queryParameters['limit'] = requestParameters['limit'];
        }

        if (requestParameters['offset'] != null) {
            queryParameters['offset'] = requestParameters['offset'];
        }

        if (requestParameters['scoreProvider'] != null) {
            queryParameters['scoreProvider'] = requestParameters['scoreProvider'];
        }

        if (requestParameters['scoreInBelow'] != null) {
            queryParameters['scoreInBelow'] = requestParameters['scoreInBelow'];
        }

        if (requestParameters['scoreOutBelow'] != null) {
            queryParameters['scoreOutBelow'] = requestParameters['scoreOutBelow'];
        }

        if (requestParameters['scoreExclusive'] != null) {
            queryParameters['scoreExclusive'] = requestParameters['scoreExclusive'];
        }

        if (requestParameters['onlyPositiveBalance'] != null) {
            queryParameters['onlyPositiveBalance'] = requestParameters['onlyPositiveBalance'];
        }

        if (requestParameters['sortBy'] != null) {
            queryParameters['sortBy'] = requestParameters['sortBy'];
        }

        if (requestParameters['sortOrder'] != null) {
            queryParameters['sortOrder'] = requestParameters['sortOrder'];
        }

        if (requestParameters['balanceBelow'] != null) {
            queryParameters['balanceBelow'] = requestParameters['balanceBelow'];
        }

        if (requestParameters['balanceAbove'] != null) {
            queryParameters['balanceAbove'] = requestParameters['balanceAbove'];
        }

        if (requestParameters['walletId'] != null) {
            queryParameters['walletId'] = requestParameters['walletId'];
        }

        if (requestParameters['customerId'] != null) {
            queryParameters['customerId'] = requestParameters['customerId'];
        }

        if (requestParameters['coinfirmScoreGreater'] != null) {
            queryParameters['coinfirmScoreGreater'] = requestParameters['coinfirmScoreGreater'];
        }

        if (requestParameters['chainalysisScoreGreater'] != null) {
            queryParameters['chainalysisScoreGreater'] = requestParameters['chainalysisScoreGreater'];
        }

        if (requestParameters['tagIDs'] != null) {
            queryParameters['tagIDs'] = requestParameters['tagIDs'];
        }

        if (requestParameters['blockchain'] != null) {
            queryParameters['blockchain'] = requestParameters['blockchain'];
        }

        if (requestParameters['network'] != null) {
            queryParameters['network'] = requestParameters['network'];
        }

        if (requestParameters['addressIds'] != null) {
            queryParameters['addressIds'] = requestParameters['addressIds'];
        }

        if (requestParameters['nfts'] != null) {
            queryParameters['nfts'] = requestParameters['nfts'];
        }

        if (requestParameters['addresses'] != null) {
            queryParameters['addresses'] = requestParameters['addresses'];
        }

        if (requestParameters['scoreFilterScoreProvider'] != null) {
            queryParameters['scoreFilter.scoreProvider'] = requestParameters['scoreFilterScoreProvider'];
        }

        if (requestParameters['scoreFilterScorechainFiltersScoreInBelow'] != null) {
            queryParameters['scoreFilter.scorechainFilters.scoreInBelow'] = requestParameters['scoreFilterScorechainFiltersScoreInBelow'];
        }

        if (requestParameters['scoreFilterScorechainFiltersScoreOutBelow'] != null) {
            queryParameters['scoreFilter.scorechainFilters.scoreOutBelow'] = requestParameters['scoreFilterScorechainFiltersScoreOutBelow'];
        }

        if (requestParameters['scoreFilterScorechainFiltersScoreExclusive'] != null) {
            queryParameters['scoreFilter.scorechainFilters.scoreExclusive'] = requestParameters['scoreFilterScorechainFiltersScoreExclusive'];
        }

        if (requestParameters['scoreFilterCoinfirmFiltersScoreGreater'] != null) {
            queryParameters['scoreFilter.coinfirmFilters.scoreGreater'] = requestParameters['scoreFilterCoinfirmFiltersScoreGreater'];
        }

        if (requestParameters['scoreFilterChainalysisFiltersScoreGreater'] != null) {
            queryParameters['scoreFilter.chainalysisFilters.scoreGreater'] = requestParameters['scoreFilterChainalysisFiltersScoreGreater'];
        }

        if (requestParameters['scoreFilterEllipticFiltersScoreGreater'] != null) {
            queryParameters['scoreFilter.ellipticFilters.scoreGreater'] = requestParameters['scoreFilterEllipticFiltersScoreGreater'];
        }

        if (requestParameters['scoreFilterTrmlabsFiltersScoreGreater'] != null) {
            queryParameters['scoreFilter.trmlabsFilters.scoreGreater'] = requestParameters['scoreFilterTrmlabsFiltersScoreGreater'];
        }

        if (requestParameters['attributeFiltersJson'] != null) {
            queryParameters['attributeFiltersJson'] = requestParameters['attributeFiltersJson'];
        }

        if (requestParameters['attributeFiltersOperator'] != null) {
            queryParameters['attributeFiltersOperator'] = requestParameters['attributeFiltersOperator'];
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = await this.configuration.apiKey("Authorization"); // ApiKeyTPV1 authentication
        }

        const response = await this.request({
            path: `/api/rest/v1/addresses`,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => TgvalidatordGetAddressesReplyFromJSON(jsonValue));
    }

    /**
     * This endpoint returns a list of addresses
     * List addresses
     */
    async walletServiceGetAddresses(requestParameters: WalletServiceGetAddressesRequest = {}, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<TgvalidatordGetAddressesReply> {
        const response = await this.walletServiceGetAddressesRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * This endpoint returns the proof of reserve for a list of addresses.  The relevance of response fields is specific to the request type.
     * Get the proof of reserve of a list of addresses
     */
    async walletServiceGetAddressesProofOfReserveRaw(requestParameters: WalletServiceGetAddressesProofOfReserveRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<TgvalidatordGetAddressesProofOfReserveReply>> {
        if (requestParameters['blockchain'] == null) {
            throw new runtime.RequiredError(
                'blockchain',
                'Required parameter "blockchain" was null or undefined when calling walletServiceGetAddressesProofOfReserve().'
            );
        }

        const queryParameters: any = {};

        if (requestParameters['addresses'] != null) {
            queryParameters['addresses'] = requestParameters['addresses'];
        }

        if (requestParameters['challenge'] != null) {
            queryParameters['challenge'] = requestParameters['challenge'];
        }

        if (requestParameters['network'] != null) {
            queryParameters['network'] = requestParameters['network'];
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = await this.configuration.apiKey("Authorization"); // ApiKeyTPV1 authentication
        }

        const response = await this.request({
            path: `/api/rest/v1/{blockchain}/addresses/proofofreserve`.replace(`{${"blockchain"}}`, encodeURIComponent(String(requestParameters['blockchain']))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => TgvalidatordGetAddressesProofOfReserveReplyFromJSON(jsonValue));
    }

    /**
     * This endpoint returns the proof of reserve for a list of addresses.  The relevance of response fields is specific to the request type.
     * Get the proof of reserve of a list of addresses
     */
    async walletServiceGetAddressesProofOfReserve(requestParameters: WalletServiceGetAddressesProofOfReserveRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<TgvalidatordGetAddressesProofOfReserveReply> {
        const response = await this.walletServiceGetAddressesProofOfReserveRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * This endpoint returns a list of addresses with their status
     * List addresses\'s status
     */
    async walletServiceGetAddressesStatusRaw(requestParameters: WalletServiceGetAddressesStatusRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<TgvalidatordGetAddressesStatusReply>> {
        const queryParameters: any = {};

        if (requestParameters['walletIds'] != null) {
            queryParameters['walletIds'] = requestParameters['walletIds'];
        }

        if (requestParameters['addressIds'] != null) {
            queryParameters['addressIds'] = requestParameters['addressIds'];
        }

        if (requestParameters['currencyIds'] != null) {
            queryParameters['currencyIds'] = requestParameters['currencyIds'];
        }

        if (requestParameters['sortingSortOrder'] != null) {
            queryParameters['sorting.sortOrder'] = requestParameters['sortingSortOrder'];
        }

        if (requestParameters['cursorCurrentPage'] != null) {
            queryParameters['cursor.currentPage'] = requestParameters['cursorCurrentPage'];
        }

        if (requestParameters['cursorPageRequest'] != null) {
            queryParameters['cursor.pageRequest'] = requestParameters['cursorPageRequest'];
        }

        if (requestParameters['cursorPageSize'] != null) {
            queryParameters['cursor.pageSize'] = requestParameters['cursorPageSize'];
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = await this.configuration.apiKey("Authorization"); // ApiKeyTPV1 authentication
        }

        const response = await this.request({
            path: `/api/rest/v1/addresses/status`,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => TgvalidatordGetAddressesStatusReplyFromJSON(jsonValue));
    }

    /**
     * This endpoint returns a list of addresses with their status
     * List addresses\'s status
     */
    async walletServiceGetAddressesStatus(requestParameters: WalletServiceGetAddressesStatusRequest = {}, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<TgvalidatordGetAddressesStatusReply> {
        const response = await this.walletServiceGetAddressesStatusRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * This endpoint returns a list of addresses with light information filtered by a unique currency and a list of addresses. The light address information mainly contains the identifiers. There is no balance, risk score or attributes.
     * List light addresses
     */
    async walletServiceGetLightAddressesRaw(requestParameters: WalletServiceGetLightAddressesRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<TgvalidatordGetLightAddressesReply>> {
        if (requestParameters['uniqueCurrencyFilterBlockchain'] == null) {
            throw new runtime.RequiredError(
                'uniqueCurrencyFilterBlockchain',
                'Required parameter "uniqueCurrencyFilterBlockchain" was null or undefined when calling walletServiceGetLightAddresses().'
            );
        }

        if (requestParameters['uniqueCurrencyFilterNetwork'] == null) {
            throw new runtime.RequiredError(
                'uniqueCurrencyFilterNetwork',
                'Required parameter "uniqueCurrencyFilterNetwork" was null or undefined when calling walletServiceGetLightAddresses().'
            );
        }

        const queryParameters: any = {};

        if (requestParameters['currencyID'] != null) {
            queryParameters['currencyID'] = requestParameters['currencyID'];
        }

        if (requestParameters['uniqueCurrencyFilterBlockchain'] != null) {
            queryParameters['uniqueCurrencyFilter.blockchain'] = requestParameters['uniqueCurrencyFilterBlockchain'];
        }

        if (requestParameters['uniqueCurrencyFilterNetwork'] != null) {
            queryParameters['uniqueCurrencyFilter.network'] = requestParameters['uniqueCurrencyFilterNetwork'];
        }

        if (requestParameters['uniqueCurrencyFilterTokenContractAddress'] != null) {
            queryParameters['uniqueCurrencyFilter.tokenContractAddress'] = requestParameters['uniqueCurrencyFilterTokenContractAddress'];
        }

        if (requestParameters['uniqueCurrencyFilterTokenID'] != null) {
            queryParameters['uniqueCurrencyFilter.tokenID'] = requestParameters['uniqueCurrencyFilterTokenID'];
        }

        if (requestParameters['addresses'] != null) {
            queryParameters['addresses'] = requestParameters['addresses'];
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = await this.configuration.apiKey("Authorization"); // ApiKeyTPV1 authentication
        }

        const response = await this.request({
            path: `/api/rest/v1/addresses/light`,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => TgvalidatordGetLightAddressesReplyFromJSON(jsonValue));
    }

    /**
     * This endpoint returns a list of addresses with light information filtered by a unique currency and a list of addresses. The light address information mainly contains the identifiers. There is no balance, risk score or attributes.
     * List light addresses
     */
    async walletServiceGetLightAddresses(requestParameters: WalletServiceGetLightAddressesRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<TgvalidatordGetLightAddressesReply> {
        const response = await this.walletServiceGetLightAddressesRaw(requestParameters, initOverrides);
        return await response.value();
    }

}

/**
 * @export
 */
export const WalletServiceGetAddressesStatusSortingSortOrderEnum = {
    Desc: 'DESC'
} as const;
export type WalletServiceGetAddressesStatusSortingSortOrderEnum = typeof WalletServiceGetAddressesStatusSortingSortOrderEnum[keyof typeof WalletServiceGetAddressesStatusSortingSortOrderEnum];
