// Code generated by protoc-gen-ts_proto. DO NOT EDIT.
// versions:
//   protoc-gen-ts_proto  v1.181.2
//   protoc               v6.33.4
// source: request-service.proto

/* eslint-disable */
import Long from "long";
import _m0 from "protobufjs/minimal";
import { RequestCursor, ResponseCursor } from "./cursor";
import { Empty } from "./google/protobuf/empty";
import { Timestamp } from "./google/protobuf/timestamp";
import {
  AutoTransferEventHandler,
  ContractCall,
  CosmosMessageCall,
  GenericContractCall,
  GenericCreateContract,
  Request,
  RequestAttribute,
  RequestBatchSignature,
  RequestBundle,
  TravelRuleDataInput,
} from "./request";

export const protobufPackage = "tgvalidatord";

export interface ExtendedAmount {
  kind: string;
  nft: ExtendedAmount_Nft | undefined;
}

export enum ExtendedAmount_Kind {
  /** _default_ - Default amount is exploded in the main struct */
  _default_ = 0,
  NFT = 1,
  UNRECOGNIZED = -1,
}

export function extendedAmount_KindFromJSON(object: any): ExtendedAmount_Kind {
  switch (object) {
    case 0:
    case "_default_":
      return ExtendedAmount_Kind._default_;
    case 1:
    case "NFT":
      return ExtendedAmount_Kind.NFT;
    case -1:
    case "UNRECOGNIZED":
    default:
      return ExtendedAmount_Kind.UNRECOGNIZED;
  }
}

export function extendedAmount_KindToJSON(object: ExtendedAmount_Kind): string {
  switch (object) {
    case ExtendedAmount_Kind._default_:
      return "_default_";
    case ExtendedAmount_Kind.NFT:
      return "NFT";
    case ExtendedAmount_Kind.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

export interface ExtendedAmount_Nft {
  id: string;
  quantity: string;
}

export interface XLMOpts {
  SponsoredByAddressID: number;
}

export interface BlockchainOpts {
  /** Add new blockchain opts here... */
  xlm?: XLMOpts | undefined;
}

export interface CreateOutgoingRequestBundleRequest {
  requests: CreateOutgoingRequestRequest[];
}

export interface CreateOutgoingAddressToAddressRequestBundleRequest {
  requests: CreateAddressToAddressTransferOutgoingRequestRequest[];
}

export interface CreateOutgoingRequestRequest {
  amount: string;
  feeLimit: string;
  fromWalletId: number;
  fromAddressId: number;
  toAddressId: number;
  toWhitelistedAddressId: number;
  gasLimit: string;
  comment: string;
  useUnconfirmedFunds: boolean;
  feePaidByReceiver: boolean;
  transactionComment: string;
  useAllFunds: boolean;
  feePayerId: number;
  extendedAmount:
    | ExtendedAmount
    | undefined;
  /** @deprecated */
  transactionReference: string;
  externalRequestId: string;
  destinationAddressMemo: string;
  /** Extra */
  opts: BlockchainOpts | undefined;
  travelRuleDataInput: TravelRuleDataInput | undefined;
  feePayerAddressId: number;
}

export interface CreateAddressToAddressTransferOutgoingRequestRequest {
  amount: string;
  currency: string;
  fromAddress: string;
  toAddress: string;
  feeLimit: string;
  gasLimit: string;
  comment: string;
  useUnconfirmedFunds: boolean;
  feePaidByReceiver: boolean;
  transactionComment: string;
  useAllFunds: boolean;
  feePayerId: number;
  extendedAmount:
    | ExtendedAmount
    | undefined;
  /** @deprecated */
  transactionReference: string;
  externalRequestId: string;
  destinationAddressMemo: string;
  opts: BlockchainOpts | undefined;
}

export interface CreateOutgoingADADelegateRequestRequest {
  fromAddressId: number;
  toStakePoolAddressId: number;
  feeLimit: string;
  comment: string;
  useUnconfirmedFunds: boolean;
  /** @deprecated */
  transactionReference: string;
  stakePoolRegistrationCertificate: Uint8Array;
  stakePoolRegistrationDeposit: boolean;
  externalRequestId: string;
  drep: string;
}

export interface CreateOutgoingADAUndelegateRequestRequest {
  fromAddressId: number;
  feeLimit: string;
  comment: string;
  useUnconfirmedFunds: boolean;
  /** @deprecated */
  transactionReference: string;
  externalRequestId: string;
}

export interface CreateOutgoingADAVoteDelegateRequestRequest {
  fromAddressId: number;
  feeLimit: string;
  comment: string;
  useUnconfirmedFunds: boolean;
  externalRequestId: string;
  drep: string;
}

export interface CreateOutgoingADAWithdrawalRequestRequest {
  fromAddressId: number;
  feeLimit: string;
  comment: string;
  useUnconfirmedFunds: boolean;
  /** @deprecated */
  transactionReference: string;
  externalRequestId: string;
}

export interface CreateOutgoingCosmosDelegateRequestRequest {
  fromAddressId: number;
  toValidatorAddressId: number;
  amount: string;
  feeLimit: string;
  gasLimit: string;
  comment: string;
  /** @deprecated */
  transactionReference: string;
  externalRequestId: string;
}

export interface CreateOutgoingCosmosUndelegateRequestRequest {
  fromAddressId: number;
  toValidatorAddressId: number;
  amount: string;
  feeLimit: string;
  gasLimit: string;
  comment: string;
  /** @deprecated */
  transactionReference: string;
  externalRequestId: string;
}

export interface CreateOutgoingCosmosWithdrawRewardRequestRequest {
  fromAddressId: number;
  toValidatorAddressId: number;
  feeLimit: string;
  gasLimit: string;
  comment: string;
  /** @deprecated */
  transactionReference: string;
  externalRequestId: string;
}

export interface CreateOutgoingXTZDelegateRequestRequest {
  fromAddressId: number;
  toBakerAddressId: number;
  gasLimit: string;
  feeLimit: string;
  comment: string;
  /** @deprecated */
  transactionReference: string;
  externalRequestId: string;
}

export interface CreateOutgoingXTZUndelegateRequestRequest {
  fromAddressId: number;
  gasLimit: string;
  feeLimit: string;
  comment: string;
  /** @deprecated */
  transactionReference: string;
  externalRequestId: string;
}

export interface CreateOutgoingXTZStakeRequestRequest {
  fromAddressId: number;
  amount: string;
  gasLimit: string;
  feeLimit: string;
  comment: string;
  externalRequestId: string;
}

export interface CreateOutgoingXTZUnstakeRequestRequest {
  fromAddressId: number;
  amount: string;
  gasLimit: string;
  feeLimit: string;
  comment: string;
  externalRequestId: string;
}

export interface CreateOutgoingFTMDelegateRequestRequest {
  fromAddressId: number;
  toValidatorAddressId: number;
  amount: string;
  feeLimit: string;
  gasLimit: string;
  comment: string;
  useUnconfirmedFunds: boolean;
  /** @deprecated */
  transactionReference: string;
  externalRequestId: string;
}

export interface CreateOutgoingFTMUndelegateRequestRequest {
  fromAddressId: number;
  toValidatorAddressId: number;
  amount: string;
  feeLimit: string;
  gasLimit: string;
  comment: string;
  /** @deprecated */
  transactionReference: string;
  externalRequestId: string;
}

export interface CreateOutgoingFTMWithdrawalRequestRequest {
  fromAddressId: number;
  toValidatorAddressId: number;
  withdrawalId: number;
  feeLimit: string;
  gasLimit: string;
  comment: string;
  /** @deprecated */
  transactionReference: string;
  externalRequestId: string;
}

export interface CreateOutgoingFTMClaimRewardsRequestRequest {
  fromAddressId: number;
  toValidatorAddressId: number;
  restake: boolean;
  feeLimit: string;
  gasLimit: string;
  comment: string;
  /** @deprecated */
  transactionReference: string;
  externalRequestId: string;
}

export interface CreateOutgoingDOTNominateRequestRequest {
  fromAddressId: number;
  validatorWLAIds: number[];
  feeLimit: string;
  comment: string;
  /** @deprecated */
  transactionReference: string;
  externalRequestId: string;
}

export interface CreateOutgoingDOTBondRequestRequest {
  fromAddressId: number;
  amount: string;
  restakeRewards: boolean;
  feeLimit: string;
  comment: string;
  useAllFunds: boolean;
  /** @deprecated */
  transactionReference: string;
  externalRequestId: string;
}

export interface CreateOutgoingDOTBondExtraRequestRequest {
  fromAddressId: number;
  amount: string;
  feeLimit: string;
  comment: string;
  useAllFunds: boolean;
  /** @deprecated */
  transactionReference: string;
  externalRequestId: string;
}

export interface CreateOutgoingDOTChillRequestRequest {
  fromAddressId: number;
  feeLimit: string;
  comment: string;
  /** @deprecated */
  transactionReference: string;
  externalRequestId: string;
}

export interface CreateOutgoingDOTUnbondRequestRequest {
  fromAddressId: number;
  amount: string;
  feeLimit: string;
  comment: string;
  /** @deprecated */
  transactionReference: string;
  externalRequestId: string;
}

export interface CreateOutgoingDOTWithdrawUnbondedRequestRequest {
  fromAddressId: number;
  feeLimit: string;
  comment: string;
  /** @deprecated */
  transactionReference: string;
  externalRequestId: string;
}

export interface CreateOutgoingMinaDelegationRequestRequest {
  fromAddressId: number;
  toWhitelistedAddressId: number;
  feeLimit: string;
  comment: string;
  externalRequestId: string;
}

export interface CreateOutgoingMinaUndelegationRequestRequest {
  fromAddressId: number;
  feeLimit: string;
  comment: string;
  externalRequestId: string;
}

export interface CreateOutgoingNEARDepositAndStakeRequestRequest {
  fromAddressId: number;
  toValidatorAddressId: number;
  amount: string;
  feeLimit: string;
  comment: string;
  transactionReference: string;
}

export interface CreateOutgoingNEARUnstakeRequestRequest {
  fromAddressId: number;
  toValidatorAddressId: number;
  amount: string;
  feeLimit: string;
  comment: string;
  transactionReference: string;
}

export interface CreateOutgoingNEARWithdrawRequestRequest {
  fromAddressId: number;
  toValidatorAddressId: number;
  amount: string;
  feeLimit: string;
  comment: string;
  transactionReference: string;
}

export interface CreateOutgoingUTXOsRequestRequest {
  amount: string;
  feeLimit: string;
  fromAddressId: number;
  toAddressId: number;
  toWhitelistedAddressId: number;
  utxoIds: number[];
  comment: string;
  feePaidByReceiver: boolean;
  /** @deprecated */
  transactionReference: string;
  externalRequestId: string;
}

export interface CreateOutgoingCancelRequestRequest {
  addressId: number;
  nonce: number;
  feePayerId: number;
  addressIds: number[];
  nonces: number[];
  externalRequestId: string;
}

export interface CreateOutgoingDeployContractRequestRequest {
  fromAddressId: number;
  bytecode: Uint8Array;
  constructor: ContractCall | undefined;
  generateWhitelistedAddress: boolean;
  gasLimit: string;
  gasPriceLimit: string;
  comment: string;
  contractType: string;
  feePayerId: number;
  feeLimit: string;
  contract:
    | GenericCreateContract
    | undefined;
  /** @deprecated */
  transactionReference: string;
  externalRequestId: string;
}

export interface CreateOutgoingCallContractRequestRequest {
  fromAddressId: number;
  toWhitelistedAddressId: number;
  method: ContractCall | undefined;
  gasLimit: string;
  gasPriceLimit: string;
  comment: string;
  contractType: string;
  amount: string;
  feePayerId: number;
  feeLimit: string;
  call:
    | GenericContractCall
    | undefined;
  /** @deprecated */
  transactionReference: string;
  externalRequestId: string;
}

export interface CreateOutgoingCosmosGenericRequestRequest {
  chainId: string;
  signers: number[];
  feeDenom: string;
  fee: string;
  feePayer: string;
  gasLimit: number;
  messages: CosmosMessageCall[];
  comment: string;
  useUnconfirmedFunds: boolean;
  /** @deprecated */
  transactionReference: string;
  broadcastKind: string;
  /** Fields for manual broadcast */
  accountsInfo: CreateOutgoingCosmosGenericRequestRequest_AccountInfo[];
  memo: string;
  externalRequestId: string;
}

export enum CreateOutgoingCosmosGenericRequestRequest_BroadcastKind {
  None = 0,
  Manual = 1,
  Automatic = 2,
  UNRECOGNIZED = -1,
}

export function createOutgoingCosmosGenericRequestRequest_BroadcastKindFromJSON(
  object: any,
): CreateOutgoingCosmosGenericRequestRequest_BroadcastKind {
  switch (object) {
    case 0:
    case "None":
      return CreateOutgoingCosmosGenericRequestRequest_BroadcastKind.None;
    case 1:
    case "Manual":
      return CreateOutgoingCosmosGenericRequestRequest_BroadcastKind.Manual;
    case 2:
    case "Automatic":
      return CreateOutgoingCosmosGenericRequestRequest_BroadcastKind.Automatic;
    case -1:
    case "UNRECOGNIZED":
    default:
      return CreateOutgoingCosmosGenericRequestRequest_BroadcastKind.UNRECOGNIZED;
  }
}

export function createOutgoingCosmosGenericRequestRequest_BroadcastKindToJSON(
  object: CreateOutgoingCosmosGenericRequestRequest_BroadcastKind,
): string {
  switch (object) {
    case CreateOutgoingCosmosGenericRequestRequest_BroadcastKind.None:
      return "None";
    case CreateOutgoingCosmosGenericRequestRequest_BroadcastKind.Manual:
      return "Manual";
    case CreateOutgoingCosmosGenericRequestRequest_BroadcastKind.Automatic:
      return "Automatic";
    case CreateOutgoingCosmosGenericRequestRequest_BroadcastKind.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

export interface CreateOutgoingCosmosGenericRequestRequest_AccountInfo {
  sequence: number;
  accountNumber: number;
}

export interface CreateOutgoingXLMMintAssetRequestRequest {
  amount: string;
  feeLimit: string;
  fromAddressId: number;
  toAddressId: number;
  toWhitelistedAddressId: number;
  comment: string;
  externalRequestId: string;
  destinationAddressMemo: string;
}

export interface CreateOutgoingXLMChangeTrustRequestRequest {
  fromAddressId: number;
  trustlineLimit: number;
  feeLimit: string;
  comment: string;
  poolID: string;
  externalRequestId: string;
  sponsoredByAddressId: number;
}

export interface CreateOutgoingXLMManageDataRequestRequest {
  fromAddressId: number;
  dataName: string;
  dataValue: string;
  feeLimit: string;
  comment: string;
  externalRequestId: string;
  sponsoredByAddressId: number;
}

export interface CreateOutgoingXLMSetOptionsRequestRequest {
  fromAddressId: number;
  setFlags: string[];
  clearFlags: string[];
  feeLimit: string;
  comment: string;
  externalRequestId: string;
}

export interface CreateOutgoingICPTransferToStakeRequestRequest {
  fromAddressId: number;
  amount: string;
  comment: string;
  externalRequestId: string;
}

export interface CreateOutgoingICPSetDissolveDelayRequestRequest {
  fromAddressId: number;
  delay: number;
  comment: string;
  externalRequestId: string;
}

export interface CreateOutgoingICPFollowRequestRequest {
  fromAddressId: number;
  neuronWhitelistedAddressIds: number[];
  topic: string;
  comment: string;
  externalRequestId: string;
}

export interface CreateOutgoingXLMSetTrustlineFlagsRequestRequest {
  fromAddressId: number;
  trustorInternalAddressId: number;
  trustorWhitelistedAddressId: number;
  setFlags: string[];
  clearFlags: string[];
  feeLimit: string;
  comment: string;
  externalRequestId: string;
}

export interface CreateOutgoingICPStartDissolvingRequestRequest {
  fromAddressId: number;
  comment: string;
  externalRequestId: string;
}

export interface CreateOutgoingXLMCreateClaimableBalanceRequestRequest {
  amount: string;
  feeLimit: string;
  fromAddressId: number;
  fromWalletId: number;
  toAddressId: number;
  toWhitelistedAddressId: number;
  comment: string;
  externalRequestId: string;
  destinationAddressMemo: string;
  absoluteTimeBefore: number;
  relativeTimeBefore: number;
  sponsoredByAddressId: number;
}

export interface CreateOutgoingXLMClaimClaimableBalanceRequestRequest {
  fromAddressId: number;
  claimableBalanceID: string;
  feeLimit: string;
  comment: string;
  externalRequestId: string;
}

export interface CreateOutgoingXLMClawbackClaimableBalanceRequestRequest {
  fromAddressId: number;
  claimableBalanceID: string;
  feeLimit: string;
  comment: string;
  externalRequestId: string;
}

export interface CreateOutgoingXLMRevokeSponsorshipRequestRequest {
  fromAddressId: number;
  toAddressId: number;
  toWhitelistedAddressId: number;
  destinationAddressMemo: string;
  claimableBalanceID: string;
  dataName: string;
  currencyID: string;
  /**
   * we currently do not support sponsorships of for XLM offers as Stellar API does not allow effective tracking
   * int64 offerID = 8;
   */
  feeLimit: string;
  comment: string;
  externalRequestId: string;
  sponsoredByAddressId: number;
}

export interface CreateOutgoingXLMClawbackRequestRequest {
  fromAddressId: number;
  toAddressId: number;
  toWhitelistedAddressId: number;
  destinationAddressMemo: string;
  amount: string;
  feeLimit: string;
  comment: string;
  externalRequestId: string;
}

export interface CreateOutgoingXLMLiquidityPoolDepositRequestRequest {
  fromAddressId: number;
  poolID: string;
  maxAmountAssetA: string;
  maxAmountAssetB: string;
  priceVariation: number;
  feeLimit: string;
  comment: string;
  externalRequestId: string;
}

export interface CreateOutgoingXLMLiquidityPoolWithdrawRequestRequest {
  fromAddressId: number;
  poolID: string;
  amount: string;
  minAmountAssetA: string;
  minAmountAssetB: string;
  feeLimit: string;
  comment: string;
  externalRequestId: string;
}

export interface CreateOutgoingXLMPathPaymentStrictSendRequestRequest {
  amount: string;
  minDestinationAmount: string;
  feeLimit: string;
  fromAddressId: number;
  toAddressId: number;
  toWhitelistedAddressId: number;
  destinationAssetID: string;
  destinationAssetIssuer: string;
  comment: string;
  externalRequestId: string;
  destinationAddressMemo: string;
}

export interface CreateOutgoingXLMPathPaymentStrictReceiveRequestRequest {
  amount: string;
  maxSenderAmount: string;
  feeLimit: string;
  fromAddressId: number;
  toAddressId: number;
  toWhitelistedAddressId: number;
  destinationAssetID: string;
  destinationAssetIssuer: string;
  comment: string;
  externalRequestId: string;
  destinationAddressMemo: string;
}

export interface CreateOutgoingXLMBuyOfferRequestRequest {
  amount: string;
  feeLimit: string;
  fromAddressId: number;
  buyingAssetID: string;
  buyingAssetIssuer: string;
  comment: string;
  price: string;
  offerID: number;
  /**
   * we currently do not support sponsorships for offer as Stellar API does not allow effective tracking
   * uint64 sponsoredByAddressId = 12 [(grpc.gateway.protoc_gen_openapiv2.options.openapiv2_field) = {description: "If set, is the ID of the address who will sponsor the cost of the operation on the minimum balance of the source address";}];
   */
  externalRequestId: string;
}

export interface CreateOutgoingXLMSellOfferRequestRequest {
  amount: string;
  feeLimit: string;
  fromAddressId: number;
  buyingAssetID: string;
  buyingAssetIssuer: string;
  comment: string;
  price: string;
  offerID: number;
  isPassive: boolean;
  /**
   * we currently do not support sponsorships for offer as Stellar API does not allow effective tracking
   * uint64 sponsoredByAddressId = 12 [(grpc.gateway.protoc_gen_openapiv2.options.openapiv2_field) = {description: "If set, is the ID of the address who will sponsor the cost of the operation on the minimum balance of the source address";}];
   */
  externalRequestId: string;
}

export interface CreateOutgoingALGOASAOptInRequestRequest {
  fromAddressId: number;
  assetId: number;
  feeLimit: string;
  comment: string;
  /** @deprecated */
  transactionReference: string;
  externalRequestId: string;
}

export interface CreateIncomingRequestRequest {
  amount: string;
  fromExchangeId: number;
  toAddressId: number;
  comment: string;
  /** @deprecated */
  transactionReference: string;
  externalRequestId: string;
  feePaidByReceiver: boolean;
}

export interface CreateFiatProviderWithdrawalRequestRequest {
  amount: string;
  fromAccountID: string;
  toAddressID?: number | undefined;
  toAccountID?: string | undefined;
  comment: string;
  externalRequestID: string;
}

export interface CreateFiatProviderDepositRequestRequest {
  amount: string;
  fromAccountID?: string | undefined;
  fromAddressID?: number | undefined;
  toAccountID: string;
  comment: string;
  externalRequestID: string;
}

export interface CreateFiatProviderTransferRequestRequest {
  amount: string;
  fromAccountID: string;
  toAccountID?: string | undefined;
  toCounterpartyAccountID?: string | undefined;
  comment: string;
  externalRequestID: string;
}

export interface CreateOutgoingSOLDelegateRequestRequest {
  fromAddressId: number;
  toValidatorAddressId: number;
  amount: string;
  feeLimit: string;
  comment: string;
  useUnconfirmedFunds: boolean;
  externalRequestId: string;
  autoMerging: boolean;
}

export interface CreateOutgoingSOLDeactivateRequestRequest {
  fromAddressId: number;
  feeLimit: string;
  comment: string;
  useUnconfirmedFunds: boolean;
  externalRequestId: string;
  fromStakeAccountDerivationIndex: number;
  amount: number;
}

export interface CreateOutgoingSOLWithdrawRequestRequest {
  fromAddressId: number;
  amount: string;
  feeLimit: string;
  comment: string;
  useUnconfirmedFunds: boolean;
  externalRequestId: string;
  fromStakeAccountDerivationIndex: number;
}

export interface CreateOutgoingSOLCreateTokenRequestRequest {
  fromAddressId: number;
  feeLimit: string;
  decimals: number;
  /** on-chain metadata */
  name: string;
  symbol: string;
  uri: string;
  comment: string;
  externalRequestId: string;
}

export interface CreateOutgoingSOLTokenMintRequestRequest {
  fromAddressId: number;
  toAddressId: number;
  toWhitelistedAddressId: number;
  amount: string;
  feeLimit: string;
  comment: string;
  externalRequestId: string;
}

export interface CreateOutgoingSOLTokenBurnRequestRequest {
  fromAddressId: number;
  amount: string;
  feeLimit: string;
  comment: string;
  externalRequestId: string;
}

export interface CreateOutgoingSOLMergeRequestRequest {
  addressId: number;
  fromStakeAccountDerivationIndex: number;
  toStakeAccountDerivationIndex: number;
  feeLimit: string;
  comment: string;
  externalRequestId: string;
  useUnconfirmedFunds: boolean;
}

export interface CreateOutgoingHederaStakingRequestRequest {
  fromAddressId: number;
  toWhitelistedAddressId: number;
  feeLimit: string;
  comment: string;
  externalRequestId: string;
}

export interface CreateOutgoingHederaUnstakingRequestRequest {
  fromAddressId: number;
  feeLimit: string;
  comment: string;
  externalRequestId: string;
}

export interface CreateRequestReply {
  result: Request | undefined;
}

export interface CreateRequestBundleReply {
  result: RequestBundle | undefined;
}

export interface GetRequestBundleRequest {
  id: number;
  showRequests: boolean;
}

export interface GetRequestBundleReply {
  result: RequestBundle | undefined;
}

export interface GetRequestBundlesRequest {
  from: Date | undefined;
  to: Date | undefined;
  statuses: string[];
  ids: number[];
  showRequests: boolean;
  cursor: RequestCursor | undefined;
}

export interface GetRequestBundlesReply {
  results: RequestBundle[];
  cursor: ResponseCursor | undefined;
}

export interface GetRequestBundlesForApprovalRequest {
  blockchains: string[];
  ids: number[];
  cursor: RequestCursor | undefined;
}

export interface GetRequestsRequest {
  limit: number;
  offset: number;
  from: Date | undefined;
  to: Date | undefined;
  currencies: string[];
  /** deprecated, use the multi-valued propery "types" instead */
  type: string;
  statuses: string[];
  types: string[];
  ids: number[];
}

export interface GetRequestsV2Request {
  from: Date | undefined;
  to: Date | undefined;
  currencyID: string;
  statuses: string[];
  types: string[];
  ids: number[];
  cursor: RequestCursor | undefined;
  sortOrder: string;
  externalRequestIDs: string[];
}

export interface GetRequestsReply {
  result: Request[];
  totalItems: number;
}

export interface GetRequestReply {
  result: Request | undefined;
}

export interface GetRequestRequest {
  id: number;
}

export interface GetRequestsForApprovalRequest {
  limit: number;
  offset: number;
  currencies: string[];
  /** *Deprecated:** use the multi-valued propery "types" instead */
  type: string;
  types: string[];
  ids: number[];
}

export interface GetRequestsForApprovalV2Request {
  currencyID: string;
  types: string[];
  ids: number[];
  cursor: RequestCursor | undefined;
  sortOrder: string;
  excludeTypes: string[];
  externalRequestIDs: string[];
}

export interface GetRequestsV2Reply {
  result: Request[];
  cursor: ResponseCursor | undefined;
}

export interface ApproveRequestsRequest {
  /**  */
  signature: string;
  comment: string;
  /** @deprecated */
  requestIds: number[];
  ids: number[];
  async: boolean;
}

export interface ApproveRequestsReply {
  /**
   * use signatures instead
   *
   * @deprecated
   */
  signedRequests: number;
  signatures: number;
  asyncSignature: RequestBatchSignature | undefined;
}

export interface GetAsyncApprovalsRequest {
  ids: number[];
  includeDetails: boolean;
}

export interface GetAsyncApprovalsReply {
  result: RequestBatchSignature[];
}

export interface RejectRequestsRequest {
  comment: string;
  /** @deprecated */
  requestIds: number[];
  ids: number[];
}

export interface UpdateRequestStatusRequest {
  id: number;
  status: string;
}

export interface GetRequestAttributeRequest {
  id: number;
}

export interface GetRequestAttributeReply {
  result: RequestAttribute | undefined;
}

export interface CreateRequestAttributesRequest {
  requestId: number;
  attributes: CreateRequestAttributeRequest[];
}

export interface CreateRequestAttributeRequest {
  key: string;
  value: string;
  contentType: string;
}

export interface GetAutoTransferEventHandlersRequest {
  cursor: RequestCursor | undefined;
  status: string;
  blockchain: string;
  network: string;
  monitoredWalletId: number;
}

export interface GetAutoTransferEventHandlersReply {
  cursor: ResponseCursor | undefined;
  handlers: AutoTransferEventHandler[];
}

export interface GetAutoTransferEventHandlerByIdRequest {
  id: string;
}

export interface GetAutoTransferEventHandlerByIdReply {
  handler: AutoTransferEventHandler | undefined;
}

export interface TriggerAutoTransferEventHandlerRequest {
  id: string;
  destinationAddressId: number;
  externalRequestId: string;
}

export interface StakingProvider {
  kind: string;
}

export interface StakeETHRequest {
  fromAddressId: number;
  amount: string;
  provider: StakingProvider | undefined;
  gasLimit: string;
  gasPriceLimit: string;
  comment: string;
  externalRequestId: string;
}

export interface CreateETHUnstakeRequestRequest {
  fromAddressId: number;
  amount: string;
  ethValidatorIDs: string[];
  comment: string;
  externalRequestId: string;
}

function createBaseExtendedAmount(): ExtendedAmount {
  return { kind: "", nft: undefined };
}

export const ExtendedAmount = {
  encode(message: ExtendedAmount, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.kind !== "") {
      writer.uint32(10).string(message.kind);
    }
    if (message.nft !== undefined) {
      ExtendedAmount_Nft.encode(message.nft, writer.uint32(18).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): ExtendedAmount {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseExtendedAmount();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.kind = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.nft = ExtendedAmount_Nft.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ExtendedAmount {
    return {
      kind: isSet(object.kind) ? globalThis.String(object.kind) : "",
      nft: isSet(object.nft) ? ExtendedAmount_Nft.fromJSON(object.nft) : undefined,
    };
  },

  toJSON(message: ExtendedAmount): unknown {
    const obj: any = {};
    if (message.kind !== "") {
      obj.kind = message.kind;
    }
    if (message.nft !== undefined) {
      obj.nft = ExtendedAmount_Nft.toJSON(message.nft);
    }
    return obj;
  },

  create(base?: DeepPartial<ExtendedAmount>): ExtendedAmount {
    return ExtendedAmount.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ExtendedAmount>): ExtendedAmount {
    const message = createBaseExtendedAmount();
    message.kind = object.kind ?? "";
    message.nft = (object.nft !== undefined && object.nft !== null)
      ? ExtendedAmount_Nft.fromPartial(object.nft)
      : undefined;
    return message;
  },
};

function createBaseExtendedAmount_Nft(): ExtendedAmount_Nft {
  return { id: "", quantity: "" };
}

export const ExtendedAmount_Nft = {
  encode(message: ExtendedAmount_Nft, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.id !== "") {
      writer.uint32(10).string(message.id);
    }
    if (message.quantity !== "") {
      writer.uint32(18).string(message.quantity);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): ExtendedAmount_Nft {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseExtendedAmount_Nft();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.id = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.quantity = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ExtendedAmount_Nft {
    return {
      id: isSet(object.id) ? globalThis.String(object.id) : "",
      quantity: isSet(object.quantity) ? globalThis.String(object.quantity) : "",
    };
  },

  toJSON(message: ExtendedAmount_Nft): unknown {
    const obj: any = {};
    if (message.id !== "") {
      obj.id = message.id;
    }
    if (message.quantity !== "") {
      obj.quantity = message.quantity;
    }
    return obj;
  },

  create(base?: DeepPartial<ExtendedAmount_Nft>): ExtendedAmount_Nft {
    return ExtendedAmount_Nft.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ExtendedAmount_Nft>): ExtendedAmount_Nft {
    const message = createBaseExtendedAmount_Nft();
    message.id = object.id ?? "";
    message.quantity = object.quantity ?? "";
    return message;
  },
};

function createBaseXLMOpts(): XLMOpts {
  return { SponsoredByAddressID: 0 };
}

export const XLMOpts = {
  encode(message: XLMOpts, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.SponsoredByAddressID !== 0) {
      writer.uint32(8).uint64(message.SponsoredByAddressID);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): XLMOpts {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseXLMOpts();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.SponsoredByAddressID = longToNumber(reader.uint64() as Long);
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): XLMOpts {
    return {
      SponsoredByAddressID: isSet(object.SponsoredByAddressID) ? globalThis.Number(object.SponsoredByAddressID) : 0,
    };
  },

  toJSON(message: XLMOpts): unknown {
    const obj: any = {};
    if (message.SponsoredByAddressID !== 0) {
      obj.SponsoredByAddressID = Math.round(message.SponsoredByAddressID);
    }
    return obj;
  },

  create(base?: DeepPartial<XLMOpts>): XLMOpts {
    return XLMOpts.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<XLMOpts>): XLMOpts {
    const message = createBaseXLMOpts();
    message.SponsoredByAddressID = object.SponsoredByAddressID ?? 0;
    return message;
  },
};

function createBaseBlockchainOpts(): BlockchainOpts {
  return { xlm: undefined };
}

export const BlockchainOpts = {
  encode(message: BlockchainOpts, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.xlm !== undefined) {
      XLMOpts.encode(message.xlm, writer.uint32(10).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): BlockchainOpts {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseBlockchainOpts();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.xlm = XLMOpts.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): BlockchainOpts {
    return { xlm: isSet(object.xlm) ? XLMOpts.fromJSON(object.xlm) : undefined };
  },

  toJSON(message: BlockchainOpts): unknown {
    const obj: any = {};
    if (message.xlm !== undefined) {
      obj.xlm = XLMOpts.toJSON(message.xlm);
    }
    return obj;
  },

  create(base?: DeepPartial<BlockchainOpts>): BlockchainOpts {
    return BlockchainOpts.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<BlockchainOpts>): BlockchainOpts {
    const message = createBaseBlockchainOpts();
    message.xlm = (object.xlm !== undefined && object.xlm !== null) ? XLMOpts.fromPartial(object.xlm) : undefined;
    return message;
  },
};

function createBaseCreateOutgoingRequestBundleRequest(): CreateOutgoingRequestBundleRequest {
  return { requests: [] };
}

export const CreateOutgoingRequestBundleRequest = {
  encode(message: CreateOutgoingRequestBundleRequest, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    for (const v of message.requests) {
      CreateOutgoingRequestRequest.encode(v!, writer.uint32(10).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CreateOutgoingRequestBundleRequest {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCreateOutgoingRequestBundleRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.requests.push(CreateOutgoingRequestRequest.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CreateOutgoingRequestBundleRequest {
    return {
      requests: globalThis.Array.isArray(object?.requests)
        ? object.requests.map((e: any) => CreateOutgoingRequestRequest.fromJSON(e))
        : [],
    };
  },

  toJSON(message: CreateOutgoingRequestBundleRequest): unknown {
    const obj: any = {};
    if (message.requests?.length) {
      obj.requests = message.requests.map((e) => CreateOutgoingRequestRequest.toJSON(e));
    }
    return obj;
  },

  create(base?: DeepPartial<CreateOutgoingRequestBundleRequest>): CreateOutgoingRequestBundleRequest {
    return CreateOutgoingRequestBundleRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CreateOutgoingRequestBundleRequest>): CreateOutgoingRequestBundleRequest {
    const message = createBaseCreateOutgoingRequestBundleRequest();
    message.requests = object.requests?.map((e) => CreateOutgoingRequestRequest.fromPartial(e)) || [];
    return message;
  },
};

function createBaseCreateOutgoingAddressToAddressRequestBundleRequest(): CreateOutgoingAddressToAddressRequestBundleRequest {
  return { requests: [] };
}

export const CreateOutgoingAddressToAddressRequestBundleRequest = {
  encode(
    message: CreateOutgoingAddressToAddressRequestBundleRequest,
    writer: _m0.Writer = _m0.Writer.create(),
  ): _m0.Writer {
    for (const v of message.requests) {
      CreateAddressToAddressTransferOutgoingRequestRequest.encode(v!, writer.uint32(10).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CreateOutgoingAddressToAddressRequestBundleRequest {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCreateOutgoingAddressToAddressRequestBundleRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.requests.push(CreateAddressToAddressTransferOutgoingRequestRequest.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CreateOutgoingAddressToAddressRequestBundleRequest {
    return {
      requests: globalThis.Array.isArray(object?.requests)
        ? object.requests.map((e: any) => CreateAddressToAddressTransferOutgoingRequestRequest.fromJSON(e))
        : [],
    };
  },

  toJSON(message: CreateOutgoingAddressToAddressRequestBundleRequest): unknown {
    const obj: any = {};
    if (message.requests?.length) {
      obj.requests = message.requests.map((e) => CreateAddressToAddressTransferOutgoingRequestRequest.toJSON(e));
    }
    return obj;
  },

  create(
    base?: DeepPartial<CreateOutgoingAddressToAddressRequestBundleRequest>,
  ): CreateOutgoingAddressToAddressRequestBundleRequest {
    return CreateOutgoingAddressToAddressRequestBundleRequest.fromPartial(base ?? {});
  },
  fromPartial(
    object: DeepPartial<CreateOutgoingAddressToAddressRequestBundleRequest>,
  ): CreateOutgoingAddressToAddressRequestBundleRequest {
    const message = createBaseCreateOutgoingAddressToAddressRequestBundleRequest();
    message.requests =
      object.requests?.map((e) => CreateAddressToAddressTransferOutgoingRequestRequest.fromPartial(e)) || [];
    return message;
  },
};

function createBaseCreateOutgoingRequestRequest(): CreateOutgoingRequestRequest {
  return {
    amount: "",
    feeLimit: "",
    fromWalletId: 0,
    fromAddressId: 0,
    toAddressId: 0,
    toWhitelistedAddressId: 0,
    gasLimit: "",
    comment: "",
    useUnconfirmedFunds: false,
    feePaidByReceiver: false,
    transactionComment: "",
    useAllFunds: false,
    feePayerId: 0,
    extendedAmount: undefined,
    transactionReference: "",
    externalRequestId: "",
    destinationAddressMemo: "",
    opts: undefined,
    travelRuleDataInput: undefined,
    feePayerAddressId: 0,
  };
}

export const CreateOutgoingRequestRequest = {
  encode(message: CreateOutgoingRequestRequest, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.amount !== "") {
      writer.uint32(10).string(message.amount);
    }
    if (message.feeLimit !== "") {
      writer.uint32(18).string(message.feeLimit);
    }
    if (message.fromWalletId !== 0) {
      writer.uint32(24).uint64(message.fromWalletId);
    }
    if (message.fromAddressId !== 0) {
      writer.uint32(32).uint64(message.fromAddressId);
    }
    if (message.toAddressId !== 0) {
      writer.uint32(40).uint64(message.toAddressId);
    }
    if (message.toWhitelistedAddressId !== 0) {
      writer.uint32(48).uint64(message.toWhitelistedAddressId);
    }
    if (message.gasLimit !== "") {
      writer.uint32(58).string(message.gasLimit);
    }
    if (message.comment !== "") {
      writer.uint32(66).string(message.comment);
    }
    if (message.useUnconfirmedFunds !== false) {
      writer.uint32(72).bool(message.useUnconfirmedFunds);
    }
    if (message.feePaidByReceiver !== false) {
      writer.uint32(80).bool(message.feePaidByReceiver);
    }
    if (message.transactionComment !== "") {
      writer.uint32(90).string(message.transactionComment);
    }
    if (message.useAllFunds !== false) {
      writer.uint32(96).bool(message.useAllFunds);
    }
    if (message.feePayerId !== 0) {
      writer.uint32(104).uint64(message.feePayerId);
    }
    if (message.extendedAmount !== undefined) {
      ExtendedAmount.encode(message.extendedAmount, writer.uint32(114).fork()).ldelim();
    }
    if (message.transactionReference !== "") {
      writer.uint32(122).string(message.transactionReference);
    }
    if (message.externalRequestId !== "") {
      writer.uint32(130).string(message.externalRequestId);
    }
    if (message.destinationAddressMemo !== "") {
      writer.uint32(138).string(message.destinationAddressMemo);
    }
    if (message.opts !== undefined) {
      BlockchainOpts.encode(message.opts, writer.uint32(146).fork()).ldelim();
    }
    if (message.travelRuleDataInput !== undefined) {
      TravelRuleDataInput.encode(message.travelRuleDataInput, writer.uint32(154).fork()).ldelim();
    }
    if (message.feePayerAddressId !== 0) {
      writer.uint32(160).uint64(message.feePayerAddressId);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CreateOutgoingRequestRequest {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCreateOutgoingRequestRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.amount = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.feeLimit = reader.string();
          continue;
        case 3:
          if (tag !== 24) {
            break;
          }

          message.fromWalletId = longToNumber(reader.uint64() as Long);
          continue;
        case 4:
          if (tag !== 32) {
            break;
          }

          message.fromAddressId = longToNumber(reader.uint64() as Long);
          continue;
        case 5:
          if (tag !== 40) {
            break;
          }

          message.toAddressId = longToNumber(reader.uint64() as Long);
          continue;
        case 6:
          if (tag !== 48) {
            break;
          }

          message.toWhitelistedAddressId = longToNumber(reader.uint64() as Long);
          continue;
        case 7:
          if (tag !== 58) {
            break;
          }

          message.gasLimit = reader.string();
          continue;
        case 8:
          if (tag !== 66) {
            break;
          }

          message.comment = reader.string();
          continue;
        case 9:
          if (tag !== 72) {
            break;
          }

          message.useUnconfirmedFunds = reader.bool();
          continue;
        case 10:
          if (tag !== 80) {
            break;
          }

          message.feePaidByReceiver = reader.bool();
          continue;
        case 11:
          if (tag !== 90) {
            break;
          }

          message.transactionComment = reader.string();
          continue;
        case 12:
          if (tag !== 96) {
            break;
          }

          message.useAllFunds = reader.bool();
          continue;
        case 13:
          if (tag !== 104) {
            break;
          }

          message.feePayerId = longToNumber(reader.uint64() as Long);
          continue;
        case 14:
          if (tag !== 114) {
            break;
          }

          message.extendedAmount = ExtendedAmount.decode(reader, reader.uint32());
          continue;
        case 15:
          if (tag !== 122) {
            break;
          }

          message.transactionReference = reader.string();
          continue;
        case 16:
          if (tag !== 130) {
            break;
          }

          message.externalRequestId = reader.string();
          continue;
        case 17:
          if (tag !== 138) {
            break;
          }

          message.destinationAddressMemo = reader.string();
          continue;
        case 18:
          if (tag !== 146) {
            break;
          }

          message.opts = BlockchainOpts.decode(reader, reader.uint32());
          continue;
        case 19:
          if (tag !== 154) {
            break;
          }

          message.travelRuleDataInput = TravelRuleDataInput.decode(reader, reader.uint32());
          continue;
        case 20:
          if (tag !== 160) {
            break;
          }

          message.feePayerAddressId = longToNumber(reader.uint64() as Long);
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CreateOutgoingRequestRequest {
    return {
      amount: isSet(object.amount) ? globalThis.String(object.amount) : "",
      feeLimit: isSet(object.feeLimit) ? globalThis.String(object.feeLimit) : "",
      fromWalletId: isSet(object.fromWalletId) ? globalThis.Number(object.fromWalletId) : 0,
      fromAddressId: isSet(object.fromAddressId) ? globalThis.Number(object.fromAddressId) : 0,
      toAddressId: isSet(object.toAddressId) ? globalThis.Number(object.toAddressId) : 0,
      toWhitelistedAddressId: isSet(object.toWhitelistedAddressId)
        ? globalThis.Number(object.toWhitelistedAddressId)
        : 0,
      gasLimit: isSet(object.gasLimit) ? globalThis.String(object.gasLimit) : "",
      comment: isSet(object.comment) ? globalThis.String(object.comment) : "",
      useUnconfirmedFunds: isSet(object.useUnconfirmedFunds) ? globalThis.Boolean(object.useUnconfirmedFunds) : false,
      feePaidByReceiver: isSet(object.feePaidByReceiver) ? globalThis.Boolean(object.feePaidByReceiver) : false,
      transactionComment: isSet(object.transactionComment) ? globalThis.String(object.transactionComment) : "",
      useAllFunds: isSet(object.useAllFunds) ? globalThis.Boolean(object.useAllFunds) : false,
      feePayerId: isSet(object.feePayerId) ? globalThis.Number(object.feePayerId) : 0,
      extendedAmount: isSet(object.extendedAmount) ? ExtendedAmount.fromJSON(object.extendedAmount) : undefined,
      transactionReference: isSet(object.transactionReference) ? globalThis.String(object.transactionReference) : "",
      externalRequestId: isSet(object.externalRequestId) ? globalThis.String(object.externalRequestId) : "",
      destinationAddressMemo: isSet(object.destinationAddressMemo)
        ? globalThis.String(object.destinationAddressMemo)
        : "",
      opts: isSet(object.opts) ? BlockchainOpts.fromJSON(object.opts) : undefined,
      travelRuleDataInput: isSet(object.travelRuleDataInput)
        ? TravelRuleDataInput.fromJSON(object.travelRuleDataInput)
        : undefined,
      feePayerAddressId: isSet(object.feePayerAddressId) ? globalThis.Number(object.feePayerAddressId) : 0,
    };
  },

  toJSON(message: CreateOutgoingRequestRequest): unknown {
    const obj: any = {};
    if (message.amount !== "") {
      obj.amount = message.amount;
    }
    if (message.feeLimit !== "") {
      obj.feeLimit = message.feeLimit;
    }
    if (message.fromWalletId !== 0) {
      obj.fromWalletId = Math.round(message.fromWalletId);
    }
    if (message.fromAddressId !== 0) {
      obj.fromAddressId = Math.round(message.fromAddressId);
    }
    if (message.toAddressId !== 0) {
      obj.toAddressId = Math.round(message.toAddressId);
    }
    if (message.toWhitelistedAddressId !== 0) {
      obj.toWhitelistedAddressId = Math.round(message.toWhitelistedAddressId);
    }
    if (message.gasLimit !== "") {
      obj.gasLimit = message.gasLimit;
    }
    if (message.comment !== "") {
      obj.comment = message.comment;
    }
    if (message.useUnconfirmedFunds !== false) {
      obj.useUnconfirmedFunds = message.useUnconfirmedFunds;
    }
    if (message.feePaidByReceiver !== false) {
      obj.feePaidByReceiver = message.feePaidByReceiver;
    }
    if (message.transactionComment !== "") {
      obj.transactionComment = message.transactionComment;
    }
    if (message.useAllFunds !== false) {
      obj.useAllFunds = message.useAllFunds;
    }
    if (message.feePayerId !== 0) {
      obj.feePayerId = Math.round(message.feePayerId);
    }
    if (message.extendedAmount !== undefined) {
      obj.extendedAmount = ExtendedAmount.toJSON(message.extendedAmount);
    }
    if (message.transactionReference !== "") {
      obj.transactionReference = message.transactionReference;
    }
    if (message.externalRequestId !== "") {
      obj.externalRequestId = message.externalRequestId;
    }
    if (message.destinationAddressMemo !== "") {
      obj.destinationAddressMemo = message.destinationAddressMemo;
    }
    if (message.opts !== undefined) {
      obj.opts = BlockchainOpts.toJSON(message.opts);
    }
    if (message.travelRuleDataInput !== undefined) {
      obj.travelRuleDataInput = TravelRuleDataInput.toJSON(message.travelRuleDataInput);
    }
    if (message.feePayerAddressId !== 0) {
      obj.feePayerAddressId = Math.round(message.feePayerAddressId);
    }
    return obj;
  },

  create(base?: DeepPartial<CreateOutgoingRequestRequest>): CreateOutgoingRequestRequest {
    return CreateOutgoingRequestRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CreateOutgoingRequestRequest>): CreateOutgoingRequestRequest {
    const message = createBaseCreateOutgoingRequestRequest();
    message.amount = object.amount ?? "";
    message.feeLimit = object.feeLimit ?? "";
    message.fromWalletId = object.fromWalletId ?? 0;
    message.fromAddressId = object.fromAddressId ?? 0;
    message.toAddressId = object.toAddressId ?? 0;
    message.toWhitelistedAddressId = object.toWhitelistedAddressId ?? 0;
    message.gasLimit = object.gasLimit ?? "";
    message.comment = object.comment ?? "";
    message.useUnconfirmedFunds = object.useUnconfirmedFunds ?? false;
    message.feePaidByReceiver = object.feePaidByReceiver ?? false;
    message.transactionComment = object.transactionComment ?? "";
    message.useAllFunds = object.useAllFunds ?? false;
    message.feePayerId = object.feePayerId ?? 0;
    message.extendedAmount = (object.extendedAmount !== undefined && object.extendedAmount !== null)
      ? ExtendedAmount.fromPartial(object.extendedAmount)
      : undefined;
    message.transactionReference = object.transactionReference ?? "";
    message.externalRequestId = object.externalRequestId ?? "";
    message.destinationAddressMemo = object.destinationAddressMemo ?? "";
    message.opts = (object.opts !== undefined && object.opts !== null)
      ? BlockchainOpts.fromPartial(object.opts)
      : undefined;
    message.travelRuleDataInput = (object.travelRuleDataInput !== undefined && object.travelRuleDataInput !== null)
      ? TravelRuleDataInput.fromPartial(object.travelRuleDataInput)
      : undefined;
    message.feePayerAddressId = object.feePayerAddressId ?? 0;
    return message;
  },
};

function createBaseCreateAddressToAddressTransferOutgoingRequestRequest(): CreateAddressToAddressTransferOutgoingRequestRequest {
  return {
    amount: "",
    currency: "",
    fromAddress: "",
    toAddress: "",
    feeLimit: "",
    gasLimit: "",
    comment: "",
    useUnconfirmedFunds: false,
    feePaidByReceiver: false,
    transactionComment: "",
    useAllFunds: false,
    feePayerId: 0,
    extendedAmount: undefined,
    transactionReference: "",
    externalRequestId: "",
    destinationAddressMemo: "",
    opts: undefined,
  };
}

export const CreateAddressToAddressTransferOutgoingRequestRequest = {
  encode(
    message: CreateAddressToAddressTransferOutgoingRequestRequest,
    writer: _m0.Writer = _m0.Writer.create(),
  ): _m0.Writer {
    if (message.amount !== "") {
      writer.uint32(10).string(message.amount);
    }
    if (message.currency !== "") {
      writer.uint32(18).string(message.currency);
    }
    if (message.fromAddress !== "") {
      writer.uint32(26).string(message.fromAddress);
    }
    if (message.toAddress !== "") {
      writer.uint32(34).string(message.toAddress);
    }
    if (message.feeLimit !== "") {
      writer.uint32(42).string(message.feeLimit);
    }
    if (message.gasLimit !== "") {
      writer.uint32(50).string(message.gasLimit);
    }
    if (message.comment !== "") {
      writer.uint32(58).string(message.comment);
    }
    if (message.useUnconfirmedFunds !== false) {
      writer.uint32(64).bool(message.useUnconfirmedFunds);
    }
    if (message.feePaidByReceiver !== false) {
      writer.uint32(72).bool(message.feePaidByReceiver);
    }
    if (message.transactionComment !== "") {
      writer.uint32(82).string(message.transactionComment);
    }
    if (message.useAllFunds !== false) {
      writer.uint32(88).bool(message.useAllFunds);
    }
    if (message.feePayerId !== 0) {
      writer.uint32(96).uint64(message.feePayerId);
    }
    if (message.extendedAmount !== undefined) {
      ExtendedAmount.encode(message.extendedAmount, writer.uint32(114).fork()).ldelim();
    }
    if (message.transactionReference !== "") {
      writer.uint32(122).string(message.transactionReference);
    }
    if (message.externalRequestId !== "") {
      writer.uint32(130).string(message.externalRequestId);
    }
    if (message.destinationAddressMemo !== "") {
      writer.uint32(138).string(message.destinationAddressMemo);
    }
    if (message.opts !== undefined) {
      BlockchainOpts.encode(message.opts, writer.uint32(146).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CreateAddressToAddressTransferOutgoingRequestRequest {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCreateAddressToAddressTransferOutgoingRequestRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.amount = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.currency = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.fromAddress = reader.string();
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.toAddress = reader.string();
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.feeLimit = reader.string();
          continue;
        case 6:
          if (tag !== 50) {
            break;
          }

          message.gasLimit = reader.string();
          continue;
        case 7:
          if (tag !== 58) {
            break;
          }

          message.comment = reader.string();
          continue;
        case 8:
          if (tag !== 64) {
            break;
          }

          message.useUnconfirmedFunds = reader.bool();
          continue;
        case 9:
          if (tag !== 72) {
            break;
          }

          message.feePaidByReceiver = reader.bool();
          continue;
        case 10:
          if (tag !== 82) {
            break;
          }

          message.transactionComment = reader.string();
          continue;
        case 11:
          if (tag !== 88) {
            break;
          }

          message.useAllFunds = reader.bool();
          continue;
        case 12:
          if (tag !== 96) {
            break;
          }

          message.feePayerId = longToNumber(reader.uint64() as Long);
          continue;
        case 14:
          if (tag !== 114) {
            break;
          }

          message.extendedAmount = ExtendedAmount.decode(reader, reader.uint32());
          continue;
        case 15:
          if (tag !== 122) {
            break;
          }

          message.transactionReference = reader.string();
          continue;
        case 16:
          if (tag !== 130) {
            break;
          }

          message.externalRequestId = reader.string();
          continue;
        case 17:
          if (tag !== 138) {
            break;
          }

          message.destinationAddressMemo = reader.string();
          continue;
        case 18:
          if (tag !== 146) {
            break;
          }

          message.opts = BlockchainOpts.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CreateAddressToAddressTransferOutgoingRequestRequest {
    return {
      amount: isSet(object.amount) ? globalThis.String(object.amount) : "",
      currency: isSet(object.currency) ? globalThis.String(object.currency) : "",
      fromAddress: isSet(object.fromAddress) ? globalThis.String(object.fromAddress) : "",
      toAddress: isSet(object.toAddress) ? globalThis.String(object.toAddress) : "",
      feeLimit: isSet(object.feeLimit) ? globalThis.String(object.feeLimit) : "",
      gasLimit: isSet(object.gasLimit) ? globalThis.String(object.gasLimit) : "",
      comment: isSet(object.comment) ? globalThis.String(object.comment) : "",
      useUnconfirmedFunds: isSet(object.useUnconfirmedFunds) ? globalThis.Boolean(object.useUnconfirmedFunds) : false,
      feePaidByReceiver: isSet(object.feePaidByReceiver) ? globalThis.Boolean(object.feePaidByReceiver) : false,
      transactionComment: isSet(object.transactionComment) ? globalThis.String(object.transactionComment) : "",
      useAllFunds: isSet(object.useAllFunds) ? globalThis.Boolean(object.useAllFunds) : false,
      feePayerId: isSet(object.feePayerId) ? globalThis.Number(object.feePayerId) : 0,
      extendedAmount: isSet(object.extendedAmount) ? ExtendedAmount.fromJSON(object.extendedAmount) : undefined,
      transactionReference: isSet(object.transactionReference) ? globalThis.String(object.transactionReference) : "",
      externalRequestId: isSet(object.externalRequestId) ? globalThis.String(object.externalRequestId) : "",
      destinationAddressMemo: isSet(object.destinationAddressMemo)
        ? globalThis.String(object.destinationAddressMemo)
        : "",
      opts: isSet(object.opts) ? BlockchainOpts.fromJSON(object.opts) : undefined,
    };
  },

  toJSON(message: CreateAddressToAddressTransferOutgoingRequestRequest): unknown {
    const obj: any = {};
    if (message.amount !== "") {
      obj.amount = message.amount;
    }
    if (message.currency !== "") {
      obj.currency = message.currency;
    }
    if (message.fromAddress !== "") {
      obj.fromAddress = message.fromAddress;
    }
    if (message.toAddress !== "") {
      obj.toAddress = message.toAddress;
    }
    if (message.feeLimit !== "") {
      obj.feeLimit = message.feeLimit;
    }
    if (message.gasLimit !== "") {
      obj.gasLimit = message.gasLimit;
    }
    if (message.comment !== "") {
      obj.comment = message.comment;
    }
    if (message.useUnconfirmedFunds !== false) {
      obj.useUnconfirmedFunds = message.useUnconfirmedFunds;
    }
    if (message.feePaidByReceiver !== false) {
      obj.feePaidByReceiver = message.feePaidByReceiver;
    }
    if (message.transactionComment !== "") {
      obj.transactionComment = message.transactionComment;
    }
    if (message.useAllFunds !== false) {
      obj.useAllFunds = message.useAllFunds;
    }
    if (message.feePayerId !== 0) {
      obj.feePayerId = Math.round(message.feePayerId);
    }
    if (message.extendedAmount !== undefined) {
      obj.extendedAmount = ExtendedAmount.toJSON(message.extendedAmount);
    }
    if (message.transactionReference !== "") {
      obj.transactionReference = message.transactionReference;
    }
    if (message.externalRequestId !== "") {
      obj.externalRequestId = message.externalRequestId;
    }
    if (message.destinationAddressMemo !== "") {
      obj.destinationAddressMemo = message.destinationAddressMemo;
    }
    if (message.opts !== undefined) {
      obj.opts = BlockchainOpts.toJSON(message.opts);
    }
    return obj;
  },

  create(
    base?: DeepPartial<CreateAddressToAddressTransferOutgoingRequestRequest>,
  ): CreateAddressToAddressTransferOutgoingRequestRequest {
    return CreateAddressToAddressTransferOutgoingRequestRequest.fromPartial(base ?? {});
  },
  fromPartial(
    object: DeepPartial<CreateAddressToAddressTransferOutgoingRequestRequest>,
  ): CreateAddressToAddressTransferOutgoingRequestRequest {
    const message = createBaseCreateAddressToAddressTransferOutgoingRequestRequest();
    message.amount = object.amount ?? "";
    message.currency = object.currency ?? "";
    message.fromAddress = object.fromAddress ?? "";
    message.toAddress = object.toAddress ?? "";
    message.feeLimit = object.feeLimit ?? "";
    message.gasLimit = object.gasLimit ?? "";
    message.comment = object.comment ?? "";
    message.useUnconfirmedFunds = object.useUnconfirmedFunds ?? false;
    message.feePaidByReceiver = object.feePaidByReceiver ?? false;
    message.transactionComment = object.transactionComment ?? "";
    message.useAllFunds = object.useAllFunds ?? false;
    message.feePayerId = object.feePayerId ?? 0;
    message.extendedAmount = (object.extendedAmount !== undefined && object.extendedAmount !== null)
      ? ExtendedAmount.fromPartial(object.extendedAmount)
      : undefined;
    message.transactionReference = object.transactionReference ?? "";
    message.externalRequestId = object.externalRequestId ?? "";
    message.destinationAddressMemo = object.destinationAddressMemo ?? "";
    message.opts = (object.opts !== undefined && object.opts !== null)
      ? BlockchainOpts.fromPartial(object.opts)
      : undefined;
    return message;
  },
};

function createBaseCreateOutgoingADADelegateRequestRequest(): CreateOutgoingADADelegateRequestRequest {
  return {
    fromAddressId: 0,
    toStakePoolAddressId: 0,
    feeLimit: "",
    comment: "",
    useUnconfirmedFunds: false,
    transactionReference: "",
    stakePoolRegistrationCertificate: new Uint8Array(0),
    stakePoolRegistrationDeposit: false,
    externalRequestId: "",
    drep: "",
  };
}

export const CreateOutgoingADADelegateRequestRequest = {
  encode(message: CreateOutgoingADADelegateRequestRequest, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.fromAddressId !== 0) {
      writer.uint32(8).uint64(message.fromAddressId);
    }
    if (message.toStakePoolAddressId !== 0) {
      writer.uint32(16).uint64(message.toStakePoolAddressId);
    }
    if (message.feeLimit !== "") {
      writer.uint32(26).string(message.feeLimit);
    }
    if (message.comment !== "") {
      writer.uint32(34).string(message.comment);
    }
    if (message.useUnconfirmedFunds !== false) {
      writer.uint32(40).bool(message.useUnconfirmedFunds);
    }
    if (message.transactionReference !== "") {
      writer.uint32(50).string(message.transactionReference);
    }
    if (message.stakePoolRegistrationCertificate.length !== 0) {
      writer.uint32(58).bytes(message.stakePoolRegistrationCertificate);
    }
    if (message.stakePoolRegistrationDeposit !== false) {
      writer.uint32(64).bool(message.stakePoolRegistrationDeposit);
    }
    if (message.externalRequestId !== "") {
      writer.uint32(74).string(message.externalRequestId);
    }
    if (message.drep !== "") {
      writer.uint32(82).string(message.drep);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CreateOutgoingADADelegateRequestRequest {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCreateOutgoingADADelegateRequestRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.fromAddressId = longToNumber(reader.uint64() as Long);
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.toStakePoolAddressId = longToNumber(reader.uint64() as Long);
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.feeLimit = reader.string();
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.comment = reader.string();
          continue;
        case 5:
          if (tag !== 40) {
            break;
          }

          message.useUnconfirmedFunds = reader.bool();
          continue;
        case 6:
          if (tag !== 50) {
            break;
          }

          message.transactionReference = reader.string();
          continue;
        case 7:
          if (tag !== 58) {
            break;
          }

          message.stakePoolRegistrationCertificate = reader.bytes();
          continue;
        case 8:
          if (tag !== 64) {
            break;
          }

          message.stakePoolRegistrationDeposit = reader.bool();
          continue;
        case 9:
          if (tag !== 74) {
            break;
          }

          message.externalRequestId = reader.string();
          continue;
        case 10:
          if (tag !== 82) {
            break;
          }

          message.drep = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CreateOutgoingADADelegateRequestRequest {
    return {
      fromAddressId: isSet(object.fromAddressId) ? globalThis.Number(object.fromAddressId) : 0,
      toStakePoolAddressId: isSet(object.toStakePoolAddressId) ? globalThis.Number(object.toStakePoolAddressId) : 0,
      feeLimit: isSet(object.feeLimit) ? globalThis.String(object.feeLimit) : "",
      comment: isSet(object.comment) ? globalThis.String(object.comment) : "",
      useUnconfirmedFunds: isSet(object.useUnconfirmedFunds) ? globalThis.Boolean(object.useUnconfirmedFunds) : false,
      transactionReference: isSet(object.transactionReference) ? globalThis.String(object.transactionReference) : "",
      stakePoolRegistrationCertificate: isSet(object.stakePoolRegistrationCertificate)
        ? bytesFromBase64(object.stakePoolRegistrationCertificate)
        : new Uint8Array(0),
      stakePoolRegistrationDeposit: isSet(object.stakePoolRegistrationDeposit)
        ? globalThis.Boolean(object.stakePoolRegistrationDeposit)
        : false,
      externalRequestId: isSet(object.externalRequestId) ? globalThis.String(object.externalRequestId) : "",
      drep: isSet(object.drep) ? globalThis.String(object.drep) : "",
    };
  },

  toJSON(message: CreateOutgoingADADelegateRequestRequest): unknown {
    const obj: any = {};
    if (message.fromAddressId !== 0) {
      obj.fromAddressId = Math.round(message.fromAddressId);
    }
    if (message.toStakePoolAddressId !== 0) {
      obj.toStakePoolAddressId = Math.round(message.toStakePoolAddressId);
    }
    if (message.feeLimit !== "") {
      obj.feeLimit = message.feeLimit;
    }
    if (message.comment !== "") {
      obj.comment = message.comment;
    }
    if (message.useUnconfirmedFunds !== false) {
      obj.useUnconfirmedFunds = message.useUnconfirmedFunds;
    }
    if (message.transactionReference !== "") {
      obj.transactionReference = message.transactionReference;
    }
    if (message.stakePoolRegistrationCertificate.length !== 0) {
      obj.stakePoolRegistrationCertificate = base64FromBytes(message.stakePoolRegistrationCertificate);
    }
    if (message.stakePoolRegistrationDeposit !== false) {
      obj.stakePoolRegistrationDeposit = message.stakePoolRegistrationDeposit;
    }
    if (message.externalRequestId !== "") {
      obj.externalRequestId = message.externalRequestId;
    }
    if (message.drep !== "") {
      obj.drep = message.drep;
    }
    return obj;
  },

  create(base?: DeepPartial<CreateOutgoingADADelegateRequestRequest>): CreateOutgoingADADelegateRequestRequest {
    return CreateOutgoingADADelegateRequestRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CreateOutgoingADADelegateRequestRequest>): CreateOutgoingADADelegateRequestRequest {
    const message = createBaseCreateOutgoingADADelegateRequestRequest();
    message.fromAddressId = object.fromAddressId ?? 0;
    message.toStakePoolAddressId = object.toStakePoolAddressId ?? 0;
    message.feeLimit = object.feeLimit ?? "";
    message.comment = object.comment ?? "";
    message.useUnconfirmedFunds = object.useUnconfirmedFunds ?? false;
    message.transactionReference = object.transactionReference ?? "";
    message.stakePoolRegistrationCertificate = object.stakePoolRegistrationCertificate ?? new Uint8Array(0);
    message.stakePoolRegistrationDeposit = object.stakePoolRegistrationDeposit ?? false;
    message.externalRequestId = object.externalRequestId ?? "";
    message.drep = object.drep ?? "";
    return message;
  },
};

function createBaseCreateOutgoingADAUndelegateRequestRequest(): CreateOutgoingADAUndelegateRequestRequest {
  return {
    fromAddressId: 0,
    feeLimit: "",
    comment: "",
    useUnconfirmedFunds: false,
    transactionReference: "",
    externalRequestId: "",
  };
}

export const CreateOutgoingADAUndelegateRequestRequest = {
  encode(message: CreateOutgoingADAUndelegateRequestRequest, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.fromAddressId !== 0) {
      writer.uint32(8).uint64(message.fromAddressId);
    }
    if (message.feeLimit !== "") {
      writer.uint32(18).string(message.feeLimit);
    }
    if (message.comment !== "") {
      writer.uint32(26).string(message.comment);
    }
    if (message.useUnconfirmedFunds !== false) {
      writer.uint32(32).bool(message.useUnconfirmedFunds);
    }
    if (message.transactionReference !== "") {
      writer.uint32(42).string(message.transactionReference);
    }
    if (message.externalRequestId !== "") {
      writer.uint32(50).string(message.externalRequestId);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CreateOutgoingADAUndelegateRequestRequest {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCreateOutgoingADAUndelegateRequestRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.fromAddressId = longToNumber(reader.uint64() as Long);
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.feeLimit = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.comment = reader.string();
          continue;
        case 4:
          if (tag !== 32) {
            break;
          }

          message.useUnconfirmedFunds = reader.bool();
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.transactionReference = reader.string();
          continue;
        case 6:
          if (tag !== 50) {
            break;
          }

          message.externalRequestId = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CreateOutgoingADAUndelegateRequestRequest {
    return {
      fromAddressId: isSet(object.fromAddressId) ? globalThis.Number(object.fromAddressId) : 0,
      feeLimit: isSet(object.feeLimit) ? globalThis.String(object.feeLimit) : "",
      comment: isSet(object.comment) ? globalThis.String(object.comment) : "",
      useUnconfirmedFunds: isSet(object.useUnconfirmedFunds) ? globalThis.Boolean(object.useUnconfirmedFunds) : false,
      transactionReference: isSet(object.transactionReference) ? globalThis.String(object.transactionReference) : "",
      externalRequestId: isSet(object.externalRequestId) ? globalThis.String(object.externalRequestId) : "",
    };
  },

  toJSON(message: CreateOutgoingADAUndelegateRequestRequest): unknown {
    const obj: any = {};
    if (message.fromAddressId !== 0) {
      obj.fromAddressId = Math.round(message.fromAddressId);
    }
    if (message.feeLimit !== "") {
      obj.feeLimit = message.feeLimit;
    }
    if (message.comment !== "") {
      obj.comment = message.comment;
    }
    if (message.useUnconfirmedFunds !== false) {
      obj.useUnconfirmedFunds = message.useUnconfirmedFunds;
    }
    if (message.transactionReference !== "") {
      obj.transactionReference = message.transactionReference;
    }
    if (message.externalRequestId !== "") {
      obj.externalRequestId = message.externalRequestId;
    }
    return obj;
  },

  create(base?: DeepPartial<CreateOutgoingADAUndelegateRequestRequest>): CreateOutgoingADAUndelegateRequestRequest {
    return CreateOutgoingADAUndelegateRequestRequest.fromPartial(base ?? {});
  },
  fromPartial(
    object: DeepPartial<CreateOutgoingADAUndelegateRequestRequest>,
  ): CreateOutgoingADAUndelegateRequestRequest {
    const message = createBaseCreateOutgoingADAUndelegateRequestRequest();
    message.fromAddressId = object.fromAddressId ?? 0;
    message.feeLimit = object.feeLimit ?? "";
    message.comment = object.comment ?? "";
    message.useUnconfirmedFunds = object.useUnconfirmedFunds ?? false;
    message.transactionReference = object.transactionReference ?? "";
    message.externalRequestId = object.externalRequestId ?? "";
    return message;
  },
};

function createBaseCreateOutgoingADAVoteDelegateRequestRequest(): CreateOutgoingADAVoteDelegateRequestRequest {
  return { fromAddressId: 0, feeLimit: "", comment: "", useUnconfirmedFunds: false, externalRequestId: "", drep: "" };
}

export const CreateOutgoingADAVoteDelegateRequestRequest = {
  encode(message: CreateOutgoingADAVoteDelegateRequestRequest, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.fromAddressId !== 0) {
      writer.uint32(8).uint64(message.fromAddressId);
    }
    if (message.feeLimit !== "") {
      writer.uint32(18).string(message.feeLimit);
    }
    if (message.comment !== "") {
      writer.uint32(26).string(message.comment);
    }
    if (message.useUnconfirmedFunds !== false) {
      writer.uint32(32).bool(message.useUnconfirmedFunds);
    }
    if (message.externalRequestId !== "") {
      writer.uint32(42).string(message.externalRequestId);
    }
    if (message.drep !== "") {
      writer.uint32(50).string(message.drep);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CreateOutgoingADAVoteDelegateRequestRequest {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCreateOutgoingADAVoteDelegateRequestRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.fromAddressId = longToNumber(reader.uint64() as Long);
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.feeLimit = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.comment = reader.string();
          continue;
        case 4:
          if (tag !== 32) {
            break;
          }

          message.useUnconfirmedFunds = reader.bool();
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.externalRequestId = reader.string();
          continue;
        case 6:
          if (tag !== 50) {
            break;
          }

          message.drep = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CreateOutgoingADAVoteDelegateRequestRequest {
    return {
      fromAddressId: isSet(object.fromAddressId) ? globalThis.Number(object.fromAddressId) : 0,
      feeLimit: isSet(object.feeLimit) ? globalThis.String(object.feeLimit) : "",
      comment: isSet(object.comment) ? globalThis.String(object.comment) : "",
      useUnconfirmedFunds: isSet(object.useUnconfirmedFunds) ? globalThis.Boolean(object.useUnconfirmedFunds) : false,
      externalRequestId: isSet(object.externalRequestId) ? globalThis.String(object.externalRequestId) : "",
      drep: isSet(object.drep) ? globalThis.String(object.drep) : "",
    };
  },

  toJSON(message: CreateOutgoingADAVoteDelegateRequestRequest): unknown {
    const obj: any = {};
    if (message.fromAddressId !== 0) {
      obj.fromAddressId = Math.round(message.fromAddressId);
    }
    if (message.feeLimit !== "") {
      obj.feeLimit = message.feeLimit;
    }
    if (message.comment !== "") {
      obj.comment = message.comment;
    }
    if (message.useUnconfirmedFunds !== false) {
      obj.useUnconfirmedFunds = message.useUnconfirmedFunds;
    }
    if (message.externalRequestId !== "") {
      obj.externalRequestId = message.externalRequestId;
    }
    if (message.drep !== "") {
      obj.drep = message.drep;
    }
    return obj;
  },

  create(base?: DeepPartial<CreateOutgoingADAVoteDelegateRequestRequest>): CreateOutgoingADAVoteDelegateRequestRequest {
    return CreateOutgoingADAVoteDelegateRequestRequest.fromPartial(base ?? {});
  },
  fromPartial(
    object: DeepPartial<CreateOutgoingADAVoteDelegateRequestRequest>,
  ): CreateOutgoingADAVoteDelegateRequestRequest {
    const message = createBaseCreateOutgoingADAVoteDelegateRequestRequest();
    message.fromAddressId = object.fromAddressId ?? 0;
    message.feeLimit = object.feeLimit ?? "";
    message.comment = object.comment ?? "";
    message.useUnconfirmedFunds = object.useUnconfirmedFunds ?? false;
    message.externalRequestId = object.externalRequestId ?? "";
    message.drep = object.drep ?? "";
    return message;
  },
};

function createBaseCreateOutgoingADAWithdrawalRequestRequest(): CreateOutgoingADAWithdrawalRequestRequest {
  return {
    fromAddressId: 0,
    feeLimit: "",
    comment: "",
    useUnconfirmedFunds: false,
    transactionReference: "",
    externalRequestId: "",
  };
}

export const CreateOutgoingADAWithdrawalRequestRequest = {
  encode(message: CreateOutgoingADAWithdrawalRequestRequest, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.fromAddressId !== 0) {
      writer.uint32(8).uint64(message.fromAddressId);
    }
    if (message.feeLimit !== "") {
      writer.uint32(18).string(message.feeLimit);
    }
    if (message.comment !== "") {
      writer.uint32(26).string(message.comment);
    }
    if (message.useUnconfirmedFunds !== false) {
      writer.uint32(32).bool(message.useUnconfirmedFunds);
    }
    if (message.transactionReference !== "") {
      writer.uint32(42).string(message.transactionReference);
    }
    if (message.externalRequestId !== "") {
      writer.uint32(50).string(message.externalRequestId);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CreateOutgoingADAWithdrawalRequestRequest {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCreateOutgoingADAWithdrawalRequestRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.fromAddressId = longToNumber(reader.uint64() as Long);
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.feeLimit = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.comment = reader.string();
          continue;
        case 4:
          if (tag !== 32) {
            break;
          }

          message.useUnconfirmedFunds = reader.bool();
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.transactionReference = reader.string();
          continue;
        case 6:
          if (tag !== 50) {
            break;
          }

          message.externalRequestId = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CreateOutgoingADAWithdrawalRequestRequest {
    return {
      fromAddressId: isSet(object.fromAddressId) ? globalThis.Number(object.fromAddressId) : 0,
      feeLimit: isSet(object.feeLimit) ? globalThis.String(object.feeLimit) : "",
      comment: isSet(object.comment) ? globalThis.String(object.comment) : "",
      useUnconfirmedFunds: isSet(object.useUnconfirmedFunds) ? globalThis.Boolean(object.useUnconfirmedFunds) : false,
      transactionReference: isSet(object.transactionReference) ? globalThis.String(object.transactionReference) : "",
      externalRequestId: isSet(object.externalRequestId) ? globalThis.String(object.externalRequestId) : "",
    };
  },

  toJSON(message: CreateOutgoingADAWithdrawalRequestRequest): unknown {
    const obj: any = {};
    if (message.fromAddressId !== 0) {
      obj.fromAddressId = Math.round(message.fromAddressId);
    }
    if (message.feeLimit !== "") {
      obj.feeLimit = message.feeLimit;
    }
    if (message.comment !== "") {
      obj.comment = message.comment;
    }
    if (message.useUnconfirmedFunds !== false) {
      obj.useUnconfirmedFunds = message.useUnconfirmedFunds;
    }
    if (message.transactionReference !== "") {
      obj.transactionReference = message.transactionReference;
    }
    if (message.externalRequestId !== "") {
      obj.externalRequestId = message.externalRequestId;
    }
    return obj;
  },

  create(base?: DeepPartial<CreateOutgoingADAWithdrawalRequestRequest>): CreateOutgoingADAWithdrawalRequestRequest {
    return CreateOutgoingADAWithdrawalRequestRequest.fromPartial(base ?? {});
  },
  fromPartial(
    object: DeepPartial<CreateOutgoingADAWithdrawalRequestRequest>,
  ): CreateOutgoingADAWithdrawalRequestRequest {
    const message = createBaseCreateOutgoingADAWithdrawalRequestRequest();
    message.fromAddressId = object.fromAddressId ?? 0;
    message.feeLimit = object.feeLimit ?? "";
    message.comment = object.comment ?? "";
    message.useUnconfirmedFunds = object.useUnconfirmedFunds ?? false;
    message.transactionReference = object.transactionReference ?? "";
    message.externalRequestId = object.externalRequestId ?? "";
    return message;
  },
};

function createBaseCreateOutgoingCosmosDelegateRequestRequest(): CreateOutgoingCosmosDelegateRequestRequest {
  return {
    fromAddressId: 0,
    toValidatorAddressId: 0,
    amount: "",
    feeLimit: "",
    gasLimit: "",
    comment: "",
    transactionReference: "",
    externalRequestId: "",
  };
}

export const CreateOutgoingCosmosDelegateRequestRequest = {
  encode(message: CreateOutgoingCosmosDelegateRequestRequest, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.fromAddressId !== 0) {
      writer.uint32(8).uint64(message.fromAddressId);
    }
    if (message.toValidatorAddressId !== 0) {
      writer.uint32(16).uint64(message.toValidatorAddressId);
    }
    if (message.amount !== "") {
      writer.uint32(26).string(message.amount);
    }
    if (message.feeLimit !== "") {
      writer.uint32(34).string(message.feeLimit);
    }
    if (message.gasLimit !== "") {
      writer.uint32(42).string(message.gasLimit);
    }
    if (message.comment !== "") {
      writer.uint32(50).string(message.comment);
    }
    if (message.transactionReference !== "") {
      writer.uint32(58).string(message.transactionReference);
    }
    if (message.externalRequestId !== "") {
      writer.uint32(66).string(message.externalRequestId);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CreateOutgoingCosmosDelegateRequestRequest {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCreateOutgoingCosmosDelegateRequestRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.fromAddressId = longToNumber(reader.uint64() as Long);
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.toValidatorAddressId = longToNumber(reader.uint64() as Long);
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.amount = reader.string();
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.feeLimit = reader.string();
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.gasLimit = reader.string();
          continue;
        case 6:
          if (tag !== 50) {
            break;
          }

          message.comment = reader.string();
          continue;
        case 7:
          if (tag !== 58) {
            break;
          }

          message.transactionReference = reader.string();
          continue;
        case 8:
          if (tag !== 66) {
            break;
          }

          message.externalRequestId = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CreateOutgoingCosmosDelegateRequestRequest {
    return {
      fromAddressId: isSet(object.fromAddressId) ? globalThis.Number(object.fromAddressId) : 0,
      toValidatorAddressId: isSet(object.toValidatorAddressId) ? globalThis.Number(object.toValidatorAddressId) : 0,
      amount: isSet(object.amount) ? globalThis.String(object.amount) : "",
      feeLimit: isSet(object.feeLimit) ? globalThis.String(object.feeLimit) : "",
      gasLimit: isSet(object.gasLimit) ? globalThis.String(object.gasLimit) : "",
      comment: isSet(object.comment) ? globalThis.String(object.comment) : "",
      transactionReference: isSet(object.transactionReference) ? globalThis.String(object.transactionReference) : "",
      externalRequestId: isSet(object.externalRequestId) ? globalThis.String(object.externalRequestId) : "",
    };
  },

  toJSON(message: CreateOutgoingCosmosDelegateRequestRequest): unknown {
    const obj: any = {};
    if (message.fromAddressId !== 0) {
      obj.fromAddressId = Math.round(message.fromAddressId);
    }
    if (message.toValidatorAddressId !== 0) {
      obj.toValidatorAddressId = Math.round(message.toValidatorAddressId);
    }
    if (message.amount !== "") {
      obj.amount = message.amount;
    }
    if (message.feeLimit !== "") {
      obj.feeLimit = message.feeLimit;
    }
    if (message.gasLimit !== "") {
      obj.gasLimit = message.gasLimit;
    }
    if (message.comment !== "") {
      obj.comment = message.comment;
    }
    if (message.transactionReference !== "") {
      obj.transactionReference = message.transactionReference;
    }
    if (message.externalRequestId !== "") {
      obj.externalRequestId = message.externalRequestId;
    }
    return obj;
  },

  create(base?: DeepPartial<CreateOutgoingCosmosDelegateRequestRequest>): CreateOutgoingCosmosDelegateRequestRequest {
    return CreateOutgoingCosmosDelegateRequestRequest.fromPartial(base ?? {});
  },
  fromPartial(
    object: DeepPartial<CreateOutgoingCosmosDelegateRequestRequest>,
  ): CreateOutgoingCosmosDelegateRequestRequest {
    const message = createBaseCreateOutgoingCosmosDelegateRequestRequest();
    message.fromAddressId = object.fromAddressId ?? 0;
    message.toValidatorAddressId = object.toValidatorAddressId ?? 0;
    message.amount = object.amount ?? "";
    message.feeLimit = object.feeLimit ?? "";
    message.gasLimit = object.gasLimit ?? "";
    message.comment = object.comment ?? "";
    message.transactionReference = object.transactionReference ?? "";
    message.externalRequestId = object.externalRequestId ?? "";
    return message;
  },
};

function createBaseCreateOutgoingCosmosUndelegateRequestRequest(): CreateOutgoingCosmosUndelegateRequestRequest {
  return {
    fromAddressId: 0,
    toValidatorAddressId: 0,
    amount: "",
    feeLimit: "",
    gasLimit: "",
    comment: "",
    transactionReference: "",
    externalRequestId: "",
  };
}

export const CreateOutgoingCosmosUndelegateRequestRequest = {
  encode(message: CreateOutgoingCosmosUndelegateRequestRequest, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.fromAddressId !== 0) {
      writer.uint32(8).uint64(message.fromAddressId);
    }
    if (message.toValidatorAddressId !== 0) {
      writer.uint32(16).uint64(message.toValidatorAddressId);
    }
    if (message.amount !== "") {
      writer.uint32(26).string(message.amount);
    }
    if (message.feeLimit !== "") {
      writer.uint32(34).string(message.feeLimit);
    }
    if (message.gasLimit !== "") {
      writer.uint32(42).string(message.gasLimit);
    }
    if (message.comment !== "") {
      writer.uint32(50).string(message.comment);
    }
    if (message.transactionReference !== "") {
      writer.uint32(58).string(message.transactionReference);
    }
    if (message.externalRequestId !== "") {
      writer.uint32(66).string(message.externalRequestId);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CreateOutgoingCosmosUndelegateRequestRequest {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCreateOutgoingCosmosUndelegateRequestRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.fromAddressId = longToNumber(reader.uint64() as Long);
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.toValidatorAddressId = longToNumber(reader.uint64() as Long);
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.amount = reader.string();
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.feeLimit = reader.string();
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.gasLimit = reader.string();
          continue;
        case 6:
          if (tag !== 50) {
            break;
          }

          message.comment = reader.string();
          continue;
        case 7:
          if (tag !== 58) {
            break;
          }

          message.transactionReference = reader.string();
          continue;
        case 8:
          if (tag !== 66) {
            break;
          }

          message.externalRequestId = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CreateOutgoingCosmosUndelegateRequestRequest {
    return {
      fromAddressId: isSet(object.fromAddressId) ? globalThis.Number(object.fromAddressId) : 0,
      toValidatorAddressId: isSet(object.toValidatorAddressId) ? globalThis.Number(object.toValidatorAddressId) : 0,
      amount: isSet(object.amount) ? globalThis.String(object.amount) : "",
      feeLimit: isSet(object.feeLimit) ? globalThis.String(object.feeLimit) : "",
      gasLimit: isSet(object.gasLimit) ? globalThis.String(object.gasLimit) : "",
      comment: isSet(object.comment) ? globalThis.String(object.comment) : "",
      transactionReference: isSet(object.transactionReference) ? globalThis.String(object.transactionReference) : "",
      externalRequestId: isSet(object.externalRequestId) ? globalThis.String(object.externalRequestId) : "",
    };
  },

  toJSON(message: CreateOutgoingCosmosUndelegateRequestRequest): unknown {
    const obj: any = {};
    if (message.fromAddressId !== 0) {
      obj.fromAddressId = Math.round(message.fromAddressId);
    }
    if (message.toValidatorAddressId !== 0) {
      obj.toValidatorAddressId = Math.round(message.toValidatorAddressId);
    }
    if (message.amount !== "") {
      obj.amount = message.amount;
    }
    if (message.feeLimit !== "") {
      obj.feeLimit = message.feeLimit;
    }
    if (message.gasLimit !== "") {
      obj.gasLimit = message.gasLimit;
    }
    if (message.comment !== "") {
      obj.comment = message.comment;
    }
    if (message.transactionReference !== "") {
      obj.transactionReference = message.transactionReference;
    }
    if (message.externalRequestId !== "") {
      obj.externalRequestId = message.externalRequestId;
    }
    return obj;
  },

  create(
    base?: DeepPartial<CreateOutgoingCosmosUndelegateRequestRequest>,
  ): CreateOutgoingCosmosUndelegateRequestRequest {
    return CreateOutgoingCosmosUndelegateRequestRequest.fromPartial(base ?? {});
  },
  fromPartial(
    object: DeepPartial<CreateOutgoingCosmosUndelegateRequestRequest>,
  ): CreateOutgoingCosmosUndelegateRequestRequest {
    const message = createBaseCreateOutgoingCosmosUndelegateRequestRequest();
    message.fromAddressId = object.fromAddressId ?? 0;
    message.toValidatorAddressId = object.toValidatorAddressId ?? 0;
    message.amount = object.amount ?? "";
    message.feeLimit = object.feeLimit ?? "";
    message.gasLimit = object.gasLimit ?? "";
    message.comment = object.comment ?? "";
    message.transactionReference = object.transactionReference ?? "";
    message.externalRequestId = object.externalRequestId ?? "";
    return message;
  },
};

function createBaseCreateOutgoingCosmosWithdrawRewardRequestRequest(): CreateOutgoingCosmosWithdrawRewardRequestRequest {
  return {
    fromAddressId: 0,
    toValidatorAddressId: 0,
    feeLimit: "",
    gasLimit: "",
    comment: "",
    transactionReference: "",
    externalRequestId: "",
  };
}

export const CreateOutgoingCosmosWithdrawRewardRequestRequest = {
  encode(
    message: CreateOutgoingCosmosWithdrawRewardRequestRequest,
    writer: _m0.Writer = _m0.Writer.create(),
  ): _m0.Writer {
    if (message.fromAddressId !== 0) {
      writer.uint32(8).uint64(message.fromAddressId);
    }
    if (message.toValidatorAddressId !== 0) {
      writer.uint32(16).uint64(message.toValidatorAddressId);
    }
    if (message.feeLimit !== "") {
      writer.uint32(26).string(message.feeLimit);
    }
    if (message.gasLimit !== "") {
      writer.uint32(34).string(message.gasLimit);
    }
    if (message.comment !== "") {
      writer.uint32(42).string(message.comment);
    }
    if (message.transactionReference !== "") {
      writer.uint32(50).string(message.transactionReference);
    }
    if (message.externalRequestId !== "") {
      writer.uint32(58).string(message.externalRequestId);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CreateOutgoingCosmosWithdrawRewardRequestRequest {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCreateOutgoingCosmosWithdrawRewardRequestRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.fromAddressId = longToNumber(reader.uint64() as Long);
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.toValidatorAddressId = longToNumber(reader.uint64() as Long);
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.feeLimit = reader.string();
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.gasLimit = reader.string();
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.comment = reader.string();
          continue;
        case 6:
          if (tag !== 50) {
            break;
          }

          message.transactionReference = reader.string();
          continue;
        case 7:
          if (tag !== 58) {
            break;
          }

          message.externalRequestId = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CreateOutgoingCosmosWithdrawRewardRequestRequest {
    return {
      fromAddressId: isSet(object.fromAddressId) ? globalThis.Number(object.fromAddressId) : 0,
      toValidatorAddressId: isSet(object.toValidatorAddressId) ? globalThis.Number(object.toValidatorAddressId) : 0,
      feeLimit: isSet(object.feeLimit) ? globalThis.String(object.feeLimit) : "",
      gasLimit: isSet(object.gasLimit) ? globalThis.String(object.gasLimit) : "",
      comment: isSet(object.comment) ? globalThis.String(object.comment) : "",
      transactionReference: isSet(object.transactionReference) ? globalThis.String(object.transactionReference) : "",
      externalRequestId: isSet(object.externalRequestId) ? globalThis.String(object.externalRequestId) : "",
    };
  },

  toJSON(message: CreateOutgoingCosmosWithdrawRewardRequestRequest): unknown {
    const obj: any = {};
    if (message.fromAddressId !== 0) {
      obj.fromAddressId = Math.round(message.fromAddressId);
    }
    if (message.toValidatorAddressId !== 0) {
      obj.toValidatorAddressId = Math.round(message.toValidatorAddressId);
    }
    if (message.feeLimit !== "") {
      obj.feeLimit = message.feeLimit;
    }
    if (message.gasLimit !== "") {
      obj.gasLimit = message.gasLimit;
    }
    if (message.comment !== "") {
      obj.comment = message.comment;
    }
    if (message.transactionReference !== "") {
      obj.transactionReference = message.transactionReference;
    }
    if (message.externalRequestId !== "") {
      obj.externalRequestId = message.externalRequestId;
    }
    return obj;
  },

  create(
    base?: DeepPartial<CreateOutgoingCosmosWithdrawRewardRequestRequest>,
  ): CreateOutgoingCosmosWithdrawRewardRequestRequest {
    return CreateOutgoingCosmosWithdrawRewardRequestRequest.fromPartial(base ?? {});
  },
  fromPartial(
    object: DeepPartial<CreateOutgoingCosmosWithdrawRewardRequestRequest>,
  ): CreateOutgoingCosmosWithdrawRewardRequestRequest {
    const message = createBaseCreateOutgoingCosmosWithdrawRewardRequestRequest();
    message.fromAddressId = object.fromAddressId ?? 0;
    message.toValidatorAddressId = object.toValidatorAddressId ?? 0;
    message.feeLimit = object.feeLimit ?? "";
    message.gasLimit = object.gasLimit ?? "";
    message.comment = object.comment ?? "";
    message.transactionReference = object.transactionReference ?? "";
    message.externalRequestId = object.externalRequestId ?? "";
    return message;
  },
};

function createBaseCreateOutgoingXTZDelegateRequestRequest(): CreateOutgoingXTZDelegateRequestRequest {
  return {
    fromAddressId: 0,
    toBakerAddressId: 0,
    gasLimit: "",
    feeLimit: "",
    comment: "",
    transactionReference: "",
    externalRequestId: "",
  };
}

export const CreateOutgoingXTZDelegateRequestRequest = {
  encode(message: CreateOutgoingXTZDelegateRequestRequest, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.fromAddressId !== 0) {
      writer.uint32(8).uint64(message.fromAddressId);
    }
    if (message.toBakerAddressId !== 0) {
      writer.uint32(16).uint64(message.toBakerAddressId);
    }
    if (message.gasLimit !== "") {
      writer.uint32(26).string(message.gasLimit);
    }
    if (message.feeLimit !== "") {
      writer.uint32(34).string(message.feeLimit);
    }
    if (message.comment !== "") {
      writer.uint32(42).string(message.comment);
    }
    if (message.transactionReference !== "") {
      writer.uint32(50).string(message.transactionReference);
    }
    if (message.externalRequestId !== "") {
      writer.uint32(58).string(message.externalRequestId);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CreateOutgoingXTZDelegateRequestRequest {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCreateOutgoingXTZDelegateRequestRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.fromAddressId = longToNumber(reader.uint64() as Long);
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.toBakerAddressId = longToNumber(reader.uint64() as Long);
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.gasLimit = reader.string();
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.feeLimit = reader.string();
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.comment = reader.string();
          continue;
        case 6:
          if (tag !== 50) {
            break;
          }

          message.transactionReference = reader.string();
          continue;
        case 7:
          if (tag !== 58) {
            break;
          }

          message.externalRequestId = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CreateOutgoingXTZDelegateRequestRequest {
    return {
      fromAddressId: isSet(object.fromAddressId) ? globalThis.Number(object.fromAddressId) : 0,
      toBakerAddressId: isSet(object.toBakerAddressId) ? globalThis.Number(object.toBakerAddressId) : 0,
      gasLimit: isSet(object.gasLimit) ? globalThis.String(object.gasLimit) : "",
      feeLimit: isSet(object.feeLimit) ? globalThis.String(object.feeLimit) : "",
      comment: isSet(object.comment) ? globalThis.String(object.comment) : "",
      transactionReference: isSet(object.transactionReference) ? globalThis.String(object.transactionReference) : "",
      externalRequestId: isSet(object.externalRequestId) ? globalThis.String(object.externalRequestId) : "",
    };
  },

  toJSON(message: CreateOutgoingXTZDelegateRequestRequest): unknown {
    const obj: any = {};
    if (message.fromAddressId !== 0) {
      obj.fromAddressId = Math.round(message.fromAddressId);
    }
    if (message.toBakerAddressId !== 0) {
      obj.toBakerAddressId = Math.round(message.toBakerAddressId);
    }
    if (message.gasLimit !== "") {
      obj.gasLimit = message.gasLimit;
    }
    if (message.feeLimit !== "") {
      obj.feeLimit = message.feeLimit;
    }
    if (message.comment !== "") {
      obj.comment = message.comment;
    }
    if (message.transactionReference !== "") {
      obj.transactionReference = message.transactionReference;
    }
    if (message.externalRequestId !== "") {
      obj.externalRequestId = message.externalRequestId;
    }
    return obj;
  },

  create(base?: DeepPartial<CreateOutgoingXTZDelegateRequestRequest>): CreateOutgoingXTZDelegateRequestRequest {
    return CreateOutgoingXTZDelegateRequestRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CreateOutgoingXTZDelegateRequestRequest>): CreateOutgoingXTZDelegateRequestRequest {
    const message = createBaseCreateOutgoingXTZDelegateRequestRequest();
    message.fromAddressId = object.fromAddressId ?? 0;
    message.toBakerAddressId = object.toBakerAddressId ?? 0;
    message.gasLimit = object.gasLimit ?? "";
    message.feeLimit = object.feeLimit ?? "";
    message.comment = object.comment ?? "";
    message.transactionReference = object.transactionReference ?? "";
    message.externalRequestId = object.externalRequestId ?? "";
    return message;
  },
};

function createBaseCreateOutgoingXTZUndelegateRequestRequest(): CreateOutgoingXTZUndelegateRequestRequest {
  return { fromAddressId: 0, gasLimit: "", feeLimit: "", comment: "", transactionReference: "", externalRequestId: "" };
}

export const CreateOutgoingXTZUndelegateRequestRequest = {
  encode(message: CreateOutgoingXTZUndelegateRequestRequest, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.fromAddressId !== 0) {
      writer.uint32(8).uint64(message.fromAddressId);
    }
    if (message.gasLimit !== "") {
      writer.uint32(18).string(message.gasLimit);
    }
    if (message.feeLimit !== "") {
      writer.uint32(26).string(message.feeLimit);
    }
    if (message.comment !== "") {
      writer.uint32(34).string(message.comment);
    }
    if (message.transactionReference !== "") {
      writer.uint32(42).string(message.transactionReference);
    }
    if (message.externalRequestId !== "") {
      writer.uint32(50).string(message.externalRequestId);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CreateOutgoingXTZUndelegateRequestRequest {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCreateOutgoingXTZUndelegateRequestRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.fromAddressId = longToNumber(reader.uint64() as Long);
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.gasLimit = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.feeLimit = reader.string();
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.comment = reader.string();
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.transactionReference = reader.string();
          continue;
        case 6:
          if (tag !== 50) {
            break;
          }

          message.externalRequestId = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CreateOutgoingXTZUndelegateRequestRequest {
    return {
      fromAddressId: isSet(object.fromAddressId) ? globalThis.Number(object.fromAddressId) : 0,
      gasLimit: isSet(object.gasLimit) ? globalThis.String(object.gasLimit) : "",
      feeLimit: isSet(object.feeLimit) ? globalThis.String(object.feeLimit) : "",
      comment: isSet(object.comment) ? globalThis.String(object.comment) : "",
      transactionReference: isSet(object.transactionReference) ? globalThis.String(object.transactionReference) : "",
      externalRequestId: isSet(object.externalRequestId) ? globalThis.String(object.externalRequestId) : "",
    };
  },

  toJSON(message: CreateOutgoingXTZUndelegateRequestRequest): unknown {
    const obj: any = {};
    if (message.fromAddressId !== 0) {
      obj.fromAddressId = Math.round(message.fromAddressId);
    }
    if (message.gasLimit !== "") {
      obj.gasLimit = message.gasLimit;
    }
    if (message.feeLimit !== "") {
      obj.feeLimit = message.feeLimit;
    }
    if (message.comment !== "") {
      obj.comment = message.comment;
    }
    if (message.transactionReference !== "") {
      obj.transactionReference = message.transactionReference;
    }
    if (message.externalRequestId !== "") {
      obj.externalRequestId = message.externalRequestId;
    }
    return obj;
  },

  create(base?: DeepPartial<CreateOutgoingXTZUndelegateRequestRequest>): CreateOutgoingXTZUndelegateRequestRequest {
    return CreateOutgoingXTZUndelegateRequestRequest.fromPartial(base ?? {});
  },
  fromPartial(
    object: DeepPartial<CreateOutgoingXTZUndelegateRequestRequest>,
  ): CreateOutgoingXTZUndelegateRequestRequest {
    const message = createBaseCreateOutgoingXTZUndelegateRequestRequest();
    message.fromAddressId = object.fromAddressId ?? 0;
    message.gasLimit = object.gasLimit ?? "";
    message.feeLimit = object.feeLimit ?? "";
    message.comment = object.comment ?? "";
    message.transactionReference = object.transactionReference ?? "";
    message.externalRequestId = object.externalRequestId ?? "";
    return message;
  },
};

function createBaseCreateOutgoingXTZStakeRequestRequest(): CreateOutgoingXTZStakeRequestRequest {
  return { fromAddressId: 0, amount: "", gasLimit: "", feeLimit: "", comment: "", externalRequestId: "" };
}

export const CreateOutgoingXTZStakeRequestRequest = {
  encode(message: CreateOutgoingXTZStakeRequestRequest, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.fromAddressId !== 0) {
      writer.uint32(8).uint64(message.fromAddressId);
    }
    if (message.amount !== "") {
      writer.uint32(18).string(message.amount);
    }
    if (message.gasLimit !== "") {
      writer.uint32(26).string(message.gasLimit);
    }
    if (message.feeLimit !== "") {
      writer.uint32(34).string(message.feeLimit);
    }
    if (message.comment !== "") {
      writer.uint32(42).string(message.comment);
    }
    if (message.externalRequestId !== "") {
      writer.uint32(50).string(message.externalRequestId);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CreateOutgoingXTZStakeRequestRequest {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCreateOutgoingXTZStakeRequestRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.fromAddressId = longToNumber(reader.uint64() as Long);
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.amount = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.gasLimit = reader.string();
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.feeLimit = reader.string();
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.comment = reader.string();
          continue;
        case 6:
          if (tag !== 50) {
            break;
          }

          message.externalRequestId = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CreateOutgoingXTZStakeRequestRequest {
    return {
      fromAddressId: isSet(object.fromAddressId) ? globalThis.Number(object.fromAddressId) : 0,
      amount: isSet(object.amount) ? globalThis.String(object.amount) : "",
      gasLimit: isSet(object.gasLimit) ? globalThis.String(object.gasLimit) : "",
      feeLimit: isSet(object.feeLimit) ? globalThis.String(object.feeLimit) : "",
      comment: isSet(object.comment) ? globalThis.String(object.comment) : "",
      externalRequestId: isSet(object.externalRequestId) ? globalThis.String(object.externalRequestId) : "",
    };
  },

  toJSON(message: CreateOutgoingXTZStakeRequestRequest): unknown {
    const obj: any = {};
    if (message.fromAddressId !== 0) {
      obj.fromAddressId = Math.round(message.fromAddressId);
    }
    if (message.amount !== "") {
      obj.amount = message.amount;
    }
    if (message.gasLimit !== "") {
      obj.gasLimit = message.gasLimit;
    }
    if (message.feeLimit !== "") {
      obj.feeLimit = message.feeLimit;
    }
    if (message.comment !== "") {
      obj.comment = message.comment;
    }
    if (message.externalRequestId !== "") {
      obj.externalRequestId = message.externalRequestId;
    }
    return obj;
  },

  create(base?: DeepPartial<CreateOutgoingXTZStakeRequestRequest>): CreateOutgoingXTZStakeRequestRequest {
    return CreateOutgoingXTZStakeRequestRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CreateOutgoingXTZStakeRequestRequest>): CreateOutgoingXTZStakeRequestRequest {
    const message = createBaseCreateOutgoingXTZStakeRequestRequest();
    message.fromAddressId = object.fromAddressId ?? 0;
    message.amount = object.amount ?? "";
    message.gasLimit = object.gasLimit ?? "";
    message.feeLimit = object.feeLimit ?? "";
    message.comment = object.comment ?? "";
    message.externalRequestId = object.externalRequestId ?? "";
    return message;
  },
};

function createBaseCreateOutgoingXTZUnstakeRequestRequest(): CreateOutgoingXTZUnstakeRequestRequest {
  return { fromAddressId: 0, amount: "", gasLimit: "", feeLimit: "", comment: "", externalRequestId: "" };
}

export const CreateOutgoingXTZUnstakeRequestRequest = {
  encode(message: CreateOutgoingXTZUnstakeRequestRequest, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.fromAddressId !== 0) {
      writer.uint32(8).uint64(message.fromAddressId);
    }
    if (message.amount !== "") {
      writer.uint32(18).string(message.amount);
    }
    if (message.gasLimit !== "") {
      writer.uint32(26).string(message.gasLimit);
    }
    if (message.feeLimit !== "") {
      writer.uint32(34).string(message.feeLimit);
    }
    if (message.comment !== "") {
      writer.uint32(42).string(message.comment);
    }
    if (message.externalRequestId !== "") {
      writer.uint32(50).string(message.externalRequestId);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CreateOutgoingXTZUnstakeRequestRequest {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCreateOutgoingXTZUnstakeRequestRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.fromAddressId = longToNumber(reader.uint64() as Long);
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.amount = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.gasLimit = reader.string();
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.feeLimit = reader.string();
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.comment = reader.string();
          continue;
        case 6:
          if (tag !== 50) {
            break;
          }

          message.externalRequestId = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CreateOutgoingXTZUnstakeRequestRequest {
    return {
      fromAddressId: isSet(object.fromAddressId) ? globalThis.Number(object.fromAddressId) : 0,
      amount: isSet(object.amount) ? globalThis.String(object.amount) : "",
      gasLimit: isSet(object.gasLimit) ? globalThis.String(object.gasLimit) : "",
      feeLimit: isSet(object.feeLimit) ? globalThis.String(object.feeLimit) : "",
      comment: isSet(object.comment) ? globalThis.String(object.comment) : "",
      externalRequestId: isSet(object.externalRequestId) ? globalThis.String(object.externalRequestId) : "",
    };
  },

  toJSON(message: CreateOutgoingXTZUnstakeRequestRequest): unknown {
    const obj: any = {};
    if (message.fromAddressId !== 0) {
      obj.fromAddressId = Math.round(message.fromAddressId);
    }
    if (message.amount !== "") {
      obj.amount = message.amount;
    }
    if (message.gasLimit !== "") {
      obj.gasLimit = message.gasLimit;
    }
    if (message.feeLimit !== "") {
      obj.feeLimit = message.feeLimit;
    }
    if (message.comment !== "") {
      obj.comment = message.comment;
    }
    if (message.externalRequestId !== "") {
      obj.externalRequestId = message.externalRequestId;
    }
    return obj;
  },

  create(base?: DeepPartial<CreateOutgoingXTZUnstakeRequestRequest>): CreateOutgoingXTZUnstakeRequestRequest {
    return CreateOutgoingXTZUnstakeRequestRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CreateOutgoingXTZUnstakeRequestRequest>): CreateOutgoingXTZUnstakeRequestRequest {
    const message = createBaseCreateOutgoingXTZUnstakeRequestRequest();
    message.fromAddressId = object.fromAddressId ?? 0;
    message.amount = object.amount ?? "";
    message.gasLimit = object.gasLimit ?? "";
    message.feeLimit = object.feeLimit ?? "";
    message.comment = object.comment ?? "";
    message.externalRequestId = object.externalRequestId ?? "";
    return message;
  },
};

function createBaseCreateOutgoingFTMDelegateRequestRequest(): CreateOutgoingFTMDelegateRequestRequest {
  return {
    fromAddressId: 0,
    toValidatorAddressId: 0,
    amount: "",
    feeLimit: "",
    gasLimit: "",
    comment: "",
    useUnconfirmedFunds: false,
    transactionReference: "",
    externalRequestId: "",
  };
}

export const CreateOutgoingFTMDelegateRequestRequest = {
  encode(message: CreateOutgoingFTMDelegateRequestRequest, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.fromAddressId !== 0) {
      writer.uint32(8).uint64(message.fromAddressId);
    }
    if (message.toValidatorAddressId !== 0) {
      writer.uint32(16).uint64(message.toValidatorAddressId);
    }
    if (message.amount !== "") {
      writer.uint32(26).string(message.amount);
    }
    if (message.feeLimit !== "") {
      writer.uint32(34).string(message.feeLimit);
    }
    if (message.gasLimit !== "") {
      writer.uint32(42).string(message.gasLimit);
    }
    if (message.comment !== "") {
      writer.uint32(50).string(message.comment);
    }
    if (message.useUnconfirmedFunds !== false) {
      writer.uint32(56).bool(message.useUnconfirmedFunds);
    }
    if (message.transactionReference !== "") {
      writer.uint32(66).string(message.transactionReference);
    }
    if (message.externalRequestId !== "") {
      writer.uint32(74).string(message.externalRequestId);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CreateOutgoingFTMDelegateRequestRequest {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCreateOutgoingFTMDelegateRequestRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.fromAddressId = longToNumber(reader.uint64() as Long);
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.toValidatorAddressId = longToNumber(reader.uint64() as Long);
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.amount = reader.string();
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.feeLimit = reader.string();
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.gasLimit = reader.string();
          continue;
        case 6:
          if (tag !== 50) {
            break;
          }

          message.comment = reader.string();
          continue;
        case 7:
          if (tag !== 56) {
            break;
          }

          message.useUnconfirmedFunds = reader.bool();
          continue;
        case 8:
          if (tag !== 66) {
            break;
          }

          message.transactionReference = reader.string();
          continue;
        case 9:
          if (tag !== 74) {
            break;
          }

          message.externalRequestId = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CreateOutgoingFTMDelegateRequestRequest {
    return {
      fromAddressId: isSet(object.fromAddressId) ? globalThis.Number(object.fromAddressId) : 0,
      toValidatorAddressId: isSet(object.toValidatorAddressId) ? globalThis.Number(object.toValidatorAddressId) : 0,
      amount: isSet(object.amount) ? globalThis.String(object.amount) : "",
      feeLimit: isSet(object.feeLimit) ? globalThis.String(object.feeLimit) : "",
      gasLimit: isSet(object.gasLimit) ? globalThis.String(object.gasLimit) : "",
      comment: isSet(object.comment) ? globalThis.String(object.comment) : "",
      useUnconfirmedFunds: isSet(object.useUnconfirmedFunds) ? globalThis.Boolean(object.useUnconfirmedFunds) : false,
      transactionReference: isSet(object.transactionReference) ? globalThis.String(object.transactionReference) : "",
      externalRequestId: isSet(object.externalRequestId) ? globalThis.String(object.externalRequestId) : "",
    };
  },

  toJSON(message: CreateOutgoingFTMDelegateRequestRequest): unknown {
    const obj: any = {};
    if (message.fromAddressId !== 0) {
      obj.fromAddressId = Math.round(message.fromAddressId);
    }
    if (message.toValidatorAddressId !== 0) {
      obj.toValidatorAddressId = Math.round(message.toValidatorAddressId);
    }
    if (message.amount !== "") {
      obj.amount = message.amount;
    }
    if (message.feeLimit !== "") {
      obj.feeLimit = message.feeLimit;
    }
    if (message.gasLimit !== "") {
      obj.gasLimit = message.gasLimit;
    }
    if (message.comment !== "") {
      obj.comment = message.comment;
    }
    if (message.useUnconfirmedFunds !== false) {
      obj.useUnconfirmedFunds = message.useUnconfirmedFunds;
    }
    if (message.transactionReference !== "") {
      obj.transactionReference = message.transactionReference;
    }
    if (message.externalRequestId !== "") {
      obj.externalRequestId = message.externalRequestId;
    }
    return obj;
  },

  create(base?: DeepPartial<CreateOutgoingFTMDelegateRequestRequest>): CreateOutgoingFTMDelegateRequestRequest {
    return CreateOutgoingFTMDelegateRequestRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CreateOutgoingFTMDelegateRequestRequest>): CreateOutgoingFTMDelegateRequestRequest {
    const message = createBaseCreateOutgoingFTMDelegateRequestRequest();
    message.fromAddressId = object.fromAddressId ?? 0;
    message.toValidatorAddressId = object.toValidatorAddressId ?? 0;
    message.amount = object.amount ?? "";
    message.feeLimit = object.feeLimit ?? "";
    message.gasLimit = object.gasLimit ?? "";
    message.comment = object.comment ?? "";
    message.useUnconfirmedFunds = object.useUnconfirmedFunds ?? false;
    message.transactionReference = object.transactionReference ?? "";
    message.externalRequestId = object.externalRequestId ?? "";
    return message;
  },
};

function createBaseCreateOutgoingFTMUndelegateRequestRequest(): CreateOutgoingFTMUndelegateRequestRequest {
  return {
    fromAddressId: 0,
    toValidatorAddressId: 0,
    amount: "",
    feeLimit: "",
    gasLimit: "",
    comment: "",
    transactionReference: "",
    externalRequestId: "",
  };
}

export const CreateOutgoingFTMUndelegateRequestRequest = {
  encode(message: CreateOutgoingFTMUndelegateRequestRequest, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.fromAddressId !== 0) {
      writer.uint32(8).uint64(message.fromAddressId);
    }
    if (message.toValidatorAddressId !== 0) {
      writer.uint32(16).uint64(message.toValidatorAddressId);
    }
    if (message.amount !== "") {
      writer.uint32(26).string(message.amount);
    }
    if (message.feeLimit !== "") {
      writer.uint32(34).string(message.feeLimit);
    }
    if (message.gasLimit !== "") {
      writer.uint32(42).string(message.gasLimit);
    }
    if (message.comment !== "") {
      writer.uint32(50).string(message.comment);
    }
    if (message.transactionReference !== "") {
      writer.uint32(58).string(message.transactionReference);
    }
    if (message.externalRequestId !== "") {
      writer.uint32(66).string(message.externalRequestId);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CreateOutgoingFTMUndelegateRequestRequest {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCreateOutgoingFTMUndelegateRequestRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.fromAddressId = longToNumber(reader.uint64() as Long);
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.toValidatorAddressId = longToNumber(reader.uint64() as Long);
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.amount = reader.string();
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.feeLimit = reader.string();
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.gasLimit = reader.string();
          continue;
        case 6:
          if (tag !== 50) {
            break;
          }

          message.comment = reader.string();
          continue;
        case 7:
          if (tag !== 58) {
            break;
          }

          message.transactionReference = reader.string();
          continue;
        case 8:
          if (tag !== 66) {
            break;
          }

          message.externalRequestId = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CreateOutgoingFTMUndelegateRequestRequest {
    return {
      fromAddressId: isSet(object.fromAddressId) ? globalThis.Number(object.fromAddressId) : 0,
      toValidatorAddressId: isSet(object.toValidatorAddressId) ? globalThis.Number(object.toValidatorAddressId) : 0,
      amount: isSet(object.amount) ? globalThis.String(object.amount) : "",
      feeLimit: isSet(object.feeLimit) ? globalThis.String(object.feeLimit) : "",
      gasLimit: isSet(object.gasLimit) ? globalThis.String(object.gasLimit) : "",
      comment: isSet(object.comment) ? globalThis.String(object.comment) : "",
      transactionReference: isSet(object.transactionReference) ? globalThis.String(object.transactionReference) : "",
      externalRequestId: isSet(object.externalRequestId) ? globalThis.String(object.externalRequestId) : "",
    };
  },

  toJSON(message: CreateOutgoingFTMUndelegateRequestRequest): unknown {
    const obj: any = {};
    if (message.fromAddressId !== 0) {
      obj.fromAddressId = Math.round(message.fromAddressId);
    }
    if (message.toValidatorAddressId !== 0) {
      obj.toValidatorAddressId = Math.round(message.toValidatorAddressId);
    }
    if (message.amount !== "") {
      obj.amount = message.amount;
    }
    if (message.feeLimit !== "") {
      obj.feeLimit = message.feeLimit;
    }
    if (message.gasLimit !== "") {
      obj.gasLimit = message.gasLimit;
    }
    if (message.comment !== "") {
      obj.comment = message.comment;
    }
    if (message.transactionReference !== "") {
      obj.transactionReference = message.transactionReference;
    }
    if (message.externalRequestId !== "") {
      obj.externalRequestId = message.externalRequestId;
    }
    return obj;
  },

  create(base?: DeepPartial<CreateOutgoingFTMUndelegateRequestRequest>): CreateOutgoingFTMUndelegateRequestRequest {
    return CreateOutgoingFTMUndelegateRequestRequest.fromPartial(base ?? {});
  },
  fromPartial(
    object: DeepPartial<CreateOutgoingFTMUndelegateRequestRequest>,
  ): CreateOutgoingFTMUndelegateRequestRequest {
    const message = createBaseCreateOutgoingFTMUndelegateRequestRequest();
    message.fromAddressId = object.fromAddressId ?? 0;
    message.toValidatorAddressId = object.toValidatorAddressId ?? 0;
    message.amount = object.amount ?? "";
    message.feeLimit = object.feeLimit ?? "";
    message.gasLimit = object.gasLimit ?? "";
    message.comment = object.comment ?? "";
    message.transactionReference = object.transactionReference ?? "";
    message.externalRequestId = object.externalRequestId ?? "";
    return message;
  },
};

function createBaseCreateOutgoingFTMWithdrawalRequestRequest(): CreateOutgoingFTMWithdrawalRequestRequest {
  return {
    fromAddressId: 0,
    toValidatorAddressId: 0,
    withdrawalId: 0,
    feeLimit: "",
    gasLimit: "",
    comment: "",
    transactionReference: "",
    externalRequestId: "",
  };
}

export const CreateOutgoingFTMWithdrawalRequestRequest = {
  encode(message: CreateOutgoingFTMWithdrawalRequestRequest, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.fromAddressId !== 0) {
      writer.uint32(8).uint64(message.fromAddressId);
    }
    if (message.toValidatorAddressId !== 0) {
      writer.uint32(16).uint64(message.toValidatorAddressId);
    }
    if (message.withdrawalId !== 0) {
      writer.uint32(24).uint64(message.withdrawalId);
    }
    if (message.feeLimit !== "") {
      writer.uint32(34).string(message.feeLimit);
    }
    if (message.gasLimit !== "") {
      writer.uint32(42).string(message.gasLimit);
    }
    if (message.comment !== "") {
      writer.uint32(50).string(message.comment);
    }
    if (message.transactionReference !== "") {
      writer.uint32(58).string(message.transactionReference);
    }
    if (message.externalRequestId !== "") {
      writer.uint32(66).string(message.externalRequestId);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CreateOutgoingFTMWithdrawalRequestRequest {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCreateOutgoingFTMWithdrawalRequestRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.fromAddressId = longToNumber(reader.uint64() as Long);
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.toValidatorAddressId = longToNumber(reader.uint64() as Long);
          continue;
        case 3:
          if (tag !== 24) {
            break;
          }

          message.withdrawalId = longToNumber(reader.uint64() as Long);
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.feeLimit = reader.string();
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.gasLimit = reader.string();
          continue;
        case 6:
          if (tag !== 50) {
            break;
          }

          message.comment = reader.string();
          continue;
        case 7:
          if (tag !== 58) {
            break;
          }

          message.transactionReference = reader.string();
          continue;
        case 8:
          if (tag !== 66) {
            break;
          }

          message.externalRequestId = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CreateOutgoingFTMWithdrawalRequestRequest {
    return {
      fromAddressId: isSet(object.fromAddressId) ? globalThis.Number(object.fromAddressId) : 0,
      toValidatorAddressId: isSet(object.toValidatorAddressId) ? globalThis.Number(object.toValidatorAddressId) : 0,
      withdrawalId: isSet(object.withdrawalId) ? globalThis.Number(object.withdrawalId) : 0,
      feeLimit: isSet(object.feeLimit) ? globalThis.String(object.feeLimit) : "",
      gasLimit: isSet(object.gasLimit) ? globalThis.String(object.gasLimit) : "",
      comment: isSet(object.comment) ? globalThis.String(object.comment) : "",
      transactionReference: isSet(object.transactionReference) ? globalThis.String(object.transactionReference) : "",
      externalRequestId: isSet(object.externalRequestId) ? globalThis.String(object.externalRequestId) : "",
    };
  },

  toJSON(message: CreateOutgoingFTMWithdrawalRequestRequest): unknown {
    const obj: any = {};
    if (message.fromAddressId !== 0) {
      obj.fromAddressId = Math.round(message.fromAddressId);
    }
    if (message.toValidatorAddressId !== 0) {
      obj.toValidatorAddressId = Math.round(message.toValidatorAddressId);
    }
    if (message.withdrawalId !== 0) {
      obj.withdrawalId = Math.round(message.withdrawalId);
    }
    if (message.feeLimit !== "") {
      obj.feeLimit = message.feeLimit;
    }
    if (message.gasLimit !== "") {
      obj.gasLimit = message.gasLimit;
    }
    if (message.comment !== "") {
      obj.comment = message.comment;
    }
    if (message.transactionReference !== "") {
      obj.transactionReference = message.transactionReference;
    }
    if (message.externalRequestId !== "") {
      obj.externalRequestId = message.externalRequestId;
    }
    return obj;
  },

  create(base?: DeepPartial<CreateOutgoingFTMWithdrawalRequestRequest>): CreateOutgoingFTMWithdrawalRequestRequest {
    return CreateOutgoingFTMWithdrawalRequestRequest.fromPartial(base ?? {});
  },
  fromPartial(
    object: DeepPartial<CreateOutgoingFTMWithdrawalRequestRequest>,
  ): CreateOutgoingFTMWithdrawalRequestRequest {
    const message = createBaseCreateOutgoingFTMWithdrawalRequestRequest();
    message.fromAddressId = object.fromAddressId ?? 0;
    message.toValidatorAddressId = object.toValidatorAddressId ?? 0;
    message.withdrawalId = object.withdrawalId ?? 0;
    message.feeLimit = object.feeLimit ?? "";
    message.gasLimit = object.gasLimit ?? "";
    message.comment = object.comment ?? "";
    message.transactionReference = object.transactionReference ?? "";
    message.externalRequestId = object.externalRequestId ?? "";
    return message;
  },
};

function createBaseCreateOutgoingFTMClaimRewardsRequestRequest(): CreateOutgoingFTMClaimRewardsRequestRequest {
  return {
    fromAddressId: 0,
    toValidatorAddressId: 0,
    restake: false,
    feeLimit: "",
    gasLimit: "",
    comment: "",
    transactionReference: "",
    externalRequestId: "",
  };
}

export const CreateOutgoingFTMClaimRewardsRequestRequest = {
  encode(message: CreateOutgoingFTMClaimRewardsRequestRequest, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.fromAddressId !== 0) {
      writer.uint32(8).uint64(message.fromAddressId);
    }
    if (message.toValidatorAddressId !== 0) {
      writer.uint32(16).uint64(message.toValidatorAddressId);
    }
    if (message.restake !== false) {
      writer.uint32(24).bool(message.restake);
    }
    if (message.feeLimit !== "") {
      writer.uint32(34).string(message.feeLimit);
    }
    if (message.gasLimit !== "") {
      writer.uint32(42).string(message.gasLimit);
    }
    if (message.comment !== "") {
      writer.uint32(50).string(message.comment);
    }
    if (message.transactionReference !== "") {
      writer.uint32(58).string(message.transactionReference);
    }
    if (message.externalRequestId !== "") {
      writer.uint32(66).string(message.externalRequestId);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CreateOutgoingFTMClaimRewardsRequestRequest {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCreateOutgoingFTMClaimRewardsRequestRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.fromAddressId = longToNumber(reader.uint64() as Long);
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.toValidatorAddressId = longToNumber(reader.uint64() as Long);
          continue;
        case 3:
          if (tag !== 24) {
            break;
          }

          message.restake = reader.bool();
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.feeLimit = reader.string();
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.gasLimit = reader.string();
          continue;
        case 6:
          if (tag !== 50) {
            break;
          }

          message.comment = reader.string();
          continue;
        case 7:
          if (tag !== 58) {
            break;
          }

          message.transactionReference = reader.string();
          continue;
        case 8:
          if (tag !== 66) {
            break;
          }

          message.externalRequestId = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CreateOutgoingFTMClaimRewardsRequestRequest {
    return {
      fromAddressId: isSet(object.fromAddressId) ? globalThis.Number(object.fromAddressId) : 0,
      toValidatorAddressId: isSet(object.toValidatorAddressId) ? globalThis.Number(object.toValidatorAddressId) : 0,
      restake: isSet(object.restake) ? globalThis.Boolean(object.restake) : false,
      feeLimit: isSet(object.feeLimit) ? globalThis.String(object.feeLimit) : "",
      gasLimit: isSet(object.gasLimit) ? globalThis.String(object.gasLimit) : "",
      comment: isSet(object.comment) ? globalThis.String(object.comment) : "",
      transactionReference: isSet(object.transactionReference) ? globalThis.String(object.transactionReference) : "",
      externalRequestId: isSet(object.externalRequestId) ? globalThis.String(object.externalRequestId) : "",
    };
  },

  toJSON(message: CreateOutgoingFTMClaimRewardsRequestRequest): unknown {
    const obj: any = {};
    if (message.fromAddressId !== 0) {
      obj.fromAddressId = Math.round(message.fromAddressId);
    }
    if (message.toValidatorAddressId !== 0) {
      obj.toValidatorAddressId = Math.round(message.toValidatorAddressId);
    }
    if (message.restake !== false) {
      obj.restake = message.restake;
    }
    if (message.feeLimit !== "") {
      obj.feeLimit = message.feeLimit;
    }
    if (message.gasLimit !== "") {
      obj.gasLimit = message.gasLimit;
    }
    if (message.comment !== "") {
      obj.comment = message.comment;
    }
    if (message.transactionReference !== "") {
      obj.transactionReference = message.transactionReference;
    }
    if (message.externalRequestId !== "") {
      obj.externalRequestId = message.externalRequestId;
    }
    return obj;
  },

  create(base?: DeepPartial<CreateOutgoingFTMClaimRewardsRequestRequest>): CreateOutgoingFTMClaimRewardsRequestRequest {
    return CreateOutgoingFTMClaimRewardsRequestRequest.fromPartial(base ?? {});
  },
  fromPartial(
    object: DeepPartial<CreateOutgoingFTMClaimRewardsRequestRequest>,
  ): CreateOutgoingFTMClaimRewardsRequestRequest {
    const message = createBaseCreateOutgoingFTMClaimRewardsRequestRequest();
    message.fromAddressId = object.fromAddressId ?? 0;
    message.toValidatorAddressId = object.toValidatorAddressId ?? 0;
    message.restake = object.restake ?? false;
    message.feeLimit = object.feeLimit ?? "";
    message.gasLimit = object.gasLimit ?? "";
    message.comment = object.comment ?? "";
    message.transactionReference = object.transactionReference ?? "";
    message.externalRequestId = object.externalRequestId ?? "";
    return message;
  },
};

function createBaseCreateOutgoingDOTNominateRequestRequest(): CreateOutgoingDOTNominateRequestRequest {
  return {
    fromAddressId: 0,
    validatorWLAIds: [],
    feeLimit: "",
    comment: "",
    transactionReference: "",
    externalRequestId: "",
  };
}

export const CreateOutgoingDOTNominateRequestRequest = {
  encode(message: CreateOutgoingDOTNominateRequestRequest, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.fromAddressId !== 0) {
      writer.uint32(8).uint64(message.fromAddressId);
    }
    writer.uint32(18).fork();
    for (const v of message.validatorWLAIds) {
      writer.uint64(v);
    }
    writer.ldelim();
    if (message.feeLimit !== "") {
      writer.uint32(26).string(message.feeLimit);
    }
    if (message.comment !== "") {
      writer.uint32(34).string(message.comment);
    }
    if (message.transactionReference !== "") {
      writer.uint32(42).string(message.transactionReference);
    }
    if (message.externalRequestId !== "") {
      writer.uint32(50).string(message.externalRequestId);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CreateOutgoingDOTNominateRequestRequest {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCreateOutgoingDOTNominateRequestRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.fromAddressId = longToNumber(reader.uint64() as Long);
          continue;
        case 2:
          if (tag === 16) {
            message.validatorWLAIds.push(longToNumber(reader.uint64() as Long));

            continue;
          }

          if (tag === 18) {
            const end2 = reader.uint32() + reader.pos;
            while (reader.pos < end2) {
              message.validatorWLAIds.push(longToNumber(reader.uint64() as Long));
            }

            continue;
          }

          break;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.feeLimit = reader.string();
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.comment = reader.string();
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.transactionReference = reader.string();
          continue;
        case 6:
          if (tag !== 50) {
            break;
          }

          message.externalRequestId = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CreateOutgoingDOTNominateRequestRequest {
    return {
      fromAddressId: isSet(object.fromAddressId) ? globalThis.Number(object.fromAddressId) : 0,
      validatorWLAIds: globalThis.Array.isArray(object?.validatorWLAIds)
        ? object.validatorWLAIds.map((e: any) => globalThis.Number(e))
        : [],
      feeLimit: isSet(object.feeLimit) ? globalThis.String(object.feeLimit) : "",
      comment: isSet(object.comment) ? globalThis.String(object.comment) : "",
      transactionReference: isSet(object.transactionReference) ? globalThis.String(object.transactionReference) : "",
      externalRequestId: isSet(object.externalRequestId) ? globalThis.String(object.externalRequestId) : "",
    };
  },

  toJSON(message: CreateOutgoingDOTNominateRequestRequest): unknown {
    const obj: any = {};
    if (message.fromAddressId !== 0) {
      obj.fromAddressId = Math.round(message.fromAddressId);
    }
    if (message.validatorWLAIds?.length) {
      obj.validatorWLAIds = message.validatorWLAIds.map((e) => Math.round(e));
    }
    if (message.feeLimit !== "") {
      obj.feeLimit = message.feeLimit;
    }
    if (message.comment !== "") {
      obj.comment = message.comment;
    }
    if (message.transactionReference !== "") {
      obj.transactionReference = message.transactionReference;
    }
    if (message.externalRequestId !== "") {
      obj.externalRequestId = message.externalRequestId;
    }
    return obj;
  },

  create(base?: DeepPartial<CreateOutgoingDOTNominateRequestRequest>): CreateOutgoingDOTNominateRequestRequest {
    return CreateOutgoingDOTNominateRequestRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CreateOutgoingDOTNominateRequestRequest>): CreateOutgoingDOTNominateRequestRequest {
    const message = createBaseCreateOutgoingDOTNominateRequestRequest();
    message.fromAddressId = object.fromAddressId ?? 0;
    message.validatorWLAIds = object.validatorWLAIds?.map((e) => e) || [];
    message.feeLimit = object.feeLimit ?? "";
    message.comment = object.comment ?? "";
    message.transactionReference = object.transactionReference ?? "";
    message.externalRequestId = object.externalRequestId ?? "";
    return message;
  },
};

function createBaseCreateOutgoingDOTBondRequestRequest(): CreateOutgoingDOTBondRequestRequest {
  return {
    fromAddressId: 0,
    amount: "",
    restakeRewards: false,
    feeLimit: "",
    comment: "",
    useAllFunds: false,
    transactionReference: "",
    externalRequestId: "",
  };
}

export const CreateOutgoingDOTBondRequestRequest = {
  encode(message: CreateOutgoingDOTBondRequestRequest, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.fromAddressId !== 0) {
      writer.uint32(8).uint64(message.fromAddressId);
    }
    if (message.amount !== "") {
      writer.uint32(18).string(message.amount);
    }
    if (message.restakeRewards !== false) {
      writer.uint32(24).bool(message.restakeRewards);
    }
    if (message.feeLimit !== "") {
      writer.uint32(34).string(message.feeLimit);
    }
    if (message.comment !== "") {
      writer.uint32(42).string(message.comment);
    }
    if (message.useAllFunds !== false) {
      writer.uint32(48).bool(message.useAllFunds);
    }
    if (message.transactionReference !== "") {
      writer.uint32(58).string(message.transactionReference);
    }
    if (message.externalRequestId !== "") {
      writer.uint32(66).string(message.externalRequestId);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CreateOutgoingDOTBondRequestRequest {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCreateOutgoingDOTBondRequestRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.fromAddressId = longToNumber(reader.uint64() as Long);
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.amount = reader.string();
          continue;
        case 3:
          if (tag !== 24) {
            break;
          }

          message.restakeRewards = reader.bool();
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.feeLimit = reader.string();
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.comment = reader.string();
          continue;
        case 6:
          if (tag !== 48) {
            break;
          }

          message.useAllFunds = reader.bool();
          continue;
        case 7:
          if (tag !== 58) {
            break;
          }

          message.transactionReference = reader.string();
          continue;
        case 8:
          if (tag !== 66) {
            break;
          }

          message.externalRequestId = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CreateOutgoingDOTBondRequestRequest {
    return {
      fromAddressId: isSet(object.fromAddressId) ? globalThis.Number(object.fromAddressId) : 0,
      amount: isSet(object.amount) ? globalThis.String(object.amount) : "",
      restakeRewards: isSet(object.restakeRewards) ? globalThis.Boolean(object.restakeRewards) : false,
      feeLimit: isSet(object.feeLimit) ? globalThis.String(object.feeLimit) : "",
      comment: isSet(object.comment) ? globalThis.String(object.comment) : "",
      useAllFunds: isSet(object.useAllFunds) ? globalThis.Boolean(object.useAllFunds) : false,
      transactionReference: isSet(object.transactionReference) ? globalThis.String(object.transactionReference) : "",
      externalRequestId: isSet(object.externalRequestId) ? globalThis.String(object.externalRequestId) : "",
    };
  },

  toJSON(message: CreateOutgoingDOTBondRequestRequest): unknown {
    const obj: any = {};
    if (message.fromAddressId !== 0) {
      obj.fromAddressId = Math.round(message.fromAddressId);
    }
    if (message.amount !== "") {
      obj.amount = message.amount;
    }
    if (message.restakeRewards !== false) {
      obj.restakeRewards = message.restakeRewards;
    }
    if (message.feeLimit !== "") {
      obj.feeLimit = message.feeLimit;
    }
    if (message.comment !== "") {
      obj.comment = message.comment;
    }
    if (message.useAllFunds !== false) {
      obj.useAllFunds = message.useAllFunds;
    }
    if (message.transactionReference !== "") {
      obj.transactionReference = message.transactionReference;
    }
    if (message.externalRequestId !== "") {
      obj.externalRequestId = message.externalRequestId;
    }
    return obj;
  },

  create(base?: DeepPartial<CreateOutgoingDOTBondRequestRequest>): CreateOutgoingDOTBondRequestRequest {
    return CreateOutgoingDOTBondRequestRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CreateOutgoingDOTBondRequestRequest>): CreateOutgoingDOTBondRequestRequest {
    const message = createBaseCreateOutgoingDOTBondRequestRequest();
    message.fromAddressId = object.fromAddressId ?? 0;
    message.amount = object.amount ?? "";
    message.restakeRewards = object.restakeRewards ?? false;
    message.feeLimit = object.feeLimit ?? "";
    message.comment = object.comment ?? "";
    message.useAllFunds = object.useAllFunds ?? false;
    message.transactionReference = object.transactionReference ?? "";
    message.externalRequestId = object.externalRequestId ?? "";
    return message;
  },
};

function createBaseCreateOutgoingDOTBondExtraRequestRequest(): CreateOutgoingDOTBondExtraRequestRequest {
  return {
    fromAddressId: 0,
    amount: "",
    feeLimit: "",
    comment: "",
    useAllFunds: false,
    transactionReference: "",
    externalRequestId: "",
  };
}

export const CreateOutgoingDOTBondExtraRequestRequest = {
  encode(message: CreateOutgoingDOTBondExtraRequestRequest, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.fromAddressId !== 0) {
      writer.uint32(8).uint64(message.fromAddressId);
    }
    if (message.amount !== "") {
      writer.uint32(18).string(message.amount);
    }
    if (message.feeLimit !== "") {
      writer.uint32(26).string(message.feeLimit);
    }
    if (message.comment !== "") {
      writer.uint32(34).string(message.comment);
    }
    if (message.useAllFunds !== false) {
      writer.uint32(40).bool(message.useAllFunds);
    }
    if (message.transactionReference !== "") {
      writer.uint32(50).string(message.transactionReference);
    }
    if (message.externalRequestId !== "") {
      writer.uint32(58).string(message.externalRequestId);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CreateOutgoingDOTBondExtraRequestRequest {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCreateOutgoingDOTBondExtraRequestRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.fromAddressId = longToNumber(reader.uint64() as Long);
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.amount = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.feeLimit = reader.string();
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.comment = reader.string();
          continue;
        case 5:
          if (tag !== 40) {
            break;
          }

          message.useAllFunds = reader.bool();
          continue;
        case 6:
          if (tag !== 50) {
            break;
          }

          message.transactionReference = reader.string();
          continue;
        case 7:
          if (tag !== 58) {
            break;
          }

          message.externalRequestId = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CreateOutgoingDOTBondExtraRequestRequest {
    return {
      fromAddressId: isSet(object.fromAddressId) ? globalThis.Number(object.fromAddressId) : 0,
      amount: isSet(object.amount) ? globalThis.String(object.amount) : "",
      feeLimit: isSet(object.feeLimit) ? globalThis.String(object.feeLimit) : "",
      comment: isSet(object.comment) ? globalThis.String(object.comment) : "",
      useAllFunds: isSet(object.useAllFunds) ? globalThis.Boolean(object.useAllFunds) : false,
      transactionReference: isSet(object.transactionReference) ? globalThis.String(object.transactionReference) : "",
      externalRequestId: isSet(object.externalRequestId) ? globalThis.String(object.externalRequestId) : "",
    };
  },

  toJSON(message: CreateOutgoingDOTBondExtraRequestRequest): unknown {
    const obj: any = {};
    if (message.fromAddressId !== 0) {
      obj.fromAddressId = Math.round(message.fromAddressId);
    }
    if (message.amount !== "") {
      obj.amount = message.amount;
    }
    if (message.feeLimit !== "") {
      obj.feeLimit = message.feeLimit;
    }
    if (message.comment !== "") {
      obj.comment = message.comment;
    }
    if (message.useAllFunds !== false) {
      obj.useAllFunds = message.useAllFunds;
    }
    if (message.transactionReference !== "") {
      obj.transactionReference = message.transactionReference;
    }
    if (message.externalRequestId !== "") {
      obj.externalRequestId = message.externalRequestId;
    }
    return obj;
  },

  create(base?: DeepPartial<CreateOutgoingDOTBondExtraRequestRequest>): CreateOutgoingDOTBondExtraRequestRequest {
    return CreateOutgoingDOTBondExtraRequestRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CreateOutgoingDOTBondExtraRequestRequest>): CreateOutgoingDOTBondExtraRequestRequest {
    const message = createBaseCreateOutgoingDOTBondExtraRequestRequest();
    message.fromAddressId = object.fromAddressId ?? 0;
    message.amount = object.amount ?? "";
    message.feeLimit = object.feeLimit ?? "";
    message.comment = object.comment ?? "";
    message.useAllFunds = object.useAllFunds ?? false;
    message.transactionReference = object.transactionReference ?? "";
    message.externalRequestId = object.externalRequestId ?? "";
    return message;
  },
};

function createBaseCreateOutgoingDOTChillRequestRequest(): CreateOutgoingDOTChillRequestRequest {
  return { fromAddressId: 0, feeLimit: "", comment: "", transactionReference: "", externalRequestId: "" };
}

export const CreateOutgoingDOTChillRequestRequest = {
  encode(message: CreateOutgoingDOTChillRequestRequest, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.fromAddressId !== 0) {
      writer.uint32(8).uint64(message.fromAddressId);
    }
    if (message.feeLimit !== "") {
      writer.uint32(18).string(message.feeLimit);
    }
    if (message.comment !== "") {
      writer.uint32(26).string(message.comment);
    }
    if (message.transactionReference !== "") {
      writer.uint32(34).string(message.transactionReference);
    }
    if (message.externalRequestId !== "") {
      writer.uint32(42).string(message.externalRequestId);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CreateOutgoingDOTChillRequestRequest {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCreateOutgoingDOTChillRequestRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.fromAddressId = longToNumber(reader.uint64() as Long);
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.feeLimit = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.comment = reader.string();
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.transactionReference = reader.string();
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.externalRequestId = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CreateOutgoingDOTChillRequestRequest {
    return {
      fromAddressId: isSet(object.fromAddressId) ? globalThis.Number(object.fromAddressId) : 0,
      feeLimit: isSet(object.feeLimit) ? globalThis.String(object.feeLimit) : "",
      comment: isSet(object.comment) ? globalThis.String(object.comment) : "",
      transactionReference: isSet(object.transactionReference) ? globalThis.String(object.transactionReference) : "",
      externalRequestId: isSet(object.externalRequestId) ? globalThis.String(object.externalRequestId) : "",
    };
  },

  toJSON(message: CreateOutgoingDOTChillRequestRequest): unknown {
    const obj: any = {};
    if (message.fromAddressId !== 0) {
      obj.fromAddressId = Math.round(message.fromAddressId);
    }
    if (message.feeLimit !== "") {
      obj.feeLimit = message.feeLimit;
    }
    if (message.comment !== "") {
      obj.comment = message.comment;
    }
    if (message.transactionReference !== "") {
      obj.transactionReference = message.transactionReference;
    }
    if (message.externalRequestId !== "") {
      obj.externalRequestId = message.externalRequestId;
    }
    return obj;
  },

  create(base?: DeepPartial<CreateOutgoingDOTChillRequestRequest>): CreateOutgoingDOTChillRequestRequest {
    return CreateOutgoingDOTChillRequestRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CreateOutgoingDOTChillRequestRequest>): CreateOutgoingDOTChillRequestRequest {
    const message = createBaseCreateOutgoingDOTChillRequestRequest();
    message.fromAddressId = object.fromAddressId ?? 0;
    message.feeLimit = object.feeLimit ?? "";
    message.comment = object.comment ?? "";
    message.transactionReference = object.transactionReference ?? "";
    message.externalRequestId = object.externalRequestId ?? "";
    return message;
  },
};

function createBaseCreateOutgoingDOTUnbondRequestRequest(): CreateOutgoingDOTUnbondRequestRequest {
  return { fromAddressId: 0, amount: "", feeLimit: "", comment: "", transactionReference: "", externalRequestId: "" };
}

export const CreateOutgoingDOTUnbondRequestRequest = {
  encode(message: CreateOutgoingDOTUnbondRequestRequest, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.fromAddressId !== 0) {
      writer.uint32(8).uint64(message.fromAddressId);
    }
    if (message.amount !== "") {
      writer.uint32(18).string(message.amount);
    }
    if (message.feeLimit !== "") {
      writer.uint32(26).string(message.feeLimit);
    }
    if (message.comment !== "") {
      writer.uint32(34).string(message.comment);
    }
    if (message.transactionReference !== "") {
      writer.uint32(42).string(message.transactionReference);
    }
    if (message.externalRequestId !== "") {
      writer.uint32(50).string(message.externalRequestId);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CreateOutgoingDOTUnbondRequestRequest {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCreateOutgoingDOTUnbondRequestRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.fromAddressId = longToNumber(reader.uint64() as Long);
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.amount = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.feeLimit = reader.string();
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.comment = reader.string();
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.transactionReference = reader.string();
          continue;
        case 6:
          if (tag !== 50) {
            break;
          }

          message.externalRequestId = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CreateOutgoingDOTUnbondRequestRequest {
    return {
      fromAddressId: isSet(object.fromAddressId) ? globalThis.Number(object.fromAddressId) : 0,
      amount: isSet(object.amount) ? globalThis.String(object.amount) : "",
      feeLimit: isSet(object.feeLimit) ? globalThis.String(object.feeLimit) : "",
      comment: isSet(object.comment) ? globalThis.String(object.comment) : "",
      transactionReference: isSet(object.transactionReference) ? globalThis.String(object.transactionReference) : "",
      externalRequestId: isSet(object.externalRequestId) ? globalThis.String(object.externalRequestId) : "",
    };
  },

  toJSON(message: CreateOutgoingDOTUnbondRequestRequest): unknown {
    const obj: any = {};
    if (message.fromAddressId !== 0) {
      obj.fromAddressId = Math.round(message.fromAddressId);
    }
    if (message.amount !== "") {
      obj.amount = message.amount;
    }
    if (message.feeLimit !== "") {
      obj.feeLimit = message.feeLimit;
    }
    if (message.comment !== "") {
      obj.comment = message.comment;
    }
    if (message.transactionReference !== "") {
      obj.transactionReference = message.transactionReference;
    }
    if (message.externalRequestId !== "") {
      obj.externalRequestId = message.externalRequestId;
    }
    return obj;
  },

  create(base?: DeepPartial<CreateOutgoingDOTUnbondRequestRequest>): CreateOutgoingDOTUnbondRequestRequest {
    return CreateOutgoingDOTUnbondRequestRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CreateOutgoingDOTUnbondRequestRequest>): CreateOutgoingDOTUnbondRequestRequest {
    const message = createBaseCreateOutgoingDOTUnbondRequestRequest();
    message.fromAddressId = object.fromAddressId ?? 0;
    message.amount = object.amount ?? "";
    message.feeLimit = object.feeLimit ?? "";
    message.comment = object.comment ?? "";
    message.transactionReference = object.transactionReference ?? "";
    message.externalRequestId = object.externalRequestId ?? "";
    return message;
  },
};

function createBaseCreateOutgoingDOTWithdrawUnbondedRequestRequest(): CreateOutgoingDOTWithdrawUnbondedRequestRequest {
  return { fromAddressId: 0, feeLimit: "", comment: "", transactionReference: "", externalRequestId: "" };
}

export const CreateOutgoingDOTWithdrawUnbondedRequestRequest = {
  encode(
    message: CreateOutgoingDOTWithdrawUnbondedRequestRequest,
    writer: _m0.Writer = _m0.Writer.create(),
  ): _m0.Writer {
    if (message.fromAddressId !== 0) {
      writer.uint32(8).uint64(message.fromAddressId);
    }
    if (message.feeLimit !== "") {
      writer.uint32(18).string(message.feeLimit);
    }
    if (message.comment !== "") {
      writer.uint32(26).string(message.comment);
    }
    if (message.transactionReference !== "") {
      writer.uint32(34).string(message.transactionReference);
    }
    if (message.externalRequestId !== "") {
      writer.uint32(42).string(message.externalRequestId);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CreateOutgoingDOTWithdrawUnbondedRequestRequest {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCreateOutgoingDOTWithdrawUnbondedRequestRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.fromAddressId = longToNumber(reader.uint64() as Long);
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.feeLimit = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.comment = reader.string();
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.transactionReference = reader.string();
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.externalRequestId = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CreateOutgoingDOTWithdrawUnbondedRequestRequest {
    return {
      fromAddressId: isSet(object.fromAddressId) ? globalThis.Number(object.fromAddressId) : 0,
      feeLimit: isSet(object.feeLimit) ? globalThis.String(object.feeLimit) : "",
      comment: isSet(object.comment) ? globalThis.String(object.comment) : "",
      transactionReference: isSet(object.transactionReference) ? globalThis.String(object.transactionReference) : "",
      externalRequestId: isSet(object.externalRequestId) ? globalThis.String(object.externalRequestId) : "",
    };
  },

  toJSON(message: CreateOutgoingDOTWithdrawUnbondedRequestRequest): unknown {
    const obj: any = {};
    if (message.fromAddressId !== 0) {
      obj.fromAddressId = Math.round(message.fromAddressId);
    }
    if (message.feeLimit !== "") {
      obj.feeLimit = message.feeLimit;
    }
    if (message.comment !== "") {
      obj.comment = message.comment;
    }
    if (message.transactionReference !== "") {
      obj.transactionReference = message.transactionReference;
    }
    if (message.externalRequestId !== "") {
      obj.externalRequestId = message.externalRequestId;
    }
    return obj;
  },

  create(
    base?: DeepPartial<CreateOutgoingDOTWithdrawUnbondedRequestRequest>,
  ): CreateOutgoingDOTWithdrawUnbondedRequestRequest {
    return CreateOutgoingDOTWithdrawUnbondedRequestRequest.fromPartial(base ?? {});
  },
  fromPartial(
    object: DeepPartial<CreateOutgoingDOTWithdrawUnbondedRequestRequest>,
  ): CreateOutgoingDOTWithdrawUnbondedRequestRequest {
    const message = createBaseCreateOutgoingDOTWithdrawUnbondedRequestRequest();
    message.fromAddressId = object.fromAddressId ?? 0;
    message.feeLimit = object.feeLimit ?? "";
    message.comment = object.comment ?? "";
    message.transactionReference = object.transactionReference ?? "";
    message.externalRequestId = object.externalRequestId ?? "";
    return message;
  },
};

function createBaseCreateOutgoingMinaDelegationRequestRequest(): CreateOutgoingMinaDelegationRequestRequest {
  return { fromAddressId: 0, toWhitelistedAddressId: 0, feeLimit: "", comment: "", externalRequestId: "" };
}

export const CreateOutgoingMinaDelegationRequestRequest = {
  encode(message: CreateOutgoingMinaDelegationRequestRequest, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.fromAddressId !== 0) {
      writer.uint32(8).uint64(message.fromAddressId);
    }
    if (message.toWhitelistedAddressId !== 0) {
      writer.uint32(16).uint64(message.toWhitelistedAddressId);
    }
    if (message.feeLimit !== "") {
      writer.uint32(26).string(message.feeLimit);
    }
    if (message.comment !== "") {
      writer.uint32(34).string(message.comment);
    }
    if (message.externalRequestId !== "") {
      writer.uint32(42).string(message.externalRequestId);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CreateOutgoingMinaDelegationRequestRequest {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCreateOutgoingMinaDelegationRequestRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.fromAddressId = longToNumber(reader.uint64() as Long);
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.toWhitelistedAddressId = longToNumber(reader.uint64() as Long);
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.feeLimit = reader.string();
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.comment = reader.string();
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.externalRequestId = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CreateOutgoingMinaDelegationRequestRequest {
    return {
      fromAddressId: isSet(object.fromAddressId) ? globalThis.Number(object.fromAddressId) : 0,
      toWhitelistedAddressId: isSet(object.toWhitelistedAddressId)
        ? globalThis.Number(object.toWhitelistedAddressId)
        : 0,
      feeLimit: isSet(object.feeLimit) ? globalThis.String(object.feeLimit) : "",
      comment: isSet(object.comment) ? globalThis.String(object.comment) : "",
      externalRequestId: isSet(object.externalRequestId) ? globalThis.String(object.externalRequestId) : "",
    };
  },

  toJSON(message: CreateOutgoingMinaDelegationRequestRequest): unknown {
    const obj: any = {};
    if (message.fromAddressId !== 0) {
      obj.fromAddressId = Math.round(message.fromAddressId);
    }
    if (message.toWhitelistedAddressId !== 0) {
      obj.toWhitelistedAddressId = Math.round(message.toWhitelistedAddressId);
    }
    if (message.feeLimit !== "") {
      obj.feeLimit = message.feeLimit;
    }
    if (message.comment !== "") {
      obj.comment = message.comment;
    }
    if (message.externalRequestId !== "") {
      obj.externalRequestId = message.externalRequestId;
    }
    return obj;
  },

  create(base?: DeepPartial<CreateOutgoingMinaDelegationRequestRequest>): CreateOutgoingMinaDelegationRequestRequest {
    return CreateOutgoingMinaDelegationRequestRequest.fromPartial(base ?? {});
  },
  fromPartial(
    object: DeepPartial<CreateOutgoingMinaDelegationRequestRequest>,
  ): CreateOutgoingMinaDelegationRequestRequest {
    const message = createBaseCreateOutgoingMinaDelegationRequestRequest();
    message.fromAddressId = object.fromAddressId ?? 0;
    message.toWhitelistedAddressId = object.toWhitelistedAddressId ?? 0;
    message.feeLimit = object.feeLimit ?? "";
    message.comment = object.comment ?? "";
    message.externalRequestId = object.externalRequestId ?? "";
    return message;
  },
};

function createBaseCreateOutgoingMinaUndelegationRequestRequest(): CreateOutgoingMinaUndelegationRequestRequest {
  return { fromAddressId: 0, feeLimit: "", comment: "", externalRequestId: "" };
}

export const CreateOutgoingMinaUndelegationRequestRequest = {
  encode(message: CreateOutgoingMinaUndelegationRequestRequest, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.fromAddressId !== 0) {
      writer.uint32(8).uint64(message.fromAddressId);
    }
    if (message.feeLimit !== "") {
      writer.uint32(18).string(message.feeLimit);
    }
    if (message.comment !== "") {
      writer.uint32(26).string(message.comment);
    }
    if (message.externalRequestId !== "") {
      writer.uint32(34).string(message.externalRequestId);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CreateOutgoingMinaUndelegationRequestRequest {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCreateOutgoingMinaUndelegationRequestRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.fromAddressId = longToNumber(reader.uint64() as Long);
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.feeLimit = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.comment = reader.string();
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.externalRequestId = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CreateOutgoingMinaUndelegationRequestRequest {
    return {
      fromAddressId: isSet(object.fromAddressId) ? globalThis.Number(object.fromAddressId) : 0,
      feeLimit: isSet(object.feeLimit) ? globalThis.String(object.feeLimit) : "",
      comment: isSet(object.comment) ? globalThis.String(object.comment) : "",
      externalRequestId: isSet(object.externalRequestId) ? globalThis.String(object.externalRequestId) : "",
    };
  },

  toJSON(message: CreateOutgoingMinaUndelegationRequestRequest): unknown {
    const obj: any = {};
    if (message.fromAddressId !== 0) {
      obj.fromAddressId = Math.round(message.fromAddressId);
    }
    if (message.feeLimit !== "") {
      obj.feeLimit = message.feeLimit;
    }
    if (message.comment !== "") {
      obj.comment = message.comment;
    }
    if (message.externalRequestId !== "") {
      obj.externalRequestId = message.externalRequestId;
    }
    return obj;
  },

  create(
    base?: DeepPartial<CreateOutgoingMinaUndelegationRequestRequest>,
  ): CreateOutgoingMinaUndelegationRequestRequest {
    return CreateOutgoingMinaUndelegationRequestRequest.fromPartial(base ?? {});
  },
  fromPartial(
    object: DeepPartial<CreateOutgoingMinaUndelegationRequestRequest>,
  ): CreateOutgoingMinaUndelegationRequestRequest {
    const message = createBaseCreateOutgoingMinaUndelegationRequestRequest();
    message.fromAddressId = object.fromAddressId ?? 0;
    message.feeLimit = object.feeLimit ?? "";
    message.comment = object.comment ?? "";
    message.externalRequestId = object.externalRequestId ?? "";
    return message;
  },
};

function createBaseCreateOutgoingNEARDepositAndStakeRequestRequest(): CreateOutgoingNEARDepositAndStakeRequestRequest {
  return { fromAddressId: 0, toValidatorAddressId: 0, amount: "", feeLimit: "", comment: "", transactionReference: "" };
}

export const CreateOutgoingNEARDepositAndStakeRequestRequest = {
  encode(
    message: CreateOutgoingNEARDepositAndStakeRequestRequest,
    writer: _m0.Writer = _m0.Writer.create(),
  ): _m0.Writer {
    if (message.fromAddressId !== 0) {
      writer.uint32(8).uint64(message.fromAddressId);
    }
    if (message.toValidatorAddressId !== 0) {
      writer.uint32(16).uint64(message.toValidatorAddressId);
    }
    if (message.amount !== "") {
      writer.uint32(26).string(message.amount);
    }
    if (message.feeLimit !== "") {
      writer.uint32(34).string(message.feeLimit);
    }
    if (message.comment !== "") {
      writer.uint32(42).string(message.comment);
    }
    if (message.transactionReference !== "") {
      writer.uint32(50).string(message.transactionReference);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CreateOutgoingNEARDepositAndStakeRequestRequest {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCreateOutgoingNEARDepositAndStakeRequestRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.fromAddressId = longToNumber(reader.uint64() as Long);
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.toValidatorAddressId = longToNumber(reader.uint64() as Long);
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.amount = reader.string();
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.feeLimit = reader.string();
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.comment = reader.string();
          continue;
        case 6:
          if (tag !== 50) {
            break;
          }

          message.transactionReference = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CreateOutgoingNEARDepositAndStakeRequestRequest {
    return {
      fromAddressId: isSet(object.fromAddressId) ? globalThis.Number(object.fromAddressId) : 0,
      toValidatorAddressId: isSet(object.toValidatorAddressId) ? globalThis.Number(object.toValidatorAddressId) : 0,
      amount: isSet(object.amount) ? globalThis.String(object.amount) : "",
      feeLimit: isSet(object.feeLimit) ? globalThis.String(object.feeLimit) : "",
      comment: isSet(object.comment) ? globalThis.String(object.comment) : "",
      transactionReference: isSet(object.transactionReference) ? globalThis.String(object.transactionReference) : "",
    };
  },

  toJSON(message: CreateOutgoingNEARDepositAndStakeRequestRequest): unknown {
    const obj: any = {};
    if (message.fromAddressId !== 0) {
      obj.fromAddressId = Math.round(message.fromAddressId);
    }
    if (message.toValidatorAddressId !== 0) {
      obj.toValidatorAddressId = Math.round(message.toValidatorAddressId);
    }
    if (message.amount !== "") {
      obj.amount = message.amount;
    }
    if (message.feeLimit !== "") {
      obj.feeLimit = message.feeLimit;
    }
    if (message.comment !== "") {
      obj.comment = message.comment;
    }
    if (message.transactionReference !== "") {
      obj.transactionReference = message.transactionReference;
    }
    return obj;
  },

  create(
    base?: DeepPartial<CreateOutgoingNEARDepositAndStakeRequestRequest>,
  ): CreateOutgoingNEARDepositAndStakeRequestRequest {
    return CreateOutgoingNEARDepositAndStakeRequestRequest.fromPartial(base ?? {});
  },
  fromPartial(
    object: DeepPartial<CreateOutgoingNEARDepositAndStakeRequestRequest>,
  ): CreateOutgoingNEARDepositAndStakeRequestRequest {
    const message = createBaseCreateOutgoingNEARDepositAndStakeRequestRequest();
    message.fromAddressId = object.fromAddressId ?? 0;
    message.toValidatorAddressId = object.toValidatorAddressId ?? 0;
    message.amount = object.amount ?? "";
    message.feeLimit = object.feeLimit ?? "";
    message.comment = object.comment ?? "";
    message.transactionReference = object.transactionReference ?? "";
    return message;
  },
};

function createBaseCreateOutgoingNEARUnstakeRequestRequest(): CreateOutgoingNEARUnstakeRequestRequest {
  return { fromAddressId: 0, toValidatorAddressId: 0, amount: "", feeLimit: "", comment: "", transactionReference: "" };
}

export const CreateOutgoingNEARUnstakeRequestRequest = {
  encode(message: CreateOutgoingNEARUnstakeRequestRequest, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.fromAddressId !== 0) {
      writer.uint32(8).uint64(message.fromAddressId);
    }
    if (message.toValidatorAddressId !== 0) {
      writer.uint32(16).uint64(message.toValidatorAddressId);
    }
    if (message.amount !== "") {
      writer.uint32(26).string(message.amount);
    }
    if (message.feeLimit !== "") {
      writer.uint32(34).string(message.feeLimit);
    }
    if (message.comment !== "") {
      writer.uint32(42).string(message.comment);
    }
    if (message.transactionReference !== "") {
      writer.uint32(50).string(message.transactionReference);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CreateOutgoingNEARUnstakeRequestRequest {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCreateOutgoingNEARUnstakeRequestRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.fromAddressId = longToNumber(reader.uint64() as Long);
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.toValidatorAddressId = longToNumber(reader.uint64() as Long);
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.amount = reader.string();
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.feeLimit = reader.string();
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.comment = reader.string();
          continue;
        case 6:
          if (tag !== 50) {
            break;
          }

          message.transactionReference = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CreateOutgoingNEARUnstakeRequestRequest {
    return {
      fromAddressId: isSet(object.fromAddressId) ? globalThis.Number(object.fromAddressId) : 0,
      toValidatorAddressId: isSet(object.toValidatorAddressId) ? globalThis.Number(object.toValidatorAddressId) : 0,
      amount: isSet(object.amount) ? globalThis.String(object.amount) : "",
      feeLimit: isSet(object.feeLimit) ? globalThis.String(object.feeLimit) : "",
      comment: isSet(object.comment) ? globalThis.String(object.comment) : "",
      transactionReference: isSet(object.transactionReference) ? globalThis.String(object.transactionReference) : "",
    };
  },

  toJSON(message: CreateOutgoingNEARUnstakeRequestRequest): unknown {
    const obj: any = {};
    if (message.fromAddressId !== 0) {
      obj.fromAddressId = Math.round(message.fromAddressId);
    }
    if (message.toValidatorAddressId !== 0) {
      obj.toValidatorAddressId = Math.round(message.toValidatorAddressId);
    }
    if (message.amount !== "") {
      obj.amount = message.amount;
    }
    if (message.feeLimit !== "") {
      obj.feeLimit = message.feeLimit;
    }
    if (message.comment !== "") {
      obj.comment = message.comment;
    }
    if (message.transactionReference !== "") {
      obj.transactionReference = message.transactionReference;
    }
    return obj;
  },

  create(base?: DeepPartial<CreateOutgoingNEARUnstakeRequestRequest>): CreateOutgoingNEARUnstakeRequestRequest {
    return CreateOutgoingNEARUnstakeRequestRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CreateOutgoingNEARUnstakeRequestRequest>): CreateOutgoingNEARUnstakeRequestRequest {
    const message = createBaseCreateOutgoingNEARUnstakeRequestRequest();
    message.fromAddressId = object.fromAddressId ?? 0;
    message.toValidatorAddressId = object.toValidatorAddressId ?? 0;
    message.amount = object.amount ?? "";
    message.feeLimit = object.feeLimit ?? "";
    message.comment = object.comment ?? "";
    message.transactionReference = object.transactionReference ?? "";
    return message;
  },
};

function createBaseCreateOutgoingNEARWithdrawRequestRequest(): CreateOutgoingNEARWithdrawRequestRequest {
  return { fromAddressId: 0, toValidatorAddressId: 0, amount: "", feeLimit: "", comment: "", transactionReference: "" };
}

export const CreateOutgoingNEARWithdrawRequestRequest = {
  encode(message: CreateOutgoingNEARWithdrawRequestRequest, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.fromAddressId !== 0) {
      writer.uint32(8).uint64(message.fromAddressId);
    }
    if (message.toValidatorAddressId !== 0) {
      writer.uint32(16).uint64(message.toValidatorAddressId);
    }
    if (message.amount !== "") {
      writer.uint32(26).string(message.amount);
    }
    if (message.feeLimit !== "") {
      writer.uint32(34).string(message.feeLimit);
    }
    if (message.comment !== "") {
      writer.uint32(42).string(message.comment);
    }
    if (message.transactionReference !== "") {
      writer.uint32(50).string(message.transactionReference);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CreateOutgoingNEARWithdrawRequestRequest {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCreateOutgoingNEARWithdrawRequestRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.fromAddressId = longToNumber(reader.uint64() as Long);
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.toValidatorAddressId = longToNumber(reader.uint64() as Long);
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.amount = reader.string();
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.feeLimit = reader.string();
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.comment = reader.string();
          continue;
        case 6:
          if (tag !== 50) {
            break;
          }

          message.transactionReference = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CreateOutgoingNEARWithdrawRequestRequest {
    return {
      fromAddressId: isSet(object.fromAddressId) ? globalThis.Number(object.fromAddressId) : 0,
      toValidatorAddressId: isSet(object.toValidatorAddressId) ? globalThis.Number(object.toValidatorAddressId) : 0,
      amount: isSet(object.amount) ? globalThis.String(object.amount) : "",
      feeLimit: isSet(object.feeLimit) ? globalThis.String(object.feeLimit) : "",
      comment: isSet(object.comment) ? globalThis.String(object.comment) : "",
      transactionReference: isSet(object.transactionReference) ? globalThis.String(object.transactionReference) : "",
    };
  },

  toJSON(message: CreateOutgoingNEARWithdrawRequestRequest): unknown {
    const obj: any = {};
    if (message.fromAddressId !== 0) {
      obj.fromAddressId = Math.round(message.fromAddressId);
    }
    if (message.toValidatorAddressId !== 0) {
      obj.toValidatorAddressId = Math.round(message.toValidatorAddressId);
    }
    if (message.amount !== "") {
      obj.amount = message.amount;
    }
    if (message.feeLimit !== "") {
      obj.feeLimit = message.feeLimit;
    }
    if (message.comment !== "") {
      obj.comment = message.comment;
    }
    if (message.transactionReference !== "") {
      obj.transactionReference = message.transactionReference;
    }
    return obj;
  },

  create(base?: DeepPartial<CreateOutgoingNEARWithdrawRequestRequest>): CreateOutgoingNEARWithdrawRequestRequest {
    return CreateOutgoingNEARWithdrawRequestRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CreateOutgoingNEARWithdrawRequestRequest>): CreateOutgoingNEARWithdrawRequestRequest {
    const message = createBaseCreateOutgoingNEARWithdrawRequestRequest();
    message.fromAddressId = object.fromAddressId ?? 0;
    message.toValidatorAddressId = object.toValidatorAddressId ?? 0;
    message.amount = object.amount ?? "";
    message.feeLimit = object.feeLimit ?? "";
    message.comment = object.comment ?? "";
    message.transactionReference = object.transactionReference ?? "";
    return message;
  },
};

function createBaseCreateOutgoingUTXOsRequestRequest(): CreateOutgoingUTXOsRequestRequest {
  return {
    amount: "",
    feeLimit: "",
    fromAddressId: 0,
    toAddressId: 0,
    toWhitelistedAddressId: 0,
    utxoIds: [],
    comment: "",
    feePaidByReceiver: false,
    transactionReference: "",
    externalRequestId: "",
  };
}

export const CreateOutgoingUTXOsRequestRequest = {
  encode(message: CreateOutgoingUTXOsRequestRequest, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.amount !== "") {
      writer.uint32(10).string(message.amount);
    }
    if (message.feeLimit !== "") {
      writer.uint32(18).string(message.feeLimit);
    }
    if (message.fromAddressId !== 0) {
      writer.uint32(24).uint64(message.fromAddressId);
    }
    if (message.toAddressId !== 0) {
      writer.uint32(32).uint64(message.toAddressId);
    }
    if (message.toWhitelistedAddressId !== 0) {
      writer.uint32(40).uint64(message.toWhitelistedAddressId);
    }
    writer.uint32(50).fork();
    for (const v of message.utxoIds) {
      writer.uint64(v);
    }
    writer.ldelim();
    if (message.comment !== "") {
      writer.uint32(58).string(message.comment);
    }
    if (message.feePaidByReceiver !== false) {
      writer.uint32(64).bool(message.feePaidByReceiver);
    }
    if (message.transactionReference !== "") {
      writer.uint32(74).string(message.transactionReference);
    }
    if (message.externalRequestId !== "") {
      writer.uint32(82).string(message.externalRequestId);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CreateOutgoingUTXOsRequestRequest {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCreateOutgoingUTXOsRequestRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.amount = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.feeLimit = reader.string();
          continue;
        case 3:
          if (tag !== 24) {
            break;
          }

          message.fromAddressId = longToNumber(reader.uint64() as Long);
          continue;
        case 4:
          if (tag !== 32) {
            break;
          }

          message.toAddressId = longToNumber(reader.uint64() as Long);
          continue;
        case 5:
          if (tag !== 40) {
            break;
          }

          message.toWhitelistedAddressId = longToNumber(reader.uint64() as Long);
          continue;
        case 6:
          if (tag === 48) {
            message.utxoIds.push(longToNumber(reader.uint64() as Long));

            continue;
          }

          if (tag === 50) {
            const end2 = reader.uint32() + reader.pos;
            while (reader.pos < end2) {
              message.utxoIds.push(longToNumber(reader.uint64() as Long));
            }

            continue;
          }

          break;
        case 7:
          if (tag !== 58) {
            break;
          }

          message.comment = reader.string();
          continue;
        case 8:
          if (tag !== 64) {
            break;
          }

          message.feePaidByReceiver = reader.bool();
          continue;
        case 9:
          if (tag !== 74) {
            break;
          }

          message.transactionReference = reader.string();
          continue;
        case 10:
          if (tag !== 82) {
            break;
          }

          message.externalRequestId = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CreateOutgoingUTXOsRequestRequest {
    return {
      amount: isSet(object.amount) ? globalThis.String(object.amount) : "",
      feeLimit: isSet(object.feeLimit) ? globalThis.String(object.feeLimit) : "",
      fromAddressId: isSet(object.fromAddressId) ? globalThis.Number(object.fromAddressId) : 0,
      toAddressId: isSet(object.toAddressId) ? globalThis.Number(object.toAddressId) : 0,
      toWhitelistedAddressId: isSet(object.toWhitelistedAddressId)
        ? globalThis.Number(object.toWhitelistedAddressId)
        : 0,
      utxoIds: globalThis.Array.isArray(object?.utxoIds) ? object.utxoIds.map((e: any) => globalThis.Number(e)) : [],
      comment: isSet(object.comment) ? globalThis.String(object.comment) : "",
      feePaidByReceiver: isSet(object.feePaidByReceiver) ? globalThis.Boolean(object.feePaidByReceiver) : false,
      transactionReference: isSet(object.transactionReference) ? globalThis.String(object.transactionReference) : "",
      externalRequestId: isSet(object.externalRequestId) ? globalThis.String(object.externalRequestId) : "",
    };
  },

  toJSON(message: CreateOutgoingUTXOsRequestRequest): unknown {
    const obj: any = {};
    if (message.amount !== "") {
      obj.amount = message.amount;
    }
    if (message.feeLimit !== "") {
      obj.feeLimit = message.feeLimit;
    }
    if (message.fromAddressId !== 0) {
      obj.fromAddressId = Math.round(message.fromAddressId);
    }
    if (message.toAddressId !== 0) {
      obj.toAddressId = Math.round(message.toAddressId);
    }
    if (message.toWhitelistedAddressId !== 0) {
      obj.toWhitelistedAddressId = Math.round(message.toWhitelistedAddressId);
    }
    if (message.utxoIds?.length) {
      obj.utxoIds = message.utxoIds.map((e) => Math.round(e));
    }
    if (message.comment !== "") {
      obj.comment = message.comment;
    }
    if (message.feePaidByReceiver !== false) {
      obj.feePaidByReceiver = message.feePaidByReceiver;
    }
    if (message.transactionReference !== "") {
      obj.transactionReference = message.transactionReference;
    }
    if (message.externalRequestId !== "") {
      obj.externalRequestId = message.externalRequestId;
    }
    return obj;
  },

  create(base?: DeepPartial<CreateOutgoingUTXOsRequestRequest>): CreateOutgoingUTXOsRequestRequest {
    return CreateOutgoingUTXOsRequestRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CreateOutgoingUTXOsRequestRequest>): CreateOutgoingUTXOsRequestRequest {
    const message = createBaseCreateOutgoingUTXOsRequestRequest();
    message.amount = object.amount ?? "";
    message.feeLimit = object.feeLimit ?? "";
    message.fromAddressId = object.fromAddressId ?? 0;
    message.toAddressId = object.toAddressId ?? 0;
    message.toWhitelistedAddressId = object.toWhitelistedAddressId ?? 0;
    message.utxoIds = object.utxoIds?.map((e) => e) || [];
    message.comment = object.comment ?? "";
    message.feePaidByReceiver = object.feePaidByReceiver ?? false;
    message.transactionReference = object.transactionReference ?? "";
    message.externalRequestId = object.externalRequestId ?? "";
    return message;
  },
};

function createBaseCreateOutgoingCancelRequestRequest(): CreateOutgoingCancelRequestRequest {
  return { addressId: 0, nonce: 0, feePayerId: 0, addressIds: [], nonces: [], externalRequestId: "" };
}

export const CreateOutgoingCancelRequestRequest = {
  encode(message: CreateOutgoingCancelRequestRequest, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.addressId !== 0) {
      writer.uint32(8).uint64(message.addressId);
    }
    if (message.nonce !== 0) {
      writer.uint32(16).uint64(message.nonce);
    }
    if (message.feePayerId !== 0) {
      writer.uint32(24).uint64(message.feePayerId);
    }
    writer.uint32(34).fork();
    for (const v of message.addressIds) {
      writer.uint64(v);
    }
    writer.ldelim();
    writer.uint32(42).fork();
    for (const v of message.nonces) {
      writer.uint64(v);
    }
    writer.ldelim();
    if (message.externalRequestId !== "") {
      writer.uint32(50).string(message.externalRequestId);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CreateOutgoingCancelRequestRequest {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCreateOutgoingCancelRequestRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.addressId = longToNumber(reader.uint64() as Long);
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.nonce = longToNumber(reader.uint64() as Long);
          continue;
        case 3:
          if (tag !== 24) {
            break;
          }

          message.feePayerId = longToNumber(reader.uint64() as Long);
          continue;
        case 4:
          if (tag === 32) {
            message.addressIds.push(longToNumber(reader.uint64() as Long));

            continue;
          }

          if (tag === 34) {
            const end2 = reader.uint32() + reader.pos;
            while (reader.pos < end2) {
              message.addressIds.push(longToNumber(reader.uint64() as Long));
            }

            continue;
          }

          break;
        case 5:
          if (tag === 40) {
            message.nonces.push(longToNumber(reader.uint64() as Long));

            continue;
          }

          if (tag === 42) {
            const end2 = reader.uint32() + reader.pos;
            while (reader.pos < end2) {
              message.nonces.push(longToNumber(reader.uint64() as Long));
            }

            continue;
          }

          break;
        case 6:
          if (tag !== 50) {
            break;
          }

          message.externalRequestId = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CreateOutgoingCancelRequestRequest {
    return {
      addressId: isSet(object.addressId) ? globalThis.Number(object.addressId) : 0,
      nonce: isSet(object.nonce) ? globalThis.Number(object.nonce) : 0,
      feePayerId: isSet(object.feePayerId) ? globalThis.Number(object.feePayerId) : 0,
      addressIds: globalThis.Array.isArray(object?.addressIds)
        ? object.addressIds.map((e: any) => globalThis.Number(e))
        : [],
      nonces: globalThis.Array.isArray(object?.nonces) ? object.nonces.map((e: any) => globalThis.Number(e)) : [],
      externalRequestId: isSet(object.externalRequestId) ? globalThis.String(object.externalRequestId) : "",
    };
  },

  toJSON(message: CreateOutgoingCancelRequestRequest): unknown {
    const obj: any = {};
    if (message.addressId !== 0) {
      obj.addressId = Math.round(message.addressId);
    }
    if (message.nonce !== 0) {
      obj.nonce = Math.round(message.nonce);
    }
    if (message.feePayerId !== 0) {
      obj.feePayerId = Math.round(message.feePayerId);
    }
    if (message.addressIds?.length) {
      obj.addressIds = message.addressIds.map((e) => Math.round(e));
    }
    if (message.nonces?.length) {
      obj.nonces = message.nonces.map((e) => Math.round(e));
    }
    if (message.externalRequestId !== "") {
      obj.externalRequestId = message.externalRequestId;
    }
    return obj;
  },

  create(base?: DeepPartial<CreateOutgoingCancelRequestRequest>): CreateOutgoingCancelRequestRequest {
    return CreateOutgoingCancelRequestRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CreateOutgoingCancelRequestRequest>): CreateOutgoingCancelRequestRequest {
    const message = createBaseCreateOutgoingCancelRequestRequest();
    message.addressId = object.addressId ?? 0;
    message.nonce = object.nonce ?? 0;
    message.feePayerId = object.feePayerId ?? 0;
    message.addressIds = object.addressIds?.map((e) => e) || [];
    message.nonces = object.nonces?.map((e) => e) || [];
    message.externalRequestId = object.externalRequestId ?? "";
    return message;
  },
};

function createBaseCreateOutgoingDeployContractRequestRequest(): CreateOutgoingDeployContractRequestRequest {
  return {
    fromAddressId: 0,
    bytecode: new Uint8Array(0),
    constructor: undefined,
    generateWhitelistedAddress: false,
    gasLimit: "",
    gasPriceLimit: "",
    comment: "",
    contractType: "",
    feePayerId: 0,
    feeLimit: "",
    contract: undefined,
    transactionReference: "",
    externalRequestId: "",
  };
}

export const CreateOutgoingDeployContractRequestRequest = {
  encode(message: CreateOutgoingDeployContractRequestRequest, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.fromAddressId !== 0) {
      writer.uint32(8).uint64(message.fromAddressId);
    }
    if (message.bytecode.length !== 0) {
      writer.uint32(18).bytes(message.bytecode);
    }
    if (message.constructor !== undefined) {
      ContractCall.encode(message.constructor, writer.uint32(26).fork()).ldelim();
    }
    if (message.generateWhitelistedAddress !== false) {
      writer.uint32(32).bool(message.generateWhitelistedAddress);
    }
    if (message.gasLimit !== "") {
      writer.uint32(42).string(message.gasLimit);
    }
    if (message.gasPriceLimit !== "") {
      writer.uint32(50).string(message.gasPriceLimit);
    }
    if (message.comment !== "") {
      writer.uint32(58).string(message.comment);
    }
    if (message.contractType !== "") {
      writer.uint32(66).string(message.contractType);
    }
    if (message.feePayerId !== 0) {
      writer.uint32(72).uint64(message.feePayerId);
    }
    if (message.feeLimit !== "") {
      writer.uint32(82).string(message.feeLimit);
    }
    if (message.contract !== undefined) {
      GenericCreateContract.encode(message.contract, writer.uint32(90).fork()).ldelim();
    }
    if (message.transactionReference !== "") {
      writer.uint32(98).string(message.transactionReference);
    }
    if (message.externalRequestId !== "") {
      writer.uint32(106).string(message.externalRequestId);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CreateOutgoingDeployContractRequestRequest {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCreateOutgoingDeployContractRequestRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.fromAddressId = longToNumber(reader.uint64() as Long);
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.bytecode = reader.bytes();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.constructor = ContractCall.decode(reader, reader.uint32());
          continue;
        case 4:
          if (tag !== 32) {
            break;
          }

          message.generateWhitelistedAddress = reader.bool();
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.gasLimit = reader.string();
          continue;
        case 6:
          if (tag !== 50) {
            break;
          }

          message.gasPriceLimit = reader.string();
          continue;
        case 7:
          if (tag !== 58) {
            break;
          }

          message.comment = reader.string();
          continue;
        case 8:
          if (tag !== 66) {
            break;
          }

          message.contractType = reader.string();
          continue;
        case 9:
          if (tag !== 72) {
            break;
          }

          message.feePayerId = longToNumber(reader.uint64() as Long);
          continue;
        case 10:
          if (tag !== 82) {
            break;
          }

          message.feeLimit = reader.string();
          continue;
        case 11:
          if (tag !== 90) {
            break;
          }

          message.contract = GenericCreateContract.decode(reader, reader.uint32());
          continue;
        case 12:
          if (tag !== 98) {
            break;
          }

          message.transactionReference = reader.string();
          continue;
        case 13:
          if (tag !== 106) {
            break;
          }

          message.externalRequestId = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CreateOutgoingDeployContractRequestRequest {
    return {
      fromAddressId: isSet(object.fromAddressId) ? globalThis.Number(object.fromAddressId) : 0,
      bytecode: isSet(object.bytecode) ? bytesFromBase64(object.bytecode) : new Uint8Array(0),
      constructor: isSet(object.constructor) ? ContractCall.fromJSON(object.constructor) : undefined,
      generateWhitelistedAddress: isSet(object.generateWhitelistedAddress)
        ? globalThis.Boolean(object.generateWhitelistedAddress)
        : false,
      gasLimit: isSet(object.gasLimit) ? globalThis.String(object.gasLimit) : "",
      gasPriceLimit: isSet(object.gasPriceLimit) ? globalThis.String(object.gasPriceLimit) : "",
      comment: isSet(object.comment) ? globalThis.String(object.comment) : "",
      contractType: isSet(object.contractType) ? globalThis.String(object.contractType) : "",
      feePayerId: isSet(object.feePayerId) ? globalThis.Number(object.feePayerId) : 0,
      feeLimit: isSet(object.feeLimit) ? globalThis.String(object.feeLimit) : "",
      contract: isSet(object.contract) ? GenericCreateContract.fromJSON(object.contract) : undefined,
      transactionReference: isSet(object.transactionReference) ? globalThis.String(object.transactionReference) : "",
      externalRequestId: isSet(object.externalRequestId) ? globalThis.String(object.externalRequestId) : "",
    };
  },

  toJSON(message: CreateOutgoingDeployContractRequestRequest): unknown {
    const obj: any = {};
    if (message.fromAddressId !== 0) {
      obj.fromAddressId = Math.round(message.fromAddressId);
    }
    if (message.bytecode.length !== 0) {
      obj.bytecode = base64FromBytes(message.bytecode);
    }
    if (message.constructor !== undefined) {
      obj.constructor = ContractCall.toJSON(message.constructor);
    }
    if (message.generateWhitelistedAddress !== false) {
      obj.generateWhitelistedAddress = message.generateWhitelistedAddress;
    }
    if (message.gasLimit !== "") {
      obj.gasLimit = message.gasLimit;
    }
    if (message.gasPriceLimit !== "") {
      obj.gasPriceLimit = message.gasPriceLimit;
    }
    if (message.comment !== "") {
      obj.comment = message.comment;
    }
    if (message.contractType !== "") {
      obj.contractType = message.contractType;
    }
    if (message.feePayerId !== 0) {
      obj.feePayerId = Math.round(message.feePayerId);
    }
    if (message.feeLimit !== "") {
      obj.feeLimit = message.feeLimit;
    }
    if (message.contract !== undefined) {
      obj.contract = GenericCreateContract.toJSON(message.contract);
    }
    if (message.transactionReference !== "") {
      obj.transactionReference = message.transactionReference;
    }
    if (message.externalRequestId !== "") {
      obj.externalRequestId = message.externalRequestId;
    }
    return obj;
  },

  create(base?: DeepPartial<CreateOutgoingDeployContractRequestRequest>): CreateOutgoingDeployContractRequestRequest {
    return CreateOutgoingDeployContractRequestRequest.fromPartial(base ?? {});
  },
  fromPartial(
    object: DeepPartial<CreateOutgoingDeployContractRequestRequest>,
  ): CreateOutgoingDeployContractRequestRequest {
    const message = createBaseCreateOutgoingDeployContractRequestRequest();
    message.fromAddressId = object.fromAddressId ?? 0;
    message.bytecode = object.bytecode ?? new Uint8Array(0);
    message.constructor = (object.constructor !== undefined && object.constructor !== null)
      ? ContractCall.fromPartial(object.constructor)
      : undefined;
    message.generateWhitelistedAddress = object.generateWhitelistedAddress ?? false;
    message.gasLimit = object.gasLimit ?? "";
    message.gasPriceLimit = object.gasPriceLimit ?? "";
    message.comment = object.comment ?? "";
    message.contractType = object.contractType ?? "";
    message.feePayerId = object.feePayerId ?? 0;
    message.feeLimit = object.feeLimit ?? "";
    message.contract = (object.contract !== undefined && object.contract !== null)
      ? GenericCreateContract.fromPartial(object.contract)
      : undefined;
    message.transactionReference = object.transactionReference ?? "";
    message.externalRequestId = object.externalRequestId ?? "";
    return message;
  },
};

function createBaseCreateOutgoingCallContractRequestRequest(): CreateOutgoingCallContractRequestRequest {
  return {
    fromAddressId: 0,
    toWhitelistedAddressId: 0,
    method: undefined,
    gasLimit: "",
    gasPriceLimit: "",
    comment: "",
    contractType: "",
    amount: "",
    feePayerId: 0,
    feeLimit: "",
    call: undefined,
    transactionReference: "",
    externalRequestId: "",
  };
}

export const CreateOutgoingCallContractRequestRequest = {
  encode(message: CreateOutgoingCallContractRequestRequest, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.fromAddressId !== 0) {
      writer.uint32(8).uint64(message.fromAddressId);
    }
    if (message.toWhitelistedAddressId !== 0) {
      writer.uint32(16).uint64(message.toWhitelistedAddressId);
    }
    if (message.method !== undefined) {
      ContractCall.encode(message.method, writer.uint32(26).fork()).ldelim();
    }
    if (message.gasLimit !== "") {
      writer.uint32(34).string(message.gasLimit);
    }
    if (message.gasPriceLimit !== "") {
      writer.uint32(42).string(message.gasPriceLimit);
    }
    if (message.comment !== "") {
      writer.uint32(50).string(message.comment);
    }
    if (message.contractType !== "") {
      writer.uint32(58).string(message.contractType);
    }
    if (message.amount !== "") {
      writer.uint32(66).string(message.amount);
    }
    if (message.feePayerId !== 0) {
      writer.uint32(72).uint64(message.feePayerId);
    }
    if (message.feeLimit !== "") {
      writer.uint32(82).string(message.feeLimit);
    }
    if (message.call !== undefined) {
      GenericContractCall.encode(message.call, writer.uint32(90).fork()).ldelim();
    }
    if (message.transactionReference !== "") {
      writer.uint32(98).string(message.transactionReference);
    }
    if (message.externalRequestId !== "") {
      writer.uint32(106).string(message.externalRequestId);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CreateOutgoingCallContractRequestRequest {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCreateOutgoingCallContractRequestRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.fromAddressId = longToNumber(reader.uint64() as Long);
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.toWhitelistedAddressId = longToNumber(reader.uint64() as Long);
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.method = ContractCall.decode(reader, reader.uint32());
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.gasLimit = reader.string();
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.gasPriceLimit = reader.string();
          continue;
        case 6:
          if (tag !== 50) {
            break;
          }

          message.comment = reader.string();
          continue;
        case 7:
          if (tag !== 58) {
            break;
          }

          message.contractType = reader.string();
          continue;
        case 8:
          if (tag !== 66) {
            break;
          }

          message.amount = reader.string();
          continue;
        case 9:
          if (tag !== 72) {
            break;
          }

          message.feePayerId = longToNumber(reader.uint64() as Long);
          continue;
        case 10:
          if (tag !== 82) {
            break;
          }

          message.feeLimit = reader.string();
          continue;
        case 11:
          if (tag !== 90) {
            break;
          }

          message.call = GenericContractCall.decode(reader, reader.uint32());
          continue;
        case 12:
          if (tag !== 98) {
            break;
          }

          message.transactionReference = reader.string();
          continue;
        case 13:
          if (tag !== 106) {
            break;
          }

          message.externalRequestId = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CreateOutgoingCallContractRequestRequest {
    return {
      fromAddressId: isSet(object.fromAddressId) ? globalThis.Number(object.fromAddressId) : 0,
      toWhitelistedAddressId: isSet(object.toWhitelistedAddressId)
        ? globalThis.Number(object.toWhitelistedAddressId)
        : 0,
      method: isSet(object.method) ? ContractCall.fromJSON(object.method) : undefined,
      gasLimit: isSet(object.gasLimit) ? globalThis.String(object.gasLimit) : "",
      gasPriceLimit: isSet(object.gasPriceLimit) ? globalThis.String(object.gasPriceLimit) : "",
      comment: isSet(object.comment) ? globalThis.String(object.comment) : "",
      contractType: isSet(object.contractType) ? globalThis.String(object.contractType) : "",
      amount: isSet(object.amount) ? globalThis.String(object.amount) : "",
      feePayerId: isSet(object.feePayerId) ? globalThis.Number(object.feePayerId) : 0,
      feeLimit: isSet(object.feeLimit) ? globalThis.String(object.feeLimit) : "",
      call: isSet(object.call) ? GenericContractCall.fromJSON(object.call) : undefined,
      transactionReference: isSet(object.transactionReference) ? globalThis.String(object.transactionReference) : "",
      externalRequestId: isSet(object.externalRequestId) ? globalThis.String(object.externalRequestId) : "",
    };
  },

  toJSON(message: CreateOutgoingCallContractRequestRequest): unknown {
    const obj: any = {};
    if (message.fromAddressId !== 0) {
      obj.fromAddressId = Math.round(message.fromAddressId);
    }
    if (message.toWhitelistedAddressId !== 0) {
      obj.toWhitelistedAddressId = Math.round(message.toWhitelistedAddressId);
    }
    if (message.method !== undefined) {
      obj.method = ContractCall.toJSON(message.method);
    }
    if (message.gasLimit !== "") {
      obj.gasLimit = message.gasLimit;
    }
    if (message.gasPriceLimit !== "") {
      obj.gasPriceLimit = message.gasPriceLimit;
    }
    if (message.comment !== "") {
      obj.comment = message.comment;
    }
    if (message.contractType !== "") {
      obj.contractType = message.contractType;
    }
    if (message.amount !== "") {
      obj.amount = message.amount;
    }
    if (message.feePayerId !== 0) {
      obj.feePayerId = Math.round(message.feePayerId);
    }
    if (message.feeLimit !== "") {
      obj.feeLimit = message.feeLimit;
    }
    if (message.call !== undefined) {
      obj.call = GenericContractCall.toJSON(message.call);
    }
    if (message.transactionReference !== "") {
      obj.transactionReference = message.transactionReference;
    }
    if (message.externalRequestId !== "") {
      obj.externalRequestId = message.externalRequestId;
    }
    return obj;
  },

  create(base?: DeepPartial<CreateOutgoingCallContractRequestRequest>): CreateOutgoingCallContractRequestRequest {
    return CreateOutgoingCallContractRequestRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CreateOutgoingCallContractRequestRequest>): CreateOutgoingCallContractRequestRequest {
    const message = createBaseCreateOutgoingCallContractRequestRequest();
    message.fromAddressId = object.fromAddressId ?? 0;
    message.toWhitelistedAddressId = object.toWhitelistedAddressId ?? 0;
    message.method = (object.method !== undefined && object.method !== null)
      ? ContractCall.fromPartial(object.method)
      : undefined;
    message.gasLimit = object.gasLimit ?? "";
    message.gasPriceLimit = object.gasPriceLimit ?? "";
    message.comment = object.comment ?? "";
    message.contractType = object.contractType ?? "";
    message.amount = object.amount ?? "";
    message.feePayerId = object.feePayerId ?? 0;
    message.feeLimit = object.feeLimit ?? "";
    message.call = (object.call !== undefined && object.call !== null)
      ? GenericContractCall.fromPartial(object.call)
      : undefined;
    message.transactionReference = object.transactionReference ?? "";
    message.externalRequestId = object.externalRequestId ?? "";
    return message;
  },
};

function createBaseCreateOutgoingCosmosGenericRequestRequest(): CreateOutgoingCosmosGenericRequestRequest {
  return {
    chainId: "",
    signers: [],
    feeDenom: "",
    fee: "",
    feePayer: "",
    gasLimit: 0,
    messages: [],
    comment: "",
    useUnconfirmedFunds: false,
    transactionReference: "",
    broadcastKind: "",
    accountsInfo: [],
    memo: "",
    externalRequestId: "",
  };
}

export const CreateOutgoingCosmosGenericRequestRequest = {
  encode(message: CreateOutgoingCosmosGenericRequestRequest, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.chainId !== "") {
      writer.uint32(10).string(message.chainId);
    }
    writer.uint32(18).fork();
    for (const v of message.signers) {
      writer.uint64(v);
    }
    writer.ldelim();
    if (message.feeDenom !== "") {
      writer.uint32(26).string(message.feeDenom);
    }
    if (message.fee !== "") {
      writer.uint32(34).string(message.fee);
    }
    if (message.feePayer !== "") {
      writer.uint32(42).string(message.feePayer);
    }
    if (message.gasLimit !== 0) {
      writer.uint32(48).uint64(message.gasLimit);
    }
    for (const v of message.messages) {
      CosmosMessageCall.encode(v!, writer.uint32(58).fork()).ldelim();
    }
    if (message.comment !== "") {
      writer.uint32(66).string(message.comment);
    }
    if (message.useUnconfirmedFunds !== false) {
      writer.uint32(72).bool(message.useUnconfirmedFunds);
    }
    if (message.transactionReference !== "") {
      writer.uint32(82).string(message.transactionReference);
    }
    if (message.broadcastKind !== "") {
      writer.uint32(90).string(message.broadcastKind);
    }
    for (const v of message.accountsInfo) {
      CreateOutgoingCosmosGenericRequestRequest_AccountInfo.encode(v!, writer.uint32(98).fork()).ldelim();
    }
    if (message.memo !== "") {
      writer.uint32(106).string(message.memo);
    }
    if (message.externalRequestId !== "") {
      writer.uint32(114).string(message.externalRequestId);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CreateOutgoingCosmosGenericRequestRequest {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCreateOutgoingCosmosGenericRequestRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.chainId = reader.string();
          continue;
        case 2:
          if (tag === 16) {
            message.signers.push(longToNumber(reader.uint64() as Long));

            continue;
          }

          if (tag === 18) {
            const end2 = reader.uint32() + reader.pos;
            while (reader.pos < end2) {
              message.signers.push(longToNumber(reader.uint64() as Long));
            }

            continue;
          }

          break;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.feeDenom = reader.string();
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.fee = reader.string();
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.feePayer = reader.string();
          continue;
        case 6:
          if (tag !== 48) {
            break;
          }

          message.gasLimit = longToNumber(reader.uint64() as Long);
          continue;
        case 7:
          if (tag !== 58) {
            break;
          }

          message.messages.push(CosmosMessageCall.decode(reader, reader.uint32()));
          continue;
        case 8:
          if (tag !== 66) {
            break;
          }

          message.comment = reader.string();
          continue;
        case 9:
          if (tag !== 72) {
            break;
          }

          message.useUnconfirmedFunds = reader.bool();
          continue;
        case 10:
          if (tag !== 82) {
            break;
          }

          message.transactionReference = reader.string();
          continue;
        case 11:
          if (tag !== 90) {
            break;
          }

          message.broadcastKind = reader.string();
          continue;
        case 12:
          if (tag !== 98) {
            break;
          }

          message.accountsInfo.push(
            CreateOutgoingCosmosGenericRequestRequest_AccountInfo.decode(reader, reader.uint32()),
          );
          continue;
        case 13:
          if (tag !== 106) {
            break;
          }

          message.memo = reader.string();
          continue;
        case 14:
          if (tag !== 114) {
            break;
          }

          message.externalRequestId = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CreateOutgoingCosmosGenericRequestRequest {
    return {
      chainId: isSet(object.chainId) ? globalThis.String(object.chainId) : "",
      signers: globalThis.Array.isArray(object?.signers) ? object.signers.map((e: any) => globalThis.Number(e)) : [],
      feeDenom: isSet(object.feeDenom) ? globalThis.String(object.feeDenom) : "",
      fee: isSet(object.fee) ? globalThis.String(object.fee) : "",
      feePayer: isSet(object.feePayer) ? globalThis.String(object.feePayer) : "",
      gasLimit: isSet(object.gasLimit) ? globalThis.Number(object.gasLimit) : 0,
      messages: globalThis.Array.isArray(object?.messages)
        ? object.messages.map((e: any) => CosmosMessageCall.fromJSON(e))
        : [],
      comment: isSet(object.comment) ? globalThis.String(object.comment) : "",
      useUnconfirmedFunds: isSet(object.useUnconfirmedFunds) ? globalThis.Boolean(object.useUnconfirmedFunds) : false,
      transactionReference: isSet(object.transactionReference) ? globalThis.String(object.transactionReference) : "",
      broadcastKind: isSet(object.broadcastKind) ? globalThis.String(object.broadcastKind) : "",
      accountsInfo: globalThis.Array.isArray(object?.accountsInfo)
        ? object.accountsInfo.map((e: any) => CreateOutgoingCosmosGenericRequestRequest_AccountInfo.fromJSON(e))
        : [],
      memo: isSet(object.memo) ? globalThis.String(object.memo) : "",
      externalRequestId: isSet(object.externalRequestId) ? globalThis.String(object.externalRequestId) : "",
    };
  },

  toJSON(message: CreateOutgoingCosmosGenericRequestRequest): unknown {
    const obj: any = {};
    if (message.chainId !== "") {
      obj.chainId = message.chainId;
    }
    if (message.signers?.length) {
      obj.signers = message.signers.map((e) => Math.round(e));
    }
    if (message.feeDenom !== "") {
      obj.feeDenom = message.feeDenom;
    }
    if (message.fee !== "") {
      obj.fee = message.fee;
    }
    if (message.feePayer !== "") {
      obj.feePayer = message.feePayer;
    }
    if (message.gasLimit !== 0) {
      obj.gasLimit = Math.round(message.gasLimit);
    }
    if (message.messages?.length) {
      obj.messages = message.messages.map((e) => CosmosMessageCall.toJSON(e));
    }
    if (message.comment !== "") {
      obj.comment = message.comment;
    }
    if (message.useUnconfirmedFunds !== false) {
      obj.useUnconfirmedFunds = message.useUnconfirmedFunds;
    }
    if (message.transactionReference !== "") {
      obj.transactionReference = message.transactionReference;
    }
    if (message.broadcastKind !== "") {
      obj.broadcastKind = message.broadcastKind;
    }
    if (message.accountsInfo?.length) {
      obj.accountsInfo = message.accountsInfo.map((e) =>
        CreateOutgoingCosmosGenericRequestRequest_AccountInfo.toJSON(e)
      );
    }
    if (message.memo !== "") {
      obj.memo = message.memo;
    }
    if (message.externalRequestId !== "") {
      obj.externalRequestId = message.externalRequestId;
    }
    return obj;
  },

  create(base?: DeepPartial<CreateOutgoingCosmosGenericRequestRequest>): CreateOutgoingCosmosGenericRequestRequest {
    return CreateOutgoingCosmosGenericRequestRequest.fromPartial(base ?? {});
  },
  fromPartial(
    object: DeepPartial<CreateOutgoingCosmosGenericRequestRequest>,
  ): CreateOutgoingCosmosGenericRequestRequest {
    const message = createBaseCreateOutgoingCosmosGenericRequestRequest();
    message.chainId = object.chainId ?? "";
    message.signers = object.signers?.map((e) => e) || [];
    message.feeDenom = object.feeDenom ?? "";
    message.fee = object.fee ?? "";
    message.feePayer = object.feePayer ?? "";
    message.gasLimit = object.gasLimit ?? 0;
    message.messages = object.messages?.map((e) => CosmosMessageCall.fromPartial(e)) || [];
    message.comment = object.comment ?? "";
    message.useUnconfirmedFunds = object.useUnconfirmedFunds ?? false;
    message.transactionReference = object.transactionReference ?? "";
    message.broadcastKind = object.broadcastKind ?? "";
    message.accountsInfo =
      object.accountsInfo?.map((e) => CreateOutgoingCosmosGenericRequestRequest_AccountInfo.fromPartial(e)) || [];
    message.memo = object.memo ?? "";
    message.externalRequestId = object.externalRequestId ?? "";
    return message;
  },
};

function createBaseCreateOutgoingCosmosGenericRequestRequest_AccountInfo(): CreateOutgoingCosmosGenericRequestRequest_AccountInfo {
  return { sequence: 0, accountNumber: 0 };
}

export const CreateOutgoingCosmosGenericRequestRequest_AccountInfo = {
  encode(
    message: CreateOutgoingCosmosGenericRequestRequest_AccountInfo,
    writer: _m0.Writer = _m0.Writer.create(),
  ): _m0.Writer {
    if (message.sequence !== 0) {
      writer.uint32(8).uint64(message.sequence);
    }
    if (message.accountNumber !== 0) {
      writer.uint32(16).uint64(message.accountNumber);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CreateOutgoingCosmosGenericRequestRequest_AccountInfo {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCreateOutgoingCosmosGenericRequestRequest_AccountInfo();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.sequence = longToNumber(reader.uint64() as Long);
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.accountNumber = longToNumber(reader.uint64() as Long);
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CreateOutgoingCosmosGenericRequestRequest_AccountInfo {
    return {
      sequence: isSet(object.sequence) ? globalThis.Number(object.sequence) : 0,
      accountNumber: isSet(object.accountNumber) ? globalThis.Number(object.accountNumber) : 0,
    };
  },

  toJSON(message: CreateOutgoingCosmosGenericRequestRequest_AccountInfo): unknown {
    const obj: any = {};
    if (message.sequence !== 0) {
      obj.sequence = Math.round(message.sequence);
    }
    if (message.accountNumber !== 0) {
      obj.accountNumber = Math.round(message.accountNumber);
    }
    return obj;
  },

  create(
    base?: DeepPartial<CreateOutgoingCosmosGenericRequestRequest_AccountInfo>,
  ): CreateOutgoingCosmosGenericRequestRequest_AccountInfo {
    return CreateOutgoingCosmosGenericRequestRequest_AccountInfo.fromPartial(base ?? {});
  },
  fromPartial(
    object: DeepPartial<CreateOutgoingCosmosGenericRequestRequest_AccountInfo>,
  ): CreateOutgoingCosmosGenericRequestRequest_AccountInfo {
    const message = createBaseCreateOutgoingCosmosGenericRequestRequest_AccountInfo();
    message.sequence = object.sequence ?? 0;
    message.accountNumber = object.accountNumber ?? 0;
    return message;
  },
};

function createBaseCreateOutgoingXLMMintAssetRequestRequest(): CreateOutgoingXLMMintAssetRequestRequest {
  return {
    amount: "",
    feeLimit: "",
    fromAddressId: 0,
    toAddressId: 0,
    toWhitelistedAddressId: 0,
    comment: "",
    externalRequestId: "",
    destinationAddressMemo: "",
  };
}

export const CreateOutgoingXLMMintAssetRequestRequest = {
  encode(message: CreateOutgoingXLMMintAssetRequestRequest, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.amount !== "") {
      writer.uint32(10).string(message.amount);
    }
    if (message.feeLimit !== "") {
      writer.uint32(18).string(message.feeLimit);
    }
    if (message.fromAddressId !== 0) {
      writer.uint32(24).uint64(message.fromAddressId);
    }
    if (message.toAddressId !== 0) {
      writer.uint32(32).uint64(message.toAddressId);
    }
    if (message.toWhitelistedAddressId !== 0) {
      writer.uint32(40).uint64(message.toWhitelistedAddressId);
    }
    if (message.comment !== "") {
      writer.uint32(50).string(message.comment);
    }
    if (message.externalRequestId !== "") {
      writer.uint32(66).string(message.externalRequestId);
    }
    if (message.destinationAddressMemo !== "") {
      writer.uint32(74).string(message.destinationAddressMemo);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CreateOutgoingXLMMintAssetRequestRequest {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCreateOutgoingXLMMintAssetRequestRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.amount = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.feeLimit = reader.string();
          continue;
        case 3:
          if (tag !== 24) {
            break;
          }

          message.fromAddressId = longToNumber(reader.uint64() as Long);
          continue;
        case 4:
          if (tag !== 32) {
            break;
          }

          message.toAddressId = longToNumber(reader.uint64() as Long);
          continue;
        case 5:
          if (tag !== 40) {
            break;
          }

          message.toWhitelistedAddressId = longToNumber(reader.uint64() as Long);
          continue;
        case 6:
          if (tag !== 50) {
            break;
          }

          message.comment = reader.string();
          continue;
        case 8:
          if (tag !== 66) {
            break;
          }

          message.externalRequestId = reader.string();
          continue;
        case 9:
          if (tag !== 74) {
            break;
          }

          message.destinationAddressMemo = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CreateOutgoingXLMMintAssetRequestRequest {
    return {
      amount: isSet(object.amount) ? globalThis.String(object.amount) : "",
      feeLimit: isSet(object.feeLimit) ? globalThis.String(object.feeLimit) : "",
      fromAddressId: isSet(object.fromAddressId) ? globalThis.Number(object.fromAddressId) : 0,
      toAddressId: isSet(object.toAddressId) ? globalThis.Number(object.toAddressId) : 0,
      toWhitelistedAddressId: isSet(object.toWhitelistedAddressId)
        ? globalThis.Number(object.toWhitelistedAddressId)
        : 0,
      comment: isSet(object.comment) ? globalThis.String(object.comment) : "",
      externalRequestId: isSet(object.externalRequestId) ? globalThis.String(object.externalRequestId) : "",
      destinationAddressMemo: isSet(object.destinationAddressMemo)
        ? globalThis.String(object.destinationAddressMemo)
        : "",
    };
  },

  toJSON(message: CreateOutgoingXLMMintAssetRequestRequest): unknown {
    const obj: any = {};
    if (message.amount !== "") {
      obj.amount = message.amount;
    }
    if (message.feeLimit !== "") {
      obj.feeLimit = message.feeLimit;
    }
    if (message.fromAddressId !== 0) {
      obj.fromAddressId = Math.round(message.fromAddressId);
    }
    if (message.toAddressId !== 0) {
      obj.toAddressId = Math.round(message.toAddressId);
    }
    if (message.toWhitelistedAddressId !== 0) {
      obj.toWhitelistedAddressId = Math.round(message.toWhitelistedAddressId);
    }
    if (message.comment !== "") {
      obj.comment = message.comment;
    }
    if (message.externalRequestId !== "") {
      obj.externalRequestId = message.externalRequestId;
    }
    if (message.destinationAddressMemo !== "") {
      obj.destinationAddressMemo = message.destinationAddressMemo;
    }
    return obj;
  },

  create(base?: DeepPartial<CreateOutgoingXLMMintAssetRequestRequest>): CreateOutgoingXLMMintAssetRequestRequest {
    return CreateOutgoingXLMMintAssetRequestRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CreateOutgoingXLMMintAssetRequestRequest>): CreateOutgoingXLMMintAssetRequestRequest {
    const message = createBaseCreateOutgoingXLMMintAssetRequestRequest();
    message.amount = object.amount ?? "";
    message.feeLimit = object.feeLimit ?? "";
    message.fromAddressId = object.fromAddressId ?? 0;
    message.toAddressId = object.toAddressId ?? 0;
    message.toWhitelistedAddressId = object.toWhitelistedAddressId ?? 0;
    message.comment = object.comment ?? "";
    message.externalRequestId = object.externalRequestId ?? "";
    message.destinationAddressMemo = object.destinationAddressMemo ?? "";
    return message;
  },
};

function createBaseCreateOutgoingXLMChangeTrustRequestRequest(): CreateOutgoingXLMChangeTrustRequestRequest {
  return {
    fromAddressId: 0,
    trustlineLimit: 0,
    feeLimit: "",
    comment: "",
    poolID: "",
    externalRequestId: "",
    sponsoredByAddressId: 0,
  };
}

export const CreateOutgoingXLMChangeTrustRequestRequest = {
  encode(message: CreateOutgoingXLMChangeTrustRequestRequest, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.fromAddressId !== 0) {
      writer.uint32(8).uint64(message.fromAddressId);
    }
    if (message.trustlineLimit !== 0) {
      writer.uint32(16).uint64(message.trustlineLimit);
    }
    if (message.feeLimit !== "") {
      writer.uint32(26).string(message.feeLimit);
    }
    if (message.comment !== "") {
      writer.uint32(34).string(message.comment);
    }
    if (message.poolID !== "") {
      writer.uint32(58).string(message.poolID);
    }
    if (message.externalRequestId !== "") {
      writer.uint32(42).string(message.externalRequestId);
    }
    if (message.sponsoredByAddressId !== 0) {
      writer.uint32(48).uint64(message.sponsoredByAddressId);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CreateOutgoingXLMChangeTrustRequestRequest {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCreateOutgoingXLMChangeTrustRequestRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.fromAddressId = longToNumber(reader.uint64() as Long);
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.trustlineLimit = longToNumber(reader.uint64() as Long);
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.feeLimit = reader.string();
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.comment = reader.string();
          continue;
        case 7:
          if (tag !== 58) {
            break;
          }

          message.poolID = reader.string();
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.externalRequestId = reader.string();
          continue;
        case 6:
          if (tag !== 48) {
            break;
          }

          message.sponsoredByAddressId = longToNumber(reader.uint64() as Long);
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CreateOutgoingXLMChangeTrustRequestRequest {
    return {
      fromAddressId: isSet(object.fromAddressId) ? globalThis.Number(object.fromAddressId) : 0,
      trustlineLimit: isSet(object.trustlineLimit) ? globalThis.Number(object.trustlineLimit) : 0,
      feeLimit: isSet(object.feeLimit) ? globalThis.String(object.feeLimit) : "",
      comment: isSet(object.comment) ? globalThis.String(object.comment) : "",
      poolID: isSet(object.poolID) ? globalThis.String(object.poolID) : "",
      externalRequestId: isSet(object.externalRequestId) ? globalThis.String(object.externalRequestId) : "",
      sponsoredByAddressId: isSet(object.sponsoredByAddressId) ? globalThis.Number(object.sponsoredByAddressId) : 0,
    };
  },

  toJSON(message: CreateOutgoingXLMChangeTrustRequestRequest): unknown {
    const obj: any = {};
    if (message.fromAddressId !== 0) {
      obj.fromAddressId = Math.round(message.fromAddressId);
    }
    if (message.trustlineLimit !== 0) {
      obj.trustlineLimit = Math.round(message.trustlineLimit);
    }
    if (message.feeLimit !== "") {
      obj.feeLimit = message.feeLimit;
    }
    if (message.comment !== "") {
      obj.comment = message.comment;
    }
    if (message.poolID !== "") {
      obj.poolID = message.poolID;
    }
    if (message.externalRequestId !== "") {
      obj.externalRequestId = message.externalRequestId;
    }
    if (message.sponsoredByAddressId !== 0) {
      obj.sponsoredByAddressId = Math.round(message.sponsoredByAddressId);
    }
    return obj;
  },

  create(base?: DeepPartial<CreateOutgoingXLMChangeTrustRequestRequest>): CreateOutgoingXLMChangeTrustRequestRequest {
    return CreateOutgoingXLMChangeTrustRequestRequest.fromPartial(base ?? {});
  },
  fromPartial(
    object: DeepPartial<CreateOutgoingXLMChangeTrustRequestRequest>,
  ): CreateOutgoingXLMChangeTrustRequestRequest {
    const message = createBaseCreateOutgoingXLMChangeTrustRequestRequest();
    message.fromAddressId = object.fromAddressId ?? 0;
    message.trustlineLimit = object.trustlineLimit ?? 0;
    message.feeLimit = object.feeLimit ?? "";
    message.comment = object.comment ?? "";
    message.poolID = object.poolID ?? "";
    message.externalRequestId = object.externalRequestId ?? "";
    message.sponsoredByAddressId = object.sponsoredByAddressId ?? 0;
    return message;
  },
};

function createBaseCreateOutgoingXLMManageDataRequestRequest(): CreateOutgoingXLMManageDataRequestRequest {
  return {
    fromAddressId: 0,
    dataName: "",
    dataValue: "",
    feeLimit: "",
    comment: "",
    externalRequestId: "",
    sponsoredByAddressId: 0,
  };
}

export const CreateOutgoingXLMManageDataRequestRequest = {
  encode(message: CreateOutgoingXLMManageDataRequestRequest, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.fromAddressId !== 0) {
      writer.uint32(8).uint64(message.fromAddressId);
    }
    if (message.dataName !== "") {
      writer.uint32(18).string(message.dataName);
    }
    if (message.dataValue !== "") {
      writer.uint32(26).string(message.dataValue);
    }
    if (message.feeLimit !== "") {
      writer.uint32(42).string(message.feeLimit);
    }
    if (message.comment !== "") {
      writer.uint32(50).string(message.comment);
    }
    if (message.externalRequestId !== "") {
      writer.uint32(58).string(message.externalRequestId);
    }
    if (message.sponsoredByAddressId !== 0) {
      writer.uint32(64).uint64(message.sponsoredByAddressId);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CreateOutgoingXLMManageDataRequestRequest {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCreateOutgoingXLMManageDataRequestRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.fromAddressId = longToNumber(reader.uint64() as Long);
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.dataName = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.dataValue = reader.string();
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.feeLimit = reader.string();
          continue;
        case 6:
          if (tag !== 50) {
            break;
          }

          message.comment = reader.string();
          continue;
        case 7:
          if (tag !== 58) {
            break;
          }

          message.externalRequestId = reader.string();
          continue;
        case 8:
          if (tag !== 64) {
            break;
          }

          message.sponsoredByAddressId = longToNumber(reader.uint64() as Long);
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CreateOutgoingXLMManageDataRequestRequest {
    return {
      fromAddressId: isSet(object.fromAddressId) ? globalThis.Number(object.fromAddressId) : 0,
      dataName: isSet(object.dataName) ? globalThis.String(object.dataName) : "",
      dataValue: isSet(object.dataValue) ? globalThis.String(object.dataValue) : "",
      feeLimit: isSet(object.feeLimit) ? globalThis.String(object.feeLimit) : "",
      comment: isSet(object.comment) ? globalThis.String(object.comment) : "",
      externalRequestId: isSet(object.externalRequestId) ? globalThis.String(object.externalRequestId) : "",
      sponsoredByAddressId: isSet(object.sponsoredByAddressId) ? globalThis.Number(object.sponsoredByAddressId) : 0,
    };
  },

  toJSON(message: CreateOutgoingXLMManageDataRequestRequest): unknown {
    const obj: any = {};
    if (message.fromAddressId !== 0) {
      obj.fromAddressId = Math.round(message.fromAddressId);
    }
    if (message.dataName !== "") {
      obj.dataName = message.dataName;
    }
    if (message.dataValue !== "") {
      obj.dataValue = message.dataValue;
    }
    if (message.feeLimit !== "") {
      obj.feeLimit = message.feeLimit;
    }
    if (message.comment !== "") {
      obj.comment = message.comment;
    }
    if (message.externalRequestId !== "") {
      obj.externalRequestId = message.externalRequestId;
    }
    if (message.sponsoredByAddressId !== 0) {
      obj.sponsoredByAddressId = Math.round(message.sponsoredByAddressId);
    }
    return obj;
  },

  create(base?: DeepPartial<CreateOutgoingXLMManageDataRequestRequest>): CreateOutgoingXLMManageDataRequestRequest {
    return CreateOutgoingXLMManageDataRequestRequest.fromPartial(base ?? {});
  },
  fromPartial(
    object: DeepPartial<CreateOutgoingXLMManageDataRequestRequest>,
  ): CreateOutgoingXLMManageDataRequestRequest {
    const message = createBaseCreateOutgoingXLMManageDataRequestRequest();
    message.fromAddressId = object.fromAddressId ?? 0;
    message.dataName = object.dataName ?? "";
    message.dataValue = object.dataValue ?? "";
    message.feeLimit = object.feeLimit ?? "";
    message.comment = object.comment ?? "";
    message.externalRequestId = object.externalRequestId ?? "";
    message.sponsoredByAddressId = object.sponsoredByAddressId ?? 0;
    return message;
  },
};

function createBaseCreateOutgoingXLMSetOptionsRequestRequest(): CreateOutgoingXLMSetOptionsRequestRequest {
  return { fromAddressId: 0, setFlags: [], clearFlags: [], feeLimit: "", comment: "", externalRequestId: "" };
}

export const CreateOutgoingXLMSetOptionsRequestRequest = {
  encode(message: CreateOutgoingXLMSetOptionsRequestRequest, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.fromAddressId !== 0) {
      writer.uint32(8).uint64(message.fromAddressId);
    }
    for (const v of message.setFlags) {
      writer.uint32(18).string(v!);
    }
    for (const v of message.clearFlags) {
      writer.uint32(26).string(v!);
    }
    if (message.feeLimit !== "") {
      writer.uint32(34).string(message.feeLimit);
    }
    if (message.comment !== "") {
      writer.uint32(42).string(message.comment);
    }
    if (message.externalRequestId !== "") {
      writer.uint32(50).string(message.externalRequestId);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CreateOutgoingXLMSetOptionsRequestRequest {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCreateOutgoingXLMSetOptionsRequestRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.fromAddressId = longToNumber(reader.uint64() as Long);
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.setFlags.push(reader.string());
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.clearFlags.push(reader.string());
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.feeLimit = reader.string();
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.comment = reader.string();
          continue;
        case 6:
          if (tag !== 50) {
            break;
          }

          message.externalRequestId = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CreateOutgoingXLMSetOptionsRequestRequest {
    return {
      fromAddressId: isSet(object.fromAddressId) ? globalThis.Number(object.fromAddressId) : 0,
      setFlags: globalThis.Array.isArray(object?.setFlags) ? object.setFlags.map((e: any) => globalThis.String(e)) : [],
      clearFlags: globalThis.Array.isArray(object?.clearFlags)
        ? object.clearFlags.map((e: any) => globalThis.String(e))
        : [],
      feeLimit: isSet(object.feeLimit) ? globalThis.String(object.feeLimit) : "",
      comment: isSet(object.comment) ? globalThis.String(object.comment) : "",
      externalRequestId: isSet(object.externalRequestId) ? globalThis.String(object.externalRequestId) : "",
    };
  },

  toJSON(message: CreateOutgoingXLMSetOptionsRequestRequest): unknown {
    const obj: any = {};
    if (message.fromAddressId !== 0) {
      obj.fromAddressId = Math.round(message.fromAddressId);
    }
    if (message.setFlags?.length) {
      obj.setFlags = message.setFlags;
    }
    if (message.clearFlags?.length) {
      obj.clearFlags = message.clearFlags;
    }
    if (message.feeLimit !== "") {
      obj.feeLimit = message.feeLimit;
    }
    if (message.comment !== "") {
      obj.comment = message.comment;
    }
    if (message.externalRequestId !== "") {
      obj.externalRequestId = message.externalRequestId;
    }
    return obj;
  },

  create(base?: DeepPartial<CreateOutgoingXLMSetOptionsRequestRequest>): CreateOutgoingXLMSetOptionsRequestRequest {
    return CreateOutgoingXLMSetOptionsRequestRequest.fromPartial(base ?? {});
  },
  fromPartial(
    object: DeepPartial<CreateOutgoingXLMSetOptionsRequestRequest>,
  ): CreateOutgoingXLMSetOptionsRequestRequest {
    const message = createBaseCreateOutgoingXLMSetOptionsRequestRequest();
    message.fromAddressId = object.fromAddressId ?? 0;
    message.setFlags = object.setFlags?.map((e) => e) || [];
    message.clearFlags = object.clearFlags?.map((e) => e) || [];
    message.feeLimit = object.feeLimit ?? "";
    message.comment = object.comment ?? "";
    message.externalRequestId = object.externalRequestId ?? "";
    return message;
  },
};

function createBaseCreateOutgoingICPTransferToStakeRequestRequest(): CreateOutgoingICPTransferToStakeRequestRequest {
  return { fromAddressId: 0, amount: "", comment: "", externalRequestId: "" };
}

export const CreateOutgoingICPTransferToStakeRequestRequest = {
  encode(
    message: CreateOutgoingICPTransferToStakeRequestRequest,
    writer: _m0.Writer = _m0.Writer.create(),
  ): _m0.Writer {
    if (message.fromAddressId !== 0) {
      writer.uint32(8).uint64(message.fromAddressId);
    }
    if (message.amount !== "") {
      writer.uint32(18).string(message.amount);
    }
    if (message.comment !== "") {
      writer.uint32(26).string(message.comment);
    }
    if (message.externalRequestId !== "") {
      writer.uint32(34).string(message.externalRequestId);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CreateOutgoingICPTransferToStakeRequestRequest {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCreateOutgoingICPTransferToStakeRequestRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.fromAddressId = longToNumber(reader.uint64() as Long);
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.amount = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.comment = reader.string();
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.externalRequestId = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CreateOutgoingICPTransferToStakeRequestRequest {
    return {
      fromAddressId: isSet(object.fromAddressId) ? globalThis.Number(object.fromAddressId) : 0,
      amount: isSet(object.amount) ? globalThis.String(object.amount) : "",
      comment: isSet(object.comment) ? globalThis.String(object.comment) : "",
      externalRequestId: isSet(object.externalRequestId) ? globalThis.String(object.externalRequestId) : "",
    };
  },

  toJSON(message: CreateOutgoingICPTransferToStakeRequestRequest): unknown {
    const obj: any = {};
    if (message.fromAddressId !== 0) {
      obj.fromAddressId = Math.round(message.fromAddressId);
    }
    if (message.amount !== "") {
      obj.amount = message.amount;
    }
    if (message.comment !== "") {
      obj.comment = message.comment;
    }
    if (message.externalRequestId !== "") {
      obj.externalRequestId = message.externalRequestId;
    }
    return obj;
  },

  create(
    base?: DeepPartial<CreateOutgoingICPTransferToStakeRequestRequest>,
  ): CreateOutgoingICPTransferToStakeRequestRequest {
    return CreateOutgoingICPTransferToStakeRequestRequest.fromPartial(base ?? {});
  },
  fromPartial(
    object: DeepPartial<CreateOutgoingICPTransferToStakeRequestRequest>,
  ): CreateOutgoingICPTransferToStakeRequestRequest {
    const message = createBaseCreateOutgoingICPTransferToStakeRequestRequest();
    message.fromAddressId = object.fromAddressId ?? 0;
    message.amount = object.amount ?? "";
    message.comment = object.comment ?? "";
    message.externalRequestId = object.externalRequestId ?? "";
    return message;
  },
};

function createBaseCreateOutgoingICPSetDissolveDelayRequestRequest(): CreateOutgoingICPSetDissolveDelayRequestRequest {
  return { fromAddressId: 0, delay: 0, comment: "", externalRequestId: "" };
}

export const CreateOutgoingICPSetDissolveDelayRequestRequest = {
  encode(
    message: CreateOutgoingICPSetDissolveDelayRequestRequest,
    writer: _m0.Writer = _m0.Writer.create(),
  ): _m0.Writer {
    if (message.fromAddressId !== 0) {
      writer.uint32(8).uint64(message.fromAddressId);
    }
    if (message.delay !== 0) {
      writer.uint32(16).uint32(message.delay);
    }
    if (message.comment !== "") {
      writer.uint32(26).string(message.comment);
    }
    if (message.externalRequestId !== "") {
      writer.uint32(34).string(message.externalRequestId);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CreateOutgoingICPSetDissolveDelayRequestRequest {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCreateOutgoingICPSetDissolveDelayRequestRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.fromAddressId = longToNumber(reader.uint64() as Long);
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.delay = reader.uint32();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.comment = reader.string();
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.externalRequestId = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CreateOutgoingICPSetDissolveDelayRequestRequest {
    return {
      fromAddressId: isSet(object.fromAddressId) ? globalThis.Number(object.fromAddressId) : 0,
      delay: isSet(object.delay) ? globalThis.Number(object.delay) : 0,
      comment: isSet(object.comment) ? globalThis.String(object.comment) : "",
      externalRequestId: isSet(object.externalRequestId) ? globalThis.String(object.externalRequestId) : "",
    };
  },

  toJSON(message: CreateOutgoingICPSetDissolveDelayRequestRequest): unknown {
    const obj: any = {};
    if (message.fromAddressId !== 0) {
      obj.fromAddressId = Math.round(message.fromAddressId);
    }
    if (message.delay !== 0) {
      obj.delay = Math.round(message.delay);
    }
    if (message.comment !== "") {
      obj.comment = message.comment;
    }
    if (message.externalRequestId !== "") {
      obj.externalRequestId = message.externalRequestId;
    }
    return obj;
  },

  create(
    base?: DeepPartial<CreateOutgoingICPSetDissolveDelayRequestRequest>,
  ): CreateOutgoingICPSetDissolveDelayRequestRequest {
    return CreateOutgoingICPSetDissolveDelayRequestRequest.fromPartial(base ?? {});
  },
  fromPartial(
    object: DeepPartial<CreateOutgoingICPSetDissolveDelayRequestRequest>,
  ): CreateOutgoingICPSetDissolveDelayRequestRequest {
    const message = createBaseCreateOutgoingICPSetDissolveDelayRequestRequest();
    message.fromAddressId = object.fromAddressId ?? 0;
    message.delay = object.delay ?? 0;
    message.comment = object.comment ?? "";
    message.externalRequestId = object.externalRequestId ?? "";
    return message;
  },
};

function createBaseCreateOutgoingICPFollowRequestRequest(): CreateOutgoingICPFollowRequestRequest {
  return { fromAddressId: 0, neuronWhitelistedAddressIds: [], topic: "", comment: "", externalRequestId: "" };
}

export const CreateOutgoingICPFollowRequestRequest = {
  encode(message: CreateOutgoingICPFollowRequestRequest, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.fromAddressId !== 0) {
      writer.uint32(8).uint64(message.fromAddressId);
    }
    writer.uint32(18).fork();
    for (const v of message.neuronWhitelistedAddressIds) {
      writer.uint64(v);
    }
    writer.ldelim();
    if (message.topic !== "") {
      writer.uint32(26).string(message.topic);
    }
    if (message.comment !== "") {
      writer.uint32(34).string(message.comment);
    }
    if (message.externalRequestId !== "") {
      writer.uint32(42).string(message.externalRequestId);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CreateOutgoingICPFollowRequestRequest {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCreateOutgoingICPFollowRequestRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.fromAddressId = longToNumber(reader.uint64() as Long);
          continue;
        case 2:
          if (tag === 16) {
            message.neuronWhitelistedAddressIds.push(longToNumber(reader.uint64() as Long));

            continue;
          }

          if (tag === 18) {
            const end2 = reader.uint32() + reader.pos;
            while (reader.pos < end2) {
              message.neuronWhitelistedAddressIds.push(longToNumber(reader.uint64() as Long));
            }

            continue;
          }

          break;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.topic = reader.string();
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.comment = reader.string();
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.externalRequestId = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CreateOutgoingICPFollowRequestRequest {
    return {
      fromAddressId: isSet(object.fromAddressId) ? globalThis.Number(object.fromAddressId) : 0,
      neuronWhitelistedAddressIds: globalThis.Array.isArray(object?.neuronWhitelistedAddressIds)
        ? object.neuronWhitelistedAddressIds.map((e: any) => globalThis.Number(e))
        : [],
      topic: isSet(object.topic) ? globalThis.String(object.topic) : "",
      comment: isSet(object.comment) ? globalThis.String(object.comment) : "",
      externalRequestId: isSet(object.externalRequestId) ? globalThis.String(object.externalRequestId) : "",
    };
  },

  toJSON(message: CreateOutgoingICPFollowRequestRequest): unknown {
    const obj: any = {};
    if (message.fromAddressId !== 0) {
      obj.fromAddressId = Math.round(message.fromAddressId);
    }
    if (message.neuronWhitelistedAddressIds?.length) {
      obj.neuronWhitelistedAddressIds = message.neuronWhitelistedAddressIds.map((e) => Math.round(e));
    }
    if (message.topic !== "") {
      obj.topic = message.topic;
    }
    if (message.comment !== "") {
      obj.comment = message.comment;
    }
    if (message.externalRequestId !== "") {
      obj.externalRequestId = message.externalRequestId;
    }
    return obj;
  },

  create(base?: DeepPartial<CreateOutgoingICPFollowRequestRequest>): CreateOutgoingICPFollowRequestRequest {
    return CreateOutgoingICPFollowRequestRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CreateOutgoingICPFollowRequestRequest>): CreateOutgoingICPFollowRequestRequest {
    const message = createBaseCreateOutgoingICPFollowRequestRequest();
    message.fromAddressId = object.fromAddressId ?? 0;
    message.neuronWhitelistedAddressIds = object.neuronWhitelistedAddressIds?.map((e) => e) || [];
    message.topic = object.topic ?? "";
    message.comment = object.comment ?? "";
    message.externalRequestId = object.externalRequestId ?? "";
    return message;
  },
};

function createBaseCreateOutgoingXLMSetTrustlineFlagsRequestRequest(): CreateOutgoingXLMSetTrustlineFlagsRequestRequest {
  return {
    fromAddressId: 0,
    trustorInternalAddressId: 0,
    trustorWhitelistedAddressId: 0,
    setFlags: [],
    clearFlags: [],
    feeLimit: "",
    comment: "",
    externalRequestId: "",
  };
}

export const CreateOutgoingXLMSetTrustlineFlagsRequestRequest = {
  encode(
    message: CreateOutgoingXLMSetTrustlineFlagsRequestRequest,
    writer: _m0.Writer = _m0.Writer.create(),
  ): _m0.Writer {
    if (message.fromAddressId !== 0) {
      writer.uint32(8).uint64(message.fromAddressId);
    }
    if (message.trustorInternalAddressId !== 0) {
      writer.uint32(16).uint64(message.trustorInternalAddressId);
    }
    if (message.trustorWhitelistedAddressId !== 0) {
      writer.uint32(64).uint64(message.trustorWhitelistedAddressId);
    }
    for (const v of message.setFlags) {
      writer.uint32(26).string(v!);
    }
    for (const v of message.clearFlags) {
      writer.uint32(34).string(v!);
    }
    if (message.feeLimit !== "") {
      writer.uint32(42).string(message.feeLimit);
    }
    if (message.comment !== "") {
      writer.uint32(50).string(message.comment);
    }
    if (message.externalRequestId !== "") {
      writer.uint32(58).string(message.externalRequestId);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CreateOutgoingXLMSetTrustlineFlagsRequestRequest {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCreateOutgoingXLMSetTrustlineFlagsRequestRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.fromAddressId = longToNumber(reader.uint64() as Long);
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.trustorInternalAddressId = longToNumber(reader.uint64() as Long);
          continue;
        case 8:
          if (tag !== 64) {
            break;
          }

          message.trustorWhitelistedAddressId = longToNumber(reader.uint64() as Long);
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.setFlags.push(reader.string());
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.clearFlags.push(reader.string());
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.feeLimit = reader.string();
          continue;
        case 6:
          if (tag !== 50) {
            break;
          }

          message.comment = reader.string();
          continue;
        case 7:
          if (tag !== 58) {
            break;
          }

          message.externalRequestId = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CreateOutgoingXLMSetTrustlineFlagsRequestRequest {
    return {
      fromAddressId: isSet(object.fromAddressId) ? globalThis.Number(object.fromAddressId) : 0,
      trustorInternalAddressId: isSet(object.trustorInternalAddressId)
        ? globalThis.Number(object.trustorInternalAddressId)
        : 0,
      trustorWhitelistedAddressId: isSet(object.trustorWhitelistedAddressId)
        ? globalThis.Number(object.trustorWhitelistedAddressId)
        : 0,
      setFlags: globalThis.Array.isArray(object?.setFlags) ? object.setFlags.map((e: any) => globalThis.String(e)) : [],
      clearFlags: globalThis.Array.isArray(object?.clearFlags)
        ? object.clearFlags.map((e: any) => globalThis.String(e))
        : [],
      feeLimit: isSet(object.feeLimit) ? globalThis.String(object.feeLimit) : "",
      comment: isSet(object.comment) ? globalThis.String(object.comment) : "",
      externalRequestId: isSet(object.externalRequestId) ? globalThis.String(object.externalRequestId) : "",
    };
  },

  toJSON(message: CreateOutgoingXLMSetTrustlineFlagsRequestRequest): unknown {
    const obj: any = {};
    if (message.fromAddressId !== 0) {
      obj.fromAddressId = Math.round(message.fromAddressId);
    }
    if (message.trustorInternalAddressId !== 0) {
      obj.trustorInternalAddressId = Math.round(message.trustorInternalAddressId);
    }
    if (message.trustorWhitelistedAddressId !== 0) {
      obj.trustorWhitelistedAddressId = Math.round(message.trustorWhitelistedAddressId);
    }
    if (message.setFlags?.length) {
      obj.setFlags = message.setFlags;
    }
    if (message.clearFlags?.length) {
      obj.clearFlags = message.clearFlags;
    }
    if (message.feeLimit !== "") {
      obj.feeLimit = message.feeLimit;
    }
    if (message.comment !== "") {
      obj.comment = message.comment;
    }
    if (message.externalRequestId !== "") {
      obj.externalRequestId = message.externalRequestId;
    }
    return obj;
  },

  create(
    base?: DeepPartial<CreateOutgoingXLMSetTrustlineFlagsRequestRequest>,
  ): CreateOutgoingXLMSetTrustlineFlagsRequestRequest {
    return CreateOutgoingXLMSetTrustlineFlagsRequestRequest.fromPartial(base ?? {});
  },
  fromPartial(
    object: DeepPartial<CreateOutgoingXLMSetTrustlineFlagsRequestRequest>,
  ): CreateOutgoingXLMSetTrustlineFlagsRequestRequest {
    const message = createBaseCreateOutgoingXLMSetTrustlineFlagsRequestRequest();
    message.fromAddressId = object.fromAddressId ?? 0;
    message.trustorInternalAddressId = object.trustorInternalAddressId ?? 0;
    message.trustorWhitelistedAddressId = object.trustorWhitelistedAddressId ?? 0;
    message.setFlags = object.setFlags?.map((e) => e) || [];
    message.clearFlags = object.clearFlags?.map((e) => e) || [];
    message.feeLimit = object.feeLimit ?? "";
    message.comment = object.comment ?? "";
    message.externalRequestId = object.externalRequestId ?? "";
    return message;
  },
};

function createBaseCreateOutgoingICPStartDissolvingRequestRequest(): CreateOutgoingICPStartDissolvingRequestRequest {
  return { fromAddressId: 0, comment: "", externalRequestId: "" };
}

export const CreateOutgoingICPStartDissolvingRequestRequest = {
  encode(
    message: CreateOutgoingICPStartDissolvingRequestRequest,
    writer: _m0.Writer = _m0.Writer.create(),
  ): _m0.Writer {
    if (message.fromAddressId !== 0) {
      writer.uint32(8).uint64(message.fromAddressId);
    }
    if (message.comment !== "") {
      writer.uint32(18).string(message.comment);
    }
    if (message.externalRequestId !== "") {
      writer.uint32(26).string(message.externalRequestId);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CreateOutgoingICPStartDissolvingRequestRequest {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCreateOutgoingICPStartDissolvingRequestRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.fromAddressId = longToNumber(reader.uint64() as Long);
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.comment = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.externalRequestId = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CreateOutgoingICPStartDissolvingRequestRequest {
    return {
      fromAddressId: isSet(object.fromAddressId) ? globalThis.Number(object.fromAddressId) : 0,
      comment: isSet(object.comment) ? globalThis.String(object.comment) : "",
      externalRequestId: isSet(object.externalRequestId) ? globalThis.String(object.externalRequestId) : "",
    };
  },

  toJSON(message: CreateOutgoingICPStartDissolvingRequestRequest): unknown {
    const obj: any = {};
    if (message.fromAddressId !== 0) {
      obj.fromAddressId = Math.round(message.fromAddressId);
    }
    if (message.comment !== "") {
      obj.comment = message.comment;
    }
    if (message.externalRequestId !== "") {
      obj.externalRequestId = message.externalRequestId;
    }
    return obj;
  },

  create(
    base?: DeepPartial<CreateOutgoingICPStartDissolvingRequestRequest>,
  ): CreateOutgoingICPStartDissolvingRequestRequest {
    return CreateOutgoingICPStartDissolvingRequestRequest.fromPartial(base ?? {});
  },
  fromPartial(
    object: DeepPartial<CreateOutgoingICPStartDissolvingRequestRequest>,
  ): CreateOutgoingICPStartDissolvingRequestRequest {
    const message = createBaseCreateOutgoingICPStartDissolvingRequestRequest();
    message.fromAddressId = object.fromAddressId ?? 0;
    message.comment = object.comment ?? "";
    message.externalRequestId = object.externalRequestId ?? "";
    return message;
  },
};

function createBaseCreateOutgoingXLMCreateClaimableBalanceRequestRequest(): CreateOutgoingXLMCreateClaimableBalanceRequestRequest {
  return {
    amount: "",
    feeLimit: "",
    fromAddressId: 0,
    fromWalletId: 0,
    toAddressId: 0,
    toWhitelistedAddressId: 0,
    comment: "",
    externalRequestId: "",
    destinationAddressMemo: "",
    absoluteTimeBefore: 0,
    relativeTimeBefore: 0,
    sponsoredByAddressId: 0,
  };
}

export const CreateOutgoingXLMCreateClaimableBalanceRequestRequest = {
  encode(
    message: CreateOutgoingXLMCreateClaimableBalanceRequestRequest,
    writer: _m0.Writer = _m0.Writer.create(),
  ): _m0.Writer {
    if (message.amount !== "") {
      writer.uint32(10).string(message.amount);
    }
    if (message.feeLimit !== "") {
      writer.uint32(18).string(message.feeLimit);
    }
    if (message.fromAddressId !== 0) {
      writer.uint32(24).uint64(message.fromAddressId);
    }
    if (message.fromWalletId !== 0) {
      writer.uint32(32).uint64(message.fromWalletId);
    }
    if (message.toAddressId !== 0) {
      writer.uint32(40).uint64(message.toAddressId);
    }
    if (message.toWhitelistedAddressId !== 0) {
      writer.uint32(48).uint64(message.toWhitelistedAddressId);
    }
    if (message.comment !== "") {
      writer.uint32(66).string(message.comment);
    }
    if (message.externalRequestId !== "") {
      writer.uint32(130).string(message.externalRequestId);
    }
    if (message.destinationAddressMemo !== "") {
      writer.uint32(138).string(message.destinationAddressMemo);
    }
    if (message.absoluteTimeBefore !== 0) {
      writer.uint32(144).uint64(message.absoluteTimeBefore);
    }
    if (message.relativeTimeBefore !== 0) {
      writer.uint32(152).uint64(message.relativeTimeBefore);
    }
    if (message.sponsoredByAddressId !== 0) {
      writer.uint32(160).uint64(message.sponsoredByAddressId);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CreateOutgoingXLMCreateClaimableBalanceRequestRequest {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCreateOutgoingXLMCreateClaimableBalanceRequestRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.amount = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.feeLimit = reader.string();
          continue;
        case 3:
          if (tag !== 24) {
            break;
          }

          message.fromAddressId = longToNumber(reader.uint64() as Long);
          continue;
        case 4:
          if (tag !== 32) {
            break;
          }

          message.fromWalletId = longToNumber(reader.uint64() as Long);
          continue;
        case 5:
          if (tag !== 40) {
            break;
          }

          message.toAddressId = longToNumber(reader.uint64() as Long);
          continue;
        case 6:
          if (tag !== 48) {
            break;
          }

          message.toWhitelistedAddressId = longToNumber(reader.uint64() as Long);
          continue;
        case 8:
          if (tag !== 66) {
            break;
          }

          message.comment = reader.string();
          continue;
        case 16:
          if (tag !== 130) {
            break;
          }

          message.externalRequestId = reader.string();
          continue;
        case 17:
          if (tag !== 138) {
            break;
          }

          message.destinationAddressMemo = reader.string();
          continue;
        case 18:
          if (tag !== 144) {
            break;
          }

          message.absoluteTimeBefore = longToNumber(reader.uint64() as Long);
          continue;
        case 19:
          if (tag !== 152) {
            break;
          }

          message.relativeTimeBefore = longToNumber(reader.uint64() as Long);
          continue;
        case 20:
          if (tag !== 160) {
            break;
          }

          message.sponsoredByAddressId = longToNumber(reader.uint64() as Long);
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CreateOutgoingXLMCreateClaimableBalanceRequestRequest {
    return {
      amount: isSet(object.amount) ? globalThis.String(object.amount) : "",
      feeLimit: isSet(object.feeLimit) ? globalThis.String(object.feeLimit) : "",
      fromAddressId: isSet(object.fromAddressId) ? globalThis.Number(object.fromAddressId) : 0,
      fromWalletId: isSet(object.fromWalletId) ? globalThis.Number(object.fromWalletId) : 0,
      toAddressId: isSet(object.toAddressId) ? globalThis.Number(object.toAddressId) : 0,
      toWhitelistedAddressId: isSet(object.toWhitelistedAddressId)
        ? globalThis.Number(object.toWhitelistedAddressId)
        : 0,
      comment: isSet(object.comment) ? globalThis.String(object.comment) : "",
      externalRequestId: isSet(object.externalRequestId) ? globalThis.String(object.externalRequestId) : "",
      destinationAddressMemo: isSet(object.destinationAddressMemo)
        ? globalThis.String(object.destinationAddressMemo)
        : "",
      absoluteTimeBefore: isSet(object.absoluteTimeBefore) ? globalThis.Number(object.absoluteTimeBefore) : 0,
      relativeTimeBefore: isSet(object.relativeTimeBefore) ? globalThis.Number(object.relativeTimeBefore) : 0,
      sponsoredByAddressId: isSet(object.sponsoredByAddressId) ? globalThis.Number(object.sponsoredByAddressId) : 0,
    };
  },

  toJSON(message: CreateOutgoingXLMCreateClaimableBalanceRequestRequest): unknown {
    const obj: any = {};
    if (message.amount !== "") {
      obj.amount = message.amount;
    }
    if (message.feeLimit !== "") {
      obj.feeLimit = message.feeLimit;
    }
    if (message.fromAddressId !== 0) {
      obj.fromAddressId = Math.round(message.fromAddressId);
    }
    if (message.fromWalletId !== 0) {
      obj.fromWalletId = Math.round(message.fromWalletId);
    }
    if (message.toAddressId !== 0) {
      obj.toAddressId = Math.round(message.toAddressId);
    }
    if (message.toWhitelistedAddressId !== 0) {
      obj.toWhitelistedAddressId = Math.round(message.toWhitelistedAddressId);
    }
    if (message.comment !== "") {
      obj.comment = message.comment;
    }
    if (message.externalRequestId !== "") {
      obj.externalRequestId = message.externalRequestId;
    }
    if (message.destinationAddressMemo !== "") {
      obj.destinationAddressMemo = message.destinationAddressMemo;
    }
    if (message.absoluteTimeBefore !== 0) {
      obj.absoluteTimeBefore = Math.round(message.absoluteTimeBefore);
    }
    if (message.relativeTimeBefore !== 0) {
      obj.relativeTimeBefore = Math.round(message.relativeTimeBefore);
    }
    if (message.sponsoredByAddressId !== 0) {
      obj.sponsoredByAddressId = Math.round(message.sponsoredByAddressId);
    }
    return obj;
  },

  create(
    base?: DeepPartial<CreateOutgoingXLMCreateClaimableBalanceRequestRequest>,
  ): CreateOutgoingXLMCreateClaimableBalanceRequestRequest {
    return CreateOutgoingXLMCreateClaimableBalanceRequestRequest.fromPartial(base ?? {});
  },
  fromPartial(
    object: DeepPartial<CreateOutgoingXLMCreateClaimableBalanceRequestRequest>,
  ): CreateOutgoingXLMCreateClaimableBalanceRequestRequest {
    const message = createBaseCreateOutgoingXLMCreateClaimableBalanceRequestRequest();
    message.amount = object.amount ?? "";
    message.feeLimit = object.feeLimit ?? "";
    message.fromAddressId = object.fromAddressId ?? 0;
    message.fromWalletId = object.fromWalletId ?? 0;
    message.toAddressId = object.toAddressId ?? 0;
    message.toWhitelistedAddressId = object.toWhitelistedAddressId ?? 0;
    message.comment = object.comment ?? "";
    message.externalRequestId = object.externalRequestId ?? "";
    message.destinationAddressMemo = object.destinationAddressMemo ?? "";
    message.absoluteTimeBefore = object.absoluteTimeBefore ?? 0;
    message.relativeTimeBefore = object.relativeTimeBefore ?? 0;
    message.sponsoredByAddressId = object.sponsoredByAddressId ?? 0;
    return message;
  },
};

function createBaseCreateOutgoingXLMClaimClaimableBalanceRequestRequest(): CreateOutgoingXLMClaimClaimableBalanceRequestRequest {
  return { fromAddressId: 0, claimableBalanceID: "", feeLimit: "", comment: "", externalRequestId: "" };
}

export const CreateOutgoingXLMClaimClaimableBalanceRequestRequest = {
  encode(
    message: CreateOutgoingXLMClaimClaimableBalanceRequestRequest,
    writer: _m0.Writer = _m0.Writer.create(),
  ): _m0.Writer {
    if (message.fromAddressId !== 0) {
      writer.uint32(8).uint64(message.fromAddressId);
    }
    if (message.claimableBalanceID !== "") {
      writer.uint32(18).string(message.claimableBalanceID);
    }
    if (message.feeLimit !== "") {
      writer.uint32(42).string(message.feeLimit);
    }
    if (message.comment !== "") {
      writer.uint32(50).string(message.comment);
    }
    if (message.externalRequestId !== "") {
      writer.uint32(58).string(message.externalRequestId);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CreateOutgoingXLMClaimClaimableBalanceRequestRequest {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCreateOutgoingXLMClaimClaimableBalanceRequestRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.fromAddressId = longToNumber(reader.uint64() as Long);
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.claimableBalanceID = reader.string();
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.feeLimit = reader.string();
          continue;
        case 6:
          if (tag !== 50) {
            break;
          }

          message.comment = reader.string();
          continue;
        case 7:
          if (tag !== 58) {
            break;
          }

          message.externalRequestId = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CreateOutgoingXLMClaimClaimableBalanceRequestRequest {
    return {
      fromAddressId: isSet(object.fromAddressId) ? globalThis.Number(object.fromAddressId) : 0,
      claimableBalanceID: isSet(object.claimableBalanceID) ? globalThis.String(object.claimableBalanceID) : "",
      feeLimit: isSet(object.feeLimit) ? globalThis.String(object.feeLimit) : "",
      comment: isSet(object.comment) ? globalThis.String(object.comment) : "",
      externalRequestId: isSet(object.externalRequestId) ? globalThis.String(object.externalRequestId) : "",
    };
  },

  toJSON(message: CreateOutgoingXLMClaimClaimableBalanceRequestRequest): unknown {
    const obj: any = {};
    if (message.fromAddressId !== 0) {
      obj.fromAddressId = Math.round(message.fromAddressId);
    }
    if (message.claimableBalanceID !== "") {
      obj.claimableBalanceID = message.claimableBalanceID;
    }
    if (message.feeLimit !== "") {
      obj.feeLimit = message.feeLimit;
    }
    if (message.comment !== "") {
      obj.comment = message.comment;
    }
    if (message.externalRequestId !== "") {
      obj.externalRequestId = message.externalRequestId;
    }
    return obj;
  },

  create(
    base?: DeepPartial<CreateOutgoingXLMClaimClaimableBalanceRequestRequest>,
  ): CreateOutgoingXLMClaimClaimableBalanceRequestRequest {
    return CreateOutgoingXLMClaimClaimableBalanceRequestRequest.fromPartial(base ?? {});
  },
  fromPartial(
    object: DeepPartial<CreateOutgoingXLMClaimClaimableBalanceRequestRequest>,
  ): CreateOutgoingXLMClaimClaimableBalanceRequestRequest {
    const message = createBaseCreateOutgoingXLMClaimClaimableBalanceRequestRequest();
    message.fromAddressId = object.fromAddressId ?? 0;
    message.claimableBalanceID = object.claimableBalanceID ?? "";
    message.feeLimit = object.feeLimit ?? "";
    message.comment = object.comment ?? "";
    message.externalRequestId = object.externalRequestId ?? "";
    return message;
  },
};

function createBaseCreateOutgoingXLMClawbackClaimableBalanceRequestRequest(): CreateOutgoingXLMClawbackClaimableBalanceRequestRequest {
  return { fromAddressId: 0, claimableBalanceID: "", feeLimit: "", comment: "", externalRequestId: "" };
}

export const CreateOutgoingXLMClawbackClaimableBalanceRequestRequest = {
  encode(
    message: CreateOutgoingXLMClawbackClaimableBalanceRequestRequest,
    writer: _m0.Writer = _m0.Writer.create(),
  ): _m0.Writer {
    if (message.fromAddressId !== 0) {
      writer.uint32(8).uint64(message.fromAddressId);
    }
    if (message.claimableBalanceID !== "") {
      writer.uint32(18).string(message.claimableBalanceID);
    }
    if (message.feeLimit !== "") {
      writer.uint32(42).string(message.feeLimit);
    }
    if (message.comment !== "") {
      writer.uint32(50).string(message.comment);
    }
    if (message.externalRequestId !== "") {
      writer.uint32(58).string(message.externalRequestId);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CreateOutgoingXLMClawbackClaimableBalanceRequestRequest {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCreateOutgoingXLMClawbackClaimableBalanceRequestRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.fromAddressId = longToNumber(reader.uint64() as Long);
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.claimableBalanceID = reader.string();
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.feeLimit = reader.string();
          continue;
        case 6:
          if (tag !== 50) {
            break;
          }

          message.comment = reader.string();
          continue;
        case 7:
          if (tag !== 58) {
            break;
          }

          message.externalRequestId = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CreateOutgoingXLMClawbackClaimableBalanceRequestRequest {
    return {
      fromAddressId: isSet(object.fromAddressId) ? globalThis.Number(object.fromAddressId) : 0,
      claimableBalanceID: isSet(object.claimableBalanceID) ? globalThis.String(object.claimableBalanceID) : "",
      feeLimit: isSet(object.feeLimit) ? globalThis.String(object.feeLimit) : "",
      comment: isSet(object.comment) ? globalThis.String(object.comment) : "",
      externalRequestId: isSet(object.externalRequestId) ? globalThis.String(object.externalRequestId) : "",
    };
  },

  toJSON(message: CreateOutgoingXLMClawbackClaimableBalanceRequestRequest): unknown {
    const obj: any = {};
    if (message.fromAddressId !== 0) {
      obj.fromAddressId = Math.round(message.fromAddressId);
    }
    if (message.claimableBalanceID !== "") {
      obj.claimableBalanceID = message.claimableBalanceID;
    }
    if (message.feeLimit !== "") {
      obj.feeLimit = message.feeLimit;
    }
    if (message.comment !== "") {
      obj.comment = message.comment;
    }
    if (message.externalRequestId !== "") {
      obj.externalRequestId = message.externalRequestId;
    }
    return obj;
  },

  create(
    base?: DeepPartial<CreateOutgoingXLMClawbackClaimableBalanceRequestRequest>,
  ): CreateOutgoingXLMClawbackClaimableBalanceRequestRequest {
    return CreateOutgoingXLMClawbackClaimableBalanceRequestRequest.fromPartial(base ?? {});
  },
  fromPartial(
    object: DeepPartial<CreateOutgoingXLMClawbackClaimableBalanceRequestRequest>,
  ): CreateOutgoingXLMClawbackClaimableBalanceRequestRequest {
    const message = createBaseCreateOutgoingXLMClawbackClaimableBalanceRequestRequest();
    message.fromAddressId = object.fromAddressId ?? 0;
    message.claimableBalanceID = object.claimableBalanceID ?? "";
    message.feeLimit = object.feeLimit ?? "";
    message.comment = object.comment ?? "";
    message.externalRequestId = object.externalRequestId ?? "";
    return message;
  },
};

function createBaseCreateOutgoingXLMRevokeSponsorshipRequestRequest(): CreateOutgoingXLMRevokeSponsorshipRequestRequest {
  return {
    fromAddressId: 0,
    toAddressId: 0,
    toWhitelistedAddressId: 0,
    destinationAddressMemo: "",
    claimableBalanceID: "",
    dataName: "",
    currencyID: "",
    feeLimit: "",
    comment: "",
    externalRequestId: "",
    sponsoredByAddressId: 0,
  };
}

export const CreateOutgoingXLMRevokeSponsorshipRequestRequest = {
  encode(
    message: CreateOutgoingXLMRevokeSponsorshipRequestRequest,
    writer: _m0.Writer = _m0.Writer.create(),
  ): _m0.Writer {
    if (message.fromAddressId !== 0) {
      writer.uint32(8).uint64(message.fromAddressId);
    }
    if (message.toAddressId !== 0) {
      writer.uint32(16).uint64(message.toAddressId);
    }
    if (message.toWhitelistedAddressId !== 0) {
      writer.uint32(24).uint64(message.toWhitelistedAddressId);
    }
    if (message.destinationAddressMemo !== "") {
      writer.uint32(106).string(message.destinationAddressMemo);
    }
    if (message.claimableBalanceID !== "") {
      writer.uint32(34).string(message.claimableBalanceID);
    }
    if (message.dataName !== "") {
      writer.uint32(50).string(message.dataName);
    }
    if (message.currencyID !== "") {
      writer.uint32(58).string(message.currencyID);
    }
    if (message.feeLimit !== "") {
      writer.uint32(74).string(message.feeLimit);
    }
    if (message.comment !== "") {
      writer.uint32(82).string(message.comment);
    }
    if (message.externalRequestId !== "") {
      writer.uint32(90).string(message.externalRequestId);
    }
    if (message.sponsoredByAddressId !== 0) {
      writer.uint32(96).uint64(message.sponsoredByAddressId);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CreateOutgoingXLMRevokeSponsorshipRequestRequest {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCreateOutgoingXLMRevokeSponsorshipRequestRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.fromAddressId = longToNumber(reader.uint64() as Long);
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.toAddressId = longToNumber(reader.uint64() as Long);
          continue;
        case 3:
          if (tag !== 24) {
            break;
          }

          message.toWhitelistedAddressId = longToNumber(reader.uint64() as Long);
          continue;
        case 13:
          if (tag !== 106) {
            break;
          }

          message.destinationAddressMemo = reader.string();
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.claimableBalanceID = reader.string();
          continue;
        case 6:
          if (tag !== 50) {
            break;
          }

          message.dataName = reader.string();
          continue;
        case 7:
          if (tag !== 58) {
            break;
          }

          message.currencyID = reader.string();
          continue;
        case 9:
          if (tag !== 74) {
            break;
          }

          message.feeLimit = reader.string();
          continue;
        case 10:
          if (tag !== 82) {
            break;
          }

          message.comment = reader.string();
          continue;
        case 11:
          if (tag !== 90) {
            break;
          }

          message.externalRequestId = reader.string();
          continue;
        case 12:
          if (tag !== 96) {
            break;
          }

          message.sponsoredByAddressId = longToNumber(reader.uint64() as Long);
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CreateOutgoingXLMRevokeSponsorshipRequestRequest {
    return {
      fromAddressId: isSet(object.fromAddressId) ? globalThis.Number(object.fromAddressId) : 0,
      toAddressId: isSet(object.toAddressId) ? globalThis.Number(object.toAddressId) : 0,
      toWhitelistedAddressId: isSet(object.toWhitelistedAddressId)
        ? globalThis.Number(object.toWhitelistedAddressId)
        : 0,
      destinationAddressMemo: isSet(object.destinationAddressMemo)
        ? globalThis.String(object.destinationAddressMemo)
        : "",
      claimableBalanceID: isSet(object.claimableBalanceID) ? globalThis.String(object.claimableBalanceID) : "",
      dataName: isSet(object.dataName) ? globalThis.String(object.dataName) : "",
      currencyID: isSet(object.currencyID) ? globalThis.String(object.currencyID) : "",
      feeLimit: isSet(object.feeLimit) ? globalThis.String(object.feeLimit) : "",
      comment: isSet(object.comment) ? globalThis.String(object.comment) : "",
      externalRequestId: isSet(object.externalRequestId) ? globalThis.String(object.externalRequestId) : "",
      sponsoredByAddressId: isSet(object.sponsoredByAddressId) ? globalThis.Number(object.sponsoredByAddressId) : 0,
    };
  },

  toJSON(message: CreateOutgoingXLMRevokeSponsorshipRequestRequest): unknown {
    const obj: any = {};
    if (message.fromAddressId !== 0) {
      obj.fromAddressId = Math.round(message.fromAddressId);
    }
    if (message.toAddressId !== 0) {
      obj.toAddressId = Math.round(message.toAddressId);
    }
    if (message.toWhitelistedAddressId !== 0) {
      obj.toWhitelistedAddressId = Math.round(message.toWhitelistedAddressId);
    }
    if (message.destinationAddressMemo !== "") {
      obj.destinationAddressMemo = message.destinationAddressMemo;
    }
    if (message.claimableBalanceID !== "") {
      obj.claimableBalanceID = message.claimableBalanceID;
    }
    if (message.dataName !== "") {
      obj.dataName = message.dataName;
    }
    if (message.currencyID !== "") {
      obj.currencyID = message.currencyID;
    }
    if (message.feeLimit !== "") {
      obj.feeLimit = message.feeLimit;
    }
    if (message.comment !== "") {
      obj.comment = message.comment;
    }
    if (message.externalRequestId !== "") {
      obj.externalRequestId = message.externalRequestId;
    }
    if (message.sponsoredByAddressId !== 0) {
      obj.sponsoredByAddressId = Math.round(message.sponsoredByAddressId);
    }
    return obj;
  },

  create(
    base?: DeepPartial<CreateOutgoingXLMRevokeSponsorshipRequestRequest>,
  ): CreateOutgoingXLMRevokeSponsorshipRequestRequest {
    return CreateOutgoingXLMRevokeSponsorshipRequestRequest.fromPartial(base ?? {});
  },
  fromPartial(
    object: DeepPartial<CreateOutgoingXLMRevokeSponsorshipRequestRequest>,
  ): CreateOutgoingXLMRevokeSponsorshipRequestRequest {
    const message = createBaseCreateOutgoingXLMRevokeSponsorshipRequestRequest();
    message.fromAddressId = object.fromAddressId ?? 0;
    message.toAddressId = object.toAddressId ?? 0;
    message.toWhitelistedAddressId = object.toWhitelistedAddressId ?? 0;
    message.destinationAddressMemo = object.destinationAddressMemo ?? "";
    message.claimableBalanceID = object.claimableBalanceID ?? "";
    message.dataName = object.dataName ?? "";
    message.currencyID = object.currencyID ?? "";
    message.feeLimit = object.feeLimit ?? "";
    message.comment = object.comment ?? "";
    message.externalRequestId = object.externalRequestId ?? "";
    message.sponsoredByAddressId = object.sponsoredByAddressId ?? 0;
    return message;
  },
};

function createBaseCreateOutgoingXLMClawbackRequestRequest(): CreateOutgoingXLMClawbackRequestRequest {
  return {
    fromAddressId: 0,
    toAddressId: 0,
    toWhitelistedAddressId: 0,
    destinationAddressMemo: "",
    amount: "",
    feeLimit: "",
    comment: "",
    externalRequestId: "",
  };
}

export const CreateOutgoingXLMClawbackRequestRequest = {
  encode(message: CreateOutgoingXLMClawbackRequestRequest, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.fromAddressId !== 0) {
      writer.uint32(8).uint64(message.fromAddressId);
    }
    if (message.toAddressId !== 0) {
      writer.uint32(16).uint64(message.toAddressId);
    }
    if (message.toWhitelistedAddressId !== 0) {
      writer.uint32(24).uint64(message.toWhitelistedAddressId);
    }
    if (message.destinationAddressMemo !== "") {
      writer.uint32(34).string(message.destinationAddressMemo);
    }
    if (message.amount !== "") {
      writer.uint32(42).string(message.amount);
    }
    if (message.feeLimit !== "") {
      writer.uint32(50).string(message.feeLimit);
    }
    if (message.comment !== "") {
      writer.uint32(58).string(message.comment);
    }
    if (message.externalRequestId !== "") {
      writer.uint32(66).string(message.externalRequestId);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CreateOutgoingXLMClawbackRequestRequest {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCreateOutgoingXLMClawbackRequestRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.fromAddressId = longToNumber(reader.uint64() as Long);
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.toAddressId = longToNumber(reader.uint64() as Long);
          continue;
        case 3:
          if (tag !== 24) {
            break;
          }

          message.toWhitelistedAddressId = longToNumber(reader.uint64() as Long);
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.destinationAddressMemo = reader.string();
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.amount = reader.string();
          continue;
        case 6:
          if (tag !== 50) {
            break;
          }

          message.feeLimit = reader.string();
          continue;
        case 7:
          if (tag !== 58) {
            break;
          }

          message.comment = reader.string();
          continue;
        case 8:
          if (tag !== 66) {
            break;
          }

          message.externalRequestId = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CreateOutgoingXLMClawbackRequestRequest {
    return {
      fromAddressId: isSet(object.fromAddressId) ? globalThis.Number(object.fromAddressId) : 0,
      toAddressId: isSet(object.toAddressId) ? globalThis.Number(object.toAddressId) : 0,
      toWhitelistedAddressId: isSet(object.toWhitelistedAddressId)
        ? globalThis.Number(object.toWhitelistedAddressId)
        : 0,
      destinationAddressMemo: isSet(object.destinationAddressMemo)
        ? globalThis.String(object.destinationAddressMemo)
        : "",
      amount: isSet(object.amount) ? globalThis.String(object.amount) : "",
      feeLimit: isSet(object.feeLimit) ? globalThis.String(object.feeLimit) : "",
      comment: isSet(object.comment) ? globalThis.String(object.comment) : "",
      externalRequestId: isSet(object.externalRequestId) ? globalThis.String(object.externalRequestId) : "",
    };
  },

  toJSON(message: CreateOutgoingXLMClawbackRequestRequest): unknown {
    const obj: any = {};
    if (message.fromAddressId !== 0) {
      obj.fromAddressId = Math.round(message.fromAddressId);
    }
    if (message.toAddressId !== 0) {
      obj.toAddressId = Math.round(message.toAddressId);
    }
    if (message.toWhitelistedAddressId !== 0) {
      obj.toWhitelistedAddressId = Math.round(message.toWhitelistedAddressId);
    }
    if (message.destinationAddressMemo !== "") {
      obj.destinationAddressMemo = message.destinationAddressMemo;
    }
    if (message.amount !== "") {
      obj.amount = message.amount;
    }
    if (message.feeLimit !== "") {
      obj.feeLimit = message.feeLimit;
    }
    if (message.comment !== "") {
      obj.comment = message.comment;
    }
    if (message.externalRequestId !== "") {
      obj.externalRequestId = message.externalRequestId;
    }
    return obj;
  },

  create(base?: DeepPartial<CreateOutgoingXLMClawbackRequestRequest>): CreateOutgoingXLMClawbackRequestRequest {
    return CreateOutgoingXLMClawbackRequestRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CreateOutgoingXLMClawbackRequestRequest>): CreateOutgoingXLMClawbackRequestRequest {
    const message = createBaseCreateOutgoingXLMClawbackRequestRequest();
    message.fromAddressId = object.fromAddressId ?? 0;
    message.toAddressId = object.toAddressId ?? 0;
    message.toWhitelistedAddressId = object.toWhitelistedAddressId ?? 0;
    message.destinationAddressMemo = object.destinationAddressMemo ?? "";
    message.amount = object.amount ?? "";
    message.feeLimit = object.feeLimit ?? "";
    message.comment = object.comment ?? "";
    message.externalRequestId = object.externalRequestId ?? "";
    return message;
  },
};

function createBaseCreateOutgoingXLMLiquidityPoolDepositRequestRequest(): CreateOutgoingXLMLiquidityPoolDepositRequestRequest {
  return {
    fromAddressId: 0,
    poolID: "",
    maxAmountAssetA: "",
    maxAmountAssetB: "",
    priceVariation: 0,
    feeLimit: "",
    comment: "",
    externalRequestId: "",
  };
}

export const CreateOutgoingXLMLiquidityPoolDepositRequestRequest = {
  encode(
    message: CreateOutgoingXLMLiquidityPoolDepositRequestRequest,
    writer: _m0.Writer = _m0.Writer.create(),
  ): _m0.Writer {
    if (message.fromAddressId !== 0) {
      writer.uint32(8).uint64(message.fromAddressId);
    }
    if (message.poolID !== "") {
      writer.uint32(18).string(message.poolID);
    }
    if (message.maxAmountAssetA !== "") {
      writer.uint32(26).string(message.maxAmountAssetA);
    }
    if (message.maxAmountAssetB !== "") {
      writer.uint32(34).string(message.maxAmountAssetB);
    }
    if (message.priceVariation !== 0) {
      writer.uint32(40).uint32(message.priceVariation);
    }
    if (message.feeLimit !== "") {
      writer.uint32(58).string(message.feeLimit);
    }
    if (message.comment !== "") {
      writer.uint32(66).string(message.comment);
    }
    if (message.externalRequestId !== "") {
      writer.uint32(74).string(message.externalRequestId);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CreateOutgoingXLMLiquidityPoolDepositRequestRequest {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCreateOutgoingXLMLiquidityPoolDepositRequestRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.fromAddressId = longToNumber(reader.uint64() as Long);
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.poolID = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.maxAmountAssetA = reader.string();
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.maxAmountAssetB = reader.string();
          continue;
        case 5:
          if (tag !== 40) {
            break;
          }

          message.priceVariation = reader.uint32();
          continue;
        case 7:
          if (tag !== 58) {
            break;
          }

          message.feeLimit = reader.string();
          continue;
        case 8:
          if (tag !== 66) {
            break;
          }

          message.comment = reader.string();
          continue;
        case 9:
          if (tag !== 74) {
            break;
          }

          message.externalRequestId = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CreateOutgoingXLMLiquidityPoolDepositRequestRequest {
    return {
      fromAddressId: isSet(object.fromAddressId) ? globalThis.Number(object.fromAddressId) : 0,
      poolID: isSet(object.poolID) ? globalThis.String(object.poolID) : "",
      maxAmountAssetA: isSet(object.maxAmountAssetA) ? globalThis.String(object.maxAmountAssetA) : "",
      maxAmountAssetB: isSet(object.maxAmountAssetB) ? globalThis.String(object.maxAmountAssetB) : "",
      priceVariation: isSet(object.priceVariation) ? globalThis.Number(object.priceVariation) : 0,
      feeLimit: isSet(object.feeLimit) ? globalThis.String(object.feeLimit) : "",
      comment: isSet(object.comment) ? globalThis.String(object.comment) : "",
      externalRequestId: isSet(object.externalRequestId) ? globalThis.String(object.externalRequestId) : "",
    };
  },

  toJSON(message: CreateOutgoingXLMLiquidityPoolDepositRequestRequest): unknown {
    const obj: any = {};
    if (message.fromAddressId !== 0) {
      obj.fromAddressId = Math.round(message.fromAddressId);
    }
    if (message.poolID !== "") {
      obj.poolID = message.poolID;
    }
    if (message.maxAmountAssetA !== "") {
      obj.maxAmountAssetA = message.maxAmountAssetA;
    }
    if (message.maxAmountAssetB !== "") {
      obj.maxAmountAssetB = message.maxAmountAssetB;
    }
    if (message.priceVariation !== 0) {
      obj.priceVariation = Math.round(message.priceVariation);
    }
    if (message.feeLimit !== "") {
      obj.feeLimit = message.feeLimit;
    }
    if (message.comment !== "") {
      obj.comment = message.comment;
    }
    if (message.externalRequestId !== "") {
      obj.externalRequestId = message.externalRequestId;
    }
    return obj;
  },

  create(
    base?: DeepPartial<CreateOutgoingXLMLiquidityPoolDepositRequestRequest>,
  ): CreateOutgoingXLMLiquidityPoolDepositRequestRequest {
    return CreateOutgoingXLMLiquidityPoolDepositRequestRequest.fromPartial(base ?? {});
  },
  fromPartial(
    object: DeepPartial<CreateOutgoingXLMLiquidityPoolDepositRequestRequest>,
  ): CreateOutgoingXLMLiquidityPoolDepositRequestRequest {
    const message = createBaseCreateOutgoingXLMLiquidityPoolDepositRequestRequest();
    message.fromAddressId = object.fromAddressId ?? 0;
    message.poolID = object.poolID ?? "";
    message.maxAmountAssetA = object.maxAmountAssetA ?? "";
    message.maxAmountAssetB = object.maxAmountAssetB ?? "";
    message.priceVariation = object.priceVariation ?? 0;
    message.feeLimit = object.feeLimit ?? "";
    message.comment = object.comment ?? "";
    message.externalRequestId = object.externalRequestId ?? "";
    return message;
  },
};

function createBaseCreateOutgoingXLMLiquidityPoolWithdrawRequestRequest(): CreateOutgoingXLMLiquidityPoolWithdrawRequestRequest {
  return {
    fromAddressId: 0,
    poolID: "",
    amount: "",
    minAmountAssetA: "",
    minAmountAssetB: "",
    feeLimit: "",
    comment: "",
    externalRequestId: "",
  };
}

export const CreateOutgoingXLMLiquidityPoolWithdrawRequestRequest = {
  encode(
    message: CreateOutgoingXLMLiquidityPoolWithdrawRequestRequest,
    writer: _m0.Writer = _m0.Writer.create(),
  ): _m0.Writer {
    if (message.fromAddressId !== 0) {
      writer.uint32(8).uint64(message.fromAddressId);
    }
    if (message.poolID !== "") {
      writer.uint32(18).string(message.poolID);
    }
    if (message.amount !== "") {
      writer.uint32(26).string(message.amount);
    }
    if (message.minAmountAssetA !== "") {
      writer.uint32(34).string(message.minAmountAssetA);
    }
    if (message.minAmountAssetB !== "") {
      writer.uint32(42).string(message.minAmountAssetB);
    }
    if (message.feeLimit !== "") {
      writer.uint32(58).string(message.feeLimit);
    }
    if (message.comment !== "") {
      writer.uint32(66).string(message.comment);
    }
    if (message.externalRequestId !== "") {
      writer.uint32(74).string(message.externalRequestId);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CreateOutgoingXLMLiquidityPoolWithdrawRequestRequest {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCreateOutgoingXLMLiquidityPoolWithdrawRequestRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.fromAddressId = longToNumber(reader.uint64() as Long);
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.poolID = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.amount = reader.string();
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.minAmountAssetA = reader.string();
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.minAmountAssetB = reader.string();
          continue;
        case 7:
          if (tag !== 58) {
            break;
          }

          message.feeLimit = reader.string();
          continue;
        case 8:
          if (tag !== 66) {
            break;
          }

          message.comment = reader.string();
          continue;
        case 9:
          if (tag !== 74) {
            break;
          }

          message.externalRequestId = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CreateOutgoingXLMLiquidityPoolWithdrawRequestRequest {
    return {
      fromAddressId: isSet(object.fromAddressId) ? globalThis.Number(object.fromAddressId) : 0,
      poolID: isSet(object.poolID) ? globalThis.String(object.poolID) : "",
      amount: isSet(object.amount) ? globalThis.String(object.amount) : "",
      minAmountAssetA: isSet(object.minAmountAssetA) ? globalThis.String(object.minAmountAssetA) : "",
      minAmountAssetB: isSet(object.minAmountAssetB) ? globalThis.String(object.minAmountAssetB) : "",
      feeLimit: isSet(object.feeLimit) ? globalThis.String(object.feeLimit) : "",
      comment: isSet(object.comment) ? globalThis.String(object.comment) : "",
      externalRequestId: isSet(object.externalRequestId) ? globalThis.String(object.externalRequestId) : "",
    };
  },

  toJSON(message: CreateOutgoingXLMLiquidityPoolWithdrawRequestRequest): unknown {
    const obj: any = {};
    if (message.fromAddressId !== 0) {
      obj.fromAddressId = Math.round(message.fromAddressId);
    }
    if (message.poolID !== "") {
      obj.poolID = message.poolID;
    }
    if (message.amount !== "") {
      obj.amount = message.amount;
    }
    if (message.minAmountAssetA !== "") {
      obj.minAmountAssetA = message.minAmountAssetA;
    }
    if (message.minAmountAssetB !== "") {
      obj.minAmountAssetB = message.minAmountAssetB;
    }
    if (message.feeLimit !== "") {
      obj.feeLimit = message.feeLimit;
    }
    if (message.comment !== "") {
      obj.comment = message.comment;
    }
    if (message.externalRequestId !== "") {
      obj.externalRequestId = message.externalRequestId;
    }
    return obj;
  },

  create(
    base?: DeepPartial<CreateOutgoingXLMLiquidityPoolWithdrawRequestRequest>,
  ): CreateOutgoingXLMLiquidityPoolWithdrawRequestRequest {
    return CreateOutgoingXLMLiquidityPoolWithdrawRequestRequest.fromPartial(base ?? {});
  },
  fromPartial(
    object: DeepPartial<CreateOutgoingXLMLiquidityPoolWithdrawRequestRequest>,
  ): CreateOutgoingXLMLiquidityPoolWithdrawRequestRequest {
    const message = createBaseCreateOutgoingXLMLiquidityPoolWithdrawRequestRequest();
    message.fromAddressId = object.fromAddressId ?? 0;
    message.poolID = object.poolID ?? "";
    message.amount = object.amount ?? "";
    message.minAmountAssetA = object.minAmountAssetA ?? "";
    message.minAmountAssetB = object.minAmountAssetB ?? "";
    message.feeLimit = object.feeLimit ?? "";
    message.comment = object.comment ?? "";
    message.externalRequestId = object.externalRequestId ?? "";
    return message;
  },
};

function createBaseCreateOutgoingXLMPathPaymentStrictSendRequestRequest(): CreateOutgoingXLMPathPaymentStrictSendRequestRequest {
  return {
    amount: "",
    minDestinationAmount: "",
    feeLimit: "",
    fromAddressId: 0,
    toAddressId: 0,
    toWhitelistedAddressId: 0,
    destinationAssetID: "",
    destinationAssetIssuer: "",
    comment: "",
    externalRequestId: "",
    destinationAddressMemo: "",
  };
}

export const CreateOutgoingXLMPathPaymentStrictSendRequestRequest = {
  encode(
    message: CreateOutgoingXLMPathPaymentStrictSendRequestRequest,
    writer: _m0.Writer = _m0.Writer.create(),
  ): _m0.Writer {
    if (message.amount !== "") {
      writer.uint32(10).string(message.amount);
    }
    if (message.minDestinationAmount !== "") {
      writer.uint32(34).string(message.minDestinationAmount);
    }
    if (message.feeLimit !== "") {
      writer.uint32(18).string(message.feeLimit);
    }
    if (message.fromAddressId !== 0) {
      writer.uint32(24).uint64(message.fromAddressId);
    }
    if (message.toAddressId !== 0) {
      writer.uint32(40).uint64(message.toAddressId);
    }
    if (message.toWhitelistedAddressId !== 0) {
      writer.uint32(48).uint64(message.toWhitelistedAddressId);
    }
    if (message.destinationAssetID !== "") {
      writer.uint32(74).string(message.destinationAssetID);
    }
    if (message.destinationAssetIssuer !== "") {
      writer.uint32(82).string(message.destinationAssetIssuer);
    }
    if (message.comment !== "") {
      writer.uint32(66).string(message.comment);
    }
    if (message.externalRequestId !== "") {
      writer.uint32(130).string(message.externalRequestId);
    }
    if (message.destinationAddressMemo !== "") {
      writer.uint32(138).string(message.destinationAddressMemo);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CreateOutgoingXLMPathPaymentStrictSendRequestRequest {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCreateOutgoingXLMPathPaymentStrictSendRequestRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.amount = reader.string();
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.minDestinationAmount = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.feeLimit = reader.string();
          continue;
        case 3:
          if (tag !== 24) {
            break;
          }

          message.fromAddressId = longToNumber(reader.uint64() as Long);
          continue;
        case 5:
          if (tag !== 40) {
            break;
          }

          message.toAddressId = longToNumber(reader.uint64() as Long);
          continue;
        case 6:
          if (tag !== 48) {
            break;
          }

          message.toWhitelistedAddressId = longToNumber(reader.uint64() as Long);
          continue;
        case 9:
          if (tag !== 74) {
            break;
          }

          message.destinationAssetID = reader.string();
          continue;
        case 10:
          if (tag !== 82) {
            break;
          }

          message.destinationAssetIssuer = reader.string();
          continue;
        case 8:
          if (tag !== 66) {
            break;
          }

          message.comment = reader.string();
          continue;
        case 16:
          if (tag !== 130) {
            break;
          }

          message.externalRequestId = reader.string();
          continue;
        case 17:
          if (tag !== 138) {
            break;
          }

          message.destinationAddressMemo = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CreateOutgoingXLMPathPaymentStrictSendRequestRequest {
    return {
      amount: isSet(object.amount) ? globalThis.String(object.amount) : "",
      minDestinationAmount: isSet(object.minDestinationAmount) ? globalThis.String(object.minDestinationAmount) : "",
      feeLimit: isSet(object.feeLimit) ? globalThis.String(object.feeLimit) : "",
      fromAddressId: isSet(object.fromAddressId) ? globalThis.Number(object.fromAddressId) : 0,
      toAddressId: isSet(object.toAddressId) ? globalThis.Number(object.toAddressId) : 0,
      toWhitelistedAddressId: isSet(object.toWhitelistedAddressId)
        ? globalThis.Number(object.toWhitelistedAddressId)
        : 0,
      destinationAssetID: isSet(object.destinationAssetID) ? globalThis.String(object.destinationAssetID) : "",
      destinationAssetIssuer: isSet(object.destinationAssetIssuer)
        ? globalThis.String(object.destinationAssetIssuer)
        : "",
      comment: isSet(object.comment) ? globalThis.String(object.comment) : "",
      externalRequestId: isSet(object.externalRequestId) ? globalThis.String(object.externalRequestId) : "",
      destinationAddressMemo: isSet(object.destinationAddressMemo)
        ? globalThis.String(object.destinationAddressMemo)
        : "",
    };
  },

  toJSON(message: CreateOutgoingXLMPathPaymentStrictSendRequestRequest): unknown {
    const obj: any = {};
    if (message.amount !== "") {
      obj.amount = message.amount;
    }
    if (message.minDestinationAmount !== "") {
      obj.minDestinationAmount = message.minDestinationAmount;
    }
    if (message.feeLimit !== "") {
      obj.feeLimit = message.feeLimit;
    }
    if (message.fromAddressId !== 0) {
      obj.fromAddressId = Math.round(message.fromAddressId);
    }
    if (message.toAddressId !== 0) {
      obj.toAddressId = Math.round(message.toAddressId);
    }
    if (message.toWhitelistedAddressId !== 0) {
      obj.toWhitelistedAddressId = Math.round(message.toWhitelistedAddressId);
    }
    if (message.destinationAssetID !== "") {
      obj.destinationAssetID = message.destinationAssetID;
    }
    if (message.destinationAssetIssuer !== "") {
      obj.destinationAssetIssuer = message.destinationAssetIssuer;
    }
    if (message.comment !== "") {
      obj.comment = message.comment;
    }
    if (message.externalRequestId !== "") {
      obj.externalRequestId = message.externalRequestId;
    }
    if (message.destinationAddressMemo !== "") {
      obj.destinationAddressMemo = message.destinationAddressMemo;
    }
    return obj;
  },

  create(
    base?: DeepPartial<CreateOutgoingXLMPathPaymentStrictSendRequestRequest>,
  ): CreateOutgoingXLMPathPaymentStrictSendRequestRequest {
    return CreateOutgoingXLMPathPaymentStrictSendRequestRequest.fromPartial(base ?? {});
  },
  fromPartial(
    object: DeepPartial<CreateOutgoingXLMPathPaymentStrictSendRequestRequest>,
  ): CreateOutgoingXLMPathPaymentStrictSendRequestRequest {
    const message = createBaseCreateOutgoingXLMPathPaymentStrictSendRequestRequest();
    message.amount = object.amount ?? "";
    message.minDestinationAmount = object.minDestinationAmount ?? "";
    message.feeLimit = object.feeLimit ?? "";
    message.fromAddressId = object.fromAddressId ?? 0;
    message.toAddressId = object.toAddressId ?? 0;
    message.toWhitelistedAddressId = object.toWhitelistedAddressId ?? 0;
    message.destinationAssetID = object.destinationAssetID ?? "";
    message.destinationAssetIssuer = object.destinationAssetIssuer ?? "";
    message.comment = object.comment ?? "";
    message.externalRequestId = object.externalRequestId ?? "";
    message.destinationAddressMemo = object.destinationAddressMemo ?? "";
    return message;
  },
};

function createBaseCreateOutgoingXLMPathPaymentStrictReceiveRequestRequest(): CreateOutgoingXLMPathPaymentStrictReceiveRequestRequest {
  return {
    amount: "",
    maxSenderAmount: "",
    feeLimit: "",
    fromAddressId: 0,
    toAddressId: 0,
    toWhitelistedAddressId: 0,
    destinationAssetID: "",
    destinationAssetIssuer: "",
    comment: "",
    externalRequestId: "",
    destinationAddressMemo: "",
  };
}

export const CreateOutgoingXLMPathPaymentStrictReceiveRequestRequest = {
  encode(
    message: CreateOutgoingXLMPathPaymentStrictReceiveRequestRequest,
    writer: _m0.Writer = _m0.Writer.create(),
  ): _m0.Writer {
    if (message.amount !== "") {
      writer.uint32(10).string(message.amount);
    }
    if (message.maxSenderAmount !== "") {
      writer.uint32(34).string(message.maxSenderAmount);
    }
    if (message.feeLimit !== "") {
      writer.uint32(18).string(message.feeLimit);
    }
    if (message.fromAddressId !== 0) {
      writer.uint32(24).uint64(message.fromAddressId);
    }
    if (message.toAddressId !== 0) {
      writer.uint32(40).uint64(message.toAddressId);
    }
    if (message.toWhitelistedAddressId !== 0) {
      writer.uint32(48).uint64(message.toWhitelistedAddressId);
    }
    if (message.destinationAssetID !== "") {
      writer.uint32(74).string(message.destinationAssetID);
    }
    if (message.destinationAssetIssuer !== "") {
      writer.uint32(82).string(message.destinationAssetIssuer);
    }
    if (message.comment !== "") {
      writer.uint32(66).string(message.comment);
    }
    if (message.externalRequestId !== "") {
      writer.uint32(130).string(message.externalRequestId);
    }
    if (message.destinationAddressMemo !== "") {
      writer.uint32(138).string(message.destinationAddressMemo);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CreateOutgoingXLMPathPaymentStrictReceiveRequestRequest {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCreateOutgoingXLMPathPaymentStrictReceiveRequestRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.amount = reader.string();
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.maxSenderAmount = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.feeLimit = reader.string();
          continue;
        case 3:
          if (tag !== 24) {
            break;
          }

          message.fromAddressId = longToNumber(reader.uint64() as Long);
          continue;
        case 5:
          if (tag !== 40) {
            break;
          }

          message.toAddressId = longToNumber(reader.uint64() as Long);
          continue;
        case 6:
          if (tag !== 48) {
            break;
          }

          message.toWhitelistedAddressId = longToNumber(reader.uint64() as Long);
          continue;
        case 9:
          if (tag !== 74) {
            break;
          }

          message.destinationAssetID = reader.string();
          continue;
        case 10:
          if (tag !== 82) {
            break;
          }

          message.destinationAssetIssuer = reader.string();
          continue;
        case 8:
          if (tag !== 66) {
            break;
          }

          message.comment = reader.string();
          continue;
        case 16:
          if (tag !== 130) {
            break;
          }

          message.externalRequestId = reader.string();
          continue;
        case 17:
          if (tag !== 138) {
            break;
          }

          message.destinationAddressMemo = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CreateOutgoingXLMPathPaymentStrictReceiveRequestRequest {
    return {
      amount: isSet(object.amount) ? globalThis.String(object.amount) : "",
      maxSenderAmount: isSet(object.maxSenderAmount) ? globalThis.String(object.maxSenderAmount) : "",
      feeLimit: isSet(object.feeLimit) ? globalThis.String(object.feeLimit) : "",
      fromAddressId: isSet(object.fromAddressId) ? globalThis.Number(object.fromAddressId) : 0,
      toAddressId: isSet(object.toAddressId) ? globalThis.Number(object.toAddressId) : 0,
      toWhitelistedAddressId: isSet(object.toWhitelistedAddressId)
        ? globalThis.Number(object.toWhitelistedAddressId)
        : 0,
      destinationAssetID: isSet(object.destinationAssetID) ? globalThis.String(object.destinationAssetID) : "",
      destinationAssetIssuer: isSet(object.destinationAssetIssuer)
        ? globalThis.String(object.destinationAssetIssuer)
        : "",
      comment: isSet(object.comment) ? globalThis.String(object.comment) : "",
      externalRequestId: isSet(object.externalRequestId) ? globalThis.String(object.externalRequestId) : "",
      destinationAddressMemo: isSet(object.destinationAddressMemo)
        ? globalThis.String(object.destinationAddressMemo)
        : "",
    };
  },

  toJSON(message: CreateOutgoingXLMPathPaymentStrictReceiveRequestRequest): unknown {
    const obj: any = {};
    if (message.amount !== "") {
      obj.amount = message.amount;
    }
    if (message.maxSenderAmount !== "") {
      obj.maxSenderAmount = message.maxSenderAmount;
    }
    if (message.feeLimit !== "") {
      obj.feeLimit = message.feeLimit;
    }
    if (message.fromAddressId !== 0) {
      obj.fromAddressId = Math.round(message.fromAddressId);
    }
    if (message.toAddressId !== 0) {
      obj.toAddressId = Math.round(message.toAddressId);
    }
    if (message.toWhitelistedAddressId !== 0) {
      obj.toWhitelistedAddressId = Math.round(message.toWhitelistedAddressId);
    }
    if (message.destinationAssetID !== "") {
      obj.destinationAssetID = message.destinationAssetID;
    }
    if (message.destinationAssetIssuer !== "") {
      obj.destinationAssetIssuer = message.destinationAssetIssuer;
    }
    if (message.comment !== "") {
      obj.comment = message.comment;
    }
    if (message.externalRequestId !== "") {
      obj.externalRequestId = message.externalRequestId;
    }
    if (message.destinationAddressMemo !== "") {
      obj.destinationAddressMemo = message.destinationAddressMemo;
    }
    return obj;
  },

  create(
    base?: DeepPartial<CreateOutgoingXLMPathPaymentStrictReceiveRequestRequest>,
  ): CreateOutgoingXLMPathPaymentStrictReceiveRequestRequest {
    return CreateOutgoingXLMPathPaymentStrictReceiveRequestRequest.fromPartial(base ?? {});
  },
  fromPartial(
    object: DeepPartial<CreateOutgoingXLMPathPaymentStrictReceiveRequestRequest>,
  ): CreateOutgoingXLMPathPaymentStrictReceiveRequestRequest {
    const message = createBaseCreateOutgoingXLMPathPaymentStrictReceiveRequestRequest();
    message.amount = object.amount ?? "";
    message.maxSenderAmount = object.maxSenderAmount ?? "";
    message.feeLimit = object.feeLimit ?? "";
    message.fromAddressId = object.fromAddressId ?? 0;
    message.toAddressId = object.toAddressId ?? 0;
    message.toWhitelistedAddressId = object.toWhitelistedAddressId ?? 0;
    message.destinationAssetID = object.destinationAssetID ?? "";
    message.destinationAssetIssuer = object.destinationAssetIssuer ?? "";
    message.comment = object.comment ?? "";
    message.externalRequestId = object.externalRequestId ?? "";
    message.destinationAddressMemo = object.destinationAddressMemo ?? "";
    return message;
  },
};

function createBaseCreateOutgoingXLMBuyOfferRequestRequest(): CreateOutgoingXLMBuyOfferRequestRequest {
  return {
    amount: "",
    feeLimit: "",
    fromAddressId: 0,
    buyingAssetID: "",
    buyingAssetIssuer: "",
    comment: "",
    price: "",
    offerID: 0,
    externalRequestId: "",
  };
}

export const CreateOutgoingXLMBuyOfferRequestRequest = {
  encode(message: CreateOutgoingXLMBuyOfferRequestRequest, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.amount !== "") {
      writer.uint32(18).string(message.amount);
    }
    if (message.feeLimit !== "") {
      writer.uint32(26).string(message.feeLimit);
    }
    if (message.fromAddressId !== 0) {
      writer.uint32(32).uint64(message.fromAddressId);
    }
    if (message.buyingAssetID !== "") {
      writer.uint32(42).string(message.buyingAssetID);
    }
    if (message.buyingAssetIssuer !== "") {
      writer.uint32(50).string(message.buyingAssetIssuer);
    }
    if (message.comment !== "") {
      writer.uint32(58).string(message.comment);
    }
    if (message.price !== "") {
      writer.uint32(66).string(message.price);
    }
    if (message.offerID !== 0) {
      writer.uint32(72).int64(message.offerID);
    }
    if (message.externalRequestId !== "") {
      writer.uint32(82).string(message.externalRequestId);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CreateOutgoingXLMBuyOfferRequestRequest {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCreateOutgoingXLMBuyOfferRequestRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 2:
          if (tag !== 18) {
            break;
          }

          message.amount = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.feeLimit = reader.string();
          continue;
        case 4:
          if (tag !== 32) {
            break;
          }

          message.fromAddressId = longToNumber(reader.uint64() as Long);
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.buyingAssetID = reader.string();
          continue;
        case 6:
          if (tag !== 50) {
            break;
          }

          message.buyingAssetIssuer = reader.string();
          continue;
        case 7:
          if (tag !== 58) {
            break;
          }

          message.comment = reader.string();
          continue;
        case 8:
          if (tag !== 66) {
            break;
          }

          message.price = reader.string();
          continue;
        case 9:
          if (tag !== 72) {
            break;
          }

          message.offerID = longToNumber(reader.int64() as Long);
          continue;
        case 10:
          if (tag !== 82) {
            break;
          }

          message.externalRequestId = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CreateOutgoingXLMBuyOfferRequestRequest {
    return {
      amount: isSet(object.amount) ? globalThis.String(object.amount) : "",
      feeLimit: isSet(object.feeLimit) ? globalThis.String(object.feeLimit) : "",
      fromAddressId: isSet(object.fromAddressId) ? globalThis.Number(object.fromAddressId) : 0,
      buyingAssetID: isSet(object.buyingAssetID) ? globalThis.String(object.buyingAssetID) : "",
      buyingAssetIssuer: isSet(object.buyingAssetIssuer) ? globalThis.String(object.buyingAssetIssuer) : "",
      comment: isSet(object.comment) ? globalThis.String(object.comment) : "",
      price: isSet(object.price) ? globalThis.String(object.price) : "",
      offerID: isSet(object.offerID) ? globalThis.Number(object.offerID) : 0,
      externalRequestId: isSet(object.externalRequestId) ? globalThis.String(object.externalRequestId) : "",
    };
  },

  toJSON(message: CreateOutgoingXLMBuyOfferRequestRequest): unknown {
    const obj: any = {};
    if (message.amount !== "") {
      obj.amount = message.amount;
    }
    if (message.feeLimit !== "") {
      obj.feeLimit = message.feeLimit;
    }
    if (message.fromAddressId !== 0) {
      obj.fromAddressId = Math.round(message.fromAddressId);
    }
    if (message.buyingAssetID !== "") {
      obj.buyingAssetID = message.buyingAssetID;
    }
    if (message.buyingAssetIssuer !== "") {
      obj.buyingAssetIssuer = message.buyingAssetIssuer;
    }
    if (message.comment !== "") {
      obj.comment = message.comment;
    }
    if (message.price !== "") {
      obj.price = message.price;
    }
    if (message.offerID !== 0) {
      obj.offerID = Math.round(message.offerID);
    }
    if (message.externalRequestId !== "") {
      obj.externalRequestId = message.externalRequestId;
    }
    return obj;
  },

  create(base?: DeepPartial<CreateOutgoingXLMBuyOfferRequestRequest>): CreateOutgoingXLMBuyOfferRequestRequest {
    return CreateOutgoingXLMBuyOfferRequestRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CreateOutgoingXLMBuyOfferRequestRequest>): CreateOutgoingXLMBuyOfferRequestRequest {
    const message = createBaseCreateOutgoingXLMBuyOfferRequestRequest();
    message.amount = object.amount ?? "";
    message.feeLimit = object.feeLimit ?? "";
    message.fromAddressId = object.fromAddressId ?? 0;
    message.buyingAssetID = object.buyingAssetID ?? "";
    message.buyingAssetIssuer = object.buyingAssetIssuer ?? "";
    message.comment = object.comment ?? "";
    message.price = object.price ?? "";
    message.offerID = object.offerID ?? 0;
    message.externalRequestId = object.externalRequestId ?? "";
    return message;
  },
};

function createBaseCreateOutgoingXLMSellOfferRequestRequest(): CreateOutgoingXLMSellOfferRequestRequest {
  return {
    amount: "",
    feeLimit: "",
    fromAddressId: 0,
    buyingAssetID: "",
    buyingAssetIssuer: "",
    comment: "",
    price: "",
    offerID: 0,
    isPassive: false,
    externalRequestId: "",
  };
}

export const CreateOutgoingXLMSellOfferRequestRequest = {
  encode(message: CreateOutgoingXLMSellOfferRequestRequest, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.amount !== "") {
      writer.uint32(18).string(message.amount);
    }
    if (message.feeLimit !== "") {
      writer.uint32(26).string(message.feeLimit);
    }
    if (message.fromAddressId !== 0) {
      writer.uint32(32).uint64(message.fromAddressId);
    }
    if (message.buyingAssetID !== "") {
      writer.uint32(42).string(message.buyingAssetID);
    }
    if (message.buyingAssetIssuer !== "") {
      writer.uint32(50).string(message.buyingAssetIssuer);
    }
    if (message.comment !== "") {
      writer.uint32(58).string(message.comment);
    }
    if (message.price !== "") {
      writer.uint32(66).string(message.price);
    }
    if (message.offerID !== 0) {
      writer.uint32(72).int64(message.offerID);
    }
    if (message.isPassive !== false) {
      writer.uint32(80).bool(message.isPassive);
    }
    if (message.externalRequestId !== "") {
      writer.uint32(90).string(message.externalRequestId);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CreateOutgoingXLMSellOfferRequestRequest {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCreateOutgoingXLMSellOfferRequestRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 2:
          if (tag !== 18) {
            break;
          }

          message.amount = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.feeLimit = reader.string();
          continue;
        case 4:
          if (tag !== 32) {
            break;
          }

          message.fromAddressId = longToNumber(reader.uint64() as Long);
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.buyingAssetID = reader.string();
          continue;
        case 6:
          if (tag !== 50) {
            break;
          }

          message.buyingAssetIssuer = reader.string();
          continue;
        case 7:
          if (tag !== 58) {
            break;
          }

          message.comment = reader.string();
          continue;
        case 8:
          if (tag !== 66) {
            break;
          }

          message.price = reader.string();
          continue;
        case 9:
          if (tag !== 72) {
            break;
          }

          message.offerID = longToNumber(reader.int64() as Long);
          continue;
        case 10:
          if (tag !== 80) {
            break;
          }

          message.isPassive = reader.bool();
          continue;
        case 11:
          if (tag !== 90) {
            break;
          }

          message.externalRequestId = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CreateOutgoingXLMSellOfferRequestRequest {
    return {
      amount: isSet(object.amount) ? globalThis.String(object.amount) : "",
      feeLimit: isSet(object.feeLimit) ? globalThis.String(object.feeLimit) : "",
      fromAddressId: isSet(object.fromAddressId) ? globalThis.Number(object.fromAddressId) : 0,
      buyingAssetID: isSet(object.buyingAssetID) ? globalThis.String(object.buyingAssetID) : "",
      buyingAssetIssuer: isSet(object.buyingAssetIssuer) ? globalThis.String(object.buyingAssetIssuer) : "",
      comment: isSet(object.comment) ? globalThis.String(object.comment) : "",
      price: isSet(object.price) ? globalThis.String(object.price) : "",
      offerID: isSet(object.offerID) ? globalThis.Number(object.offerID) : 0,
      isPassive: isSet(object.isPassive) ? globalThis.Boolean(object.isPassive) : false,
      externalRequestId: isSet(object.externalRequestId) ? globalThis.String(object.externalRequestId) : "",
    };
  },

  toJSON(message: CreateOutgoingXLMSellOfferRequestRequest): unknown {
    const obj: any = {};
    if (message.amount !== "") {
      obj.amount = message.amount;
    }
    if (message.feeLimit !== "") {
      obj.feeLimit = message.feeLimit;
    }
    if (message.fromAddressId !== 0) {
      obj.fromAddressId = Math.round(message.fromAddressId);
    }
    if (message.buyingAssetID !== "") {
      obj.buyingAssetID = message.buyingAssetID;
    }
    if (message.buyingAssetIssuer !== "") {
      obj.buyingAssetIssuer = message.buyingAssetIssuer;
    }
    if (message.comment !== "") {
      obj.comment = message.comment;
    }
    if (message.price !== "") {
      obj.price = message.price;
    }
    if (message.offerID !== 0) {
      obj.offerID = Math.round(message.offerID);
    }
    if (message.isPassive !== false) {
      obj.isPassive = message.isPassive;
    }
    if (message.externalRequestId !== "") {
      obj.externalRequestId = message.externalRequestId;
    }
    return obj;
  },

  create(base?: DeepPartial<CreateOutgoingXLMSellOfferRequestRequest>): CreateOutgoingXLMSellOfferRequestRequest {
    return CreateOutgoingXLMSellOfferRequestRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CreateOutgoingXLMSellOfferRequestRequest>): CreateOutgoingXLMSellOfferRequestRequest {
    const message = createBaseCreateOutgoingXLMSellOfferRequestRequest();
    message.amount = object.amount ?? "";
    message.feeLimit = object.feeLimit ?? "";
    message.fromAddressId = object.fromAddressId ?? 0;
    message.buyingAssetID = object.buyingAssetID ?? "";
    message.buyingAssetIssuer = object.buyingAssetIssuer ?? "";
    message.comment = object.comment ?? "";
    message.price = object.price ?? "";
    message.offerID = object.offerID ?? 0;
    message.isPassive = object.isPassive ?? false;
    message.externalRequestId = object.externalRequestId ?? "";
    return message;
  },
};

function createBaseCreateOutgoingALGOASAOptInRequestRequest(): CreateOutgoingALGOASAOptInRequestRequest {
  return { fromAddressId: 0, assetId: 0, feeLimit: "", comment: "", transactionReference: "", externalRequestId: "" };
}

export const CreateOutgoingALGOASAOptInRequestRequest = {
  encode(message: CreateOutgoingALGOASAOptInRequestRequest, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.fromAddressId !== 0) {
      writer.uint32(8).uint64(message.fromAddressId);
    }
    if (message.assetId !== 0) {
      writer.uint32(32).uint64(message.assetId);
    }
    if (message.feeLimit !== "") {
      writer.uint32(50).string(message.feeLimit);
    }
    if (message.comment !== "") {
      writer.uint32(58).string(message.comment);
    }
    if (message.transactionReference !== "") {
      writer.uint32(66).string(message.transactionReference);
    }
    if (message.externalRequestId !== "") {
      writer.uint32(74).string(message.externalRequestId);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CreateOutgoingALGOASAOptInRequestRequest {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCreateOutgoingALGOASAOptInRequestRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.fromAddressId = longToNumber(reader.uint64() as Long);
          continue;
        case 4:
          if (tag !== 32) {
            break;
          }

          message.assetId = longToNumber(reader.uint64() as Long);
          continue;
        case 6:
          if (tag !== 50) {
            break;
          }

          message.feeLimit = reader.string();
          continue;
        case 7:
          if (tag !== 58) {
            break;
          }

          message.comment = reader.string();
          continue;
        case 8:
          if (tag !== 66) {
            break;
          }

          message.transactionReference = reader.string();
          continue;
        case 9:
          if (tag !== 74) {
            break;
          }

          message.externalRequestId = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CreateOutgoingALGOASAOptInRequestRequest {
    return {
      fromAddressId: isSet(object.fromAddressId) ? globalThis.Number(object.fromAddressId) : 0,
      assetId: isSet(object.assetId) ? globalThis.Number(object.assetId) : 0,
      feeLimit: isSet(object.feeLimit) ? globalThis.String(object.feeLimit) : "",
      comment: isSet(object.comment) ? globalThis.String(object.comment) : "",
      transactionReference: isSet(object.transactionReference) ? globalThis.String(object.transactionReference) : "",
      externalRequestId: isSet(object.externalRequestId) ? globalThis.String(object.externalRequestId) : "",
    };
  },

  toJSON(message: CreateOutgoingALGOASAOptInRequestRequest): unknown {
    const obj: any = {};
    if (message.fromAddressId !== 0) {
      obj.fromAddressId = Math.round(message.fromAddressId);
    }
    if (message.assetId !== 0) {
      obj.assetId = Math.round(message.assetId);
    }
    if (message.feeLimit !== "") {
      obj.feeLimit = message.feeLimit;
    }
    if (message.comment !== "") {
      obj.comment = message.comment;
    }
    if (message.transactionReference !== "") {
      obj.transactionReference = message.transactionReference;
    }
    if (message.externalRequestId !== "") {
      obj.externalRequestId = message.externalRequestId;
    }
    return obj;
  },

  create(base?: DeepPartial<CreateOutgoingALGOASAOptInRequestRequest>): CreateOutgoingALGOASAOptInRequestRequest {
    return CreateOutgoingALGOASAOptInRequestRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CreateOutgoingALGOASAOptInRequestRequest>): CreateOutgoingALGOASAOptInRequestRequest {
    const message = createBaseCreateOutgoingALGOASAOptInRequestRequest();
    message.fromAddressId = object.fromAddressId ?? 0;
    message.assetId = object.assetId ?? 0;
    message.feeLimit = object.feeLimit ?? "";
    message.comment = object.comment ?? "";
    message.transactionReference = object.transactionReference ?? "";
    message.externalRequestId = object.externalRequestId ?? "";
    return message;
  },
};

function createBaseCreateIncomingRequestRequest(): CreateIncomingRequestRequest {
  return {
    amount: "",
    fromExchangeId: 0,
    toAddressId: 0,
    comment: "",
    transactionReference: "",
    externalRequestId: "",
    feePaidByReceiver: false,
  };
}

export const CreateIncomingRequestRequest = {
  encode(message: CreateIncomingRequestRequest, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.amount !== "") {
      writer.uint32(10).string(message.amount);
    }
    if (message.fromExchangeId !== 0) {
      writer.uint32(16).uint64(message.fromExchangeId);
    }
    if (message.toAddressId !== 0) {
      writer.uint32(24).uint64(message.toAddressId);
    }
    if (message.comment !== "") {
      writer.uint32(34).string(message.comment);
    }
    if (message.transactionReference !== "") {
      writer.uint32(42).string(message.transactionReference);
    }
    if (message.externalRequestId !== "") {
      writer.uint32(50).string(message.externalRequestId);
    }
    if (message.feePaidByReceiver !== false) {
      writer.uint32(56).bool(message.feePaidByReceiver);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CreateIncomingRequestRequest {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCreateIncomingRequestRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.amount = reader.string();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.fromExchangeId = longToNumber(reader.uint64() as Long);
          continue;
        case 3:
          if (tag !== 24) {
            break;
          }

          message.toAddressId = longToNumber(reader.uint64() as Long);
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.comment = reader.string();
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.transactionReference = reader.string();
          continue;
        case 6:
          if (tag !== 50) {
            break;
          }

          message.externalRequestId = reader.string();
          continue;
        case 7:
          if (tag !== 56) {
            break;
          }

          message.feePaidByReceiver = reader.bool();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CreateIncomingRequestRequest {
    return {
      amount: isSet(object.amount) ? globalThis.String(object.amount) : "",
      fromExchangeId: isSet(object.fromExchangeId) ? globalThis.Number(object.fromExchangeId) : 0,
      toAddressId: isSet(object.toAddressId) ? globalThis.Number(object.toAddressId) : 0,
      comment: isSet(object.comment) ? globalThis.String(object.comment) : "",
      transactionReference: isSet(object.transactionReference) ? globalThis.String(object.transactionReference) : "",
      externalRequestId: isSet(object.externalRequestId) ? globalThis.String(object.externalRequestId) : "",
      feePaidByReceiver: isSet(object.feePaidByReceiver) ? globalThis.Boolean(object.feePaidByReceiver) : false,
    };
  },

  toJSON(message: CreateIncomingRequestRequest): unknown {
    const obj: any = {};
    if (message.amount !== "") {
      obj.amount = message.amount;
    }
    if (message.fromExchangeId !== 0) {
      obj.fromExchangeId = Math.round(message.fromExchangeId);
    }
    if (message.toAddressId !== 0) {
      obj.toAddressId = Math.round(message.toAddressId);
    }
    if (message.comment !== "") {
      obj.comment = message.comment;
    }
    if (message.transactionReference !== "") {
      obj.transactionReference = message.transactionReference;
    }
    if (message.externalRequestId !== "") {
      obj.externalRequestId = message.externalRequestId;
    }
    if (message.feePaidByReceiver !== false) {
      obj.feePaidByReceiver = message.feePaidByReceiver;
    }
    return obj;
  },

  create(base?: DeepPartial<CreateIncomingRequestRequest>): CreateIncomingRequestRequest {
    return CreateIncomingRequestRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CreateIncomingRequestRequest>): CreateIncomingRequestRequest {
    const message = createBaseCreateIncomingRequestRequest();
    message.amount = object.amount ?? "";
    message.fromExchangeId = object.fromExchangeId ?? 0;
    message.toAddressId = object.toAddressId ?? 0;
    message.comment = object.comment ?? "";
    message.transactionReference = object.transactionReference ?? "";
    message.externalRequestId = object.externalRequestId ?? "";
    message.feePaidByReceiver = object.feePaidByReceiver ?? false;
    return message;
  },
};

function createBaseCreateFiatProviderWithdrawalRequestRequest(): CreateFiatProviderWithdrawalRequestRequest {
  return {
    amount: "",
    fromAccountID: "",
    toAddressID: undefined,
    toAccountID: undefined,
    comment: "",
    externalRequestID: "",
  };
}

export const CreateFiatProviderWithdrawalRequestRequest = {
  encode(message: CreateFiatProviderWithdrawalRequestRequest, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.amount !== "") {
      writer.uint32(10).string(message.amount);
    }
    if (message.fromAccountID !== "") {
      writer.uint32(18).string(message.fromAccountID);
    }
    if (message.toAddressID !== undefined) {
      writer.uint32(24).uint64(message.toAddressID);
    }
    if (message.toAccountID !== undefined) {
      writer.uint32(34).string(message.toAccountID);
    }
    if (message.comment !== "") {
      writer.uint32(42).string(message.comment);
    }
    if (message.externalRequestID !== "") {
      writer.uint32(50).string(message.externalRequestID);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CreateFiatProviderWithdrawalRequestRequest {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCreateFiatProviderWithdrawalRequestRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.amount = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.fromAccountID = reader.string();
          continue;
        case 3:
          if (tag !== 24) {
            break;
          }

          message.toAddressID = longToNumber(reader.uint64() as Long);
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.toAccountID = reader.string();
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.comment = reader.string();
          continue;
        case 6:
          if (tag !== 50) {
            break;
          }

          message.externalRequestID = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CreateFiatProviderWithdrawalRequestRequest {
    return {
      amount: isSet(object.amount) ? globalThis.String(object.amount) : "",
      fromAccountID: isSet(object.fromAccountID) ? globalThis.String(object.fromAccountID) : "",
      toAddressID: isSet(object.toAddressID) ? globalThis.Number(object.toAddressID) : undefined,
      toAccountID: isSet(object.toAccountID) ? globalThis.String(object.toAccountID) : undefined,
      comment: isSet(object.comment) ? globalThis.String(object.comment) : "",
      externalRequestID: isSet(object.externalRequestID) ? globalThis.String(object.externalRequestID) : "",
    };
  },

  toJSON(message: CreateFiatProviderWithdrawalRequestRequest): unknown {
    const obj: any = {};
    if (message.amount !== "") {
      obj.amount = message.amount;
    }
    if (message.fromAccountID !== "") {
      obj.fromAccountID = message.fromAccountID;
    }
    if (message.toAddressID !== undefined) {
      obj.toAddressID = Math.round(message.toAddressID);
    }
    if (message.toAccountID !== undefined) {
      obj.toAccountID = message.toAccountID;
    }
    if (message.comment !== "") {
      obj.comment = message.comment;
    }
    if (message.externalRequestID !== "") {
      obj.externalRequestID = message.externalRequestID;
    }
    return obj;
  },

  create(base?: DeepPartial<CreateFiatProviderWithdrawalRequestRequest>): CreateFiatProviderWithdrawalRequestRequest {
    return CreateFiatProviderWithdrawalRequestRequest.fromPartial(base ?? {});
  },
  fromPartial(
    object: DeepPartial<CreateFiatProviderWithdrawalRequestRequest>,
  ): CreateFiatProviderWithdrawalRequestRequest {
    const message = createBaseCreateFiatProviderWithdrawalRequestRequest();
    message.amount = object.amount ?? "";
    message.fromAccountID = object.fromAccountID ?? "";
    message.toAddressID = object.toAddressID ?? undefined;
    message.toAccountID = object.toAccountID ?? undefined;
    message.comment = object.comment ?? "";
    message.externalRequestID = object.externalRequestID ?? "";
    return message;
  },
};

function createBaseCreateFiatProviderDepositRequestRequest(): CreateFiatProviderDepositRequestRequest {
  return {
    amount: "",
    fromAccountID: undefined,
    fromAddressID: undefined,
    toAccountID: "",
    comment: "",
    externalRequestID: "",
  };
}

export const CreateFiatProviderDepositRequestRequest = {
  encode(message: CreateFiatProviderDepositRequestRequest, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.amount !== "") {
      writer.uint32(10).string(message.amount);
    }
    if (message.fromAccountID !== undefined) {
      writer.uint32(18).string(message.fromAccountID);
    }
    if (message.fromAddressID !== undefined) {
      writer.uint32(24).uint64(message.fromAddressID);
    }
    if (message.toAccountID !== "") {
      writer.uint32(34).string(message.toAccountID);
    }
    if (message.comment !== "") {
      writer.uint32(42).string(message.comment);
    }
    if (message.externalRequestID !== "") {
      writer.uint32(50).string(message.externalRequestID);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CreateFiatProviderDepositRequestRequest {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCreateFiatProviderDepositRequestRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.amount = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.fromAccountID = reader.string();
          continue;
        case 3:
          if (tag !== 24) {
            break;
          }

          message.fromAddressID = longToNumber(reader.uint64() as Long);
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.toAccountID = reader.string();
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.comment = reader.string();
          continue;
        case 6:
          if (tag !== 50) {
            break;
          }

          message.externalRequestID = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CreateFiatProviderDepositRequestRequest {
    return {
      amount: isSet(object.amount) ? globalThis.String(object.amount) : "",
      fromAccountID: isSet(object.fromAccountID) ? globalThis.String(object.fromAccountID) : undefined,
      fromAddressID: isSet(object.fromAddressID) ? globalThis.Number(object.fromAddressID) : undefined,
      toAccountID: isSet(object.toAccountID) ? globalThis.String(object.toAccountID) : "",
      comment: isSet(object.comment) ? globalThis.String(object.comment) : "",
      externalRequestID: isSet(object.externalRequestID) ? globalThis.String(object.externalRequestID) : "",
    };
  },

  toJSON(message: CreateFiatProviderDepositRequestRequest): unknown {
    const obj: any = {};
    if (message.amount !== "") {
      obj.amount = message.amount;
    }
    if (message.fromAccountID !== undefined) {
      obj.fromAccountID = message.fromAccountID;
    }
    if (message.fromAddressID !== undefined) {
      obj.fromAddressID = Math.round(message.fromAddressID);
    }
    if (message.toAccountID !== "") {
      obj.toAccountID = message.toAccountID;
    }
    if (message.comment !== "") {
      obj.comment = message.comment;
    }
    if (message.externalRequestID !== "") {
      obj.externalRequestID = message.externalRequestID;
    }
    return obj;
  },

  create(base?: DeepPartial<CreateFiatProviderDepositRequestRequest>): CreateFiatProviderDepositRequestRequest {
    return CreateFiatProviderDepositRequestRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CreateFiatProviderDepositRequestRequest>): CreateFiatProviderDepositRequestRequest {
    const message = createBaseCreateFiatProviderDepositRequestRequest();
    message.amount = object.amount ?? "";
    message.fromAccountID = object.fromAccountID ?? undefined;
    message.fromAddressID = object.fromAddressID ?? undefined;
    message.toAccountID = object.toAccountID ?? "";
    message.comment = object.comment ?? "";
    message.externalRequestID = object.externalRequestID ?? "";
    return message;
  },
};

function createBaseCreateFiatProviderTransferRequestRequest(): CreateFiatProviderTransferRequestRequest {
  return {
    amount: "",
    fromAccountID: "",
    toAccountID: undefined,
    toCounterpartyAccountID: undefined,
    comment: "",
    externalRequestID: "",
  };
}

export const CreateFiatProviderTransferRequestRequest = {
  encode(message: CreateFiatProviderTransferRequestRequest, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.amount !== "") {
      writer.uint32(10).string(message.amount);
    }
    if (message.fromAccountID !== "") {
      writer.uint32(18).string(message.fromAccountID);
    }
    if (message.toAccountID !== undefined) {
      writer.uint32(26).string(message.toAccountID);
    }
    if (message.toCounterpartyAccountID !== undefined) {
      writer.uint32(34).string(message.toCounterpartyAccountID);
    }
    if (message.comment !== "") {
      writer.uint32(42).string(message.comment);
    }
    if (message.externalRequestID !== "") {
      writer.uint32(50).string(message.externalRequestID);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CreateFiatProviderTransferRequestRequest {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCreateFiatProviderTransferRequestRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.amount = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.fromAccountID = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.toAccountID = reader.string();
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.toCounterpartyAccountID = reader.string();
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.comment = reader.string();
          continue;
        case 6:
          if (tag !== 50) {
            break;
          }

          message.externalRequestID = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CreateFiatProviderTransferRequestRequest {
    return {
      amount: isSet(object.amount) ? globalThis.String(object.amount) : "",
      fromAccountID: isSet(object.fromAccountID) ? globalThis.String(object.fromAccountID) : "",
      toAccountID: isSet(object.toAccountID) ? globalThis.String(object.toAccountID) : undefined,
      toCounterpartyAccountID: isSet(object.toCounterpartyAccountID)
        ? globalThis.String(object.toCounterpartyAccountID)
        : undefined,
      comment: isSet(object.comment) ? globalThis.String(object.comment) : "",
      externalRequestID: isSet(object.externalRequestID) ? globalThis.String(object.externalRequestID) : "",
    };
  },

  toJSON(message: CreateFiatProviderTransferRequestRequest): unknown {
    const obj: any = {};
    if (message.amount !== "") {
      obj.amount = message.amount;
    }
    if (message.fromAccountID !== "") {
      obj.fromAccountID = message.fromAccountID;
    }
    if (message.toAccountID !== undefined) {
      obj.toAccountID = message.toAccountID;
    }
    if (message.toCounterpartyAccountID !== undefined) {
      obj.toCounterpartyAccountID = message.toCounterpartyAccountID;
    }
    if (message.comment !== "") {
      obj.comment = message.comment;
    }
    if (message.externalRequestID !== "") {
      obj.externalRequestID = message.externalRequestID;
    }
    return obj;
  },

  create(base?: DeepPartial<CreateFiatProviderTransferRequestRequest>): CreateFiatProviderTransferRequestRequest {
    return CreateFiatProviderTransferRequestRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CreateFiatProviderTransferRequestRequest>): CreateFiatProviderTransferRequestRequest {
    const message = createBaseCreateFiatProviderTransferRequestRequest();
    message.amount = object.amount ?? "";
    message.fromAccountID = object.fromAccountID ?? "";
    message.toAccountID = object.toAccountID ?? undefined;
    message.toCounterpartyAccountID = object.toCounterpartyAccountID ?? undefined;
    message.comment = object.comment ?? "";
    message.externalRequestID = object.externalRequestID ?? "";
    return message;
  },
};

function createBaseCreateOutgoingSOLDelegateRequestRequest(): CreateOutgoingSOLDelegateRequestRequest {
  return {
    fromAddressId: 0,
    toValidatorAddressId: 0,
    amount: "",
    feeLimit: "",
    comment: "",
    useUnconfirmedFunds: false,
    externalRequestId: "",
    autoMerging: false,
  };
}

export const CreateOutgoingSOLDelegateRequestRequest = {
  encode(message: CreateOutgoingSOLDelegateRequestRequest, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.fromAddressId !== 0) {
      writer.uint32(8).uint64(message.fromAddressId);
    }
    if (message.toValidatorAddressId !== 0) {
      writer.uint32(16).uint64(message.toValidatorAddressId);
    }
    if (message.amount !== "") {
      writer.uint32(26).string(message.amount);
    }
    if (message.feeLimit !== "") {
      writer.uint32(34).string(message.feeLimit);
    }
    if (message.comment !== "") {
      writer.uint32(42).string(message.comment);
    }
    if (message.useUnconfirmedFunds !== false) {
      writer.uint32(48).bool(message.useUnconfirmedFunds);
    }
    if (message.externalRequestId !== "") {
      writer.uint32(58).string(message.externalRequestId);
    }
    if (message.autoMerging !== false) {
      writer.uint32(64).bool(message.autoMerging);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CreateOutgoingSOLDelegateRequestRequest {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCreateOutgoingSOLDelegateRequestRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.fromAddressId = longToNumber(reader.uint64() as Long);
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.toValidatorAddressId = longToNumber(reader.uint64() as Long);
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.amount = reader.string();
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.feeLimit = reader.string();
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.comment = reader.string();
          continue;
        case 6:
          if (tag !== 48) {
            break;
          }

          message.useUnconfirmedFunds = reader.bool();
          continue;
        case 7:
          if (tag !== 58) {
            break;
          }

          message.externalRequestId = reader.string();
          continue;
        case 8:
          if (tag !== 64) {
            break;
          }

          message.autoMerging = reader.bool();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CreateOutgoingSOLDelegateRequestRequest {
    return {
      fromAddressId: isSet(object.fromAddressId) ? globalThis.Number(object.fromAddressId) : 0,
      toValidatorAddressId: isSet(object.toValidatorAddressId) ? globalThis.Number(object.toValidatorAddressId) : 0,
      amount: isSet(object.amount) ? globalThis.String(object.amount) : "",
      feeLimit: isSet(object.feeLimit) ? globalThis.String(object.feeLimit) : "",
      comment: isSet(object.comment) ? globalThis.String(object.comment) : "",
      useUnconfirmedFunds: isSet(object.useUnconfirmedFunds) ? globalThis.Boolean(object.useUnconfirmedFunds) : false,
      externalRequestId: isSet(object.externalRequestId) ? globalThis.String(object.externalRequestId) : "",
      autoMerging: isSet(object.autoMerging) ? globalThis.Boolean(object.autoMerging) : false,
    };
  },

  toJSON(message: CreateOutgoingSOLDelegateRequestRequest): unknown {
    const obj: any = {};
    if (message.fromAddressId !== 0) {
      obj.fromAddressId = Math.round(message.fromAddressId);
    }
    if (message.toValidatorAddressId !== 0) {
      obj.toValidatorAddressId = Math.round(message.toValidatorAddressId);
    }
    if (message.amount !== "") {
      obj.amount = message.amount;
    }
    if (message.feeLimit !== "") {
      obj.feeLimit = message.feeLimit;
    }
    if (message.comment !== "") {
      obj.comment = message.comment;
    }
    if (message.useUnconfirmedFunds !== false) {
      obj.useUnconfirmedFunds = message.useUnconfirmedFunds;
    }
    if (message.externalRequestId !== "") {
      obj.externalRequestId = message.externalRequestId;
    }
    if (message.autoMerging !== false) {
      obj.autoMerging = message.autoMerging;
    }
    return obj;
  },

  create(base?: DeepPartial<CreateOutgoingSOLDelegateRequestRequest>): CreateOutgoingSOLDelegateRequestRequest {
    return CreateOutgoingSOLDelegateRequestRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CreateOutgoingSOLDelegateRequestRequest>): CreateOutgoingSOLDelegateRequestRequest {
    const message = createBaseCreateOutgoingSOLDelegateRequestRequest();
    message.fromAddressId = object.fromAddressId ?? 0;
    message.toValidatorAddressId = object.toValidatorAddressId ?? 0;
    message.amount = object.amount ?? "";
    message.feeLimit = object.feeLimit ?? "";
    message.comment = object.comment ?? "";
    message.useUnconfirmedFunds = object.useUnconfirmedFunds ?? false;
    message.externalRequestId = object.externalRequestId ?? "";
    message.autoMerging = object.autoMerging ?? false;
    return message;
  },
};

function createBaseCreateOutgoingSOLDeactivateRequestRequest(): CreateOutgoingSOLDeactivateRequestRequest {
  return {
    fromAddressId: 0,
    feeLimit: "",
    comment: "",
    useUnconfirmedFunds: false,
    externalRequestId: "",
    fromStakeAccountDerivationIndex: 0,
    amount: 0,
  };
}

export const CreateOutgoingSOLDeactivateRequestRequest = {
  encode(message: CreateOutgoingSOLDeactivateRequestRequest, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.fromAddressId !== 0) {
      writer.uint32(8).uint64(message.fromAddressId);
    }
    if (message.feeLimit !== "") {
      writer.uint32(18).string(message.feeLimit);
    }
    if (message.comment !== "") {
      writer.uint32(26).string(message.comment);
    }
    if (message.useUnconfirmedFunds !== false) {
      writer.uint32(32).bool(message.useUnconfirmedFunds);
    }
    if (message.externalRequestId !== "") {
      writer.uint32(42).string(message.externalRequestId);
    }
    if (message.fromStakeAccountDerivationIndex !== 0) {
      writer.uint32(48).uint64(message.fromStakeAccountDerivationIndex);
    }
    if (message.amount !== 0) {
      writer.uint32(56).uint64(message.amount);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CreateOutgoingSOLDeactivateRequestRequest {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCreateOutgoingSOLDeactivateRequestRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.fromAddressId = longToNumber(reader.uint64() as Long);
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.feeLimit = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.comment = reader.string();
          continue;
        case 4:
          if (tag !== 32) {
            break;
          }

          message.useUnconfirmedFunds = reader.bool();
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.externalRequestId = reader.string();
          continue;
        case 6:
          if (tag !== 48) {
            break;
          }

          message.fromStakeAccountDerivationIndex = longToNumber(reader.uint64() as Long);
          continue;
        case 7:
          if (tag !== 56) {
            break;
          }

          message.amount = longToNumber(reader.uint64() as Long);
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CreateOutgoingSOLDeactivateRequestRequest {
    return {
      fromAddressId: isSet(object.fromAddressId) ? globalThis.Number(object.fromAddressId) : 0,
      feeLimit: isSet(object.feeLimit) ? globalThis.String(object.feeLimit) : "",
      comment: isSet(object.comment) ? globalThis.String(object.comment) : "",
      useUnconfirmedFunds: isSet(object.useUnconfirmedFunds) ? globalThis.Boolean(object.useUnconfirmedFunds) : false,
      externalRequestId: isSet(object.externalRequestId) ? globalThis.String(object.externalRequestId) : "",
      fromStakeAccountDerivationIndex: isSet(object.fromStakeAccountDerivationIndex)
        ? globalThis.Number(object.fromStakeAccountDerivationIndex)
        : 0,
      amount: isSet(object.amount) ? globalThis.Number(object.amount) : 0,
    };
  },

  toJSON(message: CreateOutgoingSOLDeactivateRequestRequest): unknown {
    const obj: any = {};
    if (message.fromAddressId !== 0) {
      obj.fromAddressId = Math.round(message.fromAddressId);
    }
    if (message.feeLimit !== "") {
      obj.feeLimit = message.feeLimit;
    }
    if (message.comment !== "") {
      obj.comment = message.comment;
    }
    if (message.useUnconfirmedFunds !== false) {
      obj.useUnconfirmedFunds = message.useUnconfirmedFunds;
    }
    if (message.externalRequestId !== "") {
      obj.externalRequestId = message.externalRequestId;
    }
    if (message.fromStakeAccountDerivationIndex !== 0) {
      obj.fromStakeAccountDerivationIndex = Math.round(message.fromStakeAccountDerivationIndex);
    }
    if (message.amount !== 0) {
      obj.amount = Math.round(message.amount);
    }
    return obj;
  },

  create(base?: DeepPartial<CreateOutgoingSOLDeactivateRequestRequest>): CreateOutgoingSOLDeactivateRequestRequest {
    return CreateOutgoingSOLDeactivateRequestRequest.fromPartial(base ?? {});
  },
  fromPartial(
    object: DeepPartial<CreateOutgoingSOLDeactivateRequestRequest>,
  ): CreateOutgoingSOLDeactivateRequestRequest {
    const message = createBaseCreateOutgoingSOLDeactivateRequestRequest();
    message.fromAddressId = object.fromAddressId ?? 0;
    message.feeLimit = object.feeLimit ?? "";
    message.comment = object.comment ?? "";
    message.useUnconfirmedFunds = object.useUnconfirmedFunds ?? false;
    message.externalRequestId = object.externalRequestId ?? "";
    message.fromStakeAccountDerivationIndex = object.fromStakeAccountDerivationIndex ?? 0;
    message.amount = object.amount ?? 0;
    return message;
  },
};

function createBaseCreateOutgoingSOLWithdrawRequestRequest(): CreateOutgoingSOLWithdrawRequestRequest {
  return {
    fromAddressId: 0,
    amount: "",
    feeLimit: "",
    comment: "",
    useUnconfirmedFunds: false,
    externalRequestId: "",
    fromStakeAccountDerivationIndex: 0,
  };
}

export const CreateOutgoingSOLWithdrawRequestRequest = {
  encode(message: CreateOutgoingSOLWithdrawRequestRequest, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.fromAddressId !== 0) {
      writer.uint32(8).uint64(message.fromAddressId);
    }
    if (message.amount !== "") {
      writer.uint32(18).string(message.amount);
    }
    if (message.feeLimit !== "") {
      writer.uint32(26).string(message.feeLimit);
    }
    if (message.comment !== "") {
      writer.uint32(34).string(message.comment);
    }
    if (message.useUnconfirmedFunds !== false) {
      writer.uint32(40).bool(message.useUnconfirmedFunds);
    }
    if (message.externalRequestId !== "") {
      writer.uint32(50).string(message.externalRequestId);
    }
    if (message.fromStakeAccountDerivationIndex !== 0) {
      writer.uint32(56).uint64(message.fromStakeAccountDerivationIndex);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CreateOutgoingSOLWithdrawRequestRequest {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCreateOutgoingSOLWithdrawRequestRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.fromAddressId = longToNumber(reader.uint64() as Long);
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.amount = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.feeLimit = reader.string();
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.comment = reader.string();
          continue;
        case 5:
          if (tag !== 40) {
            break;
          }

          message.useUnconfirmedFunds = reader.bool();
          continue;
        case 6:
          if (tag !== 50) {
            break;
          }

          message.externalRequestId = reader.string();
          continue;
        case 7:
          if (tag !== 56) {
            break;
          }

          message.fromStakeAccountDerivationIndex = longToNumber(reader.uint64() as Long);
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CreateOutgoingSOLWithdrawRequestRequest {
    return {
      fromAddressId: isSet(object.fromAddressId) ? globalThis.Number(object.fromAddressId) : 0,
      amount: isSet(object.amount) ? globalThis.String(object.amount) : "",
      feeLimit: isSet(object.feeLimit) ? globalThis.String(object.feeLimit) : "",
      comment: isSet(object.comment) ? globalThis.String(object.comment) : "",
      useUnconfirmedFunds: isSet(object.useUnconfirmedFunds) ? globalThis.Boolean(object.useUnconfirmedFunds) : false,
      externalRequestId: isSet(object.externalRequestId) ? globalThis.String(object.externalRequestId) : "",
      fromStakeAccountDerivationIndex: isSet(object.fromStakeAccountDerivationIndex)
        ? globalThis.Number(object.fromStakeAccountDerivationIndex)
        : 0,
    };
  },

  toJSON(message: CreateOutgoingSOLWithdrawRequestRequest): unknown {
    const obj: any = {};
    if (message.fromAddressId !== 0) {
      obj.fromAddressId = Math.round(message.fromAddressId);
    }
    if (message.amount !== "") {
      obj.amount = message.amount;
    }
    if (message.feeLimit !== "") {
      obj.feeLimit = message.feeLimit;
    }
    if (message.comment !== "") {
      obj.comment = message.comment;
    }
    if (message.useUnconfirmedFunds !== false) {
      obj.useUnconfirmedFunds = message.useUnconfirmedFunds;
    }
    if (message.externalRequestId !== "") {
      obj.externalRequestId = message.externalRequestId;
    }
    if (message.fromStakeAccountDerivationIndex !== 0) {
      obj.fromStakeAccountDerivationIndex = Math.round(message.fromStakeAccountDerivationIndex);
    }
    return obj;
  },

  create(base?: DeepPartial<CreateOutgoingSOLWithdrawRequestRequest>): CreateOutgoingSOLWithdrawRequestRequest {
    return CreateOutgoingSOLWithdrawRequestRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CreateOutgoingSOLWithdrawRequestRequest>): CreateOutgoingSOLWithdrawRequestRequest {
    const message = createBaseCreateOutgoingSOLWithdrawRequestRequest();
    message.fromAddressId = object.fromAddressId ?? 0;
    message.amount = object.amount ?? "";
    message.feeLimit = object.feeLimit ?? "";
    message.comment = object.comment ?? "";
    message.useUnconfirmedFunds = object.useUnconfirmedFunds ?? false;
    message.externalRequestId = object.externalRequestId ?? "";
    message.fromStakeAccountDerivationIndex = object.fromStakeAccountDerivationIndex ?? 0;
    return message;
  },
};

function createBaseCreateOutgoingSOLCreateTokenRequestRequest(): CreateOutgoingSOLCreateTokenRequestRequest {
  return {
    fromAddressId: 0,
    feeLimit: "",
    decimals: 0,
    name: "",
    symbol: "",
    uri: "",
    comment: "",
    externalRequestId: "",
  };
}

export const CreateOutgoingSOLCreateTokenRequestRequest = {
  encode(message: CreateOutgoingSOLCreateTokenRequestRequest, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.fromAddressId !== 0) {
      writer.uint32(8).uint64(message.fromAddressId);
    }
    if (message.feeLimit !== "") {
      writer.uint32(18).string(message.feeLimit);
    }
    if (message.decimals !== 0) {
      writer.uint32(24).uint64(message.decimals);
    }
    if (message.name !== "") {
      writer.uint32(34).string(message.name);
    }
    if (message.symbol !== "") {
      writer.uint32(42).string(message.symbol);
    }
    if (message.uri !== "") {
      writer.uint32(50).string(message.uri);
    }
    if (message.comment !== "") {
      writer.uint32(58).string(message.comment);
    }
    if (message.externalRequestId !== "") {
      writer.uint32(66).string(message.externalRequestId);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CreateOutgoingSOLCreateTokenRequestRequest {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCreateOutgoingSOLCreateTokenRequestRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.fromAddressId = longToNumber(reader.uint64() as Long);
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.feeLimit = reader.string();
          continue;
        case 3:
          if (tag !== 24) {
            break;
          }

          message.decimals = longToNumber(reader.uint64() as Long);
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.name = reader.string();
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.symbol = reader.string();
          continue;
        case 6:
          if (tag !== 50) {
            break;
          }

          message.uri = reader.string();
          continue;
        case 7:
          if (tag !== 58) {
            break;
          }

          message.comment = reader.string();
          continue;
        case 8:
          if (tag !== 66) {
            break;
          }

          message.externalRequestId = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CreateOutgoingSOLCreateTokenRequestRequest {
    return {
      fromAddressId: isSet(object.fromAddressId) ? globalThis.Number(object.fromAddressId) : 0,
      feeLimit: isSet(object.feeLimit) ? globalThis.String(object.feeLimit) : "",
      decimals: isSet(object.decimals) ? globalThis.Number(object.decimals) : 0,
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      symbol: isSet(object.symbol) ? globalThis.String(object.symbol) : "",
      uri: isSet(object.uri) ? globalThis.String(object.uri) : "",
      comment: isSet(object.comment) ? globalThis.String(object.comment) : "",
      externalRequestId: isSet(object.externalRequestId) ? globalThis.String(object.externalRequestId) : "",
    };
  },

  toJSON(message: CreateOutgoingSOLCreateTokenRequestRequest): unknown {
    const obj: any = {};
    if (message.fromAddressId !== 0) {
      obj.fromAddressId = Math.round(message.fromAddressId);
    }
    if (message.feeLimit !== "") {
      obj.feeLimit = message.feeLimit;
    }
    if (message.decimals !== 0) {
      obj.decimals = Math.round(message.decimals);
    }
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.symbol !== "") {
      obj.symbol = message.symbol;
    }
    if (message.uri !== "") {
      obj.uri = message.uri;
    }
    if (message.comment !== "") {
      obj.comment = message.comment;
    }
    if (message.externalRequestId !== "") {
      obj.externalRequestId = message.externalRequestId;
    }
    return obj;
  },

  create(base?: DeepPartial<CreateOutgoingSOLCreateTokenRequestRequest>): CreateOutgoingSOLCreateTokenRequestRequest {
    return CreateOutgoingSOLCreateTokenRequestRequest.fromPartial(base ?? {});
  },
  fromPartial(
    object: DeepPartial<CreateOutgoingSOLCreateTokenRequestRequest>,
  ): CreateOutgoingSOLCreateTokenRequestRequest {
    const message = createBaseCreateOutgoingSOLCreateTokenRequestRequest();
    message.fromAddressId = object.fromAddressId ?? 0;
    message.feeLimit = object.feeLimit ?? "";
    message.decimals = object.decimals ?? 0;
    message.name = object.name ?? "";
    message.symbol = object.symbol ?? "";
    message.uri = object.uri ?? "";
    message.comment = object.comment ?? "";
    message.externalRequestId = object.externalRequestId ?? "";
    return message;
  },
};

function createBaseCreateOutgoingSOLTokenMintRequestRequest(): CreateOutgoingSOLTokenMintRequestRequest {
  return {
    fromAddressId: 0,
    toAddressId: 0,
    toWhitelistedAddressId: 0,
    amount: "",
    feeLimit: "",
    comment: "",
    externalRequestId: "",
  };
}

export const CreateOutgoingSOLTokenMintRequestRequest = {
  encode(message: CreateOutgoingSOLTokenMintRequestRequest, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.fromAddressId !== 0) {
      writer.uint32(8).uint64(message.fromAddressId);
    }
    if (message.toAddressId !== 0) {
      writer.uint32(16).uint64(message.toAddressId);
    }
    if (message.toWhitelistedAddressId !== 0) {
      writer.uint32(24).uint64(message.toWhitelistedAddressId);
    }
    if (message.amount !== "") {
      writer.uint32(34).string(message.amount);
    }
    if (message.feeLimit !== "") {
      writer.uint32(42).string(message.feeLimit);
    }
    if (message.comment !== "") {
      writer.uint32(50).string(message.comment);
    }
    if (message.externalRequestId !== "") {
      writer.uint32(58).string(message.externalRequestId);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CreateOutgoingSOLTokenMintRequestRequest {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCreateOutgoingSOLTokenMintRequestRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.fromAddressId = longToNumber(reader.uint64() as Long);
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.toAddressId = longToNumber(reader.uint64() as Long);
          continue;
        case 3:
          if (tag !== 24) {
            break;
          }

          message.toWhitelistedAddressId = longToNumber(reader.uint64() as Long);
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.amount = reader.string();
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.feeLimit = reader.string();
          continue;
        case 6:
          if (tag !== 50) {
            break;
          }

          message.comment = reader.string();
          continue;
        case 7:
          if (tag !== 58) {
            break;
          }

          message.externalRequestId = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CreateOutgoingSOLTokenMintRequestRequest {
    return {
      fromAddressId: isSet(object.fromAddressId) ? globalThis.Number(object.fromAddressId) : 0,
      toAddressId: isSet(object.toAddressId) ? globalThis.Number(object.toAddressId) : 0,
      toWhitelistedAddressId: isSet(object.toWhitelistedAddressId)
        ? globalThis.Number(object.toWhitelistedAddressId)
        : 0,
      amount: isSet(object.amount) ? globalThis.String(object.amount) : "",
      feeLimit: isSet(object.feeLimit) ? globalThis.String(object.feeLimit) : "",
      comment: isSet(object.comment) ? globalThis.String(object.comment) : "",
      externalRequestId: isSet(object.externalRequestId) ? globalThis.String(object.externalRequestId) : "",
    };
  },

  toJSON(message: CreateOutgoingSOLTokenMintRequestRequest): unknown {
    const obj: any = {};
    if (message.fromAddressId !== 0) {
      obj.fromAddressId = Math.round(message.fromAddressId);
    }
    if (message.toAddressId !== 0) {
      obj.toAddressId = Math.round(message.toAddressId);
    }
    if (message.toWhitelistedAddressId !== 0) {
      obj.toWhitelistedAddressId = Math.round(message.toWhitelistedAddressId);
    }
    if (message.amount !== "") {
      obj.amount = message.amount;
    }
    if (message.feeLimit !== "") {
      obj.feeLimit = message.feeLimit;
    }
    if (message.comment !== "") {
      obj.comment = message.comment;
    }
    if (message.externalRequestId !== "") {
      obj.externalRequestId = message.externalRequestId;
    }
    return obj;
  },

  create(base?: DeepPartial<CreateOutgoingSOLTokenMintRequestRequest>): CreateOutgoingSOLTokenMintRequestRequest {
    return CreateOutgoingSOLTokenMintRequestRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CreateOutgoingSOLTokenMintRequestRequest>): CreateOutgoingSOLTokenMintRequestRequest {
    const message = createBaseCreateOutgoingSOLTokenMintRequestRequest();
    message.fromAddressId = object.fromAddressId ?? 0;
    message.toAddressId = object.toAddressId ?? 0;
    message.toWhitelistedAddressId = object.toWhitelistedAddressId ?? 0;
    message.amount = object.amount ?? "";
    message.feeLimit = object.feeLimit ?? "";
    message.comment = object.comment ?? "";
    message.externalRequestId = object.externalRequestId ?? "";
    return message;
  },
};

function createBaseCreateOutgoingSOLTokenBurnRequestRequest(): CreateOutgoingSOLTokenBurnRequestRequest {
  return { fromAddressId: 0, amount: "", feeLimit: "", comment: "", externalRequestId: "" };
}

export const CreateOutgoingSOLTokenBurnRequestRequest = {
  encode(message: CreateOutgoingSOLTokenBurnRequestRequest, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.fromAddressId !== 0) {
      writer.uint32(8).uint64(message.fromAddressId);
    }
    if (message.amount !== "") {
      writer.uint32(18).string(message.amount);
    }
    if (message.feeLimit !== "") {
      writer.uint32(26).string(message.feeLimit);
    }
    if (message.comment !== "") {
      writer.uint32(34).string(message.comment);
    }
    if (message.externalRequestId !== "") {
      writer.uint32(42).string(message.externalRequestId);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CreateOutgoingSOLTokenBurnRequestRequest {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCreateOutgoingSOLTokenBurnRequestRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.fromAddressId = longToNumber(reader.uint64() as Long);
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.amount = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.feeLimit = reader.string();
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.comment = reader.string();
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.externalRequestId = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CreateOutgoingSOLTokenBurnRequestRequest {
    return {
      fromAddressId: isSet(object.fromAddressId) ? globalThis.Number(object.fromAddressId) : 0,
      amount: isSet(object.amount) ? globalThis.String(object.amount) : "",
      feeLimit: isSet(object.feeLimit) ? globalThis.String(object.feeLimit) : "",
      comment: isSet(object.comment) ? globalThis.String(object.comment) : "",
      externalRequestId: isSet(object.externalRequestId) ? globalThis.String(object.externalRequestId) : "",
    };
  },

  toJSON(message: CreateOutgoingSOLTokenBurnRequestRequest): unknown {
    const obj: any = {};
    if (message.fromAddressId !== 0) {
      obj.fromAddressId = Math.round(message.fromAddressId);
    }
    if (message.amount !== "") {
      obj.amount = message.amount;
    }
    if (message.feeLimit !== "") {
      obj.feeLimit = message.feeLimit;
    }
    if (message.comment !== "") {
      obj.comment = message.comment;
    }
    if (message.externalRequestId !== "") {
      obj.externalRequestId = message.externalRequestId;
    }
    return obj;
  },

  create(base?: DeepPartial<CreateOutgoingSOLTokenBurnRequestRequest>): CreateOutgoingSOLTokenBurnRequestRequest {
    return CreateOutgoingSOLTokenBurnRequestRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CreateOutgoingSOLTokenBurnRequestRequest>): CreateOutgoingSOLTokenBurnRequestRequest {
    const message = createBaseCreateOutgoingSOLTokenBurnRequestRequest();
    message.fromAddressId = object.fromAddressId ?? 0;
    message.amount = object.amount ?? "";
    message.feeLimit = object.feeLimit ?? "";
    message.comment = object.comment ?? "";
    message.externalRequestId = object.externalRequestId ?? "";
    return message;
  },
};

function createBaseCreateOutgoingSOLMergeRequestRequest(): CreateOutgoingSOLMergeRequestRequest {
  return {
    addressId: 0,
    fromStakeAccountDerivationIndex: 0,
    toStakeAccountDerivationIndex: 0,
    feeLimit: "",
    comment: "",
    externalRequestId: "",
    useUnconfirmedFunds: false,
  };
}

export const CreateOutgoingSOLMergeRequestRequest = {
  encode(message: CreateOutgoingSOLMergeRequestRequest, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.addressId !== 0) {
      writer.uint32(8).uint64(message.addressId);
    }
    if (message.fromStakeAccountDerivationIndex !== 0) {
      writer.uint32(16).uint64(message.fromStakeAccountDerivationIndex);
    }
    if (message.toStakeAccountDerivationIndex !== 0) {
      writer.uint32(24).uint64(message.toStakeAccountDerivationIndex);
    }
    if (message.feeLimit !== "") {
      writer.uint32(34).string(message.feeLimit);
    }
    if (message.comment !== "") {
      writer.uint32(42).string(message.comment);
    }
    if (message.externalRequestId !== "") {
      writer.uint32(50).string(message.externalRequestId);
    }
    if (message.useUnconfirmedFunds !== false) {
      writer.uint32(56).bool(message.useUnconfirmedFunds);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CreateOutgoingSOLMergeRequestRequest {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCreateOutgoingSOLMergeRequestRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.addressId = longToNumber(reader.uint64() as Long);
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.fromStakeAccountDerivationIndex = longToNumber(reader.uint64() as Long);
          continue;
        case 3:
          if (tag !== 24) {
            break;
          }

          message.toStakeAccountDerivationIndex = longToNumber(reader.uint64() as Long);
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.feeLimit = reader.string();
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.comment = reader.string();
          continue;
        case 6:
          if (tag !== 50) {
            break;
          }

          message.externalRequestId = reader.string();
          continue;
        case 7:
          if (tag !== 56) {
            break;
          }

          message.useUnconfirmedFunds = reader.bool();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CreateOutgoingSOLMergeRequestRequest {
    return {
      addressId: isSet(object.addressId) ? globalThis.Number(object.addressId) : 0,
      fromStakeAccountDerivationIndex: isSet(object.fromStakeAccountDerivationIndex)
        ? globalThis.Number(object.fromStakeAccountDerivationIndex)
        : 0,
      toStakeAccountDerivationIndex: isSet(object.toStakeAccountDerivationIndex)
        ? globalThis.Number(object.toStakeAccountDerivationIndex)
        : 0,
      feeLimit: isSet(object.feeLimit) ? globalThis.String(object.feeLimit) : "",
      comment: isSet(object.comment) ? globalThis.String(object.comment) : "",
      externalRequestId: isSet(object.externalRequestId) ? globalThis.String(object.externalRequestId) : "",
      useUnconfirmedFunds: isSet(object.useUnconfirmedFunds) ? globalThis.Boolean(object.useUnconfirmedFunds) : false,
    };
  },

  toJSON(message: CreateOutgoingSOLMergeRequestRequest): unknown {
    const obj: any = {};
    if (message.addressId !== 0) {
      obj.addressId = Math.round(message.addressId);
    }
    if (message.fromStakeAccountDerivationIndex !== 0) {
      obj.fromStakeAccountDerivationIndex = Math.round(message.fromStakeAccountDerivationIndex);
    }
    if (message.toStakeAccountDerivationIndex !== 0) {
      obj.toStakeAccountDerivationIndex = Math.round(message.toStakeAccountDerivationIndex);
    }
    if (message.feeLimit !== "") {
      obj.feeLimit = message.feeLimit;
    }
    if (message.comment !== "") {
      obj.comment = message.comment;
    }
    if (message.externalRequestId !== "") {
      obj.externalRequestId = message.externalRequestId;
    }
    if (message.useUnconfirmedFunds !== false) {
      obj.useUnconfirmedFunds = message.useUnconfirmedFunds;
    }
    return obj;
  },

  create(base?: DeepPartial<CreateOutgoingSOLMergeRequestRequest>): CreateOutgoingSOLMergeRequestRequest {
    return CreateOutgoingSOLMergeRequestRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CreateOutgoingSOLMergeRequestRequest>): CreateOutgoingSOLMergeRequestRequest {
    const message = createBaseCreateOutgoingSOLMergeRequestRequest();
    message.addressId = object.addressId ?? 0;
    message.fromStakeAccountDerivationIndex = object.fromStakeAccountDerivationIndex ?? 0;
    message.toStakeAccountDerivationIndex = object.toStakeAccountDerivationIndex ?? 0;
    message.feeLimit = object.feeLimit ?? "";
    message.comment = object.comment ?? "";
    message.externalRequestId = object.externalRequestId ?? "";
    message.useUnconfirmedFunds = object.useUnconfirmedFunds ?? false;
    return message;
  },
};

function createBaseCreateOutgoingHederaStakingRequestRequest(): CreateOutgoingHederaStakingRequestRequest {
  return { fromAddressId: 0, toWhitelistedAddressId: 0, feeLimit: "", comment: "", externalRequestId: "" };
}

export const CreateOutgoingHederaStakingRequestRequest = {
  encode(message: CreateOutgoingHederaStakingRequestRequest, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.fromAddressId !== 0) {
      writer.uint32(8).uint64(message.fromAddressId);
    }
    if (message.toWhitelistedAddressId !== 0) {
      writer.uint32(16).uint64(message.toWhitelistedAddressId);
    }
    if (message.feeLimit !== "") {
      writer.uint32(26).string(message.feeLimit);
    }
    if (message.comment !== "") {
      writer.uint32(34).string(message.comment);
    }
    if (message.externalRequestId !== "") {
      writer.uint32(42).string(message.externalRequestId);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CreateOutgoingHederaStakingRequestRequest {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCreateOutgoingHederaStakingRequestRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.fromAddressId = longToNumber(reader.uint64() as Long);
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.toWhitelistedAddressId = longToNumber(reader.uint64() as Long);
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.feeLimit = reader.string();
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.comment = reader.string();
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.externalRequestId = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CreateOutgoingHederaStakingRequestRequest {
    return {
      fromAddressId: isSet(object.fromAddressId) ? globalThis.Number(object.fromAddressId) : 0,
      toWhitelistedAddressId: isSet(object.toWhitelistedAddressId)
        ? globalThis.Number(object.toWhitelistedAddressId)
        : 0,
      feeLimit: isSet(object.feeLimit) ? globalThis.String(object.feeLimit) : "",
      comment: isSet(object.comment) ? globalThis.String(object.comment) : "",
      externalRequestId: isSet(object.externalRequestId) ? globalThis.String(object.externalRequestId) : "",
    };
  },

  toJSON(message: CreateOutgoingHederaStakingRequestRequest): unknown {
    const obj: any = {};
    if (message.fromAddressId !== 0) {
      obj.fromAddressId = Math.round(message.fromAddressId);
    }
    if (message.toWhitelistedAddressId !== 0) {
      obj.toWhitelistedAddressId = Math.round(message.toWhitelistedAddressId);
    }
    if (message.feeLimit !== "") {
      obj.feeLimit = message.feeLimit;
    }
    if (message.comment !== "") {
      obj.comment = message.comment;
    }
    if (message.externalRequestId !== "") {
      obj.externalRequestId = message.externalRequestId;
    }
    return obj;
  },

  create(base?: DeepPartial<CreateOutgoingHederaStakingRequestRequest>): CreateOutgoingHederaStakingRequestRequest {
    return CreateOutgoingHederaStakingRequestRequest.fromPartial(base ?? {});
  },
  fromPartial(
    object: DeepPartial<CreateOutgoingHederaStakingRequestRequest>,
  ): CreateOutgoingHederaStakingRequestRequest {
    const message = createBaseCreateOutgoingHederaStakingRequestRequest();
    message.fromAddressId = object.fromAddressId ?? 0;
    message.toWhitelistedAddressId = object.toWhitelistedAddressId ?? 0;
    message.feeLimit = object.feeLimit ?? "";
    message.comment = object.comment ?? "";
    message.externalRequestId = object.externalRequestId ?? "";
    return message;
  },
};

function createBaseCreateOutgoingHederaUnstakingRequestRequest(): CreateOutgoingHederaUnstakingRequestRequest {
  return { fromAddressId: 0, feeLimit: "", comment: "", externalRequestId: "" };
}

export const CreateOutgoingHederaUnstakingRequestRequest = {
  encode(message: CreateOutgoingHederaUnstakingRequestRequest, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.fromAddressId !== 0) {
      writer.uint32(8).uint64(message.fromAddressId);
    }
    if (message.feeLimit !== "") {
      writer.uint32(18).string(message.feeLimit);
    }
    if (message.comment !== "") {
      writer.uint32(26).string(message.comment);
    }
    if (message.externalRequestId !== "") {
      writer.uint32(34).string(message.externalRequestId);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CreateOutgoingHederaUnstakingRequestRequest {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCreateOutgoingHederaUnstakingRequestRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.fromAddressId = longToNumber(reader.uint64() as Long);
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.feeLimit = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.comment = reader.string();
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.externalRequestId = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CreateOutgoingHederaUnstakingRequestRequest {
    return {
      fromAddressId: isSet(object.fromAddressId) ? globalThis.Number(object.fromAddressId) : 0,
      feeLimit: isSet(object.feeLimit) ? globalThis.String(object.feeLimit) : "",
      comment: isSet(object.comment) ? globalThis.String(object.comment) : "",
      externalRequestId: isSet(object.externalRequestId) ? globalThis.String(object.externalRequestId) : "",
    };
  },

  toJSON(message: CreateOutgoingHederaUnstakingRequestRequest): unknown {
    const obj: any = {};
    if (message.fromAddressId !== 0) {
      obj.fromAddressId = Math.round(message.fromAddressId);
    }
    if (message.feeLimit !== "") {
      obj.feeLimit = message.feeLimit;
    }
    if (message.comment !== "") {
      obj.comment = message.comment;
    }
    if (message.externalRequestId !== "") {
      obj.externalRequestId = message.externalRequestId;
    }
    return obj;
  },

  create(base?: DeepPartial<CreateOutgoingHederaUnstakingRequestRequest>): CreateOutgoingHederaUnstakingRequestRequest {
    return CreateOutgoingHederaUnstakingRequestRequest.fromPartial(base ?? {});
  },
  fromPartial(
    object: DeepPartial<CreateOutgoingHederaUnstakingRequestRequest>,
  ): CreateOutgoingHederaUnstakingRequestRequest {
    const message = createBaseCreateOutgoingHederaUnstakingRequestRequest();
    message.fromAddressId = object.fromAddressId ?? 0;
    message.feeLimit = object.feeLimit ?? "";
    message.comment = object.comment ?? "";
    message.externalRequestId = object.externalRequestId ?? "";
    return message;
  },
};

function createBaseCreateRequestReply(): CreateRequestReply {
  return { result: undefined };
}

export const CreateRequestReply = {
  encode(message: CreateRequestReply, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.result !== undefined) {
      Request.encode(message.result, writer.uint32(10).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CreateRequestReply {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCreateRequestReply();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.result = Request.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CreateRequestReply {
    return { result: isSet(object.result) ? Request.fromJSON(object.result) : undefined };
  },

  toJSON(message: CreateRequestReply): unknown {
    const obj: any = {};
    if (message.result !== undefined) {
      obj.result = Request.toJSON(message.result);
    }
    return obj;
  },

  create(base?: DeepPartial<CreateRequestReply>): CreateRequestReply {
    return CreateRequestReply.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CreateRequestReply>): CreateRequestReply {
    const message = createBaseCreateRequestReply();
    message.result = (object.result !== undefined && object.result !== null)
      ? Request.fromPartial(object.result)
      : undefined;
    return message;
  },
};

function createBaseCreateRequestBundleReply(): CreateRequestBundleReply {
  return { result: undefined };
}

export const CreateRequestBundleReply = {
  encode(message: CreateRequestBundleReply, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.result !== undefined) {
      RequestBundle.encode(message.result, writer.uint32(10).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CreateRequestBundleReply {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCreateRequestBundleReply();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.result = RequestBundle.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CreateRequestBundleReply {
    return { result: isSet(object.result) ? RequestBundle.fromJSON(object.result) : undefined };
  },

  toJSON(message: CreateRequestBundleReply): unknown {
    const obj: any = {};
    if (message.result !== undefined) {
      obj.result = RequestBundle.toJSON(message.result);
    }
    return obj;
  },

  create(base?: DeepPartial<CreateRequestBundleReply>): CreateRequestBundleReply {
    return CreateRequestBundleReply.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CreateRequestBundleReply>): CreateRequestBundleReply {
    const message = createBaseCreateRequestBundleReply();
    message.result = (object.result !== undefined && object.result !== null)
      ? RequestBundle.fromPartial(object.result)
      : undefined;
    return message;
  },
};

function createBaseGetRequestBundleRequest(): GetRequestBundleRequest {
  return { id: 0, showRequests: false };
}

export const GetRequestBundleRequest = {
  encode(message: GetRequestBundleRequest, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.id !== 0) {
      writer.uint32(8).uint64(message.id);
    }
    if (message.showRequests !== false) {
      writer.uint32(16).bool(message.showRequests);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): GetRequestBundleRequest {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetRequestBundleRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.id = longToNumber(reader.uint64() as Long);
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.showRequests = reader.bool();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetRequestBundleRequest {
    return {
      id: isSet(object.id) ? globalThis.Number(object.id) : 0,
      showRequests: isSet(object.showRequests) ? globalThis.Boolean(object.showRequests) : false,
    };
  },

  toJSON(message: GetRequestBundleRequest): unknown {
    const obj: any = {};
    if (message.id !== 0) {
      obj.id = Math.round(message.id);
    }
    if (message.showRequests !== false) {
      obj.showRequests = message.showRequests;
    }
    return obj;
  },

  create(base?: DeepPartial<GetRequestBundleRequest>): GetRequestBundleRequest {
    return GetRequestBundleRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<GetRequestBundleRequest>): GetRequestBundleRequest {
    const message = createBaseGetRequestBundleRequest();
    message.id = object.id ?? 0;
    message.showRequests = object.showRequests ?? false;
    return message;
  },
};

function createBaseGetRequestBundleReply(): GetRequestBundleReply {
  return { result: undefined };
}

export const GetRequestBundleReply = {
  encode(message: GetRequestBundleReply, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.result !== undefined) {
      RequestBundle.encode(message.result, writer.uint32(10).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): GetRequestBundleReply {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetRequestBundleReply();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.result = RequestBundle.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetRequestBundleReply {
    return { result: isSet(object.result) ? RequestBundle.fromJSON(object.result) : undefined };
  },

  toJSON(message: GetRequestBundleReply): unknown {
    const obj: any = {};
    if (message.result !== undefined) {
      obj.result = RequestBundle.toJSON(message.result);
    }
    return obj;
  },

  create(base?: DeepPartial<GetRequestBundleReply>): GetRequestBundleReply {
    return GetRequestBundleReply.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<GetRequestBundleReply>): GetRequestBundleReply {
    const message = createBaseGetRequestBundleReply();
    message.result = (object.result !== undefined && object.result !== null)
      ? RequestBundle.fromPartial(object.result)
      : undefined;
    return message;
  },
};

function createBaseGetRequestBundlesRequest(): GetRequestBundlesRequest {
  return { from: undefined, to: undefined, statuses: [], ids: [], showRequests: false, cursor: undefined };
}

export const GetRequestBundlesRequest = {
  encode(message: GetRequestBundlesRequest, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.from !== undefined) {
      Timestamp.encode(toTimestamp(message.from), writer.uint32(10).fork()).ldelim();
    }
    if (message.to !== undefined) {
      Timestamp.encode(toTimestamp(message.to), writer.uint32(18).fork()).ldelim();
    }
    for (const v of message.statuses) {
      writer.uint32(26).string(v!);
    }
    writer.uint32(34).fork();
    for (const v of message.ids) {
      writer.uint64(v);
    }
    writer.ldelim();
    if (message.showRequests !== false) {
      writer.uint32(40).bool(message.showRequests);
    }
    if (message.cursor !== undefined) {
      RequestCursor.encode(message.cursor, writer.uint32(50).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): GetRequestBundlesRequest {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetRequestBundlesRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.from = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.to = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.statuses.push(reader.string());
          continue;
        case 4:
          if (tag === 32) {
            message.ids.push(longToNumber(reader.uint64() as Long));

            continue;
          }

          if (tag === 34) {
            const end2 = reader.uint32() + reader.pos;
            while (reader.pos < end2) {
              message.ids.push(longToNumber(reader.uint64() as Long));
            }

            continue;
          }

          break;
        case 5:
          if (tag !== 40) {
            break;
          }

          message.showRequests = reader.bool();
          continue;
        case 6:
          if (tag !== 50) {
            break;
          }

          message.cursor = RequestCursor.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetRequestBundlesRequest {
    return {
      from: isSet(object.from) ? fromJsonTimestamp(object.from) : undefined,
      to: isSet(object.to) ? fromJsonTimestamp(object.to) : undefined,
      statuses: globalThis.Array.isArray(object?.statuses) ? object.statuses.map((e: any) => globalThis.String(e)) : [],
      ids: globalThis.Array.isArray(object?.ids) ? object.ids.map((e: any) => globalThis.Number(e)) : [],
      showRequests: isSet(object.showRequests) ? globalThis.Boolean(object.showRequests) : false,
      cursor: isSet(object.cursor) ? RequestCursor.fromJSON(object.cursor) : undefined,
    };
  },

  toJSON(message: GetRequestBundlesRequest): unknown {
    const obj: any = {};
    if (message.from !== undefined) {
      obj.from = message.from.toISOString();
    }
    if (message.to !== undefined) {
      obj.to = message.to.toISOString();
    }
    if (message.statuses?.length) {
      obj.statuses = message.statuses;
    }
    if (message.ids?.length) {
      obj.ids = message.ids.map((e) => Math.round(e));
    }
    if (message.showRequests !== false) {
      obj.showRequests = message.showRequests;
    }
    if (message.cursor !== undefined) {
      obj.cursor = RequestCursor.toJSON(message.cursor);
    }
    return obj;
  },

  create(base?: DeepPartial<GetRequestBundlesRequest>): GetRequestBundlesRequest {
    return GetRequestBundlesRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<GetRequestBundlesRequest>): GetRequestBundlesRequest {
    const message = createBaseGetRequestBundlesRequest();
    message.from = object.from ?? undefined;
    message.to = object.to ?? undefined;
    message.statuses = object.statuses?.map((e) => e) || [];
    message.ids = object.ids?.map((e) => e) || [];
    message.showRequests = object.showRequests ?? false;
    message.cursor = (object.cursor !== undefined && object.cursor !== null)
      ? RequestCursor.fromPartial(object.cursor)
      : undefined;
    return message;
  },
};

function createBaseGetRequestBundlesReply(): GetRequestBundlesReply {
  return { results: [], cursor: undefined };
}

export const GetRequestBundlesReply = {
  encode(message: GetRequestBundlesReply, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    for (const v of message.results) {
      RequestBundle.encode(v!, writer.uint32(10).fork()).ldelim();
    }
    if (message.cursor !== undefined) {
      ResponseCursor.encode(message.cursor, writer.uint32(18).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): GetRequestBundlesReply {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetRequestBundlesReply();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.results.push(RequestBundle.decode(reader, reader.uint32()));
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.cursor = ResponseCursor.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetRequestBundlesReply {
    return {
      results: globalThis.Array.isArray(object?.results)
        ? object.results.map((e: any) => RequestBundle.fromJSON(e))
        : [],
      cursor: isSet(object.cursor) ? ResponseCursor.fromJSON(object.cursor) : undefined,
    };
  },

  toJSON(message: GetRequestBundlesReply): unknown {
    const obj: any = {};
    if (message.results?.length) {
      obj.results = message.results.map((e) => RequestBundle.toJSON(e));
    }
    if (message.cursor !== undefined) {
      obj.cursor = ResponseCursor.toJSON(message.cursor);
    }
    return obj;
  },

  create(base?: DeepPartial<GetRequestBundlesReply>): GetRequestBundlesReply {
    return GetRequestBundlesReply.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<GetRequestBundlesReply>): GetRequestBundlesReply {
    const message = createBaseGetRequestBundlesReply();
    message.results = object.results?.map((e) => RequestBundle.fromPartial(e)) || [];
    message.cursor = (object.cursor !== undefined && object.cursor !== null)
      ? ResponseCursor.fromPartial(object.cursor)
      : undefined;
    return message;
  },
};

function createBaseGetRequestBundlesForApprovalRequest(): GetRequestBundlesForApprovalRequest {
  return { blockchains: [], ids: [], cursor: undefined };
}

export const GetRequestBundlesForApprovalRequest = {
  encode(message: GetRequestBundlesForApprovalRequest, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    for (const v of message.blockchains) {
      writer.uint32(10).string(v!);
    }
    writer.uint32(18).fork();
    for (const v of message.ids) {
      writer.uint64(v);
    }
    writer.ldelim();
    if (message.cursor !== undefined) {
      RequestCursor.encode(message.cursor, writer.uint32(26).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): GetRequestBundlesForApprovalRequest {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetRequestBundlesForApprovalRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.blockchains.push(reader.string());
          continue;
        case 2:
          if (tag === 16) {
            message.ids.push(longToNumber(reader.uint64() as Long));

            continue;
          }

          if (tag === 18) {
            const end2 = reader.uint32() + reader.pos;
            while (reader.pos < end2) {
              message.ids.push(longToNumber(reader.uint64() as Long));
            }

            continue;
          }

          break;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.cursor = RequestCursor.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetRequestBundlesForApprovalRequest {
    return {
      blockchains: globalThis.Array.isArray(object?.blockchains)
        ? object.blockchains.map((e: any) => globalThis.String(e))
        : [],
      ids: globalThis.Array.isArray(object?.ids) ? object.ids.map((e: any) => globalThis.Number(e)) : [],
      cursor: isSet(object.cursor) ? RequestCursor.fromJSON(object.cursor) : undefined,
    };
  },

  toJSON(message: GetRequestBundlesForApprovalRequest): unknown {
    const obj: any = {};
    if (message.blockchains?.length) {
      obj.blockchains = message.blockchains;
    }
    if (message.ids?.length) {
      obj.ids = message.ids.map((e) => Math.round(e));
    }
    if (message.cursor !== undefined) {
      obj.cursor = RequestCursor.toJSON(message.cursor);
    }
    return obj;
  },

  create(base?: DeepPartial<GetRequestBundlesForApprovalRequest>): GetRequestBundlesForApprovalRequest {
    return GetRequestBundlesForApprovalRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<GetRequestBundlesForApprovalRequest>): GetRequestBundlesForApprovalRequest {
    const message = createBaseGetRequestBundlesForApprovalRequest();
    message.blockchains = object.blockchains?.map((e) => e) || [];
    message.ids = object.ids?.map((e) => e) || [];
    message.cursor = (object.cursor !== undefined && object.cursor !== null)
      ? RequestCursor.fromPartial(object.cursor)
      : undefined;
    return message;
  },
};

function createBaseGetRequestsRequest(): GetRequestsRequest {
  return {
    limit: 0,
    offset: 0,
    from: undefined,
    to: undefined,
    currencies: [],
    type: "",
    statuses: [],
    types: [],
    ids: [],
  };
}

export const GetRequestsRequest = {
  encode(message: GetRequestsRequest, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.limit !== 0) {
      writer.uint32(8).uint64(message.limit);
    }
    if (message.offset !== 0) {
      writer.uint32(16).uint64(message.offset);
    }
    if (message.from !== undefined) {
      Timestamp.encode(toTimestamp(message.from), writer.uint32(26).fork()).ldelim();
    }
    if (message.to !== undefined) {
      Timestamp.encode(toTimestamp(message.to), writer.uint32(34).fork()).ldelim();
    }
    for (const v of message.currencies) {
      writer.uint32(42).string(v!);
    }
    if (message.type !== "") {
      writer.uint32(50).string(message.type);
    }
    for (const v of message.statuses) {
      writer.uint32(58).string(v!);
    }
    for (const v of message.types) {
      writer.uint32(66).string(v!);
    }
    writer.uint32(74).fork();
    for (const v of message.ids) {
      writer.uint64(v);
    }
    writer.ldelim();
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): GetRequestsRequest {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetRequestsRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.limit = longToNumber(reader.uint64() as Long);
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.offset = longToNumber(reader.uint64() as Long);
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.from = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.to = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.currencies.push(reader.string());
          continue;
        case 6:
          if (tag !== 50) {
            break;
          }

          message.type = reader.string();
          continue;
        case 7:
          if (tag !== 58) {
            break;
          }

          message.statuses.push(reader.string());
          continue;
        case 8:
          if (tag !== 66) {
            break;
          }

          message.types.push(reader.string());
          continue;
        case 9:
          if (tag === 72) {
            message.ids.push(longToNumber(reader.uint64() as Long));

            continue;
          }

          if (tag === 74) {
            const end2 = reader.uint32() + reader.pos;
            while (reader.pos < end2) {
              message.ids.push(longToNumber(reader.uint64() as Long));
            }

            continue;
          }

          break;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetRequestsRequest {
    return {
      limit: isSet(object.limit) ? globalThis.Number(object.limit) : 0,
      offset: isSet(object.offset) ? globalThis.Number(object.offset) : 0,
      from: isSet(object.from) ? fromJsonTimestamp(object.from) : undefined,
      to: isSet(object.to) ? fromJsonTimestamp(object.to) : undefined,
      currencies: globalThis.Array.isArray(object?.currencies)
        ? object.currencies.map((e: any) => globalThis.String(e))
        : [],
      type: isSet(object.type) ? globalThis.String(object.type) : "",
      statuses: globalThis.Array.isArray(object?.statuses) ? object.statuses.map((e: any) => globalThis.String(e)) : [],
      types: globalThis.Array.isArray(object?.types) ? object.types.map((e: any) => globalThis.String(e)) : [],
      ids: globalThis.Array.isArray(object?.ids) ? object.ids.map((e: any) => globalThis.Number(e)) : [],
    };
  },

  toJSON(message: GetRequestsRequest): unknown {
    const obj: any = {};
    if (message.limit !== 0) {
      obj.limit = Math.round(message.limit);
    }
    if (message.offset !== 0) {
      obj.offset = Math.round(message.offset);
    }
    if (message.from !== undefined) {
      obj.from = message.from.toISOString();
    }
    if (message.to !== undefined) {
      obj.to = message.to.toISOString();
    }
    if (message.currencies?.length) {
      obj.currencies = message.currencies;
    }
    if (message.type !== "") {
      obj.type = message.type;
    }
    if (message.statuses?.length) {
      obj.statuses = message.statuses;
    }
    if (message.types?.length) {
      obj.types = message.types;
    }
    if (message.ids?.length) {
      obj.ids = message.ids.map((e) => Math.round(e));
    }
    return obj;
  },

  create(base?: DeepPartial<GetRequestsRequest>): GetRequestsRequest {
    return GetRequestsRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<GetRequestsRequest>): GetRequestsRequest {
    const message = createBaseGetRequestsRequest();
    message.limit = object.limit ?? 0;
    message.offset = object.offset ?? 0;
    message.from = object.from ?? undefined;
    message.to = object.to ?? undefined;
    message.currencies = object.currencies?.map((e) => e) || [];
    message.type = object.type ?? "";
    message.statuses = object.statuses?.map((e) => e) || [];
    message.types = object.types?.map((e) => e) || [];
    message.ids = object.ids?.map((e) => e) || [];
    return message;
  },
};

function createBaseGetRequestsV2Request(): GetRequestsV2Request {
  return {
    from: undefined,
    to: undefined,
    currencyID: "",
    statuses: [],
    types: [],
    ids: [],
    cursor: undefined,
    sortOrder: "",
    externalRequestIDs: [],
  };
}

export const GetRequestsV2Request = {
  encode(message: GetRequestsV2Request, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.from !== undefined) {
      Timestamp.encode(toTimestamp(message.from), writer.uint32(10).fork()).ldelim();
    }
    if (message.to !== undefined) {
      Timestamp.encode(toTimestamp(message.to), writer.uint32(18).fork()).ldelim();
    }
    if (message.currencyID !== "") {
      writer.uint32(26).string(message.currencyID);
    }
    for (const v of message.statuses) {
      writer.uint32(34).string(v!);
    }
    for (const v of message.types) {
      writer.uint32(42).string(v!);
    }
    writer.uint32(50).fork();
    for (const v of message.ids) {
      writer.uint64(v);
    }
    writer.ldelim();
    if (message.cursor !== undefined) {
      RequestCursor.encode(message.cursor, writer.uint32(58).fork()).ldelim();
    }
    if (message.sortOrder !== "") {
      writer.uint32(66).string(message.sortOrder);
    }
    for (const v of message.externalRequestIDs) {
      writer.uint32(74).string(v!);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): GetRequestsV2Request {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetRequestsV2Request();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.from = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.to = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.currencyID = reader.string();
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.statuses.push(reader.string());
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.types.push(reader.string());
          continue;
        case 6:
          if (tag === 48) {
            message.ids.push(longToNumber(reader.uint64() as Long));

            continue;
          }

          if (tag === 50) {
            const end2 = reader.uint32() + reader.pos;
            while (reader.pos < end2) {
              message.ids.push(longToNumber(reader.uint64() as Long));
            }

            continue;
          }

          break;
        case 7:
          if (tag !== 58) {
            break;
          }

          message.cursor = RequestCursor.decode(reader, reader.uint32());
          continue;
        case 8:
          if (tag !== 66) {
            break;
          }

          message.sortOrder = reader.string();
          continue;
        case 9:
          if (tag !== 74) {
            break;
          }

          message.externalRequestIDs.push(reader.string());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetRequestsV2Request {
    return {
      from: isSet(object.from) ? fromJsonTimestamp(object.from) : undefined,
      to: isSet(object.to) ? fromJsonTimestamp(object.to) : undefined,
      currencyID: isSet(object.currencyID) ? globalThis.String(object.currencyID) : "",
      statuses: globalThis.Array.isArray(object?.statuses) ? object.statuses.map((e: any) => globalThis.String(e)) : [],
      types: globalThis.Array.isArray(object?.types) ? object.types.map((e: any) => globalThis.String(e)) : [],
      ids: globalThis.Array.isArray(object?.ids) ? object.ids.map((e: any) => globalThis.Number(e)) : [],
      cursor: isSet(object.cursor) ? RequestCursor.fromJSON(object.cursor) : undefined,
      sortOrder: isSet(object.sortOrder) ? globalThis.String(object.sortOrder) : "",
      externalRequestIDs: globalThis.Array.isArray(object?.externalRequestIDs)
        ? object.externalRequestIDs.map((e: any) => globalThis.String(e))
        : [],
    };
  },

  toJSON(message: GetRequestsV2Request): unknown {
    const obj: any = {};
    if (message.from !== undefined) {
      obj.from = message.from.toISOString();
    }
    if (message.to !== undefined) {
      obj.to = message.to.toISOString();
    }
    if (message.currencyID !== "") {
      obj.currencyID = message.currencyID;
    }
    if (message.statuses?.length) {
      obj.statuses = message.statuses;
    }
    if (message.types?.length) {
      obj.types = message.types;
    }
    if (message.ids?.length) {
      obj.ids = message.ids.map((e) => Math.round(e));
    }
    if (message.cursor !== undefined) {
      obj.cursor = RequestCursor.toJSON(message.cursor);
    }
    if (message.sortOrder !== "") {
      obj.sortOrder = message.sortOrder;
    }
    if (message.externalRequestIDs?.length) {
      obj.externalRequestIDs = message.externalRequestIDs;
    }
    return obj;
  },

  create(base?: DeepPartial<GetRequestsV2Request>): GetRequestsV2Request {
    return GetRequestsV2Request.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<GetRequestsV2Request>): GetRequestsV2Request {
    const message = createBaseGetRequestsV2Request();
    message.from = object.from ?? undefined;
    message.to = object.to ?? undefined;
    message.currencyID = object.currencyID ?? "";
    message.statuses = object.statuses?.map((e) => e) || [];
    message.types = object.types?.map((e) => e) || [];
    message.ids = object.ids?.map((e) => e) || [];
    message.cursor = (object.cursor !== undefined && object.cursor !== null)
      ? RequestCursor.fromPartial(object.cursor)
      : undefined;
    message.sortOrder = object.sortOrder ?? "";
    message.externalRequestIDs = object.externalRequestIDs?.map((e) => e) || [];
    return message;
  },
};

function createBaseGetRequestsReply(): GetRequestsReply {
  return { result: [], totalItems: 0 };
}

export const GetRequestsReply = {
  encode(message: GetRequestsReply, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    for (const v of message.result) {
      Request.encode(v!, writer.uint32(10).fork()).ldelim();
    }
    if (message.totalItems !== 0) {
      writer.uint32(16).uint64(message.totalItems);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): GetRequestsReply {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetRequestsReply();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.result.push(Request.decode(reader, reader.uint32()));
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.totalItems = longToNumber(reader.uint64() as Long);
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetRequestsReply {
    return {
      result: globalThis.Array.isArray(object?.result) ? object.result.map((e: any) => Request.fromJSON(e)) : [],
      totalItems: isSet(object.totalItems) ? globalThis.Number(object.totalItems) : 0,
    };
  },

  toJSON(message: GetRequestsReply): unknown {
    const obj: any = {};
    if (message.result?.length) {
      obj.result = message.result.map((e) => Request.toJSON(e));
    }
    if (message.totalItems !== 0) {
      obj.totalItems = Math.round(message.totalItems);
    }
    return obj;
  },

  create(base?: DeepPartial<GetRequestsReply>): GetRequestsReply {
    return GetRequestsReply.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<GetRequestsReply>): GetRequestsReply {
    const message = createBaseGetRequestsReply();
    message.result = object.result?.map((e) => Request.fromPartial(e)) || [];
    message.totalItems = object.totalItems ?? 0;
    return message;
  },
};

function createBaseGetRequestReply(): GetRequestReply {
  return { result: undefined };
}

export const GetRequestReply = {
  encode(message: GetRequestReply, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.result !== undefined) {
      Request.encode(message.result, writer.uint32(10).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): GetRequestReply {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetRequestReply();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.result = Request.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetRequestReply {
    return { result: isSet(object.result) ? Request.fromJSON(object.result) : undefined };
  },

  toJSON(message: GetRequestReply): unknown {
    const obj: any = {};
    if (message.result !== undefined) {
      obj.result = Request.toJSON(message.result);
    }
    return obj;
  },

  create(base?: DeepPartial<GetRequestReply>): GetRequestReply {
    return GetRequestReply.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<GetRequestReply>): GetRequestReply {
    const message = createBaseGetRequestReply();
    message.result = (object.result !== undefined && object.result !== null)
      ? Request.fromPartial(object.result)
      : undefined;
    return message;
  },
};

function createBaseGetRequestRequest(): GetRequestRequest {
  return { id: 0 };
}

export const GetRequestRequest = {
  encode(message: GetRequestRequest, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.id !== 0) {
      writer.uint32(8).uint64(message.id);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): GetRequestRequest {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetRequestRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.id = longToNumber(reader.uint64() as Long);
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetRequestRequest {
    return { id: isSet(object.id) ? globalThis.Number(object.id) : 0 };
  },

  toJSON(message: GetRequestRequest): unknown {
    const obj: any = {};
    if (message.id !== 0) {
      obj.id = Math.round(message.id);
    }
    return obj;
  },

  create(base?: DeepPartial<GetRequestRequest>): GetRequestRequest {
    return GetRequestRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<GetRequestRequest>): GetRequestRequest {
    const message = createBaseGetRequestRequest();
    message.id = object.id ?? 0;
    return message;
  },
};

function createBaseGetRequestsForApprovalRequest(): GetRequestsForApprovalRequest {
  return { limit: 0, offset: 0, currencies: [], type: "", types: [], ids: [] };
}

export const GetRequestsForApprovalRequest = {
  encode(message: GetRequestsForApprovalRequest, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.limit !== 0) {
      writer.uint32(8).uint64(message.limit);
    }
    if (message.offset !== 0) {
      writer.uint32(16).uint64(message.offset);
    }
    for (const v of message.currencies) {
      writer.uint32(26).string(v!);
    }
    if (message.type !== "") {
      writer.uint32(34).string(message.type);
    }
    for (const v of message.types) {
      writer.uint32(42).string(v!);
    }
    writer.uint32(50).fork();
    for (const v of message.ids) {
      writer.uint64(v);
    }
    writer.ldelim();
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): GetRequestsForApprovalRequest {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetRequestsForApprovalRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.limit = longToNumber(reader.uint64() as Long);
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.offset = longToNumber(reader.uint64() as Long);
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.currencies.push(reader.string());
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.type = reader.string();
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.types.push(reader.string());
          continue;
        case 6:
          if (tag === 48) {
            message.ids.push(longToNumber(reader.uint64() as Long));

            continue;
          }

          if (tag === 50) {
            const end2 = reader.uint32() + reader.pos;
            while (reader.pos < end2) {
              message.ids.push(longToNumber(reader.uint64() as Long));
            }

            continue;
          }

          break;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetRequestsForApprovalRequest {
    return {
      limit: isSet(object.limit) ? globalThis.Number(object.limit) : 0,
      offset: isSet(object.offset) ? globalThis.Number(object.offset) : 0,
      currencies: globalThis.Array.isArray(object?.currencies)
        ? object.currencies.map((e: any) => globalThis.String(e))
        : [],
      type: isSet(object.type) ? globalThis.String(object.type) : "",
      types: globalThis.Array.isArray(object?.types) ? object.types.map((e: any) => globalThis.String(e)) : [],
      ids: globalThis.Array.isArray(object?.ids) ? object.ids.map((e: any) => globalThis.Number(e)) : [],
    };
  },

  toJSON(message: GetRequestsForApprovalRequest): unknown {
    const obj: any = {};
    if (message.limit !== 0) {
      obj.limit = Math.round(message.limit);
    }
    if (message.offset !== 0) {
      obj.offset = Math.round(message.offset);
    }
    if (message.currencies?.length) {
      obj.currencies = message.currencies;
    }
    if (message.type !== "") {
      obj.type = message.type;
    }
    if (message.types?.length) {
      obj.types = message.types;
    }
    if (message.ids?.length) {
      obj.ids = message.ids.map((e) => Math.round(e));
    }
    return obj;
  },

  create(base?: DeepPartial<GetRequestsForApprovalRequest>): GetRequestsForApprovalRequest {
    return GetRequestsForApprovalRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<GetRequestsForApprovalRequest>): GetRequestsForApprovalRequest {
    const message = createBaseGetRequestsForApprovalRequest();
    message.limit = object.limit ?? 0;
    message.offset = object.offset ?? 0;
    message.currencies = object.currencies?.map((e) => e) || [];
    message.type = object.type ?? "";
    message.types = object.types?.map((e) => e) || [];
    message.ids = object.ids?.map((e) => e) || [];
    return message;
  },
};

function createBaseGetRequestsForApprovalV2Request(): GetRequestsForApprovalV2Request {
  return {
    currencyID: "",
    types: [],
    ids: [],
    cursor: undefined,
    sortOrder: "",
    excludeTypes: [],
    externalRequestIDs: [],
  };
}

export const GetRequestsForApprovalV2Request = {
  encode(message: GetRequestsForApprovalV2Request, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.currencyID !== "") {
      writer.uint32(10).string(message.currencyID);
    }
    for (const v of message.types) {
      writer.uint32(18).string(v!);
    }
    writer.uint32(26).fork();
    for (const v of message.ids) {
      writer.uint64(v);
    }
    writer.ldelim();
    if (message.cursor !== undefined) {
      RequestCursor.encode(message.cursor, writer.uint32(50).fork()).ldelim();
    }
    if (message.sortOrder !== "") {
      writer.uint32(58).string(message.sortOrder);
    }
    for (const v of message.excludeTypes) {
      writer.uint32(66).string(v!);
    }
    for (const v of message.externalRequestIDs) {
      writer.uint32(74).string(v!);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): GetRequestsForApprovalV2Request {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetRequestsForApprovalV2Request();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.currencyID = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.types.push(reader.string());
          continue;
        case 3:
          if (tag === 24) {
            message.ids.push(longToNumber(reader.uint64() as Long));

            continue;
          }

          if (tag === 26) {
            const end2 = reader.uint32() + reader.pos;
            while (reader.pos < end2) {
              message.ids.push(longToNumber(reader.uint64() as Long));
            }

            continue;
          }

          break;
        case 6:
          if (tag !== 50) {
            break;
          }

          message.cursor = RequestCursor.decode(reader, reader.uint32());
          continue;
        case 7:
          if (tag !== 58) {
            break;
          }

          message.sortOrder = reader.string();
          continue;
        case 8:
          if (tag !== 66) {
            break;
          }

          message.excludeTypes.push(reader.string());
          continue;
        case 9:
          if (tag !== 74) {
            break;
          }

          message.externalRequestIDs.push(reader.string());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetRequestsForApprovalV2Request {
    return {
      currencyID: isSet(object.currencyID) ? globalThis.String(object.currencyID) : "",
      types: globalThis.Array.isArray(object?.types) ? object.types.map((e: any) => globalThis.String(e)) : [],
      ids: globalThis.Array.isArray(object?.ids) ? object.ids.map((e: any) => globalThis.Number(e)) : [],
      cursor: isSet(object.cursor) ? RequestCursor.fromJSON(object.cursor) : undefined,
      sortOrder: isSet(object.sortOrder) ? globalThis.String(object.sortOrder) : "",
      excludeTypes: globalThis.Array.isArray(object?.excludeTypes)
        ? object.excludeTypes.map((e: any) => globalThis.String(e))
        : [],
      externalRequestIDs: globalThis.Array.isArray(object?.externalRequestIDs)
        ? object.externalRequestIDs.map((e: any) => globalThis.String(e))
        : [],
    };
  },

  toJSON(message: GetRequestsForApprovalV2Request): unknown {
    const obj: any = {};
    if (message.currencyID !== "") {
      obj.currencyID = message.currencyID;
    }
    if (message.types?.length) {
      obj.types = message.types;
    }
    if (message.ids?.length) {
      obj.ids = message.ids.map((e) => Math.round(e));
    }
    if (message.cursor !== undefined) {
      obj.cursor = RequestCursor.toJSON(message.cursor);
    }
    if (message.sortOrder !== "") {
      obj.sortOrder = message.sortOrder;
    }
    if (message.excludeTypes?.length) {
      obj.excludeTypes = message.excludeTypes;
    }
    if (message.externalRequestIDs?.length) {
      obj.externalRequestIDs = message.externalRequestIDs;
    }
    return obj;
  },

  create(base?: DeepPartial<GetRequestsForApprovalV2Request>): GetRequestsForApprovalV2Request {
    return GetRequestsForApprovalV2Request.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<GetRequestsForApprovalV2Request>): GetRequestsForApprovalV2Request {
    const message = createBaseGetRequestsForApprovalV2Request();
    message.currencyID = object.currencyID ?? "";
    message.types = object.types?.map((e) => e) || [];
    message.ids = object.ids?.map((e) => e) || [];
    message.cursor = (object.cursor !== undefined && object.cursor !== null)
      ? RequestCursor.fromPartial(object.cursor)
      : undefined;
    message.sortOrder = object.sortOrder ?? "";
    message.excludeTypes = object.excludeTypes?.map((e) => e) || [];
    message.externalRequestIDs = object.externalRequestIDs?.map((e) => e) || [];
    return message;
  },
};

function createBaseGetRequestsV2Reply(): GetRequestsV2Reply {
  return { result: [], cursor: undefined };
}

export const GetRequestsV2Reply = {
  encode(message: GetRequestsV2Reply, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    for (const v of message.result) {
      Request.encode(v!, writer.uint32(10).fork()).ldelim();
    }
    if (message.cursor !== undefined) {
      ResponseCursor.encode(message.cursor, writer.uint32(18).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): GetRequestsV2Reply {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetRequestsV2Reply();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.result.push(Request.decode(reader, reader.uint32()));
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.cursor = ResponseCursor.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetRequestsV2Reply {
    return {
      result: globalThis.Array.isArray(object?.result) ? object.result.map((e: any) => Request.fromJSON(e)) : [],
      cursor: isSet(object.cursor) ? ResponseCursor.fromJSON(object.cursor) : undefined,
    };
  },

  toJSON(message: GetRequestsV2Reply): unknown {
    const obj: any = {};
    if (message.result?.length) {
      obj.result = message.result.map((e) => Request.toJSON(e));
    }
    if (message.cursor !== undefined) {
      obj.cursor = ResponseCursor.toJSON(message.cursor);
    }
    return obj;
  },

  create(base?: DeepPartial<GetRequestsV2Reply>): GetRequestsV2Reply {
    return GetRequestsV2Reply.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<GetRequestsV2Reply>): GetRequestsV2Reply {
    const message = createBaseGetRequestsV2Reply();
    message.result = object.result?.map((e) => Request.fromPartial(e)) || [];
    message.cursor = (object.cursor !== undefined && object.cursor !== null)
      ? ResponseCursor.fromPartial(object.cursor)
      : undefined;
    return message;
  },
};

function createBaseApproveRequestsRequest(): ApproveRequestsRequest {
  return { signature: "", comment: "", requestIds: [], ids: [], async: false };
}

export const ApproveRequestsRequest = {
  encode(message: ApproveRequestsRequest, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.signature !== "") {
      writer.uint32(10).string(message.signature);
    }
    if (message.comment !== "") {
      writer.uint32(18).string(message.comment);
    }
    writer.uint32(26).fork();
    for (const v of message.requestIds) {
      writer.uint64(v);
    }
    writer.ldelim();
    writer.uint32(34).fork();
    for (const v of message.ids) {
      writer.uint64(v);
    }
    writer.ldelim();
    if (message.async !== false) {
      writer.uint32(40).bool(message.async);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): ApproveRequestsRequest {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseApproveRequestsRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.signature = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.comment = reader.string();
          continue;
        case 3:
          if (tag === 24) {
            message.requestIds.push(longToNumber(reader.uint64() as Long));

            continue;
          }

          if (tag === 26) {
            const end2 = reader.uint32() + reader.pos;
            while (reader.pos < end2) {
              message.requestIds.push(longToNumber(reader.uint64() as Long));
            }

            continue;
          }

          break;
        case 4:
          if (tag === 32) {
            message.ids.push(longToNumber(reader.uint64() as Long));

            continue;
          }

          if (tag === 34) {
            const end2 = reader.uint32() + reader.pos;
            while (reader.pos < end2) {
              message.ids.push(longToNumber(reader.uint64() as Long));
            }

            continue;
          }

          break;
        case 5:
          if (tag !== 40) {
            break;
          }

          message.async = reader.bool();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ApproveRequestsRequest {
    return {
      signature: isSet(object.signature) ? globalThis.String(object.signature) : "",
      comment: isSet(object.comment) ? globalThis.String(object.comment) : "",
      requestIds: globalThis.Array.isArray(object?.requestIds)
        ? object.requestIds.map((e: any) => globalThis.Number(e))
        : [],
      ids: globalThis.Array.isArray(object?.ids) ? object.ids.map((e: any) => globalThis.Number(e)) : [],
      async: isSet(object.async) ? globalThis.Boolean(object.async) : false,
    };
  },

  toJSON(message: ApproveRequestsRequest): unknown {
    const obj: any = {};
    if (message.signature !== "") {
      obj.signature = message.signature;
    }
    if (message.comment !== "") {
      obj.comment = message.comment;
    }
    if (message.requestIds?.length) {
      obj.requestIds = message.requestIds.map((e) => Math.round(e));
    }
    if (message.ids?.length) {
      obj.ids = message.ids.map((e) => Math.round(e));
    }
    if (message.async !== false) {
      obj.async = message.async;
    }
    return obj;
  },

  create(base?: DeepPartial<ApproveRequestsRequest>): ApproveRequestsRequest {
    return ApproveRequestsRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ApproveRequestsRequest>): ApproveRequestsRequest {
    const message = createBaseApproveRequestsRequest();
    message.signature = object.signature ?? "";
    message.comment = object.comment ?? "";
    message.requestIds = object.requestIds?.map((e) => e) || [];
    message.ids = object.ids?.map((e) => e) || [];
    message.async = object.async ?? false;
    return message;
  },
};

function createBaseApproveRequestsReply(): ApproveRequestsReply {
  return { signedRequests: 0, signatures: 0, asyncSignature: undefined };
}

export const ApproveRequestsReply = {
  encode(message: ApproveRequestsReply, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.signedRequests !== 0) {
      writer.uint32(8).uint64(message.signedRequests);
    }
    if (message.signatures !== 0) {
      writer.uint32(16).uint64(message.signatures);
    }
    if (message.asyncSignature !== undefined) {
      RequestBatchSignature.encode(message.asyncSignature, writer.uint32(26).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): ApproveRequestsReply {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseApproveRequestsReply();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.signedRequests = longToNumber(reader.uint64() as Long);
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.signatures = longToNumber(reader.uint64() as Long);
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.asyncSignature = RequestBatchSignature.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ApproveRequestsReply {
    return {
      signedRequests: isSet(object.signedRequests) ? globalThis.Number(object.signedRequests) : 0,
      signatures: isSet(object.signatures) ? globalThis.Number(object.signatures) : 0,
      asyncSignature: isSet(object.asyncSignature) ? RequestBatchSignature.fromJSON(object.asyncSignature) : undefined,
    };
  },

  toJSON(message: ApproveRequestsReply): unknown {
    const obj: any = {};
    if (message.signedRequests !== 0) {
      obj.signedRequests = Math.round(message.signedRequests);
    }
    if (message.signatures !== 0) {
      obj.signatures = Math.round(message.signatures);
    }
    if (message.asyncSignature !== undefined) {
      obj.asyncSignature = RequestBatchSignature.toJSON(message.asyncSignature);
    }
    return obj;
  },

  create(base?: DeepPartial<ApproveRequestsReply>): ApproveRequestsReply {
    return ApproveRequestsReply.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ApproveRequestsReply>): ApproveRequestsReply {
    const message = createBaseApproveRequestsReply();
    message.signedRequests = object.signedRequests ?? 0;
    message.signatures = object.signatures ?? 0;
    message.asyncSignature = (object.asyncSignature !== undefined && object.asyncSignature !== null)
      ? RequestBatchSignature.fromPartial(object.asyncSignature)
      : undefined;
    return message;
  },
};

function createBaseGetAsyncApprovalsRequest(): GetAsyncApprovalsRequest {
  return { ids: [], includeDetails: false };
}

export const GetAsyncApprovalsRequest = {
  encode(message: GetAsyncApprovalsRequest, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    writer.uint32(10).fork();
    for (const v of message.ids) {
      writer.uint64(v);
    }
    writer.ldelim();
    if (message.includeDetails !== false) {
      writer.uint32(16).bool(message.includeDetails);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): GetAsyncApprovalsRequest {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetAsyncApprovalsRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag === 8) {
            message.ids.push(longToNumber(reader.uint64() as Long));

            continue;
          }

          if (tag === 10) {
            const end2 = reader.uint32() + reader.pos;
            while (reader.pos < end2) {
              message.ids.push(longToNumber(reader.uint64() as Long));
            }

            continue;
          }

          break;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.includeDetails = reader.bool();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetAsyncApprovalsRequest {
    return {
      ids: globalThis.Array.isArray(object?.ids) ? object.ids.map((e: any) => globalThis.Number(e)) : [],
      includeDetails: isSet(object.includeDetails) ? globalThis.Boolean(object.includeDetails) : false,
    };
  },

  toJSON(message: GetAsyncApprovalsRequest): unknown {
    const obj: any = {};
    if (message.ids?.length) {
      obj.ids = message.ids.map((e) => Math.round(e));
    }
    if (message.includeDetails !== false) {
      obj.includeDetails = message.includeDetails;
    }
    return obj;
  },

  create(base?: DeepPartial<GetAsyncApprovalsRequest>): GetAsyncApprovalsRequest {
    return GetAsyncApprovalsRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<GetAsyncApprovalsRequest>): GetAsyncApprovalsRequest {
    const message = createBaseGetAsyncApprovalsRequest();
    message.ids = object.ids?.map((e) => e) || [];
    message.includeDetails = object.includeDetails ?? false;
    return message;
  },
};

function createBaseGetAsyncApprovalsReply(): GetAsyncApprovalsReply {
  return { result: [] };
}

export const GetAsyncApprovalsReply = {
  encode(message: GetAsyncApprovalsReply, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    for (const v of message.result) {
      RequestBatchSignature.encode(v!, writer.uint32(10).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): GetAsyncApprovalsReply {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetAsyncApprovalsReply();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.result.push(RequestBatchSignature.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetAsyncApprovalsReply {
    return {
      result: globalThis.Array.isArray(object?.result)
        ? object.result.map((e: any) => RequestBatchSignature.fromJSON(e))
        : [],
    };
  },

  toJSON(message: GetAsyncApprovalsReply): unknown {
    const obj: any = {};
    if (message.result?.length) {
      obj.result = message.result.map((e) => RequestBatchSignature.toJSON(e));
    }
    return obj;
  },

  create(base?: DeepPartial<GetAsyncApprovalsReply>): GetAsyncApprovalsReply {
    return GetAsyncApprovalsReply.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<GetAsyncApprovalsReply>): GetAsyncApprovalsReply {
    const message = createBaseGetAsyncApprovalsReply();
    message.result = object.result?.map((e) => RequestBatchSignature.fromPartial(e)) || [];
    return message;
  },
};

function createBaseRejectRequestsRequest(): RejectRequestsRequest {
  return { comment: "", requestIds: [], ids: [] };
}

export const RejectRequestsRequest = {
  encode(message: RejectRequestsRequest, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.comment !== "") {
      writer.uint32(10).string(message.comment);
    }
    writer.uint32(18).fork();
    for (const v of message.requestIds) {
      writer.uint64(v);
    }
    writer.ldelim();
    writer.uint32(26).fork();
    for (const v of message.ids) {
      writer.uint64(v);
    }
    writer.ldelim();
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): RejectRequestsRequest {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseRejectRequestsRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.comment = reader.string();
          continue;
        case 2:
          if (tag === 16) {
            message.requestIds.push(longToNumber(reader.uint64() as Long));

            continue;
          }

          if (tag === 18) {
            const end2 = reader.uint32() + reader.pos;
            while (reader.pos < end2) {
              message.requestIds.push(longToNumber(reader.uint64() as Long));
            }

            continue;
          }

          break;
        case 3:
          if (tag === 24) {
            message.ids.push(longToNumber(reader.uint64() as Long));

            continue;
          }

          if (tag === 26) {
            const end2 = reader.uint32() + reader.pos;
            while (reader.pos < end2) {
              message.ids.push(longToNumber(reader.uint64() as Long));
            }

            continue;
          }

          break;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): RejectRequestsRequest {
    return {
      comment: isSet(object.comment) ? globalThis.String(object.comment) : "",
      requestIds: globalThis.Array.isArray(object?.requestIds)
        ? object.requestIds.map((e: any) => globalThis.Number(e))
        : [],
      ids: globalThis.Array.isArray(object?.ids) ? object.ids.map((e: any) => globalThis.Number(e)) : [],
    };
  },

  toJSON(message: RejectRequestsRequest): unknown {
    const obj: any = {};
    if (message.comment !== "") {
      obj.comment = message.comment;
    }
    if (message.requestIds?.length) {
      obj.requestIds = message.requestIds.map((e) => Math.round(e));
    }
    if (message.ids?.length) {
      obj.ids = message.ids.map((e) => Math.round(e));
    }
    return obj;
  },

  create(base?: DeepPartial<RejectRequestsRequest>): RejectRequestsRequest {
    return RejectRequestsRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<RejectRequestsRequest>): RejectRequestsRequest {
    const message = createBaseRejectRequestsRequest();
    message.comment = object.comment ?? "";
    message.requestIds = object.requestIds?.map((e) => e) || [];
    message.ids = object.ids?.map((e) => e) || [];
    return message;
  },
};

function createBaseUpdateRequestStatusRequest(): UpdateRequestStatusRequest {
  return { id: 0, status: "" };
}

export const UpdateRequestStatusRequest = {
  encode(message: UpdateRequestStatusRequest, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.id !== 0) {
      writer.uint32(8).uint64(message.id);
    }
    if (message.status !== "") {
      writer.uint32(18).string(message.status);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): UpdateRequestStatusRequest {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseUpdateRequestStatusRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.id = longToNumber(reader.uint64() as Long);
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.status = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): UpdateRequestStatusRequest {
    return {
      id: isSet(object.id) ? globalThis.Number(object.id) : 0,
      status: isSet(object.status) ? globalThis.String(object.status) : "",
    };
  },

  toJSON(message: UpdateRequestStatusRequest): unknown {
    const obj: any = {};
    if (message.id !== 0) {
      obj.id = Math.round(message.id);
    }
    if (message.status !== "") {
      obj.status = message.status;
    }
    return obj;
  },

  create(base?: DeepPartial<UpdateRequestStatusRequest>): UpdateRequestStatusRequest {
    return UpdateRequestStatusRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<UpdateRequestStatusRequest>): UpdateRequestStatusRequest {
    const message = createBaseUpdateRequestStatusRequest();
    message.id = object.id ?? 0;
    message.status = object.status ?? "";
    return message;
  },
};

function createBaseGetRequestAttributeRequest(): GetRequestAttributeRequest {
  return { id: 0 };
}

export const GetRequestAttributeRequest = {
  encode(message: GetRequestAttributeRequest, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.id !== 0) {
      writer.uint32(8).uint64(message.id);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): GetRequestAttributeRequest {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetRequestAttributeRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.id = longToNumber(reader.uint64() as Long);
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetRequestAttributeRequest {
    return { id: isSet(object.id) ? globalThis.Number(object.id) : 0 };
  },

  toJSON(message: GetRequestAttributeRequest): unknown {
    const obj: any = {};
    if (message.id !== 0) {
      obj.id = Math.round(message.id);
    }
    return obj;
  },

  create(base?: DeepPartial<GetRequestAttributeRequest>): GetRequestAttributeRequest {
    return GetRequestAttributeRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<GetRequestAttributeRequest>): GetRequestAttributeRequest {
    const message = createBaseGetRequestAttributeRequest();
    message.id = object.id ?? 0;
    return message;
  },
};

function createBaseGetRequestAttributeReply(): GetRequestAttributeReply {
  return { result: undefined };
}

export const GetRequestAttributeReply = {
  encode(message: GetRequestAttributeReply, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.result !== undefined) {
      RequestAttribute.encode(message.result, writer.uint32(10).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): GetRequestAttributeReply {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetRequestAttributeReply();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.result = RequestAttribute.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetRequestAttributeReply {
    return { result: isSet(object.result) ? RequestAttribute.fromJSON(object.result) : undefined };
  },

  toJSON(message: GetRequestAttributeReply): unknown {
    const obj: any = {};
    if (message.result !== undefined) {
      obj.result = RequestAttribute.toJSON(message.result);
    }
    return obj;
  },

  create(base?: DeepPartial<GetRequestAttributeReply>): GetRequestAttributeReply {
    return GetRequestAttributeReply.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<GetRequestAttributeReply>): GetRequestAttributeReply {
    const message = createBaseGetRequestAttributeReply();
    message.result = (object.result !== undefined && object.result !== null)
      ? RequestAttribute.fromPartial(object.result)
      : undefined;
    return message;
  },
};

function createBaseCreateRequestAttributesRequest(): CreateRequestAttributesRequest {
  return { requestId: 0, attributes: [] };
}

export const CreateRequestAttributesRequest = {
  encode(message: CreateRequestAttributesRequest, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.requestId !== 0) {
      writer.uint32(8).uint64(message.requestId);
    }
    for (const v of message.attributes) {
      CreateRequestAttributeRequest.encode(v!, writer.uint32(18).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CreateRequestAttributesRequest {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCreateRequestAttributesRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.requestId = longToNumber(reader.uint64() as Long);
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.attributes.push(CreateRequestAttributeRequest.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CreateRequestAttributesRequest {
    return {
      requestId: isSet(object.requestId) ? globalThis.Number(object.requestId) : 0,
      attributes: globalThis.Array.isArray(object?.attributes)
        ? object.attributes.map((e: any) => CreateRequestAttributeRequest.fromJSON(e))
        : [],
    };
  },

  toJSON(message: CreateRequestAttributesRequest): unknown {
    const obj: any = {};
    if (message.requestId !== 0) {
      obj.requestId = Math.round(message.requestId);
    }
    if (message.attributes?.length) {
      obj.attributes = message.attributes.map((e) => CreateRequestAttributeRequest.toJSON(e));
    }
    return obj;
  },

  create(base?: DeepPartial<CreateRequestAttributesRequest>): CreateRequestAttributesRequest {
    return CreateRequestAttributesRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CreateRequestAttributesRequest>): CreateRequestAttributesRequest {
    const message = createBaseCreateRequestAttributesRequest();
    message.requestId = object.requestId ?? 0;
    message.attributes = object.attributes?.map((e) => CreateRequestAttributeRequest.fromPartial(e)) || [];
    return message;
  },
};

function createBaseCreateRequestAttributeRequest(): CreateRequestAttributeRequest {
  return { key: "", value: "", contentType: "" };
}

export const CreateRequestAttributeRequest = {
  encode(message: CreateRequestAttributeRequest, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.key !== "") {
      writer.uint32(10).string(message.key);
    }
    if (message.value !== "") {
      writer.uint32(18).string(message.value);
    }
    if (message.contentType !== "") {
      writer.uint32(26).string(message.contentType);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CreateRequestAttributeRequest {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCreateRequestAttributeRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.key = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.value = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.contentType = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CreateRequestAttributeRequest {
    return {
      key: isSet(object.key) ? globalThis.String(object.key) : "",
      value: isSet(object.value) ? globalThis.String(object.value) : "",
      contentType: isSet(object.contentType) ? globalThis.String(object.contentType) : "",
    };
  },

  toJSON(message: CreateRequestAttributeRequest): unknown {
    const obj: any = {};
    if (message.key !== "") {
      obj.key = message.key;
    }
    if (message.value !== "") {
      obj.value = message.value;
    }
    if (message.contentType !== "") {
      obj.contentType = message.contentType;
    }
    return obj;
  },

  create(base?: DeepPartial<CreateRequestAttributeRequest>): CreateRequestAttributeRequest {
    return CreateRequestAttributeRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CreateRequestAttributeRequest>): CreateRequestAttributeRequest {
    const message = createBaseCreateRequestAttributeRequest();
    message.key = object.key ?? "";
    message.value = object.value ?? "";
    message.contentType = object.contentType ?? "";
    return message;
  },
};

function createBaseGetAutoTransferEventHandlersRequest(): GetAutoTransferEventHandlersRequest {
  return { cursor: undefined, status: "", blockchain: "", network: "", monitoredWalletId: 0 };
}

export const GetAutoTransferEventHandlersRequest = {
  encode(message: GetAutoTransferEventHandlersRequest, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.cursor !== undefined) {
      RequestCursor.encode(message.cursor, writer.uint32(10).fork()).ldelim();
    }
    if (message.status !== "") {
      writer.uint32(18).string(message.status);
    }
    if (message.blockchain !== "") {
      writer.uint32(26).string(message.blockchain);
    }
    if (message.network !== "") {
      writer.uint32(34).string(message.network);
    }
    if (message.monitoredWalletId !== 0) {
      writer.uint32(40).uint64(message.monitoredWalletId);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): GetAutoTransferEventHandlersRequest {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetAutoTransferEventHandlersRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.cursor = RequestCursor.decode(reader, reader.uint32());
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.status = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.blockchain = reader.string();
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.network = reader.string();
          continue;
        case 5:
          if (tag !== 40) {
            break;
          }

          message.monitoredWalletId = longToNumber(reader.uint64() as Long);
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetAutoTransferEventHandlersRequest {
    return {
      cursor: isSet(object.cursor) ? RequestCursor.fromJSON(object.cursor) : undefined,
      status: isSet(object.status) ? globalThis.String(object.status) : "",
      blockchain: isSet(object.blockchain) ? globalThis.String(object.blockchain) : "",
      network: isSet(object.network) ? globalThis.String(object.network) : "",
      monitoredWalletId: isSet(object.monitoredWalletId) ? globalThis.Number(object.monitoredWalletId) : 0,
    };
  },

  toJSON(message: GetAutoTransferEventHandlersRequest): unknown {
    const obj: any = {};
    if (message.cursor !== undefined) {
      obj.cursor = RequestCursor.toJSON(message.cursor);
    }
    if (message.status !== "") {
      obj.status = message.status;
    }
    if (message.blockchain !== "") {
      obj.blockchain = message.blockchain;
    }
    if (message.network !== "") {
      obj.network = message.network;
    }
    if (message.monitoredWalletId !== 0) {
      obj.monitoredWalletId = Math.round(message.monitoredWalletId);
    }
    return obj;
  },

  create(base?: DeepPartial<GetAutoTransferEventHandlersRequest>): GetAutoTransferEventHandlersRequest {
    return GetAutoTransferEventHandlersRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<GetAutoTransferEventHandlersRequest>): GetAutoTransferEventHandlersRequest {
    const message = createBaseGetAutoTransferEventHandlersRequest();
    message.cursor = (object.cursor !== undefined && object.cursor !== null)
      ? RequestCursor.fromPartial(object.cursor)
      : undefined;
    message.status = object.status ?? "";
    message.blockchain = object.blockchain ?? "";
    message.network = object.network ?? "";
    message.monitoredWalletId = object.monitoredWalletId ?? 0;
    return message;
  },
};

function createBaseGetAutoTransferEventHandlersReply(): GetAutoTransferEventHandlersReply {
  return { cursor: undefined, handlers: [] };
}

export const GetAutoTransferEventHandlersReply = {
  encode(message: GetAutoTransferEventHandlersReply, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.cursor !== undefined) {
      ResponseCursor.encode(message.cursor, writer.uint32(10).fork()).ldelim();
    }
    for (const v of message.handlers) {
      AutoTransferEventHandler.encode(v!, writer.uint32(18).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): GetAutoTransferEventHandlersReply {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetAutoTransferEventHandlersReply();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.cursor = ResponseCursor.decode(reader, reader.uint32());
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.handlers.push(AutoTransferEventHandler.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetAutoTransferEventHandlersReply {
    return {
      cursor: isSet(object.cursor) ? ResponseCursor.fromJSON(object.cursor) : undefined,
      handlers: globalThis.Array.isArray(object?.handlers)
        ? object.handlers.map((e: any) => AutoTransferEventHandler.fromJSON(e))
        : [],
    };
  },

  toJSON(message: GetAutoTransferEventHandlersReply): unknown {
    const obj: any = {};
    if (message.cursor !== undefined) {
      obj.cursor = ResponseCursor.toJSON(message.cursor);
    }
    if (message.handlers?.length) {
      obj.handlers = message.handlers.map((e) => AutoTransferEventHandler.toJSON(e));
    }
    return obj;
  },

  create(base?: DeepPartial<GetAutoTransferEventHandlersReply>): GetAutoTransferEventHandlersReply {
    return GetAutoTransferEventHandlersReply.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<GetAutoTransferEventHandlersReply>): GetAutoTransferEventHandlersReply {
    const message = createBaseGetAutoTransferEventHandlersReply();
    message.cursor = (object.cursor !== undefined && object.cursor !== null)
      ? ResponseCursor.fromPartial(object.cursor)
      : undefined;
    message.handlers = object.handlers?.map((e) => AutoTransferEventHandler.fromPartial(e)) || [];
    return message;
  },
};

function createBaseGetAutoTransferEventHandlerByIdRequest(): GetAutoTransferEventHandlerByIdRequest {
  return { id: "" };
}

export const GetAutoTransferEventHandlerByIdRequest = {
  encode(message: GetAutoTransferEventHandlerByIdRequest, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.id !== "") {
      writer.uint32(10).string(message.id);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): GetAutoTransferEventHandlerByIdRequest {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetAutoTransferEventHandlerByIdRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.id = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetAutoTransferEventHandlerByIdRequest {
    return { id: isSet(object.id) ? globalThis.String(object.id) : "" };
  },

  toJSON(message: GetAutoTransferEventHandlerByIdRequest): unknown {
    const obj: any = {};
    if (message.id !== "") {
      obj.id = message.id;
    }
    return obj;
  },

  create(base?: DeepPartial<GetAutoTransferEventHandlerByIdRequest>): GetAutoTransferEventHandlerByIdRequest {
    return GetAutoTransferEventHandlerByIdRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<GetAutoTransferEventHandlerByIdRequest>): GetAutoTransferEventHandlerByIdRequest {
    const message = createBaseGetAutoTransferEventHandlerByIdRequest();
    message.id = object.id ?? "";
    return message;
  },
};

function createBaseGetAutoTransferEventHandlerByIdReply(): GetAutoTransferEventHandlerByIdReply {
  return { handler: undefined };
}

export const GetAutoTransferEventHandlerByIdReply = {
  encode(message: GetAutoTransferEventHandlerByIdReply, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.handler !== undefined) {
      AutoTransferEventHandler.encode(message.handler, writer.uint32(10).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): GetAutoTransferEventHandlerByIdReply {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetAutoTransferEventHandlerByIdReply();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.handler = AutoTransferEventHandler.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetAutoTransferEventHandlerByIdReply {
    return { handler: isSet(object.handler) ? AutoTransferEventHandler.fromJSON(object.handler) : undefined };
  },

  toJSON(message: GetAutoTransferEventHandlerByIdReply): unknown {
    const obj: any = {};
    if (message.handler !== undefined) {
      obj.handler = AutoTransferEventHandler.toJSON(message.handler);
    }
    return obj;
  },

  create(base?: DeepPartial<GetAutoTransferEventHandlerByIdReply>): GetAutoTransferEventHandlerByIdReply {
    return GetAutoTransferEventHandlerByIdReply.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<GetAutoTransferEventHandlerByIdReply>): GetAutoTransferEventHandlerByIdReply {
    const message = createBaseGetAutoTransferEventHandlerByIdReply();
    message.handler = (object.handler !== undefined && object.handler !== null)
      ? AutoTransferEventHandler.fromPartial(object.handler)
      : undefined;
    return message;
  },
};

function createBaseTriggerAutoTransferEventHandlerRequest(): TriggerAutoTransferEventHandlerRequest {
  return { id: "", destinationAddressId: 0, externalRequestId: "" };
}

export const TriggerAutoTransferEventHandlerRequest = {
  encode(message: TriggerAutoTransferEventHandlerRequest, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.id !== "") {
      writer.uint32(10).string(message.id);
    }
    if (message.destinationAddressId !== 0) {
      writer.uint32(16).uint64(message.destinationAddressId);
    }
    if (message.externalRequestId !== "") {
      writer.uint32(26).string(message.externalRequestId);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): TriggerAutoTransferEventHandlerRequest {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseTriggerAutoTransferEventHandlerRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.id = reader.string();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.destinationAddressId = longToNumber(reader.uint64() as Long);
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.externalRequestId = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): TriggerAutoTransferEventHandlerRequest {
    return {
      id: isSet(object.id) ? globalThis.String(object.id) : "",
      destinationAddressId: isSet(object.destinationAddressId) ? globalThis.Number(object.destinationAddressId) : 0,
      externalRequestId: isSet(object.externalRequestId) ? globalThis.String(object.externalRequestId) : "",
    };
  },

  toJSON(message: TriggerAutoTransferEventHandlerRequest): unknown {
    const obj: any = {};
    if (message.id !== "") {
      obj.id = message.id;
    }
    if (message.destinationAddressId !== 0) {
      obj.destinationAddressId = Math.round(message.destinationAddressId);
    }
    if (message.externalRequestId !== "") {
      obj.externalRequestId = message.externalRequestId;
    }
    return obj;
  },

  create(base?: DeepPartial<TriggerAutoTransferEventHandlerRequest>): TriggerAutoTransferEventHandlerRequest {
    return TriggerAutoTransferEventHandlerRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<TriggerAutoTransferEventHandlerRequest>): TriggerAutoTransferEventHandlerRequest {
    const message = createBaseTriggerAutoTransferEventHandlerRequest();
    message.id = object.id ?? "";
    message.destinationAddressId = object.destinationAddressId ?? 0;
    message.externalRequestId = object.externalRequestId ?? "";
    return message;
  },
};

function createBaseStakingProvider(): StakingProvider {
  return { kind: "" };
}

export const StakingProvider = {
  encode(message: StakingProvider, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.kind !== "") {
      writer.uint32(10).string(message.kind);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): StakingProvider {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseStakingProvider();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.kind = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): StakingProvider {
    return { kind: isSet(object.kind) ? globalThis.String(object.kind) : "" };
  },

  toJSON(message: StakingProvider): unknown {
    const obj: any = {};
    if (message.kind !== "") {
      obj.kind = message.kind;
    }
    return obj;
  },

  create(base?: DeepPartial<StakingProvider>): StakingProvider {
    return StakingProvider.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<StakingProvider>): StakingProvider {
    const message = createBaseStakingProvider();
    message.kind = object.kind ?? "";
    return message;
  },
};

function createBaseStakeETHRequest(): StakeETHRequest {
  return {
    fromAddressId: 0,
    amount: "",
    provider: undefined,
    gasLimit: "",
    gasPriceLimit: "",
    comment: "",
    externalRequestId: "",
  };
}

export const StakeETHRequest = {
  encode(message: StakeETHRequest, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.fromAddressId !== 0) {
      writer.uint32(8).uint64(message.fromAddressId);
    }
    if (message.amount !== "") {
      writer.uint32(18).string(message.amount);
    }
    if (message.provider !== undefined) {
      StakingProvider.encode(message.provider, writer.uint32(26).fork()).ldelim();
    }
    if (message.gasLimit !== "") {
      writer.uint32(34).string(message.gasLimit);
    }
    if (message.gasPriceLimit !== "") {
      writer.uint32(42).string(message.gasPriceLimit);
    }
    if (message.comment !== "") {
      writer.uint32(50).string(message.comment);
    }
    if (message.externalRequestId !== "") {
      writer.uint32(58).string(message.externalRequestId);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): StakeETHRequest {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseStakeETHRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.fromAddressId = longToNumber(reader.uint64() as Long);
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.amount = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.provider = StakingProvider.decode(reader, reader.uint32());
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.gasLimit = reader.string();
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.gasPriceLimit = reader.string();
          continue;
        case 6:
          if (tag !== 50) {
            break;
          }

          message.comment = reader.string();
          continue;
        case 7:
          if (tag !== 58) {
            break;
          }

          message.externalRequestId = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): StakeETHRequest {
    return {
      fromAddressId: isSet(object.fromAddressId) ? globalThis.Number(object.fromAddressId) : 0,
      amount: isSet(object.amount) ? globalThis.String(object.amount) : "",
      provider: isSet(object.provider) ? StakingProvider.fromJSON(object.provider) : undefined,
      gasLimit: isSet(object.gasLimit) ? globalThis.String(object.gasLimit) : "",
      gasPriceLimit: isSet(object.gasPriceLimit) ? globalThis.String(object.gasPriceLimit) : "",
      comment: isSet(object.comment) ? globalThis.String(object.comment) : "",
      externalRequestId: isSet(object.externalRequestId) ? globalThis.String(object.externalRequestId) : "",
    };
  },

  toJSON(message: StakeETHRequest): unknown {
    const obj: any = {};
    if (message.fromAddressId !== 0) {
      obj.fromAddressId = Math.round(message.fromAddressId);
    }
    if (message.amount !== "") {
      obj.amount = message.amount;
    }
    if (message.provider !== undefined) {
      obj.provider = StakingProvider.toJSON(message.provider);
    }
    if (message.gasLimit !== "") {
      obj.gasLimit = message.gasLimit;
    }
    if (message.gasPriceLimit !== "") {
      obj.gasPriceLimit = message.gasPriceLimit;
    }
    if (message.comment !== "") {
      obj.comment = message.comment;
    }
    if (message.externalRequestId !== "") {
      obj.externalRequestId = message.externalRequestId;
    }
    return obj;
  },

  create(base?: DeepPartial<StakeETHRequest>): StakeETHRequest {
    return StakeETHRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<StakeETHRequest>): StakeETHRequest {
    const message = createBaseStakeETHRequest();
    message.fromAddressId = object.fromAddressId ?? 0;
    message.amount = object.amount ?? "";
    message.provider = (object.provider !== undefined && object.provider !== null)
      ? StakingProvider.fromPartial(object.provider)
      : undefined;
    message.gasLimit = object.gasLimit ?? "";
    message.gasPriceLimit = object.gasPriceLimit ?? "";
    message.comment = object.comment ?? "";
    message.externalRequestId = object.externalRequestId ?? "";
    return message;
  },
};

function createBaseCreateETHUnstakeRequestRequest(): CreateETHUnstakeRequestRequest {
  return { fromAddressId: 0, amount: "", ethValidatorIDs: [], comment: "", externalRequestId: "" };
}

export const CreateETHUnstakeRequestRequest = {
  encode(message: CreateETHUnstakeRequestRequest, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.fromAddressId !== 0) {
      writer.uint32(8).uint64(message.fromAddressId);
    }
    if (message.amount !== "") {
      writer.uint32(18).string(message.amount);
    }
    for (const v of message.ethValidatorIDs) {
      writer.uint32(26).string(v!);
    }
    if (message.comment !== "") {
      writer.uint32(34).string(message.comment);
    }
    if (message.externalRequestId !== "") {
      writer.uint32(42).string(message.externalRequestId);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CreateETHUnstakeRequestRequest {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCreateETHUnstakeRequestRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.fromAddressId = longToNumber(reader.uint64() as Long);
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.amount = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.ethValidatorIDs.push(reader.string());
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.comment = reader.string();
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.externalRequestId = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CreateETHUnstakeRequestRequest {
    return {
      fromAddressId: isSet(object.fromAddressId) ? globalThis.Number(object.fromAddressId) : 0,
      amount: isSet(object.amount) ? globalThis.String(object.amount) : "",
      ethValidatorIDs: globalThis.Array.isArray(object?.ethValidatorIDs)
        ? object.ethValidatorIDs.map((e: any) => globalThis.String(e))
        : [],
      comment: isSet(object.comment) ? globalThis.String(object.comment) : "",
      externalRequestId: isSet(object.externalRequestId) ? globalThis.String(object.externalRequestId) : "",
    };
  },

  toJSON(message: CreateETHUnstakeRequestRequest): unknown {
    const obj: any = {};
    if (message.fromAddressId !== 0) {
      obj.fromAddressId = Math.round(message.fromAddressId);
    }
    if (message.amount !== "") {
      obj.amount = message.amount;
    }
    if (message.ethValidatorIDs?.length) {
      obj.ethValidatorIDs = message.ethValidatorIDs;
    }
    if (message.comment !== "") {
      obj.comment = message.comment;
    }
    if (message.externalRequestId !== "") {
      obj.externalRequestId = message.externalRequestId;
    }
    return obj;
  },

  create(base?: DeepPartial<CreateETHUnstakeRequestRequest>): CreateETHUnstakeRequestRequest {
    return CreateETHUnstakeRequestRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CreateETHUnstakeRequestRequest>): CreateETHUnstakeRequestRequest {
    const message = createBaseCreateETHUnstakeRequestRequest();
    message.fromAddressId = object.fromAddressId ?? 0;
    message.amount = object.amount ?? "";
    message.ethValidatorIDs = object.ethValidatorIDs?.map((e) => e) || [];
    message.comment = object.comment ?? "";
    message.externalRequestId = object.externalRequestId ?? "";
    return message;
  },
};

export interface RequestService {
  GetRequest(request: GetRequestRequest): Promise<GetRequestReply>;
  UpdateRequestStatus(request: UpdateRequestStatusRequest): Promise<Empty>;
  GetRequestBundle(request: GetRequestBundleRequest): Promise<GetRequestBundleReply>;
  GetAutoTransferEventHandlers(
    request: GetAutoTransferEventHandlersRequest,
  ): Promise<GetAutoTransferEventHandlersReply>;
  GetAutoTransferEventHandlerById(
    request: GetAutoTransferEventHandlerByIdRequest,
  ): Promise<GetAutoTransferEventHandlerByIdReply>;
  TriggerAutoTransferEventHandler(request: TriggerAutoTransferEventHandlerRequest): Promise<Empty>;
  CreateOutgoingRequest(request: CreateOutgoingRequestRequest): Promise<CreateRequestReply>;
  CreateAddressToAddressTransferOutgoingRequest(
    request: CreateAddressToAddressTransferOutgoingRequestRequest,
  ): Promise<CreateRequestReply>;
  CreateOutgoingAddressToAddressRequestBundle(
    request: CreateOutgoingAddressToAddressRequestBundleRequest,
  ): Promise<CreateRequestBundleReply>;
  CreateOutgoingRequestBundle(request: CreateOutgoingRequestBundleRequest): Promise<CreateRequestBundleReply>;
  CreateOutgoingALGOASAOptInRequest(request: CreateOutgoingALGOASAOptInRequestRequest): Promise<CreateRequestReply>;
  CreateOutgoingXLMMintAssetRequest(request: CreateOutgoingXLMMintAssetRequestRequest): Promise<CreateRequestReply>;
  CreateOutgoingXLMChangeTrustRequest(request: CreateOutgoingXLMChangeTrustRequestRequest): Promise<CreateRequestReply>;
  CreateOutgoingXLMManageDataRequest(request: CreateOutgoingXLMManageDataRequestRequest): Promise<CreateRequestReply>;
  CreateOutgoingXLMSetTrustlineFlagsRequest(
    request: CreateOutgoingXLMSetTrustlineFlagsRequestRequest,
  ): Promise<CreateRequestReply>;
  CreateOutgoingXLMSetOptionsRequest(request: CreateOutgoingXLMSetOptionsRequestRequest): Promise<CreateRequestReply>;
  CreateOutgoingXLMCreateClaimableBalanceRequest(
    request: CreateOutgoingXLMCreateClaimableBalanceRequestRequest,
  ): Promise<CreateRequestReply>;
  CreateOutgoingXLMClaimClaimableBalanceRequest(
    request: CreateOutgoingXLMClaimClaimableBalanceRequestRequest,
  ): Promise<CreateRequestReply>;
  CreateOutgoingXLMClawbackClaimableBalanceRequest(
    request: CreateOutgoingXLMClawbackClaimableBalanceRequestRequest,
  ): Promise<CreateRequestReply>;
  CreateOutgoingXLMRevokeSponsorshipRequest(
    request: CreateOutgoingXLMRevokeSponsorshipRequestRequest,
  ): Promise<CreateRequestReply>;
  CreateOutgoingXLMClawbackRequest(request: CreateOutgoingXLMClawbackRequestRequest): Promise<CreateRequestReply>;
  CreateOutgoingXLMLiquidityPoolDepositRequest(
    request: CreateOutgoingXLMLiquidityPoolDepositRequestRequest,
  ): Promise<CreateRequestReply>;
  CreateOutgoingXLMLiquidityPoolWithdrawRequest(
    request: CreateOutgoingXLMLiquidityPoolWithdrawRequestRequest,
  ): Promise<CreateRequestReply>;
  CreateOutgoingXLMPathPaymentStrictSendRequest(
    request: CreateOutgoingXLMPathPaymentStrictSendRequestRequest,
  ): Promise<CreateRequestReply>;
  CreateOutgoingXLMPathPaymentStrictReceiveRequest(
    request: CreateOutgoingXLMPathPaymentStrictReceiveRequestRequest,
  ): Promise<CreateRequestReply>;
  CreateOutgoingXLMBuyOfferRequest(request: CreateOutgoingXLMBuyOfferRequestRequest): Promise<CreateRequestReply>;
  CreateOutgoingXLMSellOfferRequest(request: CreateOutgoingXLMSellOfferRequestRequest): Promise<CreateRequestReply>;
  CreateOutgoingXTZDelegateRequest(request: CreateOutgoingXTZDelegateRequestRequest): Promise<CreateRequestReply>;
  CreateOutgoingXTZUndelegateRequest(request: CreateOutgoingXTZUndelegateRequestRequest): Promise<CreateRequestReply>;
  CreateOutgoingXTZStakeRequest(request: CreateOutgoingXTZStakeRequestRequest): Promise<CreateRequestReply>;
  CreateOutgoingXTZUnstakeRequest(request: CreateOutgoingXTZUnstakeRequestRequest): Promise<CreateRequestReply>;
  CreateOutgoingADADelegateRequest(request: CreateOutgoingADADelegateRequestRequest): Promise<CreateRequestReply>;
  CreateOutgoingADAUndelegateRequest(request: CreateOutgoingADAUndelegateRequestRequest): Promise<CreateRequestReply>;
  CreateOutgoingADAVoteDelegateRequest(
    request: CreateOutgoingADAVoteDelegateRequestRequest,
  ): Promise<CreateRequestReply>;
  CreateOutgoingADAWithdrawalRequest(request: CreateOutgoingADAWithdrawalRequestRequest): Promise<CreateRequestReply>;
  CreateOutgoingCosmosDelegateRequest(request: CreateOutgoingCosmosDelegateRequestRequest): Promise<CreateRequestReply>;
  CreateOutgoingCosmosUndelegateRequest(
    request: CreateOutgoingCosmosUndelegateRequestRequest,
  ): Promise<CreateRequestReply>;
  CreateOutgoingCosmosWithdrawRewardRequest(
    request: CreateOutgoingCosmosWithdrawRewardRequestRequest,
  ): Promise<CreateRequestReply>;
  CreateOutgoingFTMDelegateRequest(request: CreateOutgoingFTMDelegateRequestRequest): Promise<CreateRequestReply>;
  CreateOutgoingFTMUndelegateRequest(request: CreateOutgoingFTMUndelegateRequestRequest): Promise<CreateRequestReply>;
  CreateOutgoingFTMWithdrawalRequest(request: CreateOutgoingFTMWithdrawalRequestRequest): Promise<CreateRequestReply>;
  CreateOutgoingFTMClaimRewardsRequest(
    request: CreateOutgoingFTMClaimRewardsRequestRequest,
  ): Promise<CreateRequestReply>;
  CreateOutgoingDOTNominateRequest(request: CreateOutgoingDOTNominateRequestRequest): Promise<CreateRequestReply>;
  CreateOutgoingDOTBondRequest(request: CreateOutgoingDOTBondRequestRequest): Promise<CreateRequestReply>;
  CreateOutgoingDOTBondExtraRequest(request: CreateOutgoingDOTBondExtraRequestRequest): Promise<CreateRequestReply>;
  CreateOutgoingDOTChillRequest(request: CreateOutgoingDOTChillRequestRequest): Promise<CreateRequestReply>;
  CreateOutgoingDOTUnbondRequest(request: CreateOutgoingDOTUnbondRequestRequest): Promise<CreateRequestReply>;
  CreateOutgoingMinaDelegationRequest(request: CreateOutgoingMinaDelegationRequestRequest): Promise<CreateRequestReply>;
  CreateOutgoingMinaUndelegationRequest(
    request: CreateOutgoingMinaUndelegationRequestRequest,
  ): Promise<CreateRequestReply>;
  CreateOutgoingNEARDepositAndStakeRequest(
    request: CreateOutgoingNEARDepositAndStakeRequestRequest,
  ): Promise<CreateRequestReply>;
  CreateOutgoingNEARUnstakeRequest(request: CreateOutgoingNEARUnstakeRequestRequest): Promise<CreateRequestReply>;
  CreateOutgoingNEARWithdrawRequest(request: CreateOutgoingNEARWithdrawRequestRequest): Promise<CreateRequestReply>;
  CreateOutgoingDOTWithdrawUnbondedRequest(
    request: CreateOutgoingDOTWithdrawUnbondedRequestRequest,
  ): Promise<CreateRequestReply>;
  CreateOutgoingSOLTokenMintRequest(request: CreateOutgoingSOLTokenMintRequestRequest): Promise<CreateRequestReply>;
  CreateOutgoingSOLTokenBurnRequest(request: CreateOutgoingSOLTokenBurnRequestRequest): Promise<CreateRequestReply>;
  CreateOutgoingSOLCreateTokenRequest(request: CreateOutgoingSOLCreateTokenRequestRequest): Promise<CreateRequestReply>;
  CreateOutgoingSOLDelegateRequest(request: CreateOutgoingSOLDelegateRequestRequest): Promise<CreateRequestReply>;
  CreateOutgoingSOLDeactivateRequest(request: CreateOutgoingSOLDeactivateRequestRequest): Promise<CreateRequestReply>;
  CreateOutgoingSOLWithdrawRequest(request: CreateOutgoingSOLWithdrawRequestRequest): Promise<CreateRequestReply>;
  CreateOutgoingSOLMergeRequest(request: CreateOutgoingSOLMergeRequestRequest): Promise<CreateRequestReply>;
  CreateOutgoingHederaStakingRequest(request: CreateOutgoingHederaStakingRequestRequest): Promise<CreateRequestReply>;
  CreateOutgoingHederaUnstakingRequest(
    request: CreateOutgoingHederaUnstakingRequestRequest,
  ): Promise<CreateRequestReply>;
  CreateOutgoingUTXOsRequest(request: CreateOutgoingUTXOsRequestRequest): Promise<CreateRequestReply>;
  CreateOutgoingCancelRequest(request: CreateOutgoingCancelRequestRequest): Promise<CreateRequestReply>;
  CreateOutgoingDeployContractRequest(request: CreateOutgoingDeployContractRequestRequest): Promise<CreateRequestReply>;
  CreateOutgoingCallContractRequest(request: CreateOutgoingCallContractRequestRequest): Promise<CreateRequestReply>;
  CreateOutgoingCosmosGenericRequest(request: CreateOutgoingCosmosGenericRequestRequest): Promise<CreateRequestReply>;
  CreateOutgoingICPTransferToStakeRequest(
    request: CreateOutgoingICPTransferToStakeRequestRequest,
  ): Promise<CreateRequestReply>;
  CreateOutgoingICPSetDissolveDelayRequest(
    request: CreateOutgoingICPSetDissolveDelayRequestRequest,
  ): Promise<CreateRequestReply>;
  CreateOutgoingICPFollowRequest(request: CreateOutgoingICPFollowRequestRequest): Promise<CreateRequestReply>;
  CreateOutgoingICPStartDissolvingRequest(
    request: CreateOutgoingICPStartDissolvingRequestRequest,
  ): Promise<CreateRequestReply>;
  CreateIncomingRequest(request: CreateIncomingRequestRequest): Promise<CreateRequestReply>;
  CreateFiatProviderWithdrawalRequest(request: CreateFiatProviderWithdrawalRequestRequest): Promise<CreateRequestReply>;
  CreateFiatProviderDepositRequest(request: CreateFiatProviderDepositRequestRequest): Promise<CreateRequestReply>;
  CreateFiatProviderTransferRequest(request: CreateFiatProviderTransferRequestRequest): Promise<CreateRequestReply>;
  ApproveRequests(request: ApproveRequestsRequest): Promise<ApproveRequestsReply>;
  GetAsyncApprovals(request: GetAsyncApprovalsRequest): Promise<GetAsyncApprovalsReply>;
  RejectRequests(request: RejectRequestsRequest): Promise<Empty>;
  /** Deprecated - Replaced by GetRequestsV2 */
  GetRequests(request: GetRequestsRequest): Promise<GetRequestsReply>;
  GetRequestsV2(request: GetRequestsV2Request): Promise<GetRequestsV2Reply>;
  /** Deprecated - Replaced by GetRequestsForApprovalV2 */
  GetRequestsForApproval(request: GetRequestsForApprovalRequest): Promise<GetRequestsReply>;
  GetRequestsForApprovalV2(request: GetRequestsForApprovalV2Request): Promise<GetRequestsV2Reply>;
  GetRequestBundles(request: GetRequestBundlesRequest): Promise<GetRequestBundlesReply>;
  GetRequestBundlesForApproval(request: GetRequestBundlesForApprovalRequest): Promise<GetRequestBundlesReply>;
  CreateRequestAttributes(request: CreateRequestAttributesRequest): Promise<Empty>;
  GetRequestAttribute(request: GetRequestAttributeRequest): Promise<GetRequestAttributeReply>;
  StakeETH(request: StakeETHRequest): Promise<CreateRequestReply>;
  CreateETHUnstakeRequest(request: CreateETHUnstakeRequestRequest): Promise<CreateRequestReply>;
}

export const RequestServiceServiceName = "tgvalidatord.RequestService";
export class RequestServiceClientImpl implements RequestService {
  private readonly rpc: Rpc;
  private readonly service: string;
  constructor(rpc: Rpc, opts?: { service?: string }) {
    this.service = opts?.service || RequestServiceServiceName;
    this.rpc = rpc;
    this.GetRequest = this.GetRequest.bind(this);
    this.UpdateRequestStatus = this.UpdateRequestStatus.bind(this);
    this.GetRequestBundle = this.GetRequestBundle.bind(this);
    this.GetAutoTransferEventHandlers = this.GetAutoTransferEventHandlers.bind(this);
    this.GetAutoTransferEventHandlerById = this.GetAutoTransferEventHandlerById.bind(this);
    this.TriggerAutoTransferEventHandler = this.TriggerAutoTransferEventHandler.bind(this);
    this.CreateOutgoingRequest = this.CreateOutgoingRequest.bind(this);
    this.CreateAddressToAddressTransferOutgoingRequest = this.CreateAddressToAddressTransferOutgoingRequest.bind(this);
    this.CreateOutgoingAddressToAddressRequestBundle = this.CreateOutgoingAddressToAddressRequestBundle.bind(this);
    this.CreateOutgoingRequestBundle = this.CreateOutgoingRequestBundle.bind(this);
    this.CreateOutgoingALGOASAOptInRequest = this.CreateOutgoingALGOASAOptInRequest.bind(this);
    this.CreateOutgoingXLMMintAssetRequest = this.CreateOutgoingXLMMintAssetRequest.bind(this);
    this.CreateOutgoingXLMChangeTrustRequest = this.CreateOutgoingXLMChangeTrustRequest.bind(this);
    this.CreateOutgoingXLMManageDataRequest = this.CreateOutgoingXLMManageDataRequest.bind(this);
    this.CreateOutgoingXLMSetTrustlineFlagsRequest = this.CreateOutgoingXLMSetTrustlineFlagsRequest.bind(this);
    this.CreateOutgoingXLMSetOptionsRequest = this.CreateOutgoingXLMSetOptionsRequest.bind(this);
    this.CreateOutgoingXLMCreateClaimableBalanceRequest = this.CreateOutgoingXLMCreateClaimableBalanceRequest.bind(
      this,
    );
    this.CreateOutgoingXLMClaimClaimableBalanceRequest = this.CreateOutgoingXLMClaimClaimableBalanceRequest.bind(this);
    this.CreateOutgoingXLMClawbackClaimableBalanceRequest = this.CreateOutgoingXLMClawbackClaimableBalanceRequest.bind(
      this,
    );
    this.CreateOutgoingXLMRevokeSponsorshipRequest = this.CreateOutgoingXLMRevokeSponsorshipRequest.bind(this);
    this.CreateOutgoingXLMClawbackRequest = this.CreateOutgoingXLMClawbackRequest.bind(this);
    this.CreateOutgoingXLMLiquidityPoolDepositRequest = this.CreateOutgoingXLMLiquidityPoolDepositRequest.bind(this);
    this.CreateOutgoingXLMLiquidityPoolWithdrawRequest = this.CreateOutgoingXLMLiquidityPoolWithdrawRequest.bind(this);
    this.CreateOutgoingXLMPathPaymentStrictSendRequest = this.CreateOutgoingXLMPathPaymentStrictSendRequest.bind(this);
    this.CreateOutgoingXLMPathPaymentStrictReceiveRequest = this.CreateOutgoingXLMPathPaymentStrictReceiveRequest.bind(
      this,
    );
    this.CreateOutgoingXLMBuyOfferRequest = this.CreateOutgoingXLMBuyOfferRequest.bind(this);
    this.CreateOutgoingXLMSellOfferRequest = this.CreateOutgoingXLMSellOfferRequest.bind(this);
    this.CreateOutgoingXTZDelegateRequest = this.CreateOutgoingXTZDelegateRequest.bind(this);
    this.CreateOutgoingXTZUndelegateRequest = this.CreateOutgoingXTZUndelegateRequest.bind(this);
    this.CreateOutgoingXTZStakeRequest = this.CreateOutgoingXTZStakeRequest.bind(this);
    this.CreateOutgoingXTZUnstakeRequest = this.CreateOutgoingXTZUnstakeRequest.bind(this);
    this.CreateOutgoingADADelegateRequest = this.CreateOutgoingADADelegateRequest.bind(this);
    this.CreateOutgoingADAUndelegateRequest = this.CreateOutgoingADAUndelegateRequest.bind(this);
    this.CreateOutgoingADAVoteDelegateRequest = this.CreateOutgoingADAVoteDelegateRequest.bind(this);
    this.CreateOutgoingADAWithdrawalRequest = this.CreateOutgoingADAWithdrawalRequest.bind(this);
    this.CreateOutgoingCosmosDelegateRequest = this.CreateOutgoingCosmosDelegateRequest.bind(this);
    this.CreateOutgoingCosmosUndelegateRequest = this.CreateOutgoingCosmosUndelegateRequest.bind(this);
    this.CreateOutgoingCosmosWithdrawRewardRequest = this.CreateOutgoingCosmosWithdrawRewardRequest.bind(this);
    this.CreateOutgoingFTMDelegateRequest = this.CreateOutgoingFTMDelegateRequest.bind(this);
    this.CreateOutgoingFTMUndelegateRequest = this.CreateOutgoingFTMUndelegateRequest.bind(this);
    this.CreateOutgoingFTMWithdrawalRequest = this.CreateOutgoingFTMWithdrawalRequest.bind(this);
    this.CreateOutgoingFTMClaimRewardsRequest = this.CreateOutgoingFTMClaimRewardsRequest.bind(this);
    this.CreateOutgoingDOTNominateRequest = this.CreateOutgoingDOTNominateRequest.bind(this);
    this.CreateOutgoingDOTBondRequest = this.CreateOutgoingDOTBondRequest.bind(this);
    this.CreateOutgoingDOTBondExtraRequest = this.CreateOutgoingDOTBondExtraRequest.bind(this);
    this.CreateOutgoingDOTChillRequest = this.CreateOutgoingDOTChillRequest.bind(this);
    this.CreateOutgoingDOTUnbondRequest = this.CreateOutgoingDOTUnbondRequest.bind(this);
    this.CreateOutgoingMinaDelegationRequest = this.CreateOutgoingMinaDelegationRequest.bind(this);
    this.CreateOutgoingMinaUndelegationRequest = this.CreateOutgoingMinaUndelegationRequest.bind(this);
    this.CreateOutgoingNEARDepositAndStakeRequest = this.CreateOutgoingNEARDepositAndStakeRequest.bind(this);
    this.CreateOutgoingNEARUnstakeRequest = this.CreateOutgoingNEARUnstakeRequest.bind(this);
    this.CreateOutgoingNEARWithdrawRequest = this.CreateOutgoingNEARWithdrawRequest.bind(this);
    this.CreateOutgoingDOTWithdrawUnbondedRequest = this.CreateOutgoingDOTWithdrawUnbondedRequest.bind(this);
    this.CreateOutgoingSOLTokenMintRequest = this.CreateOutgoingSOLTokenMintRequest.bind(this);
    this.CreateOutgoingSOLTokenBurnRequest = this.CreateOutgoingSOLTokenBurnRequest.bind(this);
    this.CreateOutgoingSOLCreateTokenRequest = this.CreateOutgoingSOLCreateTokenRequest.bind(this);
    this.CreateOutgoingSOLDelegateRequest = this.CreateOutgoingSOLDelegateRequest.bind(this);
    this.CreateOutgoingSOLDeactivateRequest = this.CreateOutgoingSOLDeactivateRequest.bind(this);
    this.CreateOutgoingSOLWithdrawRequest = this.CreateOutgoingSOLWithdrawRequest.bind(this);
    this.CreateOutgoingSOLMergeRequest = this.CreateOutgoingSOLMergeRequest.bind(this);
    this.CreateOutgoingHederaStakingRequest = this.CreateOutgoingHederaStakingRequest.bind(this);
    this.CreateOutgoingHederaUnstakingRequest = this.CreateOutgoingHederaUnstakingRequest.bind(this);
    this.CreateOutgoingUTXOsRequest = this.CreateOutgoingUTXOsRequest.bind(this);
    this.CreateOutgoingCancelRequest = this.CreateOutgoingCancelRequest.bind(this);
    this.CreateOutgoingDeployContractRequest = this.CreateOutgoingDeployContractRequest.bind(this);
    this.CreateOutgoingCallContractRequest = this.CreateOutgoingCallContractRequest.bind(this);
    this.CreateOutgoingCosmosGenericRequest = this.CreateOutgoingCosmosGenericRequest.bind(this);
    this.CreateOutgoingICPTransferToStakeRequest = this.CreateOutgoingICPTransferToStakeRequest.bind(this);
    this.CreateOutgoingICPSetDissolveDelayRequest = this.CreateOutgoingICPSetDissolveDelayRequest.bind(this);
    this.CreateOutgoingICPFollowRequest = this.CreateOutgoingICPFollowRequest.bind(this);
    this.CreateOutgoingICPStartDissolvingRequest = this.CreateOutgoingICPStartDissolvingRequest.bind(this);
    this.CreateIncomingRequest = this.CreateIncomingRequest.bind(this);
    this.CreateFiatProviderWithdrawalRequest = this.CreateFiatProviderWithdrawalRequest.bind(this);
    this.CreateFiatProviderDepositRequest = this.CreateFiatProviderDepositRequest.bind(this);
    this.CreateFiatProviderTransferRequest = this.CreateFiatProviderTransferRequest.bind(this);
    this.ApproveRequests = this.ApproveRequests.bind(this);
    this.GetAsyncApprovals = this.GetAsyncApprovals.bind(this);
    this.RejectRequests = this.RejectRequests.bind(this);
    this.GetRequests = this.GetRequests.bind(this);
    this.GetRequestsV2 = this.GetRequestsV2.bind(this);
    this.GetRequestsForApproval = this.GetRequestsForApproval.bind(this);
    this.GetRequestsForApprovalV2 = this.GetRequestsForApprovalV2.bind(this);
    this.GetRequestBundles = this.GetRequestBundles.bind(this);
    this.GetRequestBundlesForApproval = this.GetRequestBundlesForApproval.bind(this);
    this.CreateRequestAttributes = this.CreateRequestAttributes.bind(this);
    this.GetRequestAttribute = this.GetRequestAttribute.bind(this);
    this.StakeETH = this.StakeETH.bind(this);
    this.CreateETHUnstakeRequest = this.CreateETHUnstakeRequest.bind(this);
  }
  GetRequest(request: GetRequestRequest): Promise<GetRequestReply> {
    const data = GetRequestRequest.encode(request).finish();
    const promise = this.rpc.request(this.service, "GetRequest", data);
    return promise.then((data) => GetRequestReply.decode(_m0.Reader.create(data)));
  }

  UpdateRequestStatus(request: UpdateRequestStatusRequest): Promise<Empty> {
    const data = UpdateRequestStatusRequest.encode(request).finish();
    const promise = this.rpc.request(this.service, "UpdateRequestStatus", data);
    return promise.then((data) => Empty.decode(_m0.Reader.create(data)));
  }

  GetRequestBundle(request: GetRequestBundleRequest): Promise<GetRequestBundleReply> {
    const data = GetRequestBundleRequest.encode(request).finish();
    const promise = this.rpc.request(this.service, "GetRequestBundle", data);
    return promise.then((data) => GetRequestBundleReply.decode(_m0.Reader.create(data)));
  }

  GetAutoTransferEventHandlers(
    request: GetAutoTransferEventHandlersRequest,
  ): Promise<GetAutoTransferEventHandlersReply> {
    const data = GetAutoTransferEventHandlersRequest.encode(request).finish();
    const promise = this.rpc.request(this.service, "GetAutoTransferEventHandlers", data);
    return promise.then((data) => GetAutoTransferEventHandlersReply.decode(_m0.Reader.create(data)));
  }

  GetAutoTransferEventHandlerById(
    request: GetAutoTransferEventHandlerByIdRequest,
  ): Promise<GetAutoTransferEventHandlerByIdReply> {
    const data = GetAutoTransferEventHandlerByIdRequest.encode(request).finish();
    const promise = this.rpc.request(this.service, "GetAutoTransferEventHandlerById", data);
    return promise.then((data) => GetAutoTransferEventHandlerByIdReply.decode(_m0.Reader.create(data)));
  }

  TriggerAutoTransferEventHandler(request: TriggerAutoTransferEventHandlerRequest): Promise<Empty> {
    const data = TriggerAutoTransferEventHandlerRequest.encode(request).finish();
    const promise = this.rpc.request(this.service, "TriggerAutoTransferEventHandler", data);
    return promise.then((data) => Empty.decode(_m0.Reader.create(data)));
  }

  CreateOutgoingRequest(request: CreateOutgoingRequestRequest): Promise<CreateRequestReply> {
    const data = CreateOutgoingRequestRequest.encode(request).finish();
    const promise = this.rpc.request(this.service, "CreateOutgoingRequest", data);
    return promise.then((data) => CreateRequestReply.decode(_m0.Reader.create(data)));
  }

  CreateAddressToAddressTransferOutgoingRequest(
    request: CreateAddressToAddressTransferOutgoingRequestRequest,
  ): Promise<CreateRequestReply> {
    const data = CreateAddressToAddressTransferOutgoingRequestRequest.encode(request).finish();
    const promise = this.rpc.request(this.service, "CreateAddressToAddressTransferOutgoingRequest", data);
    return promise.then((data) => CreateRequestReply.decode(_m0.Reader.create(data)));
  }

  CreateOutgoingAddressToAddressRequestBundle(
    request: CreateOutgoingAddressToAddressRequestBundleRequest,
  ): Promise<CreateRequestBundleReply> {
    const data = CreateOutgoingAddressToAddressRequestBundleRequest.encode(request).finish();
    const promise = this.rpc.request(this.service, "CreateOutgoingAddressToAddressRequestBundle", data);
    return promise.then((data) => CreateRequestBundleReply.decode(_m0.Reader.create(data)));
  }

  CreateOutgoingRequestBundle(request: CreateOutgoingRequestBundleRequest): Promise<CreateRequestBundleReply> {
    const data = CreateOutgoingRequestBundleRequest.encode(request).finish();
    const promise = this.rpc.request(this.service, "CreateOutgoingRequestBundle", data);
    return promise.then((data) => CreateRequestBundleReply.decode(_m0.Reader.create(data)));
  }

  CreateOutgoingALGOASAOptInRequest(request: CreateOutgoingALGOASAOptInRequestRequest): Promise<CreateRequestReply> {
    const data = CreateOutgoingALGOASAOptInRequestRequest.encode(request).finish();
    const promise = this.rpc.request(this.service, "CreateOutgoingALGOASAOptInRequest", data);
    return promise.then((data) => CreateRequestReply.decode(_m0.Reader.create(data)));
  }

  CreateOutgoingXLMMintAssetRequest(request: CreateOutgoingXLMMintAssetRequestRequest): Promise<CreateRequestReply> {
    const data = CreateOutgoingXLMMintAssetRequestRequest.encode(request).finish();
    const promise = this.rpc.request(this.service, "CreateOutgoingXLMMintAssetRequest", data);
    return promise.then((data) => CreateRequestReply.decode(_m0.Reader.create(data)));
  }

  CreateOutgoingXLMChangeTrustRequest(
    request: CreateOutgoingXLMChangeTrustRequestRequest,
  ): Promise<CreateRequestReply> {
    const data = CreateOutgoingXLMChangeTrustRequestRequest.encode(request).finish();
    const promise = this.rpc.request(this.service, "CreateOutgoingXLMChangeTrustRequest", data);
    return promise.then((data) => CreateRequestReply.decode(_m0.Reader.create(data)));
  }

  CreateOutgoingXLMManageDataRequest(request: CreateOutgoingXLMManageDataRequestRequest): Promise<CreateRequestReply> {
    const data = CreateOutgoingXLMManageDataRequestRequest.encode(request).finish();
    const promise = this.rpc.request(this.service, "CreateOutgoingXLMManageDataRequest", data);
    return promise.then((data) => CreateRequestReply.decode(_m0.Reader.create(data)));
  }

  CreateOutgoingXLMSetTrustlineFlagsRequest(
    request: CreateOutgoingXLMSetTrustlineFlagsRequestRequest,
  ): Promise<CreateRequestReply> {
    const data = CreateOutgoingXLMSetTrustlineFlagsRequestRequest.encode(request).finish();
    const promise = this.rpc.request(this.service, "CreateOutgoingXLMSetTrustlineFlagsRequest", data);
    return promise.then((data) => CreateRequestReply.decode(_m0.Reader.create(data)));
  }

  CreateOutgoingXLMSetOptionsRequest(request: CreateOutgoingXLMSetOptionsRequestRequest): Promise<CreateRequestReply> {
    const data = CreateOutgoingXLMSetOptionsRequestRequest.encode(request).finish();
    const promise = this.rpc.request(this.service, "CreateOutgoingXLMSetOptionsRequest", data);
    return promise.then((data) => CreateRequestReply.decode(_m0.Reader.create(data)));
  }

  CreateOutgoingXLMCreateClaimableBalanceRequest(
    request: CreateOutgoingXLMCreateClaimableBalanceRequestRequest,
  ): Promise<CreateRequestReply> {
    const data = CreateOutgoingXLMCreateClaimableBalanceRequestRequest.encode(request).finish();
    const promise = this.rpc.request(this.service, "CreateOutgoingXLMCreateClaimableBalanceRequest", data);
    return promise.then((data) => CreateRequestReply.decode(_m0.Reader.create(data)));
  }

  CreateOutgoingXLMClaimClaimableBalanceRequest(
    request: CreateOutgoingXLMClaimClaimableBalanceRequestRequest,
  ): Promise<CreateRequestReply> {
    const data = CreateOutgoingXLMClaimClaimableBalanceRequestRequest.encode(request).finish();
    const promise = this.rpc.request(this.service, "CreateOutgoingXLMClaimClaimableBalanceRequest", data);
    return promise.then((data) => CreateRequestReply.decode(_m0.Reader.create(data)));
  }

  CreateOutgoingXLMClawbackClaimableBalanceRequest(
    request: CreateOutgoingXLMClawbackClaimableBalanceRequestRequest,
  ): Promise<CreateRequestReply> {
    const data = CreateOutgoingXLMClawbackClaimableBalanceRequestRequest.encode(request).finish();
    const promise = this.rpc.request(this.service, "CreateOutgoingXLMClawbackClaimableBalanceRequest", data);
    return promise.then((data) => CreateRequestReply.decode(_m0.Reader.create(data)));
  }

  CreateOutgoingXLMRevokeSponsorshipRequest(
    request: CreateOutgoingXLMRevokeSponsorshipRequestRequest,
  ): Promise<CreateRequestReply> {
    const data = CreateOutgoingXLMRevokeSponsorshipRequestRequest.encode(request).finish();
    const promise = this.rpc.request(this.service, "CreateOutgoingXLMRevokeSponsorshipRequest", data);
    return promise.then((data) => CreateRequestReply.decode(_m0.Reader.create(data)));
  }

  CreateOutgoingXLMClawbackRequest(request: CreateOutgoingXLMClawbackRequestRequest): Promise<CreateRequestReply> {
    const data = CreateOutgoingXLMClawbackRequestRequest.encode(request).finish();
    const promise = this.rpc.request(this.service, "CreateOutgoingXLMClawbackRequest", data);
    return promise.then((data) => CreateRequestReply.decode(_m0.Reader.create(data)));
  }

  CreateOutgoingXLMLiquidityPoolDepositRequest(
    request: CreateOutgoingXLMLiquidityPoolDepositRequestRequest,
  ): Promise<CreateRequestReply> {
    const data = CreateOutgoingXLMLiquidityPoolDepositRequestRequest.encode(request).finish();
    const promise = this.rpc.request(this.service, "CreateOutgoingXLMLiquidityPoolDepositRequest", data);
    return promise.then((data) => CreateRequestReply.decode(_m0.Reader.create(data)));
  }

  CreateOutgoingXLMLiquidityPoolWithdrawRequest(
    request: CreateOutgoingXLMLiquidityPoolWithdrawRequestRequest,
  ): Promise<CreateRequestReply> {
    const data = CreateOutgoingXLMLiquidityPoolWithdrawRequestRequest.encode(request).finish();
    const promise = this.rpc.request(this.service, "CreateOutgoingXLMLiquidityPoolWithdrawRequest", data);
    return promise.then((data) => CreateRequestReply.decode(_m0.Reader.create(data)));
  }

  CreateOutgoingXLMPathPaymentStrictSendRequest(
    request: CreateOutgoingXLMPathPaymentStrictSendRequestRequest,
  ): Promise<CreateRequestReply> {
    const data = CreateOutgoingXLMPathPaymentStrictSendRequestRequest.encode(request).finish();
    const promise = this.rpc.request(this.service, "CreateOutgoingXLMPathPaymentStrictSendRequest", data);
    return promise.then((data) => CreateRequestReply.decode(_m0.Reader.create(data)));
  }

  CreateOutgoingXLMPathPaymentStrictReceiveRequest(
    request: CreateOutgoingXLMPathPaymentStrictReceiveRequestRequest,
  ): Promise<CreateRequestReply> {
    const data = CreateOutgoingXLMPathPaymentStrictReceiveRequestRequest.encode(request).finish();
    const promise = this.rpc.request(this.service, "CreateOutgoingXLMPathPaymentStrictReceiveRequest", data);
    return promise.then((data) => CreateRequestReply.decode(_m0.Reader.create(data)));
  }

  CreateOutgoingXLMBuyOfferRequest(request: CreateOutgoingXLMBuyOfferRequestRequest): Promise<CreateRequestReply> {
    const data = CreateOutgoingXLMBuyOfferRequestRequest.encode(request).finish();
    const promise = this.rpc.request(this.service, "CreateOutgoingXLMBuyOfferRequest", data);
    return promise.then((data) => CreateRequestReply.decode(_m0.Reader.create(data)));
  }

  CreateOutgoingXLMSellOfferRequest(request: CreateOutgoingXLMSellOfferRequestRequest): Promise<CreateRequestReply> {
    const data = CreateOutgoingXLMSellOfferRequestRequest.encode(request).finish();
    const promise = this.rpc.request(this.service, "CreateOutgoingXLMSellOfferRequest", data);
    return promise.then((data) => CreateRequestReply.decode(_m0.Reader.create(data)));
  }

  CreateOutgoingXTZDelegateRequest(request: CreateOutgoingXTZDelegateRequestRequest): Promise<CreateRequestReply> {
    const data = CreateOutgoingXTZDelegateRequestRequest.encode(request).finish();
    const promise = this.rpc.request(this.service, "CreateOutgoingXTZDelegateRequest", data);
    return promise.then((data) => CreateRequestReply.decode(_m0.Reader.create(data)));
  }

  CreateOutgoingXTZUndelegateRequest(request: CreateOutgoingXTZUndelegateRequestRequest): Promise<CreateRequestReply> {
    const data = CreateOutgoingXTZUndelegateRequestRequest.encode(request).finish();
    const promise = this.rpc.request(this.service, "CreateOutgoingXTZUndelegateRequest", data);
    return promise.then((data) => CreateRequestReply.decode(_m0.Reader.create(data)));
  }

  CreateOutgoingXTZStakeRequest(request: CreateOutgoingXTZStakeRequestRequest): Promise<CreateRequestReply> {
    const data = CreateOutgoingXTZStakeRequestRequest.encode(request).finish();
    const promise = this.rpc.request(this.service, "CreateOutgoingXTZStakeRequest", data);
    return promise.then((data) => CreateRequestReply.decode(_m0.Reader.create(data)));
  }

  CreateOutgoingXTZUnstakeRequest(request: CreateOutgoingXTZUnstakeRequestRequest): Promise<CreateRequestReply> {
    const data = CreateOutgoingXTZUnstakeRequestRequest.encode(request).finish();
    const promise = this.rpc.request(this.service, "CreateOutgoingXTZUnstakeRequest", data);
    return promise.then((data) => CreateRequestReply.decode(_m0.Reader.create(data)));
  }

  CreateOutgoingADADelegateRequest(request: CreateOutgoingADADelegateRequestRequest): Promise<CreateRequestReply> {
    const data = CreateOutgoingADADelegateRequestRequest.encode(request).finish();
    const promise = this.rpc.request(this.service, "CreateOutgoingADADelegateRequest", data);
    return promise.then((data) => CreateRequestReply.decode(_m0.Reader.create(data)));
  }

  CreateOutgoingADAUndelegateRequest(request: CreateOutgoingADAUndelegateRequestRequest): Promise<CreateRequestReply> {
    const data = CreateOutgoingADAUndelegateRequestRequest.encode(request).finish();
    const promise = this.rpc.request(this.service, "CreateOutgoingADAUndelegateRequest", data);
    return promise.then((data) => CreateRequestReply.decode(_m0.Reader.create(data)));
  }

  CreateOutgoingADAVoteDelegateRequest(
    request: CreateOutgoingADAVoteDelegateRequestRequest,
  ): Promise<CreateRequestReply> {
    const data = CreateOutgoingADAVoteDelegateRequestRequest.encode(request).finish();
    const promise = this.rpc.request(this.service, "CreateOutgoingADAVoteDelegateRequest", data);
    return promise.then((data) => CreateRequestReply.decode(_m0.Reader.create(data)));
  }

  CreateOutgoingADAWithdrawalRequest(request: CreateOutgoingADAWithdrawalRequestRequest): Promise<CreateRequestReply> {
    const data = CreateOutgoingADAWithdrawalRequestRequest.encode(request).finish();
    const promise = this.rpc.request(this.service, "CreateOutgoingADAWithdrawalRequest", data);
    return promise.then((data) => CreateRequestReply.decode(_m0.Reader.create(data)));
  }

  CreateOutgoingCosmosDelegateRequest(
    request: CreateOutgoingCosmosDelegateRequestRequest,
  ): Promise<CreateRequestReply> {
    const data = CreateOutgoingCosmosDelegateRequestRequest.encode(request).finish();
    const promise = this.rpc.request(this.service, "CreateOutgoingCosmosDelegateRequest", data);
    return promise.then((data) => CreateRequestReply.decode(_m0.Reader.create(data)));
  }

  CreateOutgoingCosmosUndelegateRequest(
    request: CreateOutgoingCosmosUndelegateRequestRequest,
  ): Promise<CreateRequestReply> {
    const data = CreateOutgoingCosmosUndelegateRequestRequest.encode(request).finish();
    const promise = this.rpc.request(this.service, "CreateOutgoingCosmosUndelegateRequest", data);
    return promise.then((data) => CreateRequestReply.decode(_m0.Reader.create(data)));
  }

  CreateOutgoingCosmosWithdrawRewardRequest(
    request: CreateOutgoingCosmosWithdrawRewardRequestRequest,
  ): Promise<CreateRequestReply> {
    const data = CreateOutgoingCosmosWithdrawRewardRequestRequest.encode(request).finish();
    const promise = this.rpc.request(this.service, "CreateOutgoingCosmosWithdrawRewardRequest", data);
    return promise.then((data) => CreateRequestReply.decode(_m0.Reader.create(data)));
  }

  CreateOutgoingFTMDelegateRequest(request: CreateOutgoingFTMDelegateRequestRequest): Promise<CreateRequestReply> {
    const data = CreateOutgoingFTMDelegateRequestRequest.encode(request).finish();
    const promise = this.rpc.request(this.service, "CreateOutgoingFTMDelegateRequest", data);
    return promise.then((data) => CreateRequestReply.decode(_m0.Reader.create(data)));
  }

  CreateOutgoingFTMUndelegateRequest(request: CreateOutgoingFTMUndelegateRequestRequest): Promise<CreateRequestReply> {
    const data = CreateOutgoingFTMUndelegateRequestRequest.encode(request).finish();
    const promise = this.rpc.request(this.service, "CreateOutgoingFTMUndelegateRequest", data);
    return promise.then((data) => CreateRequestReply.decode(_m0.Reader.create(data)));
  }

  CreateOutgoingFTMWithdrawalRequest(request: CreateOutgoingFTMWithdrawalRequestRequest): Promise<CreateRequestReply> {
    const data = CreateOutgoingFTMWithdrawalRequestRequest.encode(request).finish();
    const promise = this.rpc.request(this.service, "CreateOutgoingFTMWithdrawalRequest", data);
    return promise.then((data) => CreateRequestReply.decode(_m0.Reader.create(data)));
  }

  CreateOutgoingFTMClaimRewardsRequest(
    request: CreateOutgoingFTMClaimRewardsRequestRequest,
  ): Promise<CreateRequestReply> {
    const data = CreateOutgoingFTMClaimRewardsRequestRequest.encode(request).finish();
    const promise = this.rpc.request(this.service, "CreateOutgoingFTMClaimRewardsRequest", data);
    return promise.then((data) => CreateRequestReply.decode(_m0.Reader.create(data)));
  }

  CreateOutgoingDOTNominateRequest(request: CreateOutgoingDOTNominateRequestRequest): Promise<CreateRequestReply> {
    const data = CreateOutgoingDOTNominateRequestRequest.encode(request).finish();
    const promise = this.rpc.request(this.service, "CreateOutgoingDOTNominateRequest", data);
    return promise.then((data) => CreateRequestReply.decode(_m0.Reader.create(data)));
  }

  CreateOutgoingDOTBondRequest(request: CreateOutgoingDOTBondRequestRequest): Promise<CreateRequestReply> {
    const data = CreateOutgoingDOTBondRequestRequest.encode(request).finish();
    const promise = this.rpc.request(this.service, "CreateOutgoingDOTBondRequest", data);
    return promise.then((data) => CreateRequestReply.decode(_m0.Reader.create(data)));
  }

  CreateOutgoingDOTBondExtraRequest(request: CreateOutgoingDOTBondExtraRequestRequest): Promise<CreateRequestReply> {
    const data = CreateOutgoingDOTBondExtraRequestRequest.encode(request).finish();
    const promise = this.rpc.request(this.service, "CreateOutgoingDOTBondExtraRequest", data);
    return promise.then((data) => CreateRequestReply.decode(_m0.Reader.create(data)));
  }

  CreateOutgoingDOTChillRequest(request: CreateOutgoingDOTChillRequestRequest): Promise<CreateRequestReply> {
    const data = CreateOutgoingDOTChillRequestRequest.encode(request).finish();
    const promise = this.rpc.request(this.service, "CreateOutgoingDOTChillRequest", data);
    return promise.then((data) => CreateRequestReply.decode(_m0.Reader.create(data)));
  }

  CreateOutgoingDOTUnbondRequest(request: CreateOutgoingDOTUnbondRequestRequest): Promise<CreateRequestReply> {
    const data = CreateOutgoingDOTUnbondRequestRequest.encode(request).finish();
    const promise = this.rpc.request(this.service, "CreateOutgoingDOTUnbondRequest", data);
    return promise.then((data) => CreateRequestReply.decode(_m0.Reader.create(data)));
  }

  CreateOutgoingMinaDelegationRequest(
    request: CreateOutgoingMinaDelegationRequestRequest,
  ): Promise<CreateRequestReply> {
    const data = CreateOutgoingMinaDelegationRequestRequest.encode(request).finish();
    const promise = this.rpc.request(this.service, "CreateOutgoingMinaDelegationRequest", data);
    return promise.then((data) => CreateRequestReply.decode(_m0.Reader.create(data)));
  }

  CreateOutgoingMinaUndelegationRequest(
    request: CreateOutgoingMinaUndelegationRequestRequest,
  ): Promise<CreateRequestReply> {
    const data = CreateOutgoingMinaUndelegationRequestRequest.encode(request).finish();
    const promise = this.rpc.request(this.service, "CreateOutgoingMinaUndelegationRequest", data);
    return promise.then((data) => CreateRequestReply.decode(_m0.Reader.create(data)));
  }

  CreateOutgoingNEARDepositAndStakeRequest(
    request: CreateOutgoingNEARDepositAndStakeRequestRequest,
  ): Promise<CreateRequestReply> {
    const data = CreateOutgoingNEARDepositAndStakeRequestRequest.encode(request).finish();
    const promise = this.rpc.request(this.service, "CreateOutgoingNEARDepositAndStakeRequest", data);
    return promise.then((data) => CreateRequestReply.decode(_m0.Reader.create(data)));
  }

  CreateOutgoingNEARUnstakeRequest(request: CreateOutgoingNEARUnstakeRequestRequest): Promise<CreateRequestReply> {
    const data = CreateOutgoingNEARUnstakeRequestRequest.encode(request).finish();
    const promise = this.rpc.request(this.service, "CreateOutgoingNEARUnstakeRequest", data);
    return promise.then((data) => CreateRequestReply.decode(_m0.Reader.create(data)));
  }

  CreateOutgoingNEARWithdrawRequest(request: CreateOutgoingNEARWithdrawRequestRequest): Promise<CreateRequestReply> {
    const data = CreateOutgoingNEARWithdrawRequestRequest.encode(request).finish();
    const promise = this.rpc.request(this.service, "CreateOutgoingNEARWithdrawRequest", data);
    return promise.then((data) => CreateRequestReply.decode(_m0.Reader.create(data)));
  }

  CreateOutgoingDOTWithdrawUnbondedRequest(
    request: CreateOutgoingDOTWithdrawUnbondedRequestRequest,
  ): Promise<CreateRequestReply> {
    const data = CreateOutgoingDOTWithdrawUnbondedRequestRequest.encode(request).finish();
    const promise = this.rpc.request(this.service, "CreateOutgoingDOTWithdrawUnbondedRequest", data);
    return promise.then((data) => CreateRequestReply.decode(_m0.Reader.create(data)));
  }

  CreateOutgoingSOLTokenMintRequest(request: CreateOutgoingSOLTokenMintRequestRequest): Promise<CreateRequestReply> {
    const data = CreateOutgoingSOLTokenMintRequestRequest.encode(request).finish();
    const promise = this.rpc.request(this.service, "CreateOutgoingSOLTokenMintRequest", data);
    return promise.then((data) => CreateRequestReply.decode(_m0.Reader.create(data)));
  }

  CreateOutgoingSOLTokenBurnRequest(request: CreateOutgoingSOLTokenBurnRequestRequest): Promise<CreateRequestReply> {
    const data = CreateOutgoingSOLTokenBurnRequestRequest.encode(request).finish();
    const promise = this.rpc.request(this.service, "CreateOutgoingSOLTokenBurnRequest", data);
    return promise.then((data) => CreateRequestReply.decode(_m0.Reader.create(data)));
  }

  CreateOutgoingSOLCreateTokenRequest(
    request: CreateOutgoingSOLCreateTokenRequestRequest,
  ): Promise<CreateRequestReply> {
    const data = CreateOutgoingSOLCreateTokenRequestRequest.encode(request).finish();
    const promise = this.rpc.request(this.service, "CreateOutgoingSOLCreateTokenRequest", data);
    return promise.then((data) => CreateRequestReply.decode(_m0.Reader.create(data)));
  }

  CreateOutgoingSOLDelegateRequest(request: CreateOutgoingSOLDelegateRequestRequest): Promise<CreateRequestReply> {
    const data = CreateOutgoingSOLDelegateRequestRequest.encode(request).finish();
    const promise = this.rpc.request(this.service, "CreateOutgoingSOLDelegateRequest", data);
    return promise.then((data) => CreateRequestReply.decode(_m0.Reader.create(data)));
  }

  CreateOutgoingSOLDeactivateRequest(request: CreateOutgoingSOLDeactivateRequestRequest): Promise<CreateRequestReply> {
    const data = CreateOutgoingSOLDeactivateRequestRequest.encode(request).finish();
    const promise = this.rpc.request(this.service, "CreateOutgoingSOLDeactivateRequest", data);
    return promise.then((data) => CreateRequestReply.decode(_m0.Reader.create(data)));
  }

  CreateOutgoingSOLWithdrawRequest(request: CreateOutgoingSOLWithdrawRequestRequest): Promise<CreateRequestReply> {
    const data = CreateOutgoingSOLWithdrawRequestRequest.encode(request).finish();
    const promise = this.rpc.request(this.service, "CreateOutgoingSOLWithdrawRequest", data);
    return promise.then((data) => CreateRequestReply.decode(_m0.Reader.create(data)));
  }

  CreateOutgoingSOLMergeRequest(request: CreateOutgoingSOLMergeRequestRequest): Promise<CreateRequestReply> {
    const data = CreateOutgoingSOLMergeRequestRequest.encode(request).finish();
    const promise = this.rpc.request(this.service, "CreateOutgoingSOLMergeRequest", data);
    return promise.then((data) => CreateRequestReply.decode(_m0.Reader.create(data)));
  }

  CreateOutgoingHederaStakingRequest(request: CreateOutgoingHederaStakingRequestRequest): Promise<CreateRequestReply> {
    const data = CreateOutgoingHederaStakingRequestRequest.encode(request).finish();
    const promise = this.rpc.request(this.service, "CreateOutgoingHederaStakingRequest", data);
    return promise.then((data) => CreateRequestReply.decode(_m0.Reader.create(data)));
  }

  CreateOutgoingHederaUnstakingRequest(
    request: CreateOutgoingHederaUnstakingRequestRequest,
  ): Promise<CreateRequestReply> {
    const data = CreateOutgoingHederaUnstakingRequestRequest.encode(request).finish();
    const promise = this.rpc.request(this.service, "CreateOutgoingHederaUnstakingRequest", data);
    return promise.then((data) => CreateRequestReply.decode(_m0.Reader.create(data)));
  }

  CreateOutgoingUTXOsRequest(request: CreateOutgoingUTXOsRequestRequest): Promise<CreateRequestReply> {
    const data = CreateOutgoingUTXOsRequestRequest.encode(request).finish();
    const promise = this.rpc.request(this.service, "CreateOutgoingUTXOsRequest", data);
    return promise.then((data) => CreateRequestReply.decode(_m0.Reader.create(data)));
  }

  CreateOutgoingCancelRequest(request: CreateOutgoingCancelRequestRequest): Promise<CreateRequestReply> {
    const data = CreateOutgoingCancelRequestRequest.encode(request).finish();
    const promise = this.rpc.request(this.service, "CreateOutgoingCancelRequest", data);
    return promise.then((data) => CreateRequestReply.decode(_m0.Reader.create(data)));
  }

  CreateOutgoingDeployContractRequest(
    request: CreateOutgoingDeployContractRequestRequest,
  ): Promise<CreateRequestReply> {
    const data = CreateOutgoingDeployContractRequestRequest.encode(request).finish();
    const promise = this.rpc.request(this.service, "CreateOutgoingDeployContractRequest", data);
    return promise.then((data) => CreateRequestReply.decode(_m0.Reader.create(data)));
  }

  CreateOutgoingCallContractRequest(request: CreateOutgoingCallContractRequestRequest): Promise<CreateRequestReply> {
    const data = CreateOutgoingCallContractRequestRequest.encode(request).finish();
    const promise = this.rpc.request(this.service, "CreateOutgoingCallContractRequest", data);
    return promise.then((data) => CreateRequestReply.decode(_m0.Reader.create(data)));
  }

  CreateOutgoingCosmosGenericRequest(request: CreateOutgoingCosmosGenericRequestRequest): Promise<CreateRequestReply> {
    const data = CreateOutgoingCosmosGenericRequestRequest.encode(request).finish();
    const promise = this.rpc.request(this.service, "CreateOutgoingCosmosGenericRequest", data);
    return promise.then((data) => CreateRequestReply.decode(_m0.Reader.create(data)));
  }

  CreateOutgoingICPTransferToStakeRequest(
    request: CreateOutgoingICPTransferToStakeRequestRequest,
  ): Promise<CreateRequestReply> {
    const data = CreateOutgoingICPTransferToStakeRequestRequest.encode(request).finish();
    const promise = this.rpc.request(this.service, "CreateOutgoingICPTransferToStakeRequest", data);
    return promise.then((data) => CreateRequestReply.decode(_m0.Reader.create(data)));
  }

  CreateOutgoingICPSetDissolveDelayRequest(
    request: CreateOutgoingICPSetDissolveDelayRequestRequest,
  ): Promise<CreateRequestReply> {
    const data = CreateOutgoingICPSetDissolveDelayRequestRequest.encode(request).finish();
    const promise = this.rpc.request(this.service, "CreateOutgoingICPSetDissolveDelayRequest", data);
    return promise.then((data) => CreateRequestReply.decode(_m0.Reader.create(data)));
  }

  CreateOutgoingICPFollowRequest(request: CreateOutgoingICPFollowRequestRequest): Promise<CreateRequestReply> {
    const data = CreateOutgoingICPFollowRequestRequest.encode(request).finish();
    const promise = this.rpc.request(this.service, "CreateOutgoingICPFollowRequest", data);
    return promise.then((data) => CreateRequestReply.decode(_m0.Reader.create(data)));
  }

  CreateOutgoingICPStartDissolvingRequest(
    request: CreateOutgoingICPStartDissolvingRequestRequest,
  ): Promise<CreateRequestReply> {
    const data = CreateOutgoingICPStartDissolvingRequestRequest.encode(request).finish();
    const promise = this.rpc.request(this.service, "CreateOutgoingICPStartDissolvingRequest", data);
    return promise.then((data) => CreateRequestReply.decode(_m0.Reader.create(data)));
  }

  CreateIncomingRequest(request: CreateIncomingRequestRequest): Promise<CreateRequestReply> {
    const data = CreateIncomingRequestRequest.encode(request).finish();
    const promise = this.rpc.request(this.service, "CreateIncomingRequest", data);
    return promise.then((data) => CreateRequestReply.decode(_m0.Reader.create(data)));
  }

  CreateFiatProviderWithdrawalRequest(
    request: CreateFiatProviderWithdrawalRequestRequest,
  ): Promise<CreateRequestReply> {
    const data = CreateFiatProviderWithdrawalRequestRequest.encode(request).finish();
    const promise = this.rpc.request(this.service, "CreateFiatProviderWithdrawalRequest", data);
    return promise.then((data) => CreateRequestReply.decode(_m0.Reader.create(data)));
  }

  CreateFiatProviderDepositRequest(request: CreateFiatProviderDepositRequestRequest): Promise<CreateRequestReply> {
    const data = CreateFiatProviderDepositRequestRequest.encode(request).finish();
    const promise = this.rpc.request(this.service, "CreateFiatProviderDepositRequest", data);
    return promise.then((data) => CreateRequestReply.decode(_m0.Reader.create(data)));
  }

  CreateFiatProviderTransferRequest(request: CreateFiatProviderTransferRequestRequest): Promise<CreateRequestReply> {
    const data = CreateFiatProviderTransferRequestRequest.encode(request).finish();
    const promise = this.rpc.request(this.service, "CreateFiatProviderTransferRequest", data);
    return promise.then((data) => CreateRequestReply.decode(_m0.Reader.create(data)));
  }

  ApproveRequests(request: ApproveRequestsRequest): Promise<ApproveRequestsReply> {
    const data = ApproveRequestsRequest.encode(request).finish();
    const promise = this.rpc.request(this.service, "ApproveRequests", data);
    return promise.then((data) => ApproveRequestsReply.decode(_m0.Reader.create(data)));
  }

  GetAsyncApprovals(request: GetAsyncApprovalsRequest): Promise<GetAsyncApprovalsReply> {
    const data = GetAsyncApprovalsRequest.encode(request).finish();
    const promise = this.rpc.request(this.service, "GetAsyncApprovals", data);
    return promise.then((data) => GetAsyncApprovalsReply.decode(_m0.Reader.create(data)));
  }

  RejectRequests(request: RejectRequestsRequest): Promise<Empty> {
    const data = RejectRequestsRequest.encode(request).finish();
    const promise = this.rpc.request(this.service, "RejectRequests", data);
    return promise.then((data) => Empty.decode(_m0.Reader.create(data)));
  }

  GetRequests(request: GetRequestsRequest): Promise<GetRequestsReply> {
    const data = GetRequestsRequest.encode(request).finish();
    const promise = this.rpc.request(this.service, "GetRequests", data);
    return promise.then((data) => GetRequestsReply.decode(_m0.Reader.create(data)));
  }

  GetRequestsV2(request: GetRequestsV2Request): Promise<GetRequestsV2Reply> {
    const data = GetRequestsV2Request.encode(request).finish();
    const promise = this.rpc.request(this.service, "GetRequestsV2", data);
    return promise.then((data) => GetRequestsV2Reply.decode(_m0.Reader.create(data)));
  }

  GetRequestsForApproval(request: GetRequestsForApprovalRequest): Promise<GetRequestsReply> {
    const data = GetRequestsForApprovalRequest.encode(request).finish();
    const promise = this.rpc.request(this.service, "GetRequestsForApproval", data);
    return promise.then((data) => GetRequestsReply.decode(_m0.Reader.create(data)));
  }

  GetRequestsForApprovalV2(request: GetRequestsForApprovalV2Request): Promise<GetRequestsV2Reply> {
    const data = GetRequestsForApprovalV2Request.encode(request).finish();
    const promise = this.rpc.request(this.service, "GetRequestsForApprovalV2", data);
    return promise.then((data) => GetRequestsV2Reply.decode(_m0.Reader.create(data)));
  }

  GetRequestBundles(request: GetRequestBundlesRequest): Promise<GetRequestBundlesReply> {
    const data = GetRequestBundlesRequest.encode(request).finish();
    const promise = this.rpc.request(this.service, "GetRequestBundles", data);
    return promise.then((data) => GetRequestBundlesReply.decode(_m0.Reader.create(data)));
  }

  GetRequestBundlesForApproval(request: GetRequestBundlesForApprovalRequest): Promise<GetRequestBundlesReply> {
    const data = GetRequestBundlesForApprovalRequest.encode(request).finish();
    const promise = this.rpc.request(this.service, "GetRequestBundlesForApproval", data);
    return promise.then((data) => GetRequestBundlesReply.decode(_m0.Reader.create(data)));
  }

  CreateRequestAttributes(request: CreateRequestAttributesRequest): Promise<Empty> {
    const data = CreateRequestAttributesRequest.encode(request).finish();
    const promise = this.rpc.request(this.service, "CreateRequestAttributes", data);
    return promise.then((data) => Empty.decode(_m0.Reader.create(data)));
  }

  GetRequestAttribute(request: GetRequestAttributeRequest): Promise<GetRequestAttributeReply> {
    const data = GetRequestAttributeRequest.encode(request).finish();
    const promise = this.rpc.request(this.service, "GetRequestAttribute", data);
    return promise.then((data) => GetRequestAttributeReply.decode(_m0.Reader.create(data)));
  }

  StakeETH(request: StakeETHRequest): Promise<CreateRequestReply> {
    const data = StakeETHRequest.encode(request).finish();
    const promise = this.rpc.request(this.service, "StakeETH", data);
    return promise.then((data) => CreateRequestReply.decode(_m0.Reader.create(data)));
  }

  CreateETHUnstakeRequest(request: CreateETHUnstakeRequestRequest): Promise<CreateRequestReply> {
    const data = CreateETHUnstakeRequestRequest.encode(request).finish();
    const promise = this.rpc.request(this.service, "CreateETHUnstakeRequest", data);
    return promise.then((data) => CreateRequestReply.decode(_m0.Reader.create(data)));
  }
}

interface Rpc {
  request(service: string, method: string, data: Uint8Array): Promise<Uint8Array>;
}

function bytesFromBase64(b64: string): Uint8Array {
  const bin = globalThis.atob(b64);
  const arr = new Uint8Array(bin.length);
  for (let i = 0; i < bin.length; ++i) {
    arr[i] = bin.charCodeAt(i);
  }
  return arr;
}

function base64FromBytes(arr: Uint8Array): string {
  const bin: string[] = [];
  arr.forEach((byte) => {
    bin.push(globalThis.String.fromCharCode(byte));
  });
  return globalThis.btoa(bin.join(""));
}

type Builtin = Date | Function | Uint8Array | string | number | boolean | undefined;

export type DeepPartial<T> = T extends Builtin ? T
  : T extends globalThis.Array<infer U> ? globalThis.Array<DeepPartial<U>>
  : T extends ReadonlyArray<infer U> ? ReadonlyArray<DeepPartial<U>>
  : T extends {} ? { [K in keyof T]?: DeepPartial<T[K]> }
  : Partial<T>;

function toTimestamp(date: Date): Timestamp {
  const seconds = Math.trunc(date.getTime() / 1_000);
  const nanos = (date.getTime() % 1_000) * 1_000_000;
  return { seconds, nanos };
}

function fromTimestamp(t: Timestamp): Date {
  let millis = (t.seconds || 0) * 1_000;
  millis += (t.nanos || 0) / 1_000_000;
  return new globalThis.Date(millis);
}

function fromJsonTimestamp(o: any): Date {
  if (o instanceof globalThis.Date) {
    return o;
  } else if (typeof o === "string") {
    return new globalThis.Date(o);
  } else {
    return fromTimestamp(Timestamp.fromJSON(o));
  }
}

function longToNumber(long: Long): number {
  if (long.gt(globalThis.Number.MAX_SAFE_INTEGER)) {
    throw new globalThis.Error("Value is larger than Number.MAX_SAFE_INTEGER");
  }
  if (long.lt(globalThis.Number.MIN_SAFE_INTEGER)) {
    throw new globalThis.Error("Value is smaller than Number.MIN_SAFE_INTEGER");
  }
  return long.toNumber();
}

if (_m0.util.Long !== Long) {
  _m0.util.Long = Long as any;
  _m0.configure();
}

function isSet(value: any): boolean {
  return value !== null && value !== undefined;
}
