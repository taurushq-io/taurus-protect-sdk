/*
 * Taurus-PROTECT APIs
 * Taurus-PROTECT APIs description
 *
 * The version of the OpenAPI document: 1.0
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


package com.taurushq.sdk.protect.openapi.model;

import java.util.Objects;
import com.google.gson.TypeAdapter;
import com.google.gson.annotations.JsonAdapter;
import com.google.gson.annotations.SerializedName;
import com.google.gson.stream.JsonReader;
import com.google.gson.stream.JsonWriter;
import java.io.IOException;
import java.util.Arrays;

import com.google.gson.Gson;
import com.google.gson.GsonBuilder;
import com.google.gson.JsonArray;
import com.google.gson.JsonDeserializationContext;
import com.google.gson.JsonDeserializer;
import com.google.gson.JsonElement;
import com.google.gson.JsonObject;
import com.google.gson.JsonParseException;
import com.google.gson.TypeAdapterFactory;
import com.google.gson.reflect.TypeToken;
import com.google.gson.TypeAdapter;
import com.google.gson.stream.JsonReader;
import com.google.gson.stream.JsonWriter;
import java.io.IOException;

import java.util.HashMap;
import java.util.HashSet;
import java.util.List;
import java.util.Map;
import java.util.Set;

import com.taurushq.sdk.protect.openapi.JSON;

/**
 * TgvalidatordCurrency
 */
@javax.annotation.Generated(value = "org.openapitools.codegen.languages.JavaClientCodegen", date = "2026-01-23T15:56:06.931912+01:00[Europe/Zurich]", comments = "Generator version: 7.9.0")
public class TgvalidatordCurrency {
  public static final String SERIALIZED_NAME_NAME = "name";
  @SerializedName(SERIALIZED_NAME_NAME)
  private String name;

  public static final String SERIALIZED_NAME_SYMBOL = "symbol";
  @SerializedName(SERIALIZED_NAME_SYMBOL)
  private String symbol;

  public static final String SERIALIZED_NAME_COIN_TYPE_INDEX = "coinTypeIndex";
  @SerializedName(SERIALIZED_NAME_COIN_TYPE_INDEX)
  private String coinTypeIndex;

  public static final String SERIALIZED_NAME_BLOCKCHAIN = "blockchain";
  @SerializedName(SERIALIZED_NAME_BLOCKCHAIN)
  private String blockchain;

  public static final String SERIALIZED_NAME_IS_TOKEN = "isToken";
  @SerializedName(SERIALIZED_NAME_IS_TOKEN)
  private Boolean isToken;

  public static final String SERIALIZED_NAME_IS_E_R_C20 = "isERC20";
  @SerializedName(SERIALIZED_NAME_IS_E_R_C20)
  private Boolean isERC20;

  public static final String SERIALIZED_NAME_DECIMALS = "decimals";
  @SerializedName(SERIALIZED_NAME_DECIMALS)
  private String decimals;

  public static final String SERIALIZED_NAME_CONTRACT_ADDRESS = "contractAddress";
  @SerializedName(SERIALIZED_NAME_CONTRACT_ADDRESS)
  private String contractAddress;

  public static final String SERIALIZED_NAME_HAS_STAKING = "hasStaking";
  @SerializedName(SERIALIZED_NAME_HAS_STAKING)
  private Boolean hasStaking;

  public static final String SERIALIZED_NAME_IS_U_T_X_O_BASED = "isUTXOBased";
  @SerializedName(SERIALIZED_NAME_IS_U_T_X_O_BASED)
  private Boolean isUTXOBased;

  public static final String SERIALIZED_NAME_IS_ACCOUNT_BASED = "isAccountBased";
  @SerializedName(SERIALIZED_NAME_IS_ACCOUNT_BASED)
  private Boolean isAccountBased;

  public static final String SERIALIZED_NAME_IS_FIAT = "isFiat";
  @SerializedName(SERIALIZED_NAME_IS_FIAT)
  private Boolean isFiat;

  public static final String SERIALIZED_NAME_IS_F_A12 = "isFA12";
  @SerializedName(SERIALIZED_NAME_IS_F_A12)
  private Boolean isFA12;

  public static final String SERIALIZED_NAME_IS_F_A20 = "isFA20";
  @SerializedName(SERIALIZED_NAME_IS_F_A20)
  private Boolean isFA20;

  public static final String SERIALIZED_NAME_IS_N_F_T = "isNFT";
  @SerializedName(SERIALIZED_NAME_IS_N_F_T)
  private Boolean isNFT;

  public static final String SERIALIZED_NAME_ENABLED = "enabled";
  @SerializedName(SERIALIZED_NAME_ENABLED)
  private Boolean enabled;

  public static final String SERIALIZED_NAME_ID = "id";
  @SerializedName(SERIALIZED_NAME_ID)
  private String id;

  public static final String SERIALIZED_NAME_DISPLAY_NAME = "displayName";
  @SerializedName(SERIALIZED_NAME_DISPLAY_NAME)
  private String displayName;

  public static final String SERIALIZED_NAME_TYPE = "type";
  @SerializedName(SERIALIZED_NAME_TYPE)
  private String type;

  public static final String SERIALIZED_NAME_WLCA_ID = "wlcaId";
  @SerializedName(SERIALIZED_NAME_WLCA_ID)
  private String wlcaId;

  public static final String SERIALIZED_NAME_NETWORK = "network";
  @SerializedName(SERIALIZED_NAME_NETWORK)
  private String network;

  public static final String SERIALIZED_NAME_TOKEN_I_D = "tokenID";
  @SerializedName(SERIALIZED_NAME_TOKEN_I_D)
  private String tokenID;

  public static final String SERIALIZED_NAME_LOGO = "logo";
  @SerializedName(SERIALIZED_NAME_LOGO)
  private String logo;

  public TgvalidatordCurrency() {
  }

  public TgvalidatordCurrency name(String name) {
    this.name = name;
    return this;
  }

  /**
   * Name of the currency.
   * @return name
   */
  @javax.annotation.Nullable
  public String getName() {
    return name;
  }

  public void setName(String name) {
    this.name = name;
  }


  public TgvalidatordCurrency symbol(String symbol) {
    this.symbol = symbol;
    return this;
  }

  /**
   * Shorthand symbol for the currency.
   * @return symbol
   */
  @javax.annotation.Nullable
  public String getSymbol() {
    return symbol;
  }

  public void setSymbol(String symbol) {
    this.symbol = symbol;
  }


  public TgvalidatordCurrency coinTypeIndex(String coinTypeIndex) {
    this.coinTypeIndex = coinTypeIndex;
    return this;
  }

  /**
   * Index used to identify the coin type in BIP44. (e.g. Bitcoin is 0, Ethereum is 60).
   * @return coinTypeIndex
   */
  @javax.annotation.Nullable
  public String getCoinTypeIndex() {
    return coinTypeIndex;
  }

  public void setCoinTypeIndex(String coinTypeIndex) {
    this.coinTypeIndex = coinTypeIndex;
  }


  public TgvalidatordCurrency blockchain(String blockchain) {
    this.blockchain = blockchain;
    return this;
  }

  /**
   * The Blockchain the currency is associated with, (e.g. ETH, BTC).
   * @return blockchain
   */
  @javax.annotation.Nullable
  public String getBlockchain() {
    return blockchain;
  }

  public void setBlockchain(String blockchain) {
    this.blockchain = blockchain;
  }


  public TgvalidatordCurrency isToken(Boolean isToken) {
    this.isToken = isToken;
    return this;
  }

  /**
   * Indicates if the currency is a token (e.g., ERC-20).
   * @return isToken
   */
  @javax.annotation.Nullable
  public Boolean getIsToken() {
    return isToken;
  }

  public void setIsToken(Boolean isToken) {
    this.isToken = isToken;
  }


  public TgvalidatordCurrency isERC20(Boolean isERC20) {
    this.isERC20 = isERC20;
    return this;
  }

  /**
   * Indicates if the token is an ERC-20 token.
   * @return isERC20
   */
  @javax.annotation.Nullable
  public Boolean getIsERC20() {
    return isERC20;
  }

  public void setIsERC20(Boolean isERC20) {
    this.isERC20 = isERC20;
  }


  public TgvalidatordCurrency decimals(String decimals) {
    this.decimals = decimals;
    return this;
  }

  /**
   * Number of decimal places the currency uses (e.g. 18 for ETH).
   * @return decimals
   */
  @javax.annotation.Nullable
  public String getDecimals() {
    return decimals;
  }

  public void setDecimals(String decimals) {
    this.decimals = decimals;
  }


  public TgvalidatordCurrency contractAddress(String contractAddress) {
    this.contractAddress = contractAddress;
    return this;
  }

  /**
   * Smart contract address if currency is a smart contract (e.g. ERC-20.).
   * @return contractAddress
   */
  @javax.annotation.Nullable
  public String getContractAddress() {
    return contractAddress;
  }

  public void setContractAddress(String contractAddress) {
    this.contractAddress = contractAddress;
  }


  public TgvalidatordCurrency hasStaking(Boolean hasStaking) {
    this.hasStaking = hasStaking;
    return this;
  }

  /**
   * Indicates if the currency supports staking.
   * @return hasStaking
   */
  @javax.annotation.Nullable
  public Boolean getHasStaking() {
    return hasStaking;
  }

  public void setHasStaking(Boolean hasStaking) {
    this.hasStaking = hasStaking;
  }


  public TgvalidatordCurrency isUTXOBased(Boolean isUTXOBased) {
    this.isUTXOBased = isUTXOBased;
    return this;
  }

  /**
   * Indicates if the currency is UTXO-based (e.g. Bitcoin).
   * @return isUTXOBased
   */
  @javax.annotation.Nullable
  public Boolean getIsUTXOBased() {
    return isUTXOBased;
  }

  public void setIsUTXOBased(Boolean isUTXOBased) {
    this.isUTXOBased = isUTXOBased;
  }


  public TgvalidatordCurrency isAccountBased(Boolean isAccountBased) {
    this.isAccountBased = isAccountBased;
    return this;
  }

  /**
   * Indicates if the currency is account-based (e.g. Ethereum).
   * @return isAccountBased
   */
  @javax.annotation.Nullable
  public Boolean getIsAccountBased() {
    return isAccountBased;
  }

  public void setIsAccountBased(Boolean isAccountBased) {
    this.isAccountBased = isAccountBased;
  }


  public TgvalidatordCurrency isFiat(Boolean isFiat) {
    this.isFiat = isFiat;
    return this;
  }

  /**
   * Indicates if the currency is a fiat currency (e.g. CHF, EUR, USD).
   * @return isFiat
   */
  @javax.annotation.Nullable
  public Boolean getIsFiat() {
    return isFiat;
  }

  public void setIsFiat(Boolean isFiat) {
    this.isFiat = isFiat;
  }


  public TgvalidatordCurrency isFA12(Boolean isFA12) {
    this.isFA12 = isFA12;
    return this;
  }

  /**
   * Indicates if the currency is based on FA12 standard (used in Tezos).
   * @return isFA12
   */
  @javax.annotation.Nullable
  public Boolean getIsFA12() {
    return isFA12;
  }

  public void setIsFA12(Boolean isFA12) {
    this.isFA12 = isFA12;
  }


  public TgvalidatordCurrency isFA20(Boolean isFA20) {
    this.isFA20 = isFA20;
    return this;
  }

  /**
   * Indicates if the currency is based on FA20 standard (used in Tezos).
   * @return isFA20
   */
  @javax.annotation.Nullable
  public Boolean getIsFA20() {
    return isFA20;
  }

  public void setIsFA20(Boolean isFA20) {
    this.isFA20 = isFA20;
  }


  public TgvalidatordCurrency isNFT(Boolean isNFT) {
    this.isNFT = isNFT;
    return this;
  }

  /**
   * Indicates if the currency represents a Non-Fungible Token (NFT).
   * @return isNFT
   */
  @javax.annotation.Nullable
  public Boolean getIsNFT() {
    return isNFT;
  }

  public void setIsNFT(Boolean isNFT) {
    this.isNFT = isNFT;
  }


  public TgvalidatordCurrency enabled(Boolean enabled) {
    this.enabled = enabled;
    return this;
  }

  /**
   * Indicates if the currency is enabled in the current tenant.
   * @return enabled
   */
  @javax.annotation.Nullable
  public Boolean getEnabled() {
    return enabled;
  }

  public void setEnabled(Boolean enabled) {
    this.enabled = enabled;
  }


  public TgvalidatordCurrency id(String id) {
    this.id = id;
    return this;
  }

  /**
   * Unique identifier of the currency.
   * @return id
   */
  @javax.annotation.Nullable
  public String getId() {
    return id;
  }

  public void setId(String id) {
    this.id = id;
  }


  public TgvalidatordCurrency displayName(String displayName) {
    this.displayName = displayName;
    return this;
  }

  /**
   * Display name for the currency, (e.g. Ethereum, Bitcoin).
   * @return displayName
   */
  @javax.annotation.Nullable
  public String getDisplayName() {
    return displayName;
  }

  public void setDisplayName(String displayName) {
    this.displayName = displayName;
  }


  public TgvalidatordCurrency type(String type) {
    this.type = type;
    return this;
  }

  /**
   * Type of the currency. Can be &#x60;token&#x60;, &#x60;fiat&#x60;, &#x60;native&#x60; , or &#x60;signet&#x60;.
   * @return type
   */
  @javax.annotation.Nullable
  public String getType() {
    return type;
  }

  public void setType(String type) {
    this.type = type;
  }


  public TgvalidatordCurrency wlcaId(String wlcaId) {
    this.wlcaId = wlcaId;
    return this;
  }

  /**
   * White listed contract address id associated with the currency.
   * @return wlcaId
   */
  @javax.annotation.Nullable
  public String getWlcaId() {
    return wlcaId;
  }

  public void setWlcaId(String wlcaId) {
    this.wlcaId = wlcaId;
  }


  public TgvalidatordCurrency network(String network) {
    this.network = network;
    return this;
  }

  /**
   * Network or environment the currency is used on (e.g. &#39;mainnet&#39;, &#39;testnet&#39;).
   * @return network
   */
  @javax.annotation.Nullable
  public String getNetwork() {
    return network;
  }

  public void setNetwork(String network) {
    this.network = network;
  }


  public TgvalidatordCurrency tokenID(String tokenID) {
    this.tokenID = tokenID;
    return this;
  }

  /**
   * Unique id for the token, if applicable (e.g. for NFTs).
   * @return tokenID
   */
  @javax.annotation.Nullable
  public String getTokenID() {
    return tokenID;
  }

  public void setTokenID(String tokenID) {
    this.tokenID = tokenID;
  }


  public TgvalidatordCurrency logo(String logo) {
    this.logo = logo;
    return this;
  }

  /**
   * Currency logo in Data URI scheme. Base 64 encoded. (e.g. data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAUAAAAFCAYAAACNbyblAAAAHElEQVQI12P4//8/w38GIAXDIBKE0DHxgljNBAAO9TXL0Y4OHwAAAABJRU5ErkJggg&#x3D;&#x3D;).
   * @return logo
   */
  @javax.annotation.Nullable
  public String getLogo() {
    return logo;
  }

  public void setLogo(String logo) {
    this.logo = logo;
  }

  /**
   * A container for additional, undeclared properties.
   * This is a holder for any undeclared properties as specified with
   * the 'additionalProperties' keyword in the OAS document.
   */
  private Map<String, Object> additionalProperties;

  /**
   * Set the additional (undeclared) property with the specified name and value.
   * If the property does not already exist, create it otherwise replace it.
   *
   * @param key name of the property
   * @param value value of the property
   * @return the TgvalidatordCurrency instance itself
   */
  public TgvalidatordCurrency putAdditionalProperty(String key, Object value) {
    if (this.additionalProperties == null) {
        this.additionalProperties = new HashMap<String, Object>();
    }
    this.additionalProperties.put(key, value);
    return this;
  }

  /**
   * Return the additional (undeclared) property.
   *
   * @return a map of objects
   */
  public Map<String, Object> getAdditionalProperties() {
    return additionalProperties;
  }

  /**
   * Return the additional (undeclared) property with the specified name.
   *
   * @param key name of the property
   * @return an object
   */
  public Object getAdditionalProperty(String key) {
    if (this.additionalProperties == null) {
        return null;
    }
    return this.additionalProperties.get(key);
  }


  @Override
  public boolean equals(Object o) {
    if (this == o) {
      return true;
    }
    if (o == null || getClass() != o.getClass()) {
      return false;
    }
    TgvalidatordCurrency tgvalidatordCurrency = (TgvalidatordCurrency) o;
    return Objects.equals(this.name, tgvalidatordCurrency.name) &&
        Objects.equals(this.symbol, tgvalidatordCurrency.symbol) &&
        Objects.equals(this.coinTypeIndex, tgvalidatordCurrency.coinTypeIndex) &&
        Objects.equals(this.blockchain, tgvalidatordCurrency.blockchain) &&
        Objects.equals(this.isToken, tgvalidatordCurrency.isToken) &&
        Objects.equals(this.isERC20, tgvalidatordCurrency.isERC20) &&
        Objects.equals(this.decimals, tgvalidatordCurrency.decimals) &&
        Objects.equals(this.contractAddress, tgvalidatordCurrency.contractAddress) &&
        Objects.equals(this.hasStaking, tgvalidatordCurrency.hasStaking) &&
        Objects.equals(this.isUTXOBased, tgvalidatordCurrency.isUTXOBased) &&
        Objects.equals(this.isAccountBased, tgvalidatordCurrency.isAccountBased) &&
        Objects.equals(this.isFiat, tgvalidatordCurrency.isFiat) &&
        Objects.equals(this.isFA12, tgvalidatordCurrency.isFA12) &&
        Objects.equals(this.isFA20, tgvalidatordCurrency.isFA20) &&
        Objects.equals(this.isNFT, tgvalidatordCurrency.isNFT) &&
        Objects.equals(this.enabled, tgvalidatordCurrency.enabled) &&
        Objects.equals(this.id, tgvalidatordCurrency.id) &&
        Objects.equals(this.displayName, tgvalidatordCurrency.displayName) &&
        Objects.equals(this.type, tgvalidatordCurrency.type) &&
        Objects.equals(this.wlcaId, tgvalidatordCurrency.wlcaId) &&
        Objects.equals(this.network, tgvalidatordCurrency.network) &&
        Objects.equals(this.tokenID, tgvalidatordCurrency.tokenID) &&
        Objects.equals(this.logo, tgvalidatordCurrency.logo)&&
        Objects.equals(this.additionalProperties, tgvalidatordCurrency.additionalProperties);
  }

  @Override
  public int hashCode() {
    return Objects.hash(name, symbol, coinTypeIndex, blockchain, isToken, isERC20, decimals, contractAddress, hasStaking, isUTXOBased, isAccountBased, isFiat, isFA12, isFA20, isNFT, enabled, id, displayName, type, wlcaId, network, tokenID, logo, additionalProperties);
  }

  @Override
  public String toString() {
    StringBuilder sb = new StringBuilder();
    sb.append("class TgvalidatordCurrency {\n");
    sb.append("    name: ").append(toIndentedString(name)).append("\n");
    sb.append("    symbol: ").append(toIndentedString(symbol)).append("\n");
    sb.append("    coinTypeIndex: ").append(toIndentedString(coinTypeIndex)).append("\n");
    sb.append("    blockchain: ").append(toIndentedString(blockchain)).append("\n");
    sb.append("    isToken: ").append(toIndentedString(isToken)).append("\n");
    sb.append("    isERC20: ").append(toIndentedString(isERC20)).append("\n");
    sb.append("    decimals: ").append(toIndentedString(decimals)).append("\n");
    sb.append("    contractAddress: ").append(toIndentedString(contractAddress)).append("\n");
    sb.append("    hasStaking: ").append(toIndentedString(hasStaking)).append("\n");
    sb.append("    isUTXOBased: ").append(toIndentedString(isUTXOBased)).append("\n");
    sb.append("    isAccountBased: ").append(toIndentedString(isAccountBased)).append("\n");
    sb.append("    isFiat: ").append(toIndentedString(isFiat)).append("\n");
    sb.append("    isFA12: ").append(toIndentedString(isFA12)).append("\n");
    sb.append("    isFA20: ").append(toIndentedString(isFA20)).append("\n");
    sb.append("    isNFT: ").append(toIndentedString(isNFT)).append("\n");
    sb.append("    enabled: ").append(toIndentedString(enabled)).append("\n");
    sb.append("    id: ").append(toIndentedString(id)).append("\n");
    sb.append("    displayName: ").append(toIndentedString(displayName)).append("\n");
    sb.append("    type: ").append(toIndentedString(type)).append("\n");
    sb.append("    wlcaId: ").append(toIndentedString(wlcaId)).append("\n");
    sb.append("    network: ").append(toIndentedString(network)).append("\n");
    sb.append("    tokenID: ").append(toIndentedString(tokenID)).append("\n");
    sb.append("    logo: ").append(toIndentedString(logo)).append("\n");
    sb.append("    additionalProperties: ").append(toIndentedString(additionalProperties)).append("\n");
    sb.append("}");
    return sb.toString();
  }

  /**
   * Convert the given object to string with each line indented by 4 spaces
   * (except the first line).
   */
  private String toIndentedString(Object o) {
    if (o == null) {
      return "null";
    }
    return o.toString().replace("\n", "\n    ");
  }


  public static HashSet<String> openapiFields;
  public static HashSet<String> openapiRequiredFields;

  static {
    // a set of all properties/fields (JSON key names)
    openapiFields = new HashSet<String>();
    openapiFields.add("name");
    openapiFields.add("symbol");
    openapiFields.add("coinTypeIndex");
    openapiFields.add("blockchain");
    openapiFields.add("isToken");
    openapiFields.add("isERC20");
    openapiFields.add("decimals");
    openapiFields.add("contractAddress");
    openapiFields.add("hasStaking");
    openapiFields.add("isUTXOBased");
    openapiFields.add("isAccountBased");
    openapiFields.add("isFiat");
    openapiFields.add("isFA12");
    openapiFields.add("isFA20");
    openapiFields.add("isNFT");
    openapiFields.add("enabled");
    openapiFields.add("id");
    openapiFields.add("displayName");
    openapiFields.add("type");
    openapiFields.add("wlcaId");
    openapiFields.add("network");
    openapiFields.add("tokenID");
    openapiFields.add("logo");

    // a set of required properties/fields (JSON key names)
    openapiRequiredFields = new HashSet<String>();
  }

  /**
   * Validates the JSON Element and throws an exception if issues found
   *
   * @param jsonElement JSON Element
   * @throws IOException if the JSON Element is invalid with respect to TgvalidatordCurrency
   */
  public static void validateJsonElement(JsonElement jsonElement) throws IOException {
      if (jsonElement == null) {
        if (!TgvalidatordCurrency.openapiRequiredFields.isEmpty()) { // has required fields but JSON element is null
          throw new IllegalArgumentException(String.format("The required field(s) %s in TgvalidatordCurrency is not found in the empty JSON string", TgvalidatordCurrency.openapiRequiredFields.toString()));
        }
      }
        JsonObject jsonObj = jsonElement.getAsJsonObject();
      if ((jsonObj.get("name") != null && !jsonObj.get("name").isJsonNull()) && !jsonObj.get("name").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `name` to be a primitive type in the JSON string but got `%s`", jsonObj.get("name").toString()));
      }
      if ((jsonObj.get("symbol") != null && !jsonObj.get("symbol").isJsonNull()) && !jsonObj.get("symbol").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `symbol` to be a primitive type in the JSON string but got `%s`", jsonObj.get("symbol").toString()));
      }
      if ((jsonObj.get("coinTypeIndex") != null && !jsonObj.get("coinTypeIndex").isJsonNull()) && !jsonObj.get("coinTypeIndex").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `coinTypeIndex` to be a primitive type in the JSON string but got `%s`", jsonObj.get("coinTypeIndex").toString()));
      }
      if ((jsonObj.get("blockchain") != null && !jsonObj.get("blockchain").isJsonNull()) && !jsonObj.get("blockchain").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `blockchain` to be a primitive type in the JSON string but got `%s`", jsonObj.get("blockchain").toString()));
      }
      if ((jsonObj.get("decimals") != null && !jsonObj.get("decimals").isJsonNull()) && !jsonObj.get("decimals").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `decimals` to be a primitive type in the JSON string but got `%s`", jsonObj.get("decimals").toString()));
      }
      if ((jsonObj.get("contractAddress") != null && !jsonObj.get("contractAddress").isJsonNull()) && !jsonObj.get("contractAddress").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `contractAddress` to be a primitive type in the JSON string but got `%s`", jsonObj.get("contractAddress").toString()));
      }
      if ((jsonObj.get("id") != null && !jsonObj.get("id").isJsonNull()) && !jsonObj.get("id").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `id` to be a primitive type in the JSON string but got `%s`", jsonObj.get("id").toString()));
      }
      if ((jsonObj.get("displayName") != null && !jsonObj.get("displayName").isJsonNull()) && !jsonObj.get("displayName").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `displayName` to be a primitive type in the JSON string but got `%s`", jsonObj.get("displayName").toString()));
      }
      if ((jsonObj.get("type") != null && !jsonObj.get("type").isJsonNull()) && !jsonObj.get("type").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `type` to be a primitive type in the JSON string but got `%s`", jsonObj.get("type").toString()));
      }
      if ((jsonObj.get("wlcaId") != null && !jsonObj.get("wlcaId").isJsonNull()) && !jsonObj.get("wlcaId").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `wlcaId` to be a primitive type in the JSON string but got `%s`", jsonObj.get("wlcaId").toString()));
      }
      if ((jsonObj.get("network") != null && !jsonObj.get("network").isJsonNull()) && !jsonObj.get("network").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `network` to be a primitive type in the JSON string but got `%s`", jsonObj.get("network").toString()));
      }
      if ((jsonObj.get("tokenID") != null && !jsonObj.get("tokenID").isJsonNull()) && !jsonObj.get("tokenID").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `tokenID` to be a primitive type in the JSON string but got `%s`", jsonObj.get("tokenID").toString()));
      }
      if ((jsonObj.get("logo") != null && !jsonObj.get("logo").isJsonNull()) && !jsonObj.get("logo").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `logo` to be a primitive type in the JSON string but got `%s`", jsonObj.get("logo").toString()));
      }
  }

  public static class CustomTypeAdapterFactory implements TypeAdapterFactory {
    @SuppressWarnings("unchecked")
    @Override
    public <T> TypeAdapter<T> create(Gson gson, TypeToken<T> type) {
       if (!TgvalidatordCurrency.class.isAssignableFrom(type.getRawType())) {
         return null; // this class only serializes 'TgvalidatordCurrency' and its subtypes
       }
       final TypeAdapter<JsonElement> elementAdapter = gson.getAdapter(JsonElement.class);
       final TypeAdapter<TgvalidatordCurrency> thisAdapter
                        = gson.getDelegateAdapter(this, TypeToken.get(TgvalidatordCurrency.class));

       return (TypeAdapter<T>) new TypeAdapter<TgvalidatordCurrency>() {
           @Override
           public void write(JsonWriter out, TgvalidatordCurrency value) throws IOException {
             JsonObject obj = thisAdapter.toJsonTree(value).getAsJsonObject();
             obj.remove("additionalProperties");
             // serialize additional properties
             if (value.getAdditionalProperties() != null) {
               for (Map.Entry<String, Object> entry : value.getAdditionalProperties().entrySet()) {
                 if (entry.getValue() instanceof String)
                   obj.addProperty(entry.getKey(), (String) entry.getValue());
                 else if (entry.getValue() instanceof Number)
                   obj.addProperty(entry.getKey(), (Number) entry.getValue());
                 else if (entry.getValue() instanceof Boolean)
                   obj.addProperty(entry.getKey(), (Boolean) entry.getValue());
                 else if (entry.getValue() instanceof Character)
                   obj.addProperty(entry.getKey(), (Character) entry.getValue());
                 else {
                   JsonElement jsonElement = gson.toJsonTree(entry.getValue());
                   if (jsonElement.isJsonArray()) {
                     obj.add(entry.getKey(), jsonElement.getAsJsonArray());
                   } else {
                     obj.add(entry.getKey(), jsonElement.getAsJsonObject());
                   }
                 }
               }
             }
             elementAdapter.write(out, obj);
           }

           @Override
           public TgvalidatordCurrency read(JsonReader in) throws IOException {
             JsonElement jsonElement = elementAdapter.read(in);
             validateJsonElement(jsonElement);
             JsonObject jsonObj = jsonElement.getAsJsonObject();
             // store additional fields in the deserialized instance
             TgvalidatordCurrency instance = thisAdapter.fromJsonTree(jsonObj);
             for (Map.Entry<String, JsonElement> entry : jsonObj.entrySet()) {
               if (!openapiFields.contains(entry.getKey())) {
                 if (entry.getValue().isJsonPrimitive()) { // primitive type
                   if (entry.getValue().getAsJsonPrimitive().isString())
                     instance.putAdditionalProperty(entry.getKey(), entry.getValue().getAsString());
                   else if (entry.getValue().getAsJsonPrimitive().isNumber())
                     instance.putAdditionalProperty(entry.getKey(), entry.getValue().getAsNumber());
                   else if (entry.getValue().getAsJsonPrimitive().isBoolean())
                     instance.putAdditionalProperty(entry.getKey(), entry.getValue().getAsBoolean());
                   else
                     throw new IllegalArgumentException(String.format("The field `%s` has unknown primitive type. Value: %s", entry.getKey(), entry.getValue().toString()));
                 } else if (entry.getValue().isJsonArray()) {
                     instance.putAdditionalProperty(entry.getKey(), gson.fromJson(entry.getValue(), List.class));
                 } else { // JSON object
                     instance.putAdditionalProperty(entry.getKey(), gson.fromJson(entry.getValue(), HashMap.class));
                 }
               }
             }
             return instance;
           }

       }.nullSafe();
    }
  }

  /**
   * Create an instance of TgvalidatordCurrency given an JSON string
   *
   * @param jsonString JSON string
   * @return An instance of TgvalidatordCurrency
   * @throws IOException if the JSON string is invalid with respect to TgvalidatordCurrency
   */
  public static TgvalidatordCurrency fromJson(String jsonString) throws IOException {
    return JSON.getGson().fromJson(jsonString, TgvalidatordCurrency.class);
  }

  /**
   * Convert an instance of TgvalidatordCurrency to an JSON string
   *
   * @return JSON string
   */
  public String toJson() {
    return JSON.getGson().toJson(this);
  }
}

