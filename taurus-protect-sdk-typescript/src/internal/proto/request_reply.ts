// Code generated by protoc-gen-ts_proto. DO NOT EDIT.
// versions:
//   protoc-gen-ts_proto  v1.181.2
//   protoc               v6.33.4
// source: request_reply.proto

/* eslint-disable */
import Long from "long";
import _m0 from "protobufjs/minimal";
import { CommitmentKind, commitmentKindFromJSON, commitmentKindToJSON } from "./commitments";

export const protobufPackage = "tgvalidatord";

export enum Blockchain {
  None = 0,
  BTC = 1,
  BCH = 2,
  LTC = 3,
  /** ETH - BSV = 4;  // keep this line to show that this field is reserved forever */
  ETH = 5,
  XLM = 6,
  XRP = 7,
  /**
   * XTZ - NEO = 8;   // keep this line to show that this field is reserved forever
   * GRAM = 9;  // keep this line to show that this field is reserved forever
   * ETC = 10;  // keep this line to show that this field is reserved forever
   */
  XTZ = 11,
  /** ADA - Diem = 12; // keep this line to show that this field is reserved forever */
  ADA = 13,
  DOT = 14,
  FTM = 15,
  ALGO = 16,
  SOL = 17,
  Cosmos = 18,
  Polygon = 19,
  NEAR = 20,
  AvalancheC = 21,
  ICP = 22,
  /** TAO - Bittensor */
  TAO = 23,
  DOGE = 24,
  Hedera = 25,
  Sonic = 26,
  Mina = 27,
  Filecoin = 28,
  TRON = 29,
  /** Canton - ... */
  Canton = 30,
  UNRECOGNIZED = -1,
}

export function blockchainFromJSON(object: any): Blockchain {
  switch (object) {
    case 0:
    case "None":
      return Blockchain.None;
    case 1:
    case "BTC":
      return Blockchain.BTC;
    case 2:
    case "BCH":
      return Blockchain.BCH;
    case 3:
    case "LTC":
      return Blockchain.LTC;
    case 5:
    case "ETH":
      return Blockchain.ETH;
    case 6:
    case "XLM":
      return Blockchain.XLM;
    case 7:
    case "XRP":
      return Blockchain.XRP;
    case 11:
    case "XTZ":
      return Blockchain.XTZ;
    case 13:
    case "ADA":
      return Blockchain.ADA;
    case 14:
    case "DOT":
      return Blockchain.DOT;
    case 15:
    case "FTM":
      return Blockchain.FTM;
    case 16:
    case "ALGO":
      return Blockchain.ALGO;
    case 17:
    case "SOL":
      return Blockchain.SOL;
    case 18:
    case "Cosmos":
      return Blockchain.Cosmos;
    case 19:
    case "Polygon":
      return Blockchain.Polygon;
    case 20:
    case "NEAR":
      return Blockchain.NEAR;
    case 21:
    case "AvalancheC":
      return Blockchain.AvalancheC;
    case 22:
    case "ICP":
      return Blockchain.ICP;
    case 23:
    case "TAO":
      return Blockchain.TAO;
    case 24:
    case "DOGE":
      return Blockchain.DOGE;
    case 25:
    case "Hedera":
      return Blockchain.Hedera;
    case 26:
    case "Sonic":
      return Blockchain.Sonic;
    case 27:
    case "Mina":
      return Blockchain.Mina;
    case 28:
    case "Filecoin":
      return Blockchain.Filecoin;
    case 29:
    case "TRON":
      return Blockchain.TRON;
    case 30:
    case "Canton":
      return Blockchain.Canton;
    case -1:
    case "UNRECOGNIZED":
    default:
      return Blockchain.UNRECOGNIZED;
  }
}

export function blockchainToJSON(object: Blockchain): string {
  switch (object) {
    case Blockchain.None:
      return "None";
    case Blockchain.BTC:
      return "BTC";
    case Blockchain.BCH:
      return "BCH";
    case Blockchain.LTC:
      return "LTC";
    case Blockchain.ETH:
      return "ETH";
    case Blockchain.XLM:
      return "XLM";
    case Blockchain.XRP:
      return "XRP";
    case Blockchain.XTZ:
      return "XTZ";
    case Blockchain.ADA:
      return "ADA";
    case Blockchain.DOT:
      return "DOT";
    case Blockchain.FTM:
      return "FTM";
    case Blockchain.ALGO:
      return "ALGO";
    case Blockchain.SOL:
      return "SOL";
    case Blockchain.Cosmos:
      return "Cosmos";
    case Blockchain.Polygon:
      return "Polygon";
    case Blockchain.NEAR:
      return "NEAR";
    case Blockchain.AvalancheC:
      return "AvalancheC";
    case Blockchain.ICP:
      return "ICP";
    case Blockchain.TAO:
      return "TAO";
    case Blockchain.DOGE:
      return "DOGE";
    case Blockchain.Hedera:
      return "Hedera";
    case Blockchain.Sonic:
      return "Sonic";
    case Blockchain.Mina:
      return "Mina";
    case Blockchain.Filecoin:
      return "Filecoin";
    case Blockchain.TRON:
      return "TRON";
    case Blockchain.Canton:
      return "Canton";
    case Blockchain.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

export enum BTCAddressType {
  BTC_P2PKH = 0,
  BTC_P2SH_P2WPKH = 1,
  BTC_P2WPKH = 2,
  UNRECOGNIZED = -1,
}

export function bTCAddressTypeFromJSON(object: any): BTCAddressType {
  switch (object) {
    case 0:
    case "BTC_P2PKH":
      return BTCAddressType.BTC_P2PKH;
    case 1:
    case "BTC_P2SH_P2WPKH":
      return BTCAddressType.BTC_P2SH_P2WPKH;
    case 2:
    case "BTC_P2WPKH":
      return BTCAddressType.BTC_P2WPKH;
    case -1:
    case "UNRECOGNIZED":
    default:
      return BTCAddressType.UNRECOGNIZED;
  }
}

export function bTCAddressTypeToJSON(object: BTCAddressType): string {
  switch (object) {
    case BTCAddressType.BTC_P2PKH:
      return "BTC_P2PKH";
    case BTCAddressType.BTC_P2SH_P2WPKH:
      return "BTC_P2SH_P2WPKH";
    case BTCAddressType.BTC_P2WPKH:
      return "BTC_P2WPKH";
    case BTCAddressType.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

export enum BTCSigHashType {
  BTC_SIGHASH_ALL = 0,
  UNRECOGNIZED = -1,
}

export function bTCSigHashTypeFromJSON(object: any): BTCSigHashType {
  switch (object) {
    case 0:
    case "BTC_SIGHASH_ALL":
      return BTCSigHashType.BTC_SIGHASH_ALL;
    case -1:
    case "UNRECOGNIZED":
    default:
      return BTCSigHashType.UNRECOGNIZED;
  }
}

export function bTCSigHashTypeToJSON(object: BTCSigHashType): string {
  switch (object) {
    case BTCSigHashType.BTC_SIGHASH_ALL:
      return "BTC_SIGHASH_ALL";
    case BTCSigHashType.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

export enum LTCAddressType {
  LTC_P2PKH = 0,
  LTC_P2SH_P2WPKH = 1,
  LTC_P2WPKH = 2,
  UNRECOGNIZED = -1,
}

export function lTCAddressTypeFromJSON(object: any): LTCAddressType {
  switch (object) {
    case 0:
    case "LTC_P2PKH":
      return LTCAddressType.LTC_P2PKH;
    case 1:
    case "LTC_P2SH_P2WPKH":
      return LTCAddressType.LTC_P2SH_P2WPKH;
    case 2:
    case "LTC_P2WPKH":
      return LTCAddressType.LTC_P2WPKH;
    case -1:
    case "UNRECOGNIZED":
    default:
      return LTCAddressType.UNRECOGNIZED;
  }
}

export function lTCAddressTypeToJSON(object: LTCAddressType): string {
  switch (object) {
    case LTCAddressType.LTC_P2PKH:
      return "LTC_P2PKH";
    case LTCAddressType.LTC_P2SH_P2WPKH:
      return "LTC_P2SH_P2WPKH";
    case LTCAddressType.LTC_P2WPKH:
      return "LTC_P2WPKH";
    case LTCAddressType.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

export enum LTCSigHashType {
  LTC_SIGHASH_ALL = 0,
  UNRECOGNIZED = -1,
}

export function lTCSigHashTypeFromJSON(object: any): LTCSigHashType {
  switch (object) {
    case 0:
    case "LTC_SIGHASH_ALL":
      return LTCSigHashType.LTC_SIGHASH_ALL;
    case -1:
    case "UNRECOGNIZED":
    default:
      return LTCSigHashType.UNRECOGNIZED;
  }
}

export function lTCSigHashTypeToJSON(object: LTCSigHashType): string {
  switch (object) {
    case LTCSigHashType.LTC_SIGHASH_ALL:
      return "LTC_SIGHASH_ALL";
    case LTCSigHashType.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

export enum BCHAddressType {
  BCH_P2PKH = 0,
  UNRECOGNIZED = -1,
}

export function bCHAddressTypeFromJSON(object: any): BCHAddressType {
  switch (object) {
    case 0:
    case "BCH_P2PKH":
      return BCHAddressType.BCH_P2PKH;
    case -1:
    case "UNRECOGNIZED":
    default:
      return BCHAddressType.UNRECOGNIZED;
  }
}

export function bCHAddressTypeToJSON(object: BCHAddressType): string {
  switch (object) {
    case BCHAddressType.BCH_P2PKH:
      return "BCH_P2PKH";
    case BCHAddressType.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

export enum BCHSigHashType {
  BCH_SIGHASH_ALL = 0,
  UNRECOGNIZED = -1,
}

export function bCHSigHashTypeFromJSON(object: any): BCHSigHashType {
  switch (object) {
    case 0:
    case "BCH_SIGHASH_ALL":
      return BCHSigHashType.BCH_SIGHASH_ALL;
    case -1:
    case "UNRECOGNIZED":
    default:
      return BCHSigHashType.UNRECOGNIZED;
  }
}

export function bCHSigHashTypeToJSON(object: BCHSigHashType): string {
  switch (object) {
    case BCHSigHashType.BCH_SIGHASH_ALL:
      return "BCH_SIGHASH_ALL";
    case BCHSigHashType.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

export enum DOGEAddressType {
  DOGE_P2PKH = 0,
  UNRECOGNIZED = -1,
}

export function dOGEAddressTypeFromJSON(object: any): DOGEAddressType {
  switch (object) {
    case 0:
    case "DOGE_P2PKH":
      return DOGEAddressType.DOGE_P2PKH;
    case -1:
    case "UNRECOGNIZED":
    default:
      return DOGEAddressType.UNRECOGNIZED;
  }
}

export function dOGEAddressTypeToJSON(object: DOGEAddressType): string {
  switch (object) {
    case DOGEAddressType.DOGE_P2PKH:
      return "DOGE_P2PKH";
    case DOGEAddressType.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

export enum DOGESigHashType {
  DOGE_SIGHASH_ALL = 0,
  UNRECOGNIZED = -1,
}

export function dOGESigHashTypeFromJSON(object: any): DOGESigHashType {
  switch (object) {
    case 0:
    case "DOGE_SIGHASH_ALL":
      return DOGESigHashType.DOGE_SIGHASH_ALL;
    case -1:
    case "UNRECOGNIZED":
    default:
      return DOGESigHashType.UNRECOGNIZED;
  }
}

export function dOGESigHashTypeToJSON(object: DOGESigHashType): string {
  switch (object) {
    case DOGESigHashType.DOGE_SIGHASH_ALL:
      return "DOGE_SIGHASH_ALL";
    case DOGESigHashType.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

export enum FilecoinAddressType {
  FILECOIN_SECP256K1 = 0,
  FILECOIN_BLS = 1,
  FILECOIN_DELEGATED = 2,
  UNRECOGNIZED = -1,
}

export function filecoinAddressTypeFromJSON(object: any): FilecoinAddressType {
  switch (object) {
    case 0:
    case "FILECOIN_SECP256K1":
      return FilecoinAddressType.FILECOIN_SECP256K1;
    case 1:
    case "FILECOIN_BLS":
      return FilecoinAddressType.FILECOIN_BLS;
    case 2:
    case "FILECOIN_DELEGATED":
      return FilecoinAddressType.FILECOIN_DELEGATED;
    case -1:
    case "UNRECOGNIZED":
    default:
      return FilecoinAddressType.UNRECOGNIZED;
  }
}

export function filecoinAddressTypeToJSON(object: FilecoinAddressType): string {
  switch (object) {
    case FilecoinAddressType.FILECOIN_SECP256K1:
      return "FILECOIN_SECP256K1";
    case FilecoinAddressType.FILECOIN_BLS:
      return "FILECOIN_BLS";
    case FilecoinAddressType.FILECOIN_DELEGATED:
      return "FILECOIN_DELEGATED";
    case FilecoinAddressType.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

export enum Role {
  REQUESTAPPROVER = 0,
  TGVALIDATORD = 1,
  PRICEUPDATER = 2,
  SUPERADMIN = 3,
  REQUESTCREATOR = 4,
  HSMSLOT = 5,
  SECONDARYCOMMITTER = 6,
  REQUESTCANCELER = 7,
  ACCOUNTCREATOR = 8,
  WHITELISTEDADDRESSCREATOR = 9,
  TPUSER = 10,
  WHITELISTEDADDRESSAPPROVER = 11,
  REQUESTMOBILEAPPSIGNER = 12,
  WHITELISTEDADDRESSMOBILEAPPSIGNER = 13,
  AIRGAPEXPORTER = 14,
  AIRGAPIMPORTER = 15,
  AIRGAPSIGNER = 16,
  UNRECOGNIZED = -1,
}

export function roleFromJSON(object: any): Role {
  switch (object) {
    case 0:
    case "REQUESTAPPROVER":
      return Role.REQUESTAPPROVER;
    case 1:
    case "TGVALIDATORD":
      return Role.TGVALIDATORD;
    case 2:
    case "PRICEUPDATER":
      return Role.PRICEUPDATER;
    case 3:
    case "SUPERADMIN":
      return Role.SUPERADMIN;
    case 4:
    case "REQUESTCREATOR":
      return Role.REQUESTCREATOR;
    case 5:
    case "HSMSLOT":
      return Role.HSMSLOT;
    case 6:
    case "SECONDARYCOMMITTER":
      return Role.SECONDARYCOMMITTER;
    case 7:
    case "REQUESTCANCELER":
      return Role.REQUESTCANCELER;
    case 8:
    case "ACCOUNTCREATOR":
      return Role.ACCOUNTCREATOR;
    case 9:
    case "WHITELISTEDADDRESSCREATOR":
      return Role.WHITELISTEDADDRESSCREATOR;
    case 10:
    case "TPUSER":
      return Role.TPUSER;
    case 11:
    case "WHITELISTEDADDRESSAPPROVER":
      return Role.WHITELISTEDADDRESSAPPROVER;
    case 12:
    case "REQUESTMOBILEAPPSIGNER":
      return Role.REQUESTMOBILEAPPSIGNER;
    case 13:
    case "WHITELISTEDADDRESSMOBILEAPPSIGNER":
      return Role.WHITELISTEDADDRESSMOBILEAPPSIGNER;
    case 14:
    case "AIRGAPEXPORTER":
      return Role.AIRGAPEXPORTER;
    case 15:
    case "AIRGAPIMPORTER":
      return Role.AIRGAPIMPORTER;
    case 16:
    case "AIRGAPSIGNER":
      return Role.AIRGAPSIGNER;
    case -1:
    case "UNRECOGNIZED":
    default:
      return Role.UNRECOGNIZED;
  }
}

export function roleToJSON(object: Role): string {
  switch (object) {
    case Role.REQUESTAPPROVER:
      return "REQUESTAPPROVER";
    case Role.TGVALIDATORD:
      return "TGVALIDATORD";
    case Role.PRICEUPDATER:
      return "PRICEUPDATER";
    case Role.SUPERADMIN:
      return "SUPERADMIN";
    case Role.REQUESTCREATOR:
      return "REQUESTCREATOR";
    case Role.HSMSLOT:
      return "HSMSLOT";
    case Role.SECONDARYCOMMITTER:
      return "SECONDARYCOMMITTER";
    case Role.REQUESTCANCELER:
      return "REQUESTCANCELER";
    case Role.ACCOUNTCREATOR:
      return "ACCOUNTCREATOR";
    case Role.WHITELISTEDADDRESSCREATOR:
      return "WHITELISTEDADDRESSCREATOR";
    case Role.TPUSER:
      return "TPUSER";
    case Role.WHITELISTEDADDRESSAPPROVER:
      return "WHITELISTEDADDRESSAPPROVER";
    case Role.REQUESTMOBILEAPPSIGNER:
      return "REQUESTMOBILEAPPSIGNER";
    case Role.WHITELISTEDADDRESSMOBILEAPPSIGNER:
      return "WHITELISTEDADDRESSMOBILEAPPSIGNER";
    case Role.AIRGAPEXPORTER:
      return "AIRGAPEXPORTER";
    case Role.AIRGAPIMPORTER:
      return "AIRGAPIMPORTER";
    case Role.AIRGAPSIGNER:
      return "AIRGAPSIGNER";
    case Role.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

export interface Status {
  code: Status_StatusCode;
  message: string;
}

export enum Status_StatusCode {
  Success = 0,
  InternalError = 1,
  ValidationError = 2,
  SecurityError = 3,
  UNRECOGNIZED = -1,
}

export function status_StatusCodeFromJSON(object: any): Status_StatusCode {
  switch (object) {
    case 0:
    case "Success":
      return Status_StatusCode.Success;
    case 1:
    case "InternalError":
      return Status_StatusCode.InternalError;
    case 2:
    case "ValidationError":
      return Status_StatusCode.ValidationError;
    case 3:
    case "SecurityError":
      return Status_StatusCode.SecurityError;
    case -1:
    case "UNRECOGNIZED":
    default:
      return Status_StatusCode.UNRECOGNIZED;
  }
}

export function status_StatusCodeToJSON(object: Status_StatusCode): string {
  switch (object) {
    case Status_StatusCode.Success:
      return "Success";
    case Status_StatusCode.InternalError:
      return "InternalError";
    case Status_StatusCode.ValidationError:
      return "ValidationError";
    case Status_StatusCode.SecurityError:
      return "SecurityError";
    case Status_StatusCode.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

export interface Traces {
  function: string;
  /** duration in ms */
  duration: number;
  children: Traces[];
  /** offset against parent, in ms */
  offset: number;
}

export interface EncryptedRepliesContainer {
  iv: Uint8Array;
  /** Encrypted SignedRepliesEnvelope */
  ciphertext: Uint8Array;
  /** hmac-sha256(key,ciphertext) */
  mac: Uint8Array;
}

export interface SignedRepliesEnvelope {
  /** correspond to SignedRequestEnvelope.id */
  id: string;
  status:
    | Status
    | undefined;
  /** payload is signed by the HSM */
  payloadSignature: Uint8Array;
  /** contains a Replies message */
  payload: Uint8Array;
  /**
   * If this field is set, all fields with index under 1000 must be absent.
   * This lets us keep deserialization simple, and backwards-compatible
   */
  encryptedRepliesEnvelope:
    | EncryptedRepliesContainer
    | undefined;
  /** Traces are always sent decrypted, not taken into account in the encrypted container */
  traces: Traces | undefined;
}

export interface Replies {
  replies: Reply[];
}

export interface Reply {
  /** correspond to RequestEnvelope.id */
  id: string;
  status: Status | undefined;
  payloadType: Reply_PayloadType;
  payload: Uint8Array;
}

export enum Reply_PayloadType {
  None = 0,
  Bytes = 1,
  AddressResponse = 3,
  /** TransactionsResponse - GRAMAddressResponse = 4;     // keep this line to show that this field is reserved forever */
  TransactionsResponse = 5,
  ETHTransactionsResponse = 6,
  /** ProofOfReserveResponse - ETCTransactionsResponse = 7; // keep this line to show that this field is reserved forever */
  ProofOfReserveResponse = 8,
  /**
   * ETHWrappedTransactionsResponse - DiemJWTResponse = 9;         // keep this line to show that this field is reserved forever
   * DiemAddressResponse = 10;    // keep this line to show that this field is reserved forever
   */
  ETHWrappedTransactionsResponse = 11,
  ETHWrappedCreateContractResponse = 12,
  ADAProofOfReserveResponse = 13,
  FTMTransactionsResponse = 14,
  ETHSignTextResponse = 15,
  PolygonTransactionsResponse = 16,
  PolygonWrappedTransactionsResponse = 17,
  PolygonWrappedCreateContractResponse = 18,
  PolygonSignTextResponse = 19,
  AvaxCChainTransactionsResponse = 20,
  AvaxCChainWrappedTransactionsResponse = 21,
  AvaxCChainWrappedCreateContractResponse = 22,
  AvaxCChainSignTextResponse = 23,
  BTCSignTextResponse = 24,
  ICPRequestsResponse = 25,
  ICPAddressResponse = 26,
  MonitoringResponse = 27,
  SonicTransactionsResponse = 28,
  FilecoinTransactionsResponse = 29,
  TRONTransactionsResponse = 30,
  CantonAddressResponse = 31,
  UNRECOGNIZED = -1,
}

export function reply_PayloadTypeFromJSON(object: any): Reply_PayloadType {
  switch (object) {
    case 0:
    case "None":
      return Reply_PayloadType.None;
    case 1:
    case "Bytes":
      return Reply_PayloadType.Bytes;
    case 3:
    case "AddressResponse":
      return Reply_PayloadType.AddressResponse;
    case 5:
    case "TransactionsResponse":
      return Reply_PayloadType.TransactionsResponse;
    case 6:
    case "ETHTransactionsResponse":
      return Reply_PayloadType.ETHTransactionsResponse;
    case 8:
    case "ProofOfReserveResponse":
      return Reply_PayloadType.ProofOfReserveResponse;
    case 11:
    case "ETHWrappedTransactionsResponse":
      return Reply_PayloadType.ETHWrappedTransactionsResponse;
    case 12:
    case "ETHWrappedCreateContractResponse":
      return Reply_PayloadType.ETHWrappedCreateContractResponse;
    case 13:
    case "ADAProofOfReserveResponse":
      return Reply_PayloadType.ADAProofOfReserveResponse;
    case 14:
    case "FTMTransactionsResponse":
      return Reply_PayloadType.FTMTransactionsResponse;
    case 15:
    case "ETHSignTextResponse":
      return Reply_PayloadType.ETHSignTextResponse;
    case 16:
    case "PolygonTransactionsResponse":
      return Reply_PayloadType.PolygonTransactionsResponse;
    case 17:
    case "PolygonWrappedTransactionsResponse":
      return Reply_PayloadType.PolygonWrappedTransactionsResponse;
    case 18:
    case "PolygonWrappedCreateContractResponse":
      return Reply_PayloadType.PolygonWrappedCreateContractResponse;
    case 19:
    case "PolygonSignTextResponse":
      return Reply_PayloadType.PolygonSignTextResponse;
    case 20:
    case "AvaxCChainTransactionsResponse":
      return Reply_PayloadType.AvaxCChainTransactionsResponse;
    case 21:
    case "AvaxCChainWrappedTransactionsResponse":
      return Reply_PayloadType.AvaxCChainWrappedTransactionsResponse;
    case 22:
    case "AvaxCChainWrappedCreateContractResponse":
      return Reply_PayloadType.AvaxCChainWrappedCreateContractResponse;
    case 23:
    case "AvaxCChainSignTextResponse":
      return Reply_PayloadType.AvaxCChainSignTextResponse;
    case 24:
    case "BTCSignTextResponse":
      return Reply_PayloadType.BTCSignTextResponse;
    case 25:
    case "ICPRequestsResponse":
      return Reply_PayloadType.ICPRequestsResponse;
    case 26:
    case "ICPAddressResponse":
      return Reply_PayloadType.ICPAddressResponse;
    case 27:
    case "MonitoringResponse":
      return Reply_PayloadType.MonitoringResponse;
    case 28:
    case "SonicTransactionsResponse":
      return Reply_PayloadType.SonicTransactionsResponse;
    case 29:
    case "FilecoinTransactionsResponse":
      return Reply_PayloadType.FilecoinTransactionsResponse;
    case 30:
    case "TRONTransactionsResponse":
      return Reply_PayloadType.TRONTransactionsResponse;
    case 31:
    case "CantonAddressResponse":
      return Reply_PayloadType.CantonAddressResponse;
    case -1:
    case "UNRECOGNIZED":
    default:
      return Reply_PayloadType.UNRECOGNIZED;
  }
}

export function reply_PayloadTypeToJSON(object: Reply_PayloadType): string {
  switch (object) {
    case Reply_PayloadType.None:
      return "None";
    case Reply_PayloadType.Bytes:
      return "Bytes";
    case Reply_PayloadType.AddressResponse:
      return "AddressResponse";
    case Reply_PayloadType.TransactionsResponse:
      return "TransactionsResponse";
    case Reply_PayloadType.ETHTransactionsResponse:
      return "ETHTransactionsResponse";
    case Reply_PayloadType.ProofOfReserveResponse:
      return "ProofOfReserveResponse";
    case Reply_PayloadType.ETHWrappedTransactionsResponse:
      return "ETHWrappedTransactionsResponse";
    case Reply_PayloadType.ETHWrappedCreateContractResponse:
      return "ETHWrappedCreateContractResponse";
    case Reply_PayloadType.ADAProofOfReserveResponse:
      return "ADAProofOfReserveResponse";
    case Reply_PayloadType.FTMTransactionsResponse:
      return "FTMTransactionsResponse";
    case Reply_PayloadType.ETHSignTextResponse:
      return "ETHSignTextResponse";
    case Reply_PayloadType.PolygonTransactionsResponse:
      return "PolygonTransactionsResponse";
    case Reply_PayloadType.PolygonWrappedTransactionsResponse:
      return "PolygonWrappedTransactionsResponse";
    case Reply_PayloadType.PolygonWrappedCreateContractResponse:
      return "PolygonWrappedCreateContractResponse";
    case Reply_PayloadType.PolygonSignTextResponse:
      return "PolygonSignTextResponse";
    case Reply_PayloadType.AvaxCChainTransactionsResponse:
      return "AvaxCChainTransactionsResponse";
    case Reply_PayloadType.AvaxCChainWrappedTransactionsResponse:
      return "AvaxCChainWrappedTransactionsResponse";
    case Reply_PayloadType.AvaxCChainWrappedCreateContractResponse:
      return "AvaxCChainWrappedCreateContractResponse";
    case Reply_PayloadType.AvaxCChainSignTextResponse:
      return "AvaxCChainSignTextResponse";
    case Reply_PayloadType.BTCSignTextResponse:
      return "BTCSignTextResponse";
    case Reply_PayloadType.ICPRequestsResponse:
      return "ICPRequestsResponse";
    case Reply_PayloadType.ICPAddressResponse:
      return "ICPAddressResponse";
    case Reply_PayloadType.MonitoringResponse:
      return "MonitoringResponse";
    case Reply_PayloadType.SonicTransactionsResponse:
      return "SonicTransactionsResponse";
    case Reply_PayloadType.FilecoinTransactionsResponse:
      return "FilecoinTransactionsResponse";
    case Reply_PayloadType.TRONTransactionsResponse:
      return "TRONTransactionsResponse";
    case Reply_PayloadType.CantonAddressResponse:
      return "CantonAddressResponse";
    case Reply_PayloadType.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

export interface MonitoringResponse {
  /** json payload: {"serial_number": "XXXX", "fm_version": "vX.X.X", "fm_commit": "abcdef", "rules_timestamp": 123456} */
  payload: string;
  /** b64_encode of ECDSA-SHA256 over P256 of payload */
  signature: string;
}

export interface ProofOfReserveResponse {
  curve: ProofOfReserveResponse_Curve;
  cipher: ProofOfReserveResponse_Cipher;
  address: string;
  path: string;
  /** public key for the curve. For p256 x::y, for ed25519, 32byte pubkey. */
  publicKey: Uint8Array;
  challenge: string;
  challengeResponse: Uint8Array;
}

export enum ProofOfReserveResponse_Curve {
  Secp256k1 = 0,
  Ed25519 = 1,
  Secp256r1 = 2,
  Pallas = 3,
  UNRECOGNIZED = -1,
}

export function proofOfReserveResponse_CurveFromJSON(object: any): ProofOfReserveResponse_Curve {
  switch (object) {
    case 0:
    case "Secp256k1":
      return ProofOfReserveResponse_Curve.Secp256k1;
    case 1:
    case "Ed25519":
      return ProofOfReserveResponse_Curve.Ed25519;
    case 2:
    case "Secp256r1":
      return ProofOfReserveResponse_Curve.Secp256r1;
    case 3:
    case "Pallas":
      return ProofOfReserveResponse_Curve.Pallas;
    case -1:
    case "UNRECOGNIZED":
    default:
      return ProofOfReserveResponse_Curve.UNRECOGNIZED;
  }
}

export function proofOfReserveResponse_CurveToJSON(object: ProofOfReserveResponse_Curve): string {
  switch (object) {
    case ProofOfReserveResponse_Curve.Secp256k1:
      return "Secp256k1";
    case ProofOfReserveResponse_Curve.Ed25519:
      return "Ed25519";
    case ProofOfReserveResponse_Curve.Secp256r1:
      return "Secp256r1";
    case ProofOfReserveResponse_Curve.Pallas:
      return "Pallas";
    case ProofOfReserveResponse_Curve.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

export enum ProofOfReserveResponse_Cipher {
  ECDSA_SHA256 = 0,
  ECDSA_SHA512 = 1,
  EDDSA = 2,
  Schnorr = 3,
  UNRECOGNIZED = -1,
}

export function proofOfReserveResponse_CipherFromJSON(object: any): ProofOfReserveResponse_Cipher {
  switch (object) {
    case 0:
    case "ECDSA_SHA256":
      return ProofOfReserveResponse_Cipher.ECDSA_SHA256;
    case 1:
    case "ECDSA_SHA512":
      return ProofOfReserveResponse_Cipher.ECDSA_SHA512;
    case 2:
    case "EDDSA":
      return ProofOfReserveResponse_Cipher.EDDSA;
    case 3:
    case "Schnorr":
      return ProofOfReserveResponse_Cipher.Schnorr;
    case -1:
    case "UNRECOGNIZED":
    default:
      return ProofOfReserveResponse_Cipher.UNRECOGNIZED;
  }
}

export function proofOfReserveResponse_CipherToJSON(object: ProofOfReserveResponse_Cipher): string {
  switch (object) {
    case ProofOfReserveResponse_Cipher.ECDSA_SHA256:
      return "ECDSA_SHA256";
    case ProofOfReserveResponse_Cipher.ECDSA_SHA512:
      return "ECDSA_SHA512";
    case ProofOfReserveResponse_Cipher.EDDSA:
      return "EDDSA";
    case ProofOfReserveResponse_Cipher.Schnorr:
      return "Schnorr";
    case ProofOfReserveResponse_Cipher.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

export interface TransactionsResponse {
  transactions: TransactionsResponse_Transaction[];
}

export interface TransactionsResponse_Transaction {
  id: string;
  transaction: string;
}

export interface SourceInternalWallet {
  id: number;
  name: string;
  path: string;
}

export interface SourceInternalAddress {
  id: number;
  address: string;
  label: string;
  path: string;
}

export interface SourceExchange {
  id: number;
  label: string;
}

export interface SourceFiatProviderAccount {
  id: string;
  label: string;
  /** e.g. "wallet", "bank" etc. */
  accountType: string;
  /** true if this is a counterparty account, false if this is a provider account */
  isCounterparty: boolean;
}

/**
 * this message is used when there are actions we need to approve coming from an external address
 * for example approving an incoming TnPledge (action AcceptPledge)
 */
export interface SourceExternalAddress {
  /** wl address id */
  id: number;
  address: string;
  label: string;
  memo: string;
}

export interface Source {
  type: Source_SourceType;
  payload: Uint8Array;
}

/** 1:1 mapping between enum and payload */
export enum Source_SourceType {
  /** SourceInternalWallet - payload  is "SourceInternalWallet" */
  SourceInternalWallet = 0,
  /** SourceInternalAddress - payload is "SourceInternalAddress" */
  SourceInternalAddress = 1,
  /** SourceExchange - payload is "SourceExchange" */
  SourceExchange = 2,
  /** SourceExternalAddress - payload is "SourceExternalAddress" */
  SourceExternalAddress = 3,
  /** SourceFiatProviderAccount - payload is "SourceFiatProviderAccount" */
  SourceFiatProviderAccount = 4,
  UNRECOGNIZED = -1,
}

export function source_SourceTypeFromJSON(object: any): Source_SourceType {
  switch (object) {
    case 0:
    case "SourceInternalWallet":
      return Source_SourceType.SourceInternalWallet;
    case 1:
    case "SourceInternalAddress":
      return Source_SourceType.SourceInternalAddress;
    case 2:
    case "SourceExchange":
      return Source_SourceType.SourceExchange;
    case 3:
    case "SourceExternalAddress":
      return Source_SourceType.SourceExternalAddress;
    case 4:
    case "SourceFiatProviderAccount":
      return Source_SourceType.SourceFiatProviderAccount;
    case -1:
    case "UNRECOGNIZED":
    default:
      return Source_SourceType.UNRECOGNIZED;
  }
}

export function source_SourceTypeToJSON(object: Source_SourceType): string {
  switch (object) {
    case Source_SourceType.SourceInternalWallet:
      return "SourceInternalWallet";
    case Source_SourceType.SourceInternalAddress:
      return "SourceInternalAddress";
    case Source_SourceType.SourceExchange:
      return "SourceExchange";
    case Source_SourceType.SourceExternalAddress:
      return "SourceExternalAddress";
    case Source_SourceType.SourceFiatProviderAccount:
      return "SourceFiatProviderAccount";
    case Source_SourceType.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

export interface DestinationInternalAddress {
  id: number;
  address: string;
  label: string;
  path: string;
}

export interface DestinationExternalAddress {
  id: number;
  address: string;
  label: string;
  memo: string;
}

export interface DestinationExchangeAddress {
  id: number;
  address: string;
  label: string;
  exchangeAccountId: number;
  exchangeAccountLabel: string;
  memo: string;
}

export interface DestinationFiatProviderAccount {
  id: string;
  label: string;
  /** e.g. "wallet", "bank" etc. */
  accountType: string;
  /** true if this is a counterparty account, false if this is a provider account */
  isCounterparty: boolean;
}

export interface DestinationContractAddress {
  id: number;
  address: string;
  name: string;
  symbol: string;
  blockchain: Blockchain;
}

export interface Destination {
  type: Destination_DestinationType;
  payload: Uint8Array;
}

/** 1:1 mapping between enum and payload */
export enum Destination_DestinationType {
  /** DestinationInternalAddress - payload is "DestinationInternalAddress" */
  DestinationInternalAddress = 0,
  /** DestinationExternalAddress - payload is "DestinationExternalAddress" */
  DestinationExternalAddress = 1,
  /** DestinationExchangeAddress - Payload is "DestinationExchangeAddress" */
  DestinationExchangeAddress = 2,
  /** DestinationContractAddress - Payload is "DestinationContractAddress" */
  DestinationContractAddress = 3,
  /** DestinationFiatProviderAccount - Payload is "DestinationFiatProviderAccount" */
  DestinationFiatProviderAccount = 4,
  UNRECOGNIZED = -1,
}

export function destination_DestinationTypeFromJSON(object: any): Destination_DestinationType {
  switch (object) {
    case 0:
    case "DestinationInternalAddress":
      return Destination_DestinationType.DestinationInternalAddress;
    case 1:
    case "DestinationExternalAddress":
      return Destination_DestinationType.DestinationExternalAddress;
    case 2:
    case "DestinationExchangeAddress":
      return Destination_DestinationType.DestinationExchangeAddress;
    case 3:
    case "DestinationContractAddress":
      return Destination_DestinationType.DestinationContractAddress;
    case 4:
    case "DestinationFiatProviderAccount":
      return Destination_DestinationType.DestinationFiatProviderAccount;
    case -1:
    case "UNRECOGNIZED":
    default:
      return Destination_DestinationType.UNRECOGNIZED;
  }
}

export function destination_DestinationTypeToJSON(object: Destination_DestinationType): string {
  switch (object) {
    case Destination_DestinationType.DestinationInternalAddress:
      return "DestinationInternalAddress";
    case Destination_DestinationType.DestinationExternalAddress:
      return "DestinationExternalAddress";
    case Destination_DestinationType.DestinationExchangeAddress:
      return "DestinationExchangeAddress";
    case Destination_DestinationType.DestinationContractAddress:
      return "DestinationContractAddress";
    case Destination_DestinationType.DestinationFiatProviderAccount:
      return "DestinationFiatProviderAccount";
    case Destination_DestinationType.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

export interface WhitelistedContractAddressArray {
  addresses: DestinationContractAddress[];
}

/** Contains the common metadata of every blockchain transaction type */
export interface RequestMetadata {
  /** Keys used for tx validation ("from", "to", "amount"...) */
  key: string;
  type: RequestMetadata_MetadataType;
  /** serialized message of type "MetadataType" (i.e., Source, Destination, etc) */
  value: Uint8Array;
  column: string;
  /** metadata must be commited by a second party */
  DeprecatedSecondaryCommit: boolean;
}

export enum RequestMetadata_MetadataType {
  Bytes = 0,
  String = 1,
  BigInt = 2,
  BigIntArray = 3,
  Source = 4,
  Destination = 5,
  StringArray = 6,
  Tuple = 7,
  Array = 8,
  BytesArray = 9,
  Amount = 10,
  SignedBigInt = 11,
  Operation = 12,
  BytesHash = 13,
  WhitelistedContractAddress = 14,
  WhitelistedContractAddressArray = 15,
  UNRECOGNIZED = -1,
}

export function requestMetadata_MetadataTypeFromJSON(object: any): RequestMetadata_MetadataType {
  switch (object) {
    case 0:
    case "Bytes":
      return RequestMetadata_MetadataType.Bytes;
    case 1:
    case "String":
      return RequestMetadata_MetadataType.String;
    case 2:
    case "BigInt":
      return RequestMetadata_MetadataType.BigInt;
    case 3:
    case "BigIntArray":
      return RequestMetadata_MetadataType.BigIntArray;
    case 4:
    case "Source":
      return RequestMetadata_MetadataType.Source;
    case 5:
    case "Destination":
      return RequestMetadata_MetadataType.Destination;
    case 6:
    case "StringArray":
      return RequestMetadata_MetadataType.StringArray;
    case 7:
    case "Tuple":
      return RequestMetadata_MetadataType.Tuple;
    case 8:
    case "Array":
      return RequestMetadata_MetadataType.Array;
    case 9:
    case "BytesArray":
      return RequestMetadata_MetadataType.BytesArray;
    case 10:
    case "Amount":
      return RequestMetadata_MetadataType.Amount;
    case 11:
    case "SignedBigInt":
      return RequestMetadata_MetadataType.SignedBigInt;
    case 12:
    case "Operation":
      return RequestMetadata_MetadataType.Operation;
    case 13:
    case "BytesHash":
      return RequestMetadata_MetadataType.BytesHash;
    case 14:
    case "WhitelistedContractAddress":
      return RequestMetadata_MetadataType.WhitelistedContractAddress;
    case 15:
    case "WhitelistedContractAddressArray":
      return RequestMetadata_MetadataType.WhitelistedContractAddressArray;
    case -1:
    case "UNRECOGNIZED":
    default:
      return RequestMetadata_MetadataType.UNRECOGNIZED;
  }
}

export function requestMetadata_MetadataTypeToJSON(object: RequestMetadata_MetadataType): string {
  switch (object) {
    case RequestMetadata_MetadataType.Bytes:
      return "Bytes";
    case RequestMetadata_MetadataType.String:
      return "String";
    case RequestMetadata_MetadataType.BigInt:
      return "BigInt";
    case RequestMetadata_MetadataType.BigIntArray:
      return "BigIntArray";
    case RequestMetadata_MetadataType.Source:
      return "Source";
    case RequestMetadata_MetadataType.Destination:
      return "Destination";
    case RequestMetadata_MetadataType.StringArray:
      return "StringArray";
    case RequestMetadata_MetadataType.Tuple:
      return "Tuple";
    case RequestMetadata_MetadataType.Array:
      return "Array";
    case RequestMetadata_MetadataType.BytesArray:
      return "BytesArray";
    case RequestMetadata_MetadataType.Amount:
      return "Amount";
    case RequestMetadata_MetadataType.SignedBigInt:
      return "SignedBigInt";
    case RequestMetadata_MetadataType.Operation:
      return "Operation";
    case RequestMetadata_MetadataType.BytesHash:
      return "BytesHash";
    case RequestMetadata_MetadataType.WhitelistedContractAddress:
      return "WhitelistedContractAddress";
    case RequestMetadata_MetadataType.WhitelistedContractAddressArray:
      return "WhitelistedContractAddressArray";
    case RequestMetadata_MetadataType.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

export interface RequestMetadata_ArrayElems {
  type: RequestMetadata_MetadataType;
  value: Uint8Array[];
}

export interface RequestMetadata_TupleElems {
  elems: RequestMetadata_TupleElems_Elem[];
}

export interface RequestMetadata_TupleElems_Elem {
  type: RequestMetadata_MetadataType;
  value: Uint8Array;
}

export interface RequestMetadata_XOperation {
  operation: string;
  arguments: RequestMetadata_XOperation_Arg[];
}

export interface RequestMetadata_XOperation_Arg {
  type: RequestMetadata_MetadataType;
  value: Uint8Array;
}

export interface SignedBigInt {
  negative: boolean;
  payload: Uint8Array;
}

export interface BytesArray {
  payload: Uint8Array[];
}

export interface BigIntArray {
  payload: Uint8Array[];
}

export interface StringArray {
  payload: string[];
}

export interface Amount {
  valueFrom: Uint8Array;
  valueTo: string;
  rate: string;
  decimals: number;
  currencyFrom: string;
  currencyTo: string;
  /** signatures of the sha256 hash of a json serialized string ({"blockchain":"ETH","currencyFrom":"BNB","currencyTo":"CHF","decimals":"18", "rate":"123.1000"}) by user with the role "priceupdater" */
  signatures: UserSignature[];
}

export interface UserSignatures {
  signatures: UserSignature[];
}

export interface UserSignature {
  userId: string;
  signature: Uint8Array;
  comment: string;
}

export interface SignedRequestsEnvelope {
  id: string;
  /** payload is signed by the core */
  payloadSignature:
    | UserSignature
    | undefined;
  /** contains a serialized "RequestsEnvelope" */
  payload: Uint8Array;
  /**
   * If this field is set, all fields with index under 1000 must be absent.
   * This lets us keep deserialization simple, and backwards-compatible
   */
  encryptedPayload:
    | EncryptedSignedRequestsEnvelope
    | undefined;
  /** Always sent in cleartext, not contained within the encrypted container */
  enableTracing: boolean;
}

export interface EncryptedSignedRequestsEnvelope {
  /** Must match the tenant inside the payload */
  tenant: number;
  iv: Uint8Array;
  /** decrypts to a packed SignedRequestsEnvelope */
  ciphertext: Uint8Array;
  /** Uncompressed 65 bytes (0x04::x::y) "public key" format */
  ecPoint: Uint8Array;
  /** hmac-sha256(key,ciphertext) */
  mac: Uint8Array;
}

export interface RequestsEnvelope {
  ts: number;
  /** HSM slot */
  slot: number;
  /** HSM has N admin public keys and a signature threshold M for admins loaded during key ceremony. HSM must check that at least M signatures are correct */
  rulesSignatures: UserSignature[];
  /** contains a serialized "RulesContainer" message */
  rules: Uint8Array;
  requests: RequestEnvelope[];
}

/** This message is used for routing to the right cylinder */
export interface RequestEnvelope {
  id: string;
  ts: number;
  blockchain: Blockchain;
  payloadType: RequestEnvelope_PayloadType;
  /** contains a serialized  "Request" message: e.g. TransactionRequest, BTCAddressRequest, HMACRequest, etc. */
  payload: Uint8Array;
  network: RequestEnvelope_Network;
  networkId: string;
}

export enum RequestEnvelope_Network {
  Mainnet = 0,
  Testnet = 1,
  UNRECOGNIZED = -1,
}

export function requestEnvelope_NetworkFromJSON(object: any): RequestEnvelope_Network {
  switch (object) {
    case 0:
    case "Mainnet":
      return RequestEnvelope_Network.Mainnet;
    case 1:
    case "Testnet":
      return RequestEnvelope_Network.Testnet;
    case -1:
    case "UNRECOGNIZED":
    default:
      return RequestEnvelope_Network.UNRECOGNIZED;
  }
}

export function requestEnvelope_NetworkToJSON(object: RequestEnvelope_Network): string {
  switch (object) {
    case RequestEnvelope_Network.Mainnet:
      return "Mainnet";
    case RequestEnvelope_Network.Testnet:
      return "Testnet";
    case RequestEnvelope_Network.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

/** 1:1 mapping between PayloadType and serialized Message, update envelope deserialization when updating */
export enum RequestEnvelope_PayloadType {
  TransactionRequest = 0,
  HMACRequest = 1,
  BTCAddressRequest = 3,
  BCHAddressRequest = 4,
  LTCAddressRequest = 5,
  /** XLMAddressRequest - BSVAddressRequest = 6;    // keep this line to show that this field is reserved forever */
  XLMAddressRequest = 7,
  XRPAddressRequest = 8,
  ETHAddressRequest = 9,
  /**
   * BTCProofOfReserveRequest - ETCAddressRequest = 10;   // keep this line to show that this field is reserved forever
   * NEOAddressRequest = 11;   // keep this line to show that this field is reserved forever
   * GRAMAddressRequest = 12;  // keep this line to show that this field is reserved forever
   */
  BTCProofOfReserveRequest = 13,
  BCHProofOfReserveRequest = 14,
  LTCProofOfReserveRequest = 15,
  /** XLMProofOfReserveRequest - BSVProofOfReserveRequest = 16;   // keep this line to show that this field is reserved forever */
  XLMProofOfReserveRequest = 17,
  XRPProofOfReserveRequest = 18,
  ETHProofOfReserveRequest = 19,
  /**
   * XTZAddressRequest - ETCProofOfReserveRequest = 20;   // keep this line to show that this field is reserved forever
   * NEOProofOfReserveRequest = 21;   // keep this line to show that this field is reserved forever
   * GRAMProofOfReserveRequest = 22;  // keep this line to show that this field is reserved forever
   */
  XTZAddressRequest = 23,
  XTZProofOfReserveRequest = 24,
  XTZRevealRequest = 25,
  /**
   * ADAAddressRequest - DiemAddressRequest = 26;        // keep this line to show that this field is reserved forever
   * DiemProofOfReserveRequest = 27; // keep this line to show that this field is reserved forever
   * DiemJWTRequest = 28;            // keep this line to show that this field is reserved forever
   */
  ADAAddressRequest = 29,
  ADAProofOfReserveRequest = 30,
  NoSignatureNeededRequest = 31,
  DOTAddressRequest = 32,
  DOTProofOfReserveRequest = 33,
  FTMAddressRequest = 34,
  FTMProofOfReserveRequest = 35,
  ALGOAddressRequest = 36,
  ALGOProofOfReserveRequest = 37,
  SOLAddressRequest = 38,
  SOLProofOfReserveRequest = 39,
  CosmosAddressRequest = 40,
  CosmosProofOfReserveRequest = 41,
  ETHSignTextRequest = 42,
  PolygonAddressRequest = 43,
  PolygonProofOfReserveRequest = 44,
  PolygonSignTextRequest = 45,
  BundleTransactionRequest = 46,
  NEARAddressRequest = 47,
  NEARProofOfReserveRequest = 48,
  AvaxCChainAddressRequest = 49,
  AvaxCChainProofOfReserveRequest = 50,
  AvaxCChainSignTextRequest = 51,
  BTCSignTextRequest = 52,
  ICPAddressRequest = 53,
  ICPProofOfReserveRequest = 54,
  ICPClaimOrRefreshRequest = 55,
  ICPSetAutoStakeRewardsRequest = 56,
  ICPSpawnRequest = 57,
  ICPDisburseToPrimaryRequest = 58,
  ICPListNeuronsRequests = 59,
  TnPledgeActionRequest = 60,
  MonitoringRequest = 61,
  TAOAddressRequest = 62,
  TAOProofOfReserveRequest = 63,
  DOGEAddressRequest = 64,
  DOGEProofOfReserveRequest = 65,
  HederaProofOfReserveRequest = 66,
  HederaAddressRequest = 67,
  SonicAddressRequest = 68,
  SonicProofOfReserveRequest = 69,
  ICPRefreshVotingPowerRequest = 70,
  MinaProofOfReserveRequest = 71,
  MinaAddressRequest = 72,
  FilecoinAddressRequest = 73,
  FilecoinProofOfReserveRequest = 74,
  TRONProofOfReserveRequest = 75,
  TRONAddressRequest = 76,
  ICPDisburseMaturityToPrimaryRequest = 77,
  /** CantonAddressRequest - ... */
  CantonAddressRequest = 78,
  CantonProofOfReserveRequest = 79,
  CantonCreateTransferPreapprovalProposal = 80,
  SOLCleanupDerivedAccountRequest = 81,
  UNRECOGNIZED = -1,
}

export function requestEnvelope_PayloadTypeFromJSON(object: any): RequestEnvelope_PayloadType {
  switch (object) {
    case 0:
    case "TransactionRequest":
      return RequestEnvelope_PayloadType.TransactionRequest;
    case 1:
    case "HMACRequest":
      return RequestEnvelope_PayloadType.HMACRequest;
    case 3:
    case "BTCAddressRequest":
      return RequestEnvelope_PayloadType.BTCAddressRequest;
    case 4:
    case "BCHAddressRequest":
      return RequestEnvelope_PayloadType.BCHAddressRequest;
    case 5:
    case "LTCAddressRequest":
      return RequestEnvelope_PayloadType.LTCAddressRequest;
    case 7:
    case "XLMAddressRequest":
      return RequestEnvelope_PayloadType.XLMAddressRequest;
    case 8:
    case "XRPAddressRequest":
      return RequestEnvelope_PayloadType.XRPAddressRequest;
    case 9:
    case "ETHAddressRequest":
      return RequestEnvelope_PayloadType.ETHAddressRequest;
    case 13:
    case "BTCProofOfReserveRequest":
      return RequestEnvelope_PayloadType.BTCProofOfReserveRequest;
    case 14:
    case "BCHProofOfReserveRequest":
      return RequestEnvelope_PayloadType.BCHProofOfReserveRequest;
    case 15:
    case "LTCProofOfReserveRequest":
      return RequestEnvelope_PayloadType.LTCProofOfReserveRequest;
    case 17:
    case "XLMProofOfReserveRequest":
      return RequestEnvelope_PayloadType.XLMProofOfReserveRequest;
    case 18:
    case "XRPProofOfReserveRequest":
      return RequestEnvelope_PayloadType.XRPProofOfReserveRequest;
    case 19:
    case "ETHProofOfReserveRequest":
      return RequestEnvelope_PayloadType.ETHProofOfReserveRequest;
    case 23:
    case "XTZAddressRequest":
      return RequestEnvelope_PayloadType.XTZAddressRequest;
    case 24:
    case "XTZProofOfReserveRequest":
      return RequestEnvelope_PayloadType.XTZProofOfReserveRequest;
    case 25:
    case "XTZRevealRequest":
      return RequestEnvelope_PayloadType.XTZRevealRequest;
    case 29:
    case "ADAAddressRequest":
      return RequestEnvelope_PayloadType.ADAAddressRequest;
    case 30:
    case "ADAProofOfReserveRequest":
      return RequestEnvelope_PayloadType.ADAProofOfReserveRequest;
    case 31:
    case "NoSignatureNeededRequest":
      return RequestEnvelope_PayloadType.NoSignatureNeededRequest;
    case 32:
    case "DOTAddressRequest":
      return RequestEnvelope_PayloadType.DOTAddressRequest;
    case 33:
    case "DOTProofOfReserveRequest":
      return RequestEnvelope_PayloadType.DOTProofOfReserveRequest;
    case 34:
    case "FTMAddressRequest":
      return RequestEnvelope_PayloadType.FTMAddressRequest;
    case 35:
    case "FTMProofOfReserveRequest":
      return RequestEnvelope_PayloadType.FTMProofOfReserveRequest;
    case 36:
    case "ALGOAddressRequest":
      return RequestEnvelope_PayloadType.ALGOAddressRequest;
    case 37:
    case "ALGOProofOfReserveRequest":
      return RequestEnvelope_PayloadType.ALGOProofOfReserveRequest;
    case 38:
    case "SOLAddressRequest":
      return RequestEnvelope_PayloadType.SOLAddressRequest;
    case 39:
    case "SOLProofOfReserveRequest":
      return RequestEnvelope_PayloadType.SOLProofOfReserveRequest;
    case 40:
    case "CosmosAddressRequest":
      return RequestEnvelope_PayloadType.CosmosAddressRequest;
    case 41:
    case "CosmosProofOfReserveRequest":
      return RequestEnvelope_PayloadType.CosmosProofOfReserveRequest;
    case 42:
    case "ETHSignTextRequest":
      return RequestEnvelope_PayloadType.ETHSignTextRequest;
    case 43:
    case "PolygonAddressRequest":
      return RequestEnvelope_PayloadType.PolygonAddressRequest;
    case 44:
    case "PolygonProofOfReserveRequest":
      return RequestEnvelope_PayloadType.PolygonProofOfReserveRequest;
    case 45:
    case "PolygonSignTextRequest":
      return RequestEnvelope_PayloadType.PolygonSignTextRequest;
    case 46:
    case "BundleTransactionRequest":
      return RequestEnvelope_PayloadType.BundleTransactionRequest;
    case 47:
    case "NEARAddressRequest":
      return RequestEnvelope_PayloadType.NEARAddressRequest;
    case 48:
    case "NEARProofOfReserveRequest":
      return RequestEnvelope_PayloadType.NEARProofOfReserveRequest;
    case 49:
    case "AvaxCChainAddressRequest":
      return RequestEnvelope_PayloadType.AvaxCChainAddressRequest;
    case 50:
    case "AvaxCChainProofOfReserveRequest":
      return RequestEnvelope_PayloadType.AvaxCChainProofOfReserveRequest;
    case 51:
    case "AvaxCChainSignTextRequest":
      return RequestEnvelope_PayloadType.AvaxCChainSignTextRequest;
    case 52:
    case "BTCSignTextRequest":
      return RequestEnvelope_PayloadType.BTCSignTextRequest;
    case 53:
    case "ICPAddressRequest":
      return RequestEnvelope_PayloadType.ICPAddressRequest;
    case 54:
    case "ICPProofOfReserveRequest":
      return RequestEnvelope_PayloadType.ICPProofOfReserveRequest;
    case 55:
    case "ICPClaimOrRefreshRequest":
      return RequestEnvelope_PayloadType.ICPClaimOrRefreshRequest;
    case 56:
    case "ICPSetAutoStakeRewardsRequest":
      return RequestEnvelope_PayloadType.ICPSetAutoStakeRewardsRequest;
    case 57:
    case "ICPSpawnRequest":
      return RequestEnvelope_PayloadType.ICPSpawnRequest;
    case 58:
    case "ICPDisburseToPrimaryRequest":
      return RequestEnvelope_PayloadType.ICPDisburseToPrimaryRequest;
    case 59:
    case "ICPListNeuronsRequests":
      return RequestEnvelope_PayloadType.ICPListNeuronsRequests;
    case 60:
    case "TnPledgeActionRequest":
      return RequestEnvelope_PayloadType.TnPledgeActionRequest;
    case 61:
    case "MonitoringRequest":
      return RequestEnvelope_PayloadType.MonitoringRequest;
    case 62:
    case "TAOAddressRequest":
      return RequestEnvelope_PayloadType.TAOAddressRequest;
    case 63:
    case "TAOProofOfReserveRequest":
      return RequestEnvelope_PayloadType.TAOProofOfReserveRequest;
    case 64:
    case "DOGEAddressRequest":
      return RequestEnvelope_PayloadType.DOGEAddressRequest;
    case 65:
    case "DOGEProofOfReserveRequest":
      return RequestEnvelope_PayloadType.DOGEProofOfReserveRequest;
    case 66:
    case "HederaProofOfReserveRequest":
      return RequestEnvelope_PayloadType.HederaProofOfReserveRequest;
    case 67:
    case "HederaAddressRequest":
      return RequestEnvelope_PayloadType.HederaAddressRequest;
    case 68:
    case "SonicAddressRequest":
      return RequestEnvelope_PayloadType.SonicAddressRequest;
    case 69:
    case "SonicProofOfReserveRequest":
      return RequestEnvelope_PayloadType.SonicProofOfReserveRequest;
    case 70:
    case "ICPRefreshVotingPowerRequest":
      return RequestEnvelope_PayloadType.ICPRefreshVotingPowerRequest;
    case 71:
    case "MinaProofOfReserveRequest":
      return RequestEnvelope_PayloadType.MinaProofOfReserveRequest;
    case 72:
    case "MinaAddressRequest":
      return RequestEnvelope_PayloadType.MinaAddressRequest;
    case 73:
    case "FilecoinAddressRequest":
      return RequestEnvelope_PayloadType.FilecoinAddressRequest;
    case 74:
    case "FilecoinProofOfReserveRequest":
      return RequestEnvelope_PayloadType.FilecoinProofOfReserveRequest;
    case 75:
    case "TRONProofOfReserveRequest":
      return RequestEnvelope_PayloadType.TRONProofOfReserveRequest;
    case 76:
    case "TRONAddressRequest":
      return RequestEnvelope_PayloadType.TRONAddressRequest;
    case 77:
    case "ICPDisburseMaturityToPrimaryRequest":
      return RequestEnvelope_PayloadType.ICPDisburseMaturityToPrimaryRequest;
    case 78:
    case "CantonAddressRequest":
      return RequestEnvelope_PayloadType.CantonAddressRequest;
    case 79:
    case "CantonProofOfReserveRequest":
      return RequestEnvelope_PayloadType.CantonProofOfReserveRequest;
    case 80:
    case "CantonCreateTransferPreapprovalProposal":
      return RequestEnvelope_PayloadType.CantonCreateTransferPreapprovalProposal;
    case 81:
    case "SOLCleanupDerivedAccountRequest":
      return RequestEnvelope_PayloadType.SOLCleanupDerivedAccountRequest;
    case -1:
    case "UNRECOGNIZED":
    default:
      return RequestEnvelope_PayloadType.UNRECOGNIZED;
  }
}

export function requestEnvelope_PayloadTypeToJSON(object: RequestEnvelope_PayloadType): string {
  switch (object) {
    case RequestEnvelope_PayloadType.TransactionRequest:
      return "TransactionRequest";
    case RequestEnvelope_PayloadType.HMACRequest:
      return "HMACRequest";
    case RequestEnvelope_PayloadType.BTCAddressRequest:
      return "BTCAddressRequest";
    case RequestEnvelope_PayloadType.BCHAddressRequest:
      return "BCHAddressRequest";
    case RequestEnvelope_PayloadType.LTCAddressRequest:
      return "LTCAddressRequest";
    case RequestEnvelope_PayloadType.XLMAddressRequest:
      return "XLMAddressRequest";
    case RequestEnvelope_PayloadType.XRPAddressRequest:
      return "XRPAddressRequest";
    case RequestEnvelope_PayloadType.ETHAddressRequest:
      return "ETHAddressRequest";
    case RequestEnvelope_PayloadType.BTCProofOfReserveRequest:
      return "BTCProofOfReserveRequest";
    case RequestEnvelope_PayloadType.BCHProofOfReserveRequest:
      return "BCHProofOfReserveRequest";
    case RequestEnvelope_PayloadType.LTCProofOfReserveRequest:
      return "LTCProofOfReserveRequest";
    case RequestEnvelope_PayloadType.XLMProofOfReserveRequest:
      return "XLMProofOfReserveRequest";
    case RequestEnvelope_PayloadType.XRPProofOfReserveRequest:
      return "XRPProofOfReserveRequest";
    case RequestEnvelope_PayloadType.ETHProofOfReserveRequest:
      return "ETHProofOfReserveRequest";
    case RequestEnvelope_PayloadType.XTZAddressRequest:
      return "XTZAddressRequest";
    case RequestEnvelope_PayloadType.XTZProofOfReserveRequest:
      return "XTZProofOfReserveRequest";
    case RequestEnvelope_PayloadType.XTZRevealRequest:
      return "XTZRevealRequest";
    case RequestEnvelope_PayloadType.ADAAddressRequest:
      return "ADAAddressRequest";
    case RequestEnvelope_PayloadType.ADAProofOfReserveRequest:
      return "ADAProofOfReserveRequest";
    case RequestEnvelope_PayloadType.NoSignatureNeededRequest:
      return "NoSignatureNeededRequest";
    case RequestEnvelope_PayloadType.DOTAddressRequest:
      return "DOTAddressRequest";
    case RequestEnvelope_PayloadType.DOTProofOfReserveRequest:
      return "DOTProofOfReserveRequest";
    case RequestEnvelope_PayloadType.FTMAddressRequest:
      return "FTMAddressRequest";
    case RequestEnvelope_PayloadType.FTMProofOfReserveRequest:
      return "FTMProofOfReserveRequest";
    case RequestEnvelope_PayloadType.ALGOAddressRequest:
      return "ALGOAddressRequest";
    case RequestEnvelope_PayloadType.ALGOProofOfReserveRequest:
      return "ALGOProofOfReserveRequest";
    case RequestEnvelope_PayloadType.SOLAddressRequest:
      return "SOLAddressRequest";
    case RequestEnvelope_PayloadType.SOLProofOfReserveRequest:
      return "SOLProofOfReserveRequest";
    case RequestEnvelope_PayloadType.CosmosAddressRequest:
      return "CosmosAddressRequest";
    case RequestEnvelope_PayloadType.CosmosProofOfReserveRequest:
      return "CosmosProofOfReserveRequest";
    case RequestEnvelope_PayloadType.ETHSignTextRequest:
      return "ETHSignTextRequest";
    case RequestEnvelope_PayloadType.PolygonAddressRequest:
      return "PolygonAddressRequest";
    case RequestEnvelope_PayloadType.PolygonProofOfReserveRequest:
      return "PolygonProofOfReserveRequest";
    case RequestEnvelope_PayloadType.PolygonSignTextRequest:
      return "PolygonSignTextRequest";
    case RequestEnvelope_PayloadType.BundleTransactionRequest:
      return "BundleTransactionRequest";
    case RequestEnvelope_PayloadType.NEARAddressRequest:
      return "NEARAddressRequest";
    case RequestEnvelope_PayloadType.NEARProofOfReserveRequest:
      return "NEARProofOfReserveRequest";
    case RequestEnvelope_PayloadType.AvaxCChainAddressRequest:
      return "AvaxCChainAddressRequest";
    case RequestEnvelope_PayloadType.AvaxCChainProofOfReserveRequest:
      return "AvaxCChainProofOfReserveRequest";
    case RequestEnvelope_PayloadType.AvaxCChainSignTextRequest:
      return "AvaxCChainSignTextRequest";
    case RequestEnvelope_PayloadType.BTCSignTextRequest:
      return "BTCSignTextRequest";
    case RequestEnvelope_PayloadType.ICPAddressRequest:
      return "ICPAddressRequest";
    case RequestEnvelope_PayloadType.ICPProofOfReserveRequest:
      return "ICPProofOfReserveRequest";
    case RequestEnvelope_PayloadType.ICPClaimOrRefreshRequest:
      return "ICPClaimOrRefreshRequest";
    case RequestEnvelope_PayloadType.ICPSetAutoStakeRewardsRequest:
      return "ICPSetAutoStakeRewardsRequest";
    case RequestEnvelope_PayloadType.ICPSpawnRequest:
      return "ICPSpawnRequest";
    case RequestEnvelope_PayloadType.ICPDisburseToPrimaryRequest:
      return "ICPDisburseToPrimaryRequest";
    case RequestEnvelope_PayloadType.ICPListNeuronsRequests:
      return "ICPListNeuronsRequests";
    case RequestEnvelope_PayloadType.TnPledgeActionRequest:
      return "TnPledgeActionRequest";
    case RequestEnvelope_PayloadType.MonitoringRequest:
      return "MonitoringRequest";
    case RequestEnvelope_PayloadType.TAOAddressRequest:
      return "TAOAddressRequest";
    case RequestEnvelope_PayloadType.TAOProofOfReserveRequest:
      return "TAOProofOfReserveRequest";
    case RequestEnvelope_PayloadType.DOGEAddressRequest:
      return "DOGEAddressRequest";
    case RequestEnvelope_PayloadType.DOGEProofOfReserveRequest:
      return "DOGEProofOfReserveRequest";
    case RequestEnvelope_PayloadType.HederaProofOfReserveRequest:
      return "HederaProofOfReserveRequest";
    case RequestEnvelope_PayloadType.HederaAddressRequest:
      return "HederaAddressRequest";
    case RequestEnvelope_PayloadType.SonicAddressRequest:
      return "SonicAddressRequest";
    case RequestEnvelope_PayloadType.SonicProofOfReserveRequest:
      return "SonicProofOfReserveRequest";
    case RequestEnvelope_PayloadType.ICPRefreshVotingPowerRequest:
      return "ICPRefreshVotingPowerRequest";
    case RequestEnvelope_PayloadType.MinaProofOfReserveRequest:
      return "MinaProofOfReserveRequest";
    case RequestEnvelope_PayloadType.MinaAddressRequest:
      return "MinaAddressRequest";
    case RequestEnvelope_PayloadType.FilecoinAddressRequest:
      return "FilecoinAddressRequest";
    case RequestEnvelope_PayloadType.FilecoinProofOfReserveRequest:
      return "FilecoinProofOfReserveRequest";
    case RequestEnvelope_PayloadType.TRONProofOfReserveRequest:
      return "TRONProofOfReserveRequest";
    case RequestEnvelope_PayloadType.TRONAddressRequest:
      return "TRONAddressRequest";
    case RequestEnvelope_PayloadType.ICPDisburseMaturityToPrimaryRequest:
      return "ICPDisburseMaturityToPrimaryRequest";
    case RequestEnvelope_PayloadType.CantonAddressRequest:
      return "CantonAddressRequest";
    case RequestEnvelope_PayloadType.CantonProofOfReserveRequest:
      return "CantonProofOfReserveRequest";
    case RequestEnvelope_PayloadType.CantonCreateTransferPreapprovalProposal:
      return "CantonCreateTransferPreapprovalProposal";
    case RequestEnvelope_PayloadType.SOLCleanupDerivedAccountRequest:
      return "SOLCleanupDerivedAccountRequest";
    case RequestEnvelope_PayloadType.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

export interface RequestSignature {
  signature: UserSignature | undefined;
  hashes: string[];
}

export interface HMACRequest {
  type: HMACRequest_HMACType;
  /** secret's label */
  label: string;
  /** contains the payload to be HMACed */
  payload: Uint8Array;
  signatures: RequestSignature[];
  metadata: RequestMetadata[];
}

/** 1:1 mapping between PayloadType and serialized Message */
export enum HMACRequest_HMACType {
  HMACSHA256 = 0,
  HMACSHA384 = 1,
  HMACSHA512 = 2,
  UNRECOGNIZED = -1,
}

export function hMACRequest_HMACTypeFromJSON(object: any): HMACRequest_HMACType {
  switch (object) {
    case 0:
    case "HMACSHA256":
      return HMACRequest_HMACType.HMACSHA256;
    case 1:
    case "HMACSHA384":
      return HMACRequest_HMACType.HMACSHA384;
    case 2:
    case "HMACSHA512":
      return HMACRequest_HMACType.HMACSHA512;
    case -1:
    case "UNRECOGNIZED":
    default:
      return HMACRequest_HMACType.UNRECOGNIZED;
  }
}

export function hMACRequest_HMACTypeToJSON(object: HMACRequest_HMACType): string {
  switch (object) {
    case HMACRequest_HMACType.HMACSHA256:
      return "HMACSHA256";
    case HMACRequest_HMACType.HMACSHA384:
      return "HMACSHA384";
    case HMACRequest_HMACType.HMACSHA512:
      return "HMACSHA512";
    case HMACRequest_HMACType.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

/** TODO: Maybe better to have dedicated requests ? (message CoinbaseCustodyWithdrawalRequest, SignetXXRequest ...) */
export interface NoSignatureNeededRequest {
  type: NoSignatureNeededRequest_RequestType;
  signatures: RequestSignature[];
  metadata: RequestMetadata[];
}

export enum NoSignatureNeededRequest_RequestType {
  CoinbaseCustodyWithdrawal = 0,
  SignetRedeem = 1,
  SignetDeposit = 2,
  SignetSend = 3,
  WoortonWithdrawal = 4,
  ETHStakingExit = 5,
  FiatProviderDeposit = 6,
  FiatProviderWithdrawal = 7,
  FiatProviderTransfer = 8,
  UNRECOGNIZED = -1,
}

export function noSignatureNeededRequest_RequestTypeFromJSON(object: any): NoSignatureNeededRequest_RequestType {
  switch (object) {
    case 0:
    case "CoinbaseCustodyWithdrawal":
      return NoSignatureNeededRequest_RequestType.CoinbaseCustodyWithdrawal;
    case 1:
    case "SignetRedeem":
      return NoSignatureNeededRequest_RequestType.SignetRedeem;
    case 2:
    case "SignetDeposit":
      return NoSignatureNeededRequest_RequestType.SignetDeposit;
    case 3:
    case "SignetSend":
      return NoSignatureNeededRequest_RequestType.SignetSend;
    case 4:
    case "WoortonWithdrawal":
      return NoSignatureNeededRequest_RequestType.WoortonWithdrawal;
    case 5:
    case "ETHStakingExit":
      return NoSignatureNeededRequest_RequestType.ETHStakingExit;
    case 6:
    case "FiatProviderDeposit":
      return NoSignatureNeededRequest_RequestType.FiatProviderDeposit;
    case 7:
    case "FiatProviderWithdrawal":
      return NoSignatureNeededRequest_RequestType.FiatProviderWithdrawal;
    case 8:
    case "FiatProviderTransfer":
      return NoSignatureNeededRequest_RequestType.FiatProviderTransfer;
    case -1:
    case "UNRECOGNIZED":
    default:
      return NoSignatureNeededRequest_RequestType.UNRECOGNIZED;
  }
}

export function noSignatureNeededRequest_RequestTypeToJSON(object: NoSignatureNeededRequest_RequestType): string {
  switch (object) {
    case NoSignatureNeededRequest_RequestType.CoinbaseCustodyWithdrawal:
      return "CoinbaseCustodyWithdrawal";
    case NoSignatureNeededRequest_RequestType.SignetRedeem:
      return "SignetRedeem";
    case NoSignatureNeededRequest_RequestType.SignetDeposit:
      return "SignetDeposit";
    case NoSignatureNeededRequest_RequestType.SignetSend:
      return "SignetSend";
    case NoSignatureNeededRequest_RequestType.WoortonWithdrawal:
      return "WoortonWithdrawal";
    case NoSignatureNeededRequest_RequestType.ETHStakingExit:
      return "ETHStakingExit";
    case NoSignatureNeededRequest_RequestType.FiatProviderDeposit:
      return "FiatProviderDeposit";
    case NoSignatureNeededRequest_RequestType.FiatProviderWithdrawal:
      return "FiatProviderWithdrawal";
    case NoSignatureNeededRequest_RequestType.FiatProviderTransfer:
      return "FiatProviderTransfer";
    case NoSignatureNeededRequest_RequestType.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

export interface Commitment {
  kind: CommitmentKind;
  commitment: Uint8Array;
  intent: Uint8Array;
  /**
   * Signatures are over the sha256(<commitment_type>::sha256(commitment_bytes)::<metadata_hash>)
   * where commitment type is the string representation of the name of the commitment message in protobuf
   * This is meant to prevent passing off one type of commitment as another.
   */
  signatures: UserSignature[];
}

export interface TnPledgeActionRequest {
  action: TnPledgeActionRequest_PledgeAction;
  signatures: RequestSignature[];
  metadata: RequestMetadata[];
}

export enum TnPledgeActionRequest_PledgeAction {
  CreatePledge = 0,
  AcceptPledge = 1,
  Unpledge = 2,
  AddCollateral = 3,
  WithdrawPledge = 4,
  InitiateWithdrawPledge = 5,
  UNRECOGNIZED = -1,
}

export function tnPledgeActionRequest_PledgeActionFromJSON(object: any): TnPledgeActionRequest_PledgeAction {
  switch (object) {
    case 0:
    case "CreatePledge":
      return TnPledgeActionRequest_PledgeAction.CreatePledge;
    case 1:
    case "AcceptPledge":
      return TnPledgeActionRequest_PledgeAction.AcceptPledge;
    case 2:
    case "Unpledge":
      return TnPledgeActionRequest_PledgeAction.Unpledge;
    case 3:
    case "AddCollateral":
      return TnPledgeActionRequest_PledgeAction.AddCollateral;
    case 4:
    case "WithdrawPledge":
      return TnPledgeActionRequest_PledgeAction.WithdrawPledge;
    case 5:
    case "InitiateWithdrawPledge":
      return TnPledgeActionRequest_PledgeAction.InitiateWithdrawPledge;
    case -1:
    case "UNRECOGNIZED":
    default:
      return TnPledgeActionRequest_PledgeAction.UNRECOGNIZED;
  }
}

export function tnPledgeActionRequest_PledgeActionToJSON(object: TnPledgeActionRequest_PledgeAction): string {
  switch (object) {
    case TnPledgeActionRequest_PledgeAction.CreatePledge:
      return "CreatePledge";
    case TnPledgeActionRequest_PledgeAction.AcceptPledge:
      return "AcceptPledge";
    case TnPledgeActionRequest_PledgeAction.Unpledge:
      return "Unpledge";
    case TnPledgeActionRequest_PledgeAction.AddCollateral:
      return "AddCollateral";
    case TnPledgeActionRequest_PledgeAction.WithdrawPledge:
      return "WithdrawPledge";
    case TnPledgeActionRequest_PledgeAction.InitiateWithdrawPledge:
      return "InitiateWithdrawPledge";
    case TnPledgeActionRequest_PledgeAction.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

export interface MonitoringRequest {
}

export interface TransactionRequest {
  payloadType: TransactionRequest_PayloadType;
  /** contains a serialized blockchain specific message, like "BTCTransactionRequest", "XLMPaymentsRequest" */
  payload: Uint8Array;
  /** In order to verify the signatures, the payload has to be decoded to find the proper keys set based on the address or the wallet from the rules */
  signatures: RequestSignature[];
  metadata: RequestMetadata[];
  commitment: Commitment | undefined;
}

/**
 * 1:1 mapping between PayloadType and serialized Message, update envelope deserialization when updating
 * Must end with "Request"
 */
export enum TransactionRequest_PayloadType {
  BTCTransactionRequest = 0,
  BCHTransactionRequest = 1,
  LTCTransactionRequest = 2,
  /**
   * XLMPaymentsRequest - BSVTransactionRequest = 3; // keep this line to show that this field is reserved forever
   * NEOPaymentRequest = 4;     // keep this line to show that this field is reserved forever
   * NEOClaimRequest = 5;       // keep this line to show that this field is reserved forever
   */
  XLMPaymentsRequest = 6,
  XRPPaymentsRequest = 8,
  ETHTransactionsRequest = 9,
  /**
   * XTZTransactionsRequest - ETCTransactionsRequest = 10;  // keep this line to show that this field is reserved forever
   * GRAMTransfersRequest = 11;    // keep this line to show that this field is reserved forever
   * GRAMNewStakeRequest = 12;     // keep this line to show that this field is reserved forever
   * GRAMRecoverStakeRequest = 13; // keep this line to show that this field is reserved forever
   */
  XTZTransactionsRequest = 14,
  XTZDelegationsRequest = 15,
  ETHCreateContractRequest = 16,
  XTZBlockHeaderRequest = 17,
  /**
   * XTZFA12TransfersRequest - DiemTransfersRequest = 18;       // keep this line to show that this field is reserved forever
   * DiemAuthKeyRotationRequest = 19; // keep this line to show that this field is reserved forever
   * DiemPreburnRequest = 20;         // keep this line to show that this field is reserved forever
   * DiemPremintRequest = 21;         // keep this line to show that this field is reserved forever
   */
  XTZFA12TransfersRequest = 22,
  XTZFA2TransfersRequest = 23,
  ETHWrappedTransactionsRequest = 24,
  ETHWrappedCreateContractRequest = 25,
  ADATransactionRequest = 26,
  ADADelegationRequest = 27,
  ADAUndelegationRequest = 28,
  ADAWithdrawalRequest = 29,
  XTZCreateContractRequest = 30,
  DOTTransactionsRequest = 31,
  DOTBondRequest = 32,
  DOTBondExtraRequest = 33,
  DOTChillRequest = 34,
  DOTUnbondRequest = 35,
  DOTNominateRequest = 36,
  DOTWithdrawUnbondedRequest = 37,
  DOTPayoutStakersRequest = 38,
  FTMTransactionsRequest = 39,
  FTMStakingDelegateRequest = 40,
  FTMStakingClaimRewardsRequest = 41,
  FTMStakingLockRequest = 42,
  ALGOTransactionsRequest = 43,
  ALGOAssetOptinRequest = 44,
  ALGOAssetTransferRequest = 45,
  SOLTransfersRequest = 46,
  /** SOLDelegateStakeRequest - SOLCreateStakeAddressRequest = 47; // keep this line to show that this field is reserved forever */
  SOLDelegateStakeRequest = 48,
  SOLDeactivateStakeRequest = 49,
  SOLWithdrawStakeRequest = 50,
  /** CosmosGenericCallRequest - SOLTransferToStakeRequest = 51; // keep this line to show that this field is reserved forever */
  CosmosGenericCallRequest = 52,
  CosmosCancelRequest = 53,
  PolygonTransactionsRequest = 54,
  PolygonCreateContractRequest = 55,
  PolygonWrappedTransactionsRequest = 56,
  PolygonWrappedCreateContractRequest = 57,
  NEARTransactionsRequest = 58,
  AvaxCChainTransactionsRequest = 59,
  AvaxCChainCreateContractRequest = 60,
  AvaxCChainWrappedTransactionsRequest = 61,
  AvaxCChainWrappedCreateContractRequest = 62,
  NEARDepositAndStakeRequest = 63,
  NEARUnstakeRequest = 64,
  NEARWithdrawRequest = 65,
  XLMChangeTrustRequest = 66,
  ICPTransferRequest = 67,
  XLMSetOptionsRequest = 68,
  XLMSetTrustlineFLagsRequest = 69,
  XLMManageDataRequest = 70,
  ICPTransferToStakeRequest = 71,
  ICPFollowRequest = 72,
  ICPSetDissolveDelayRequest = 73,
  ICPStartDissolvingRequest = 74,
  ICPDisburseRequest = 75,
  XLMCreateClaimableBalanceRequest = 76,
  XLMClaimClaimableBalanceRequest = 77,
  XLMClawbackClaimableBalanceRequest = 78,
  XLMRevokeSponsorshipRequest = 79,
  XLMClawbackRequest = 80,
  XLMMintAssetRequest = 81,
  XLMLiquidityPoolDepositRequest = 82,
  XLMLiquidityPoolWithdrawRequest = 83,
  XLMPathPaymentSendRequest = 84,
  XLMPathPaymentReceiveRequest = 85,
  XLMOfferRequest = 86,
  ICPICRC1TransferRequest = 87,
  SOLTokenTransfersRequest = 88,
  SOLTokenCreateRequest = 89,
  SOLTokenMintRequest = 90,
  SOLTokenBurnRequest = 91,
  TAOTransactionsRequest = 92,
  TAOAddStakeRequest = 93,
  TAORemoveStakeRequest = 94,
  XTZStakeRequest = 95,
  XTZUnstakeRequest = 96,
  XTZFinalizeUnstakeRequest = 97,
  DOGETransactionRequest = 98,
  HederaTransactionsRequest = 99,
  SonicTransactionsRequest = 100,
  SonicStakingDelegateRequest = 101,
  SonicStakingClaimRewardsRequest = 102,
  MinaPaymentsRequest = 103,
  MinaDelegationRequest = 104,
  FilecoinTransactionsRequest = 105,
  ADAVoteDelegationRequest = 106,
  SOLPartialDeactivateStakeRequest = 107,
  SOLMergeStakeRequest = 108,
  TRONTransactionsRequest = 109,
  SOLTokenFreezeAccountRequest = 110,
  ICPDisburseMaturityToPrimary = 111,
  CantonTransactionsRequest = 112,
  UNRECOGNIZED = -1,
}

export function transactionRequest_PayloadTypeFromJSON(object: any): TransactionRequest_PayloadType {
  switch (object) {
    case 0:
    case "BTCTransactionRequest":
      return TransactionRequest_PayloadType.BTCTransactionRequest;
    case 1:
    case "BCHTransactionRequest":
      return TransactionRequest_PayloadType.BCHTransactionRequest;
    case 2:
    case "LTCTransactionRequest":
      return TransactionRequest_PayloadType.LTCTransactionRequest;
    case 6:
    case "XLMPaymentsRequest":
      return TransactionRequest_PayloadType.XLMPaymentsRequest;
    case 8:
    case "XRPPaymentsRequest":
      return TransactionRequest_PayloadType.XRPPaymentsRequest;
    case 9:
    case "ETHTransactionsRequest":
      return TransactionRequest_PayloadType.ETHTransactionsRequest;
    case 14:
    case "XTZTransactionsRequest":
      return TransactionRequest_PayloadType.XTZTransactionsRequest;
    case 15:
    case "XTZDelegationsRequest":
      return TransactionRequest_PayloadType.XTZDelegationsRequest;
    case 16:
    case "ETHCreateContractRequest":
      return TransactionRequest_PayloadType.ETHCreateContractRequest;
    case 17:
    case "XTZBlockHeaderRequest":
      return TransactionRequest_PayloadType.XTZBlockHeaderRequest;
    case 22:
    case "XTZFA12TransfersRequest":
      return TransactionRequest_PayloadType.XTZFA12TransfersRequest;
    case 23:
    case "XTZFA2TransfersRequest":
      return TransactionRequest_PayloadType.XTZFA2TransfersRequest;
    case 24:
    case "ETHWrappedTransactionsRequest":
      return TransactionRequest_PayloadType.ETHWrappedTransactionsRequest;
    case 25:
    case "ETHWrappedCreateContractRequest":
      return TransactionRequest_PayloadType.ETHWrappedCreateContractRequest;
    case 26:
    case "ADATransactionRequest":
      return TransactionRequest_PayloadType.ADATransactionRequest;
    case 27:
    case "ADADelegationRequest":
      return TransactionRequest_PayloadType.ADADelegationRequest;
    case 28:
    case "ADAUndelegationRequest":
      return TransactionRequest_PayloadType.ADAUndelegationRequest;
    case 29:
    case "ADAWithdrawalRequest":
      return TransactionRequest_PayloadType.ADAWithdrawalRequest;
    case 30:
    case "XTZCreateContractRequest":
      return TransactionRequest_PayloadType.XTZCreateContractRequest;
    case 31:
    case "DOTTransactionsRequest":
      return TransactionRequest_PayloadType.DOTTransactionsRequest;
    case 32:
    case "DOTBondRequest":
      return TransactionRequest_PayloadType.DOTBondRequest;
    case 33:
    case "DOTBondExtraRequest":
      return TransactionRequest_PayloadType.DOTBondExtraRequest;
    case 34:
    case "DOTChillRequest":
      return TransactionRequest_PayloadType.DOTChillRequest;
    case 35:
    case "DOTUnbondRequest":
      return TransactionRequest_PayloadType.DOTUnbondRequest;
    case 36:
    case "DOTNominateRequest":
      return TransactionRequest_PayloadType.DOTNominateRequest;
    case 37:
    case "DOTWithdrawUnbondedRequest":
      return TransactionRequest_PayloadType.DOTWithdrawUnbondedRequest;
    case 38:
    case "DOTPayoutStakersRequest":
      return TransactionRequest_PayloadType.DOTPayoutStakersRequest;
    case 39:
    case "FTMTransactionsRequest":
      return TransactionRequest_PayloadType.FTMTransactionsRequest;
    case 40:
    case "FTMStakingDelegateRequest":
      return TransactionRequest_PayloadType.FTMStakingDelegateRequest;
    case 41:
    case "FTMStakingClaimRewardsRequest":
      return TransactionRequest_PayloadType.FTMStakingClaimRewardsRequest;
    case 42:
    case "FTMStakingLockRequest":
      return TransactionRequest_PayloadType.FTMStakingLockRequest;
    case 43:
    case "ALGOTransactionsRequest":
      return TransactionRequest_PayloadType.ALGOTransactionsRequest;
    case 44:
    case "ALGOAssetOptinRequest":
      return TransactionRequest_PayloadType.ALGOAssetOptinRequest;
    case 45:
    case "ALGOAssetTransferRequest":
      return TransactionRequest_PayloadType.ALGOAssetTransferRequest;
    case 46:
    case "SOLTransfersRequest":
      return TransactionRequest_PayloadType.SOLTransfersRequest;
    case 48:
    case "SOLDelegateStakeRequest":
      return TransactionRequest_PayloadType.SOLDelegateStakeRequest;
    case 49:
    case "SOLDeactivateStakeRequest":
      return TransactionRequest_PayloadType.SOLDeactivateStakeRequest;
    case 50:
    case "SOLWithdrawStakeRequest":
      return TransactionRequest_PayloadType.SOLWithdrawStakeRequest;
    case 52:
    case "CosmosGenericCallRequest":
      return TransactionRequest_PayloadType.CosmosGenericCallRequest;
    case 53:
    case "CosmosCancelRequest":
      return TransactionRequest_PayloadType.CosmosCancelRequest;
    case 54:
    case "PolygonTransactionsRequest":
      return TransactionRequest_PayloadType.PolygonTransactionsRequest;
    case 55:
    case "PolygonCreateContractRequest":
      return TransactionRequest_PayloadType.PolygonCreateContractRequest;
    case 56:
    case "PolygonWrappedTransactionsRequest":
      return TransactionRequest_PayloadType.PolygonWrappedTransactionsRequest;
    case 57:
    case "PolygonWrappedCreateContractRequest":
      return TransactionRequest_PayloadType.PolygonWrappedCreateContractRequest;
    case 58:
    case "NEARTransactionsRequest":
      return TransactionRequest_PayloadType.NEARTransactionsRequest;
    case 59:
    case "AvaxCChainTransactionsRequest":
      return TransactionRequest_PayloadType.AvaxCChainTransactionsRequest;
    case 60:
    case "AvaxCChainCreateContractRequest":
      return TransactionRequest_PayloadType.AvaxCChainCreateContractRequest;
    case 61:
    case "AvaxCChainWrappedTransactionsRequest":
      return TransactionRequest_PayloadType.AvaxCChainWrappedTransactionsRequest;
    case 62:
    case "AvaxCChainWrappedCreateContractRequest":
      return TransactionRequest_PayloadType.AvaxCChainWrappedCreateContractRequest;
    case 63:
    case "NEARDepositAndStakeRequest":
      return TransactionRequest_PayloadType.NEARDepositAndStakeRequest;
    case 64:
    case "NEARUnstakeRequest":
      return TransactionRequest_PayloadType.NEARUnstakeRequest;
    case 65:
    case "NEARWithdrawRequest":
      return TransactionRequest_PayloadType.NEARWithdrawRequest;
    case 66:
    case "XLMChangeTrustRequest":
      return TransactionRequest_PayloadType.XLMChangeTrustRequest;
    case 67:
    case "ICPTransferRequest":
      return TransactionRequest_PayloadType.ICPTransferRequest;
    case 68:
    case "XLMSetOptionsRequest":
      return TransactionRequest_PayloadType.XLMSetOptionsRequest;
    case 69:
    case "XLMSetTrustlineFLagsRequest":
      return TransactionRequest_PayloadType.XLMSetTrustlineFLagsRequest;
    case 70:
    case "XLMManageDataRequest":
      return TransactionRequest_PayloadType.XLMManageDataRequest;
    case 71:
    case "ICPTransferToStakeRequest":
      return TransactionRequest_PayloadType.ICPTransferToStakeRequest;
    case 72:
    case "ICPFollowRequest":
      return TransactionRequest_PayloadType.ICPFollowRequest;
    case 73:
    case "ICPSetDissolveDelayRequest":
      return TransactionRequest_PayloadType.ICPSetDissolveDelayRequest;
    case 74:
    case "ICPStartDissolvingRequest":
      return TransactionRequest_PayloadType.ICPStartDissolvingRequest;
    case 75:
    case "ICPDisburseRequest":
      return TransactionRequest_PayloadType.ICPDisburseRequest;
    case 76:
    case "XLMCreateClaimableBalanceRequest":
      return TransactionRequest_PayloadType.XLMCreateClaimableBalanceRequest;
    case 77:
    case "XLMClaimClaimableBalanceRequest":
      return TransactionRequest_PayloadType.XLMClaimClaimableBalanceRequest;
    case 78:
    case "XLMClawbackClaimableBalanceRequest":
      return TransactionRequest_PayloadType.XLMClawbackClaimableBalanceRequest;
    case 79:
    case "XLMRevokeSponsorshipRequest":
      return TransactionRequest_PayloadType.XLMRevokeSponsorshipRequest;
    case 80:
    case "XLMClawbackRequest":
      return TransactionRequest_PayloadType.XLMClawbackRequest;
    case 81:
    case "XLMMintAssetRequest":
      return TransactionRequest_PayloadType.XLMMintAssetRequest;
    case 82:
    case "XLMLiquidityPoolDepositRequest":
      return TransactionRequest_PayloadType.XLMLiquidityPoolDepositRequest;
    case 83:
    case "XLMLiquidityPoolWithdrawRequest":
      return TransactionRequest_PayloadType.XLMLiquidityPoolWithdrawRequest;
    case 84:
    case "XLMPathPaymentSendRequest":
      return TransactionRequest_PayloadType.XLMPathPaymentSendRequest;
    case 85:
    case "XLMPathPaymentReceiveRequest":
      return TransactionRequest_PayloadType.XLMPathPaymentReceiveRequest;
    case 86:
    case "XLMOfferRequest":
      return TransactionRequest_PayloadType.XLMOfferRequest;
    case 87:
    case "ICPICRC1TransferRequest":
      return TransactionRequest_PayloadType.ICPICRC1TransferRequest;
    case 88:
    case "SOLTokenTransfersRequest":
      return TransactionRequest_PayloadType.SOLTokenTransfersRequest;
    case 89:
    case "SOLTokenCreateRequest":
      return TransactionRequest_PayloadType.SOLTokenCreateRequest;
    case 90:
    case "SOLTokenMintRequest":
      return TransactionRequest_PayloadType.SOLTokenMintRequest;
    case 91:
    case "SOLTokenBurnRequest":
      return TransactionRequest_PayloadType.SOLTokenBurnRequest;
    case 92:
    case "TAOTransactionsRequest":
      return TransactionRequest_PayloadType.TAOTransactionsRequest;
    case 93:
    case "TAOAddStakeRequest":
      return TransactionRequest_PayloadType.TAOAddStakeRequest;
    case 94:
    case "TAORemoveStakeRequest":
      return TransactionRequest_PayloadType.TAORemoveStakeRequest;
    case 95:
    case "XTZStakeRequest":
      return TransactionRequest_PayloadType.XTZStakeRequest;
    case 96:
    case "XTZUnstakeRequest":
      return TransactionRequest_PayloadType.XTZUnstakeRequest;
    case 97:
    case "XTZFinalizeUnstakeRequest":
      return TransactionRequest_PayloadType.XTZFinalizeUnstakeRequest;
    case 98:
    case "DOGETransactionRequest":
      return TransactionRequest_PayloadType.DOGETransactionRequest;
    case 99:
    case "HederaTransactionsRequest":
      return TransactionRequest_PayloadType.HederaTransactionsRequest;
    case 100:
    case "SonicTransactionsRequest":
      return TransactionRequest_PayloadType.SonicTransactionsRequest;
    case 101:
    case "SonicStakingDelegateRequest":
      return TransactionRequest_PayloadType.SonicStakingDelegateRequest;
    case 102:
    case "SonicStakingClaimRewardsRequest":
      return TransactionRequest_PayloadType.SonicStakingClaimRewardsRequest;
    case 103:
    case "MinaPaymentsRequest":
      return TransactionRequest_PayloadType.MinaPaymentsRequest;
    case 104:
    case "MinaDelegationRequest":
      return TransactionRequest_PayloadType.MinaDelegationRequest;
    case 105:
    case "FilecoinTransactionsRequest":
      return TransactionRequest_PayloadType.FilecoinTransactionsRequest;
    case 106:
    case "ADAVoteDelegationRequest":
      return TransactionRequest_PayloadType.ADAVoteDelegationRequest;
    case 107:
    case "SOLPartialDeactivateStakeRequest":
      return TransactionRequest_PayloadType.SOLPartialDeactivateStakeRequest;
    case 108:
    case "SOLMergeStakeRequest":
      return TransactionRequest_PayloadType.SOLMergeStakeRequest;
    case 109:
    case "TRONTransactionsRequest":
      return TransactionRequest_PayloadType.TRONTransactionsRequest;
    case 110:
    case "SOLTokenFreezeAccountRequest":
      return TransactionRequest_PayloadType.SOLTokenFreezeAccountRequest;
    case 111:
    case "ICPDisburseMaturityToPrimary":
      return TransactionRequest_PayloadType.ICPDisburseMaturityToPrimary;
    case 112:
    case "CantonTransactionsRequest":
      return TransactionRequest_PayloadType.CantonTransactionsRequest;
    case -1:
    case "UNRECOGNIZED":
    default:
      return TransactionRequest_PayloadType.UNRECOGNIZED;
  }
}

export function transactionRequest_PayloadTypeToJSON(object: TransactionRequest_PayloadType): string {
  switch (object) {
    case TransactionRequest_PayloadType.BTCTransactionRequest:
      return "BTCTransactionRequest";
    case TransactionRequest_PayloadType.BCHTransactionRequest:
      return "BCHTransactionRequest";
    case TransactionRequest_PayloadType.LTCTransactionRequest:
      return "LTCTransactionRequest";
    case TransactionRequest_PayloadType.XLMPaymentsRequest:
      return "XLMPaymentsRequest";
    case TransactionRequest_PayloadType.XRPPaymentsRequest:
      return "XRPPaymentsRequest";
    case TransactionRequest_PayloadType.ETHTransactionsRequest:
      return "ETHTransactionsRequest";
    case TransactionRequest_PayloadType.XTZTransactionsRequest:
      return "XTZTransactionsRequest";
    case TransactionRequest_PayloadType.XTZDelegationsRequest:
      return "XTZDelegationsRequest";
    case TransactionRequest_PayloadType.ETHCreateContractRequest:
      return "ETHCreateContractRequest";
    case TransactionRequest_PayloadType.XTZBlockHeaderRequest:
      return "XTZBlockHeaderRequest";
    case TransactionRequest_PayloadType.XTZFA12TransfersRequest:
      return "XTZFA12TransfersRequest";
    case TransactionRequest_PayloadType.XTZFA2TransfersRequest:
      return "XTZFA2TransfersRequest";
    case TransactionRequest_PayloadType.ETHWrappedTransactionsRequest:
      return "ETHWrappedTransactionsRequest";
    case TransactionRequest_PayloadType.ETHWrappedCreateContractRequest:
      return "ETHWrappedCreateContractRequest";
    case TransactionRequest_PayloadType.ADATransactionRequest:
      return "ADATransactionRequest";
    case TransactionRequest_PayloadType.ADADelegationRequest:
      return "ADADelegationRequest";
    case TransactionRequest_PayloadType.ADAUndelegationRequest:
      return "ADAUndelegationRequest";
    case TransactionRequest_PayloadType.ADAWithdrawalRequest:
      return "ADAWithdrawalRequest";
    case TransactionRequest_PayloadType.XTZCreateContractRequest:
      return "XTZCreateContractRequest";
    case TransactionRequest_PayloadType.DOTTransactionsRequest:
      return "DOTTransactionsRequest";
    case TransactionRequest_PayloadType.DOTBondRequest:
      return "DOTBondRequest";
    case TransactionRequest_PayloadType.DOTBondExtraRequest:
      return "DOTBondExtraRequest";
    case TransactionRequest_PayloadType.DOTChillRequest:
      return "DOTChillRequest";
    case TransactionRequest_PayloadType.DOTUnbondRequest:
      return "DOTUnbondRequest";
    case TransactionRequest_PayloadType.DOTNominateRequest:
      return "DOTNominateRequest";
    case TransactionRequest_PayloadType.DOTWithdrawUnbondedRequest:
      return "DOTWithdrawUnbondedRequest";
    case TransactionRequest_PayloadType.DOTPayoutStakersRequest:
      return "DOTPayoutStakersRequest";
    case TransactionRequest_PayloadType.FTMTransactionsRequest:
      return "FTMTransactionsRequest";
    case TransactionRequest_PayloadType.FTMStakingDelegateRequest:
      return "FTMStakingDelegateRequest";
    case TransactionRequest_PayloadType.FTMStakingClaimRewardsRequest:
      return "FTMStakingClaimRewardsRequest";
    case TransactionRequest_PayloadType.FTMStakingLockRequest:
      return "FTMStakingLockRequest";
    case TransactionRequest_PayloadType.ALGOTransactionsRequest:
      return "ALGOTransactionsRequest";
    case TransactionRequest_PayloadType.ALGOAssetOptinRequest:
      return "ALGOAssetOptinRequest";
    case TransactionRequest_PayloadType.ALGOAssetTransferRequest:
      return "ALGOAssetTransferRequest";
    case TransactionRequest_PayloadType.SOLTransfersRequest:
      return "SOLTransfersRequest";
    case TransactionRequest_PayloadType.SOLDelegateStakeRequest:
      return "SOLDelegateStakeRequest";
    case TransactionRequest_PayloadType.SOLDeactivateStakeRequest:
      return "SOLDeactivateStakeRequest";
    case TransactionRequest_PayloadType.SOLWithdrawStakeRequest:
      return "SOLWithdrawStakeRequest";
    case TransactionRequest_PayloadType.CosmosGenericCallRequest:
      return "CosmosGenericCallRequest";
    case TransactionRequest_PayloadType.CosmosCancelRequest:
      return "CosmosCancelRequest";
    case TransactionRequest_PayloadType.PolygonTransactionsRequest:
      return "PolygonTransactionsRequest";
    case TransactionRequest_PayloadType.PolygonCreateContractRequest:
      return "PolygonCreateContractRequest";
    case TransactionRequest_PayloadType.PolygonWrappedTransactionsRequest:
      return "PolygonWrappedTransactionsRequest";
    case TransactionRequest_PayloadType.PolygonWrappedCreateContractRequest:
      return "PolygonWrappedCreateContractRequest";
    case TransactionRequest_PayloadType.NEARTransactionsRequest:
      return "NEARTransactionsRequest";
    case TransactionRequest_PayloadType.AvaxCChainTransactionsRequest:
      return "AvaxCChainTransactionsRequest";
    case TransactionRequest_PayloadType.AvaxCChainCreateContractRequest:
      return "AvaxCChainCreateContractRequest";
    case TransactionRequest_PayloadType.AvaxCChainWrappedTransactionsRequest:
      return "AvaxCChainWrappedTransactionsRequest";
    case TransactionRequest_PayloadType.AvaxCChainWrappedCreateContractRequest:
      return "AvaxCChainWrappedCreateContractRequest";
    case TransactionRequest_PayloadType.NEARDepositAndStakeRequest:
      return "NEARDepositAndStakeRequest";
    case TransactionRequest_PayloadType.NEARUnstakeRequest:
      return "NEARUnstakeRequest";
    case TransactionRequest_PayloadType.NEARWithdrawRequest:
      return "NEARWithdrawRequest";
    case TransactionRequest_PayloadType.XLMChangeTrustRequest:
      return "XLMChangeTrustRequest";
    case TransactionRequest_PayloadType.ICPTransferRequest:
      return "ICPTransferRequest";
    case TransactionRequest_PayloadType.XLMSetOptionsRequest:
      return "XLMSetOptionsRequest";
    case TransactionRequest_PayloadType.XLMSetTrustlineFLagsRequest:
      return "XLMSetTrustlineFLagsRequest";
    case TransactionRequest_PayloadType.XLMManageDataRequest:
      return "XLMManageDataRequest";
    case TransactionRequest_PayloadType.ICPTransferToStakeRequest:
      return "ICPTransferToStakeRequest";
    case TransactionRequest_PayloadType.ICPFollowRequest:
      return "ICPFollowRequest";
    case TransactionRequest_PayloadType.ICPSetDissolveDelayRequest:
      return "ICPSetDissolveDelayRequest";
    case TransactionRequest_PayloadType.ICPStartDissolvingRequest:
      return "ICPStartDissolvingRequest";
    case TransactionRequest_PayloadType.ICPDisburseRequest:
      return "ICPDisburseRequest";
    case TransactionRequest_PayloadType.XLMCreateClaimableBalanceRequest:
      return "XLMCreateClaimableBalanceRequest";
    case TransactionRequest_PayloadType.XLMClaimClaimableBalanceRequest:
      return "XLMClaimClaimableBalanceRequest";
    case TransactionRequest_PayloadType.XLMClawbackClaimableBalanceRequest:
      return "XLMClawbackClaimableBalanceRequest";
    case TransactionRequest_PayloadType.XLMRevokeSponsorshipRequest:
      return "XLMRevokeSponsorshipRequest";
    case TransactionRequest_PayloadType.XLMClawbackRequest:
      return "XLMClawbackRequest";
    case TransactionRequest_PayloadType.XLMMintAssetRequest:
      return "XLMMintAssetRequest";
    case TransactionRequest_PayloadType.XLMLiquidityPoolDepositRequest:
      return "XLMLiquidityPoolDepositRequest";
    case TransactionRequest_PayloadType.XLMLiquidityPoolWithdrawRequest:
      return "XLMLiquidityPoolWithdrawRequest";
    case TransactionRequest_PayloadType.XLMPathPaymentSendRequest:
      return "XLMPathPaymentSendRequest";
    case TransactionRequest_PayloadType.XLMPathPaymentReceiveRequest:
      return "XLMPathPaymentReceiveRequest";
    case TransactionRequest_PayloadType.XLMOfferRequest:
      return "XLMOfferRequest";
    case TransactionRequest_PayloadType.ICPICRC1TransferRequest:
      return "ICPICRC1TransferRequest";
    case TransactionRequest_PayloadType.SOLTokenTransfersRequest:
      return "SOLTokenTransfersRequest";
    case TransactionRequest_PayloadType.SOLTokenCreateRequest:
      return "SOLTokenCreateRequest";
    case TransactionRequest_PayloadType.SOLTokenMintRequest:
      return "SOLTokenMintRequest";
    case TransactionRequest_PayloadType.SOLTokenBurnRequest:
      return "SOLTokenBurnRequest";
    case TransactionRequest_PayloadType.TAOTransactionsRequest:
      return "TAOTransactionsRequest";
    case TransactionRequest_PayloadType.TAOAddStakeRequest:
      return "TAOAddStakeRequest";
    case TransactionRequest_PayloadType.TAORemoveStakeRequest:
      return "TAORemoveStakeRequest";
    case TransactionRequest_PayloadType.XTZStakeRequest:
      return "XTZStakeRequest";
    case TransactionRequest_PayloadType.XTZUnstakeRequest:
      return "XTZUnstakeRequest";
    case TransactionRequest_PayloadType.XTZFinalizeUnstakeRequest:
      return "XTZFinalizeUnstakeRequest";
    case TransactionRequest_PayloadType.DOGETransactionRequest:
      return "DOGETransactionRequest";
    case TransactionRequest_PayloadType.HederaTransactionsRequest:
      return "HederaTransactionsRequest";
    case TransactionRequest_PayloadType.SonicTransactionsRequest:
      return "SonicTransactionsRequest";
    case TransactionRequest_PayloadType.SonicStakingDelegateRequest:
      return "SonicStakingDelegateRequest";
    case TransactionRequest_PayloadType.SonicStakingClaimRewardsRequest:
      return "SonicStakingClaimRewardsRequest";
    case TransactionRequest_PayloadType.MinaPaymentsRequest:
      return "MinaPaymentsRequest";
    case TransactionRequest_PayloadType.MinaDelegationRequest:
      return "MinaDelegationRequest";
    case TransactionRequest_PayloadType.FilecoinTransactionsRequest:
      return "FilecoinTransactionsRequest";
    case TransactionRequest_PayloadType.ADAVoteDelegationRequest:
      return "ADAVoteDelegationRequest";
    case TransactionRequest_PayloadType.SOLPartialDeactivateStakeRequest:
      return "SOLPartialDeactivateStakeRequest";
    case TransactionRequest_PayloadType.SOLMergeStakeRequest:
      return "SOLMergeStakeRequest";
    case TransactionRequest_PayloadType.TRONTransactionsRequest:
      return "TRONTransactionsRequest";
    case TransactionRequest_PayloadType.SOLTokenFreezeAccountRequest:
      return "SOLTokenFreezeAccountRequest";
    case TransactionRequest_PayloadType.ICPDisburseMaturityToPrimary:
      return "ICPDisburseMaturityToPrimary";
    case TransactionRequest_PayloadType.CantonTransactionsRequest:
      return "CantonTransactionsRequest";
    case TransactionRequest_PayloadType.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

/**
 * A Bundle Transaction is a single blockchain transaction that satisfies all the TransactionRequests
 * They are used to reduce chain fees and wait times
 * Instead of passing signatures per request, signatures are combined and passed at the top level.
 */
export interface BundleTransactionRequest {
  id: string;
  bundle: TransactionRequest[];
  signatures: RequestSignature[];
}

export interface AddressResponse {
  address: string;
  signature: Uint8Array;
}

export interface CantonAddressRequest {
  prefix: string;
  path: string;
  forParticipantID: string;
}

export interface CantonAddressResponse {
  party: string;
  partySignature: Uint8Array;
  signedTopologyTransactions: Uint8Array;
}

export interface CantonTransaction {
  id: string;
  source: string;
  partyPrefix: string;
  preparedSubmission: Uint8Array;
  /** Fields not used by the engine, reserved for validator */
  choiceArguments: Uint8Array;
  commandID: string;
  party: string;
}

export interface CantonTransactionsRequest {
  kind: CantonTransactionsRequest_CantonOperationKind;
  transactions: CantonTransaction[];
}

export enum CantonTransactionsRequest_CantonOperationKind {
  Unknown = 0,
  CreateTransferPreapprovalProposal = 1,
  CantonCoinTransfers = 2,
  UNRECOGNIZED = -1,
}

export function cantonTransactionsRequest_CantonOperationKindFromJSON(
  object: any,
): CantonTransactionsRequest_CantonOperationKind {
  switch (object) {
    case 0:
    case "Unknown":
      return CantonTransactionsRequest_CantonOperationKind.Unknown;
    case 1:
    case "CreateTransferPreapprovalProposal":
      return CantonTransactionsRequest_CantonOperationKind.CreateTransferPreapprovalProposal;
    case 2:
    case "CantonCoinTransfers":
      return CantonTransactionsRequest_CantonOperationKind.CantonCoinTransfers;
    case -1:
    case "UNRECOGNIZED":
    default:
      return CantonTransactionsRequest_CantonOperationKind.UNRECOGNIZED;
  }
}

export function cantonTransactionsRequest_CantonOperationKindToJSON(
  object: CantonTransactionsRequest_CantonOperationKind,
): string {
  switch (object) {
    case CantonTransactionsRequest_CantonOperationKind.Unknown:
      return "Unknown";
    case CantonTransactionsRequest_CantonOperationKind.CreateTransferPreapprovalProposal:
      return "CreateTransferPreapprovalProposal";
    case CantonTransactionsRequest_CantonOperationKind.CantonCoinTransfers:
      return "CantonCoinTransfers";
    case CantonTransactionsRequest_CantonOperationKind.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

export interface CantonProofOfReserveRequest {
  path: string;
  prefix: string;
  challenge: string;
}

export interface ICPAddressResponse {
  accountIdentifier: string;
  accountIdentifierSignature: Uint8Array;
  principal: string;
  subAccount: string;
}

export interface ICPProofOfReserveRequest {
  path: string;
  challenge: string;
}

export interface ICPAddressRequest {
  path: string;
}

export interface ICPRequestsRequest {
  requests: ICPRequest[];
}

export interface ICPRequestsResponse {
  requests: ICPRequestsResponse_ICPRequestResponse[];
}

export interface ICPRequestsResponse_ICPRequestResponse {
  id: string;
  operationRequest: string;
  statusRequest: string;
}

export interface ICPTransfer {
  from: string;
  to: string;
  amount: number;
  fee: number;
  memo: number;
  createdAtTime: number;
}

export interface ICPTransferToStake {
  from: string;
  amount: number;
  fee: number;
  memo: number;
  createdAtTime: number;
}

export interface ICPFollow {
  from: string;
  followees: number[];
  topic: number;
}

export interface ICPClaimOrRefresh {
  from: string;
}

export interface ICPSetAutoStakeRewards {
  from: string;
}

export interface ICPSetDissolveDelay {
  from: string;
  nowTimestampSeconds: number;
  delayTimestampSeconds: number;
}

export interface ICPSpawn {
  from: string;
  nonce: number;
}

export interface ICPDisburseToPrimary {
  from: string;
  nonce: number;
  amount: number;
}

export interface ICPStartDissolving {
  from: string;
}

export interface ICPDisburse {
  from: string;
  amount: number;
}

export interface ICPListNeurons {
  from: string;
}

export interface ICPRefreshVotingPower {
  from: string;
}

export interface ICPDisburseMaturityToPrimary {
  from: string;
}

/**
 * type TransferArgs = record {
 * from_subaccount : opt Subaccount; // type Subaccount = blob
 * to : Account; // type Account = record { owner : principal; subaccount : opt Subaccount; };
 * amount : nat;
 * fee : opt nat;
 * memo : opt blob;
 * created_at_time : opt nat64;
 * };
 */
export interface ICRC1Transfer {
  /** Example: "k2t6j-2nvnp-4zjm3-25dtz-6xhaa-c7boj-5gayf-oj3xs-i43lp-teztq-6ae-dfxgiyy.102030405060708090a0b0c0d0e0f101112131415161718191a1b1c1d1e1f20 or k2t6j-2nvnp-4zjm3-25dtz-6xhaa-c7boj-5gayf-oj3xs-i43lp-teztq-6ae" */
  to: string;
  amount: number;
  fee: number;
  memo: string;
  createdAtTime: number;
  natAmount: Uint8Array;
  natFee: Uint8Array;
}

export interface ICPRequest {
  id: string;
  sender: string;
  nonce: Uint8Array;
  ingressExpiry: number;
  canisterId: string;
  kind: ICPRequest_ICPRequestKind;
  payload: Uint8Array;
  /**
   * -- Deprecate/remove it when proto support is fully removed from their network
   * Useful for staking only
   * This as been added in case we're updating the HSM before validatord, we need to return proto by default
   */
  encodeAsCandid: boolean;
}

export enum ICPRequest_ICPRequestKind {
  None = 0,
  /** Transfer - ICP (native) tokens transfer */
  Transfer = 1,
  /** TransferToStake - Staking */
  TransferToStake = 2,
  /** ClaimOrRefresh - Claim or refresh neuron (basically tell the governance canister to ask the ledger canister about the neuron balance etc.) */
  ClaimOrRefresh = 3,
  /** SetAutoStakeRewards - Set auto_stake_rewards to true */
  SetAutoStakeRewards = 4,
  /** Follow - Follow a neuron */
  Follow = 5,
  /** SetDissolveDelay - Set the dissolve delay of the main neuron */
  SetDissolveDelay = 6,
  /** StartDissolving - Dissolve the main neuron */
  StartDissolving = 7,
  /** Spawn - Spawn a new neuron from the main one (mint the maturity on the ledger) */
  Spawn = 8,
  /** DisburseToPrimary - Disburse a secondary neuron to the main neuron */
  DisburseToPrimary = 9,
  /** Disburse - Disburse the main neuron (send ICP tokens from the neuron to the address) */
  Disburse = 10,
  /** ListNeurons - Query the neurons controlled by the "from" address */
  ListNeurons = 11,
  /** ICRC1Transfer - ICRC1 */
  ICRC1Transfer = 12,
  /** RefreshVotingPower - Keep the neuron "alive" (ping) */
  RefreshVotingPower = 13,
  /** DisburseMaturityToPrimary - Disburse the maturity of the main neuron (mint ICP tokens to the address of the main neuron) */
  DisburseMaturityToPrimary = 14,
  UNRECOGNIZED = -1,
}

export function iCPRequest_ICPRequestKindFromJSON(object: any): ICPRequest_ICPRequestKind {
  switch (object) {
    case 0:
    case "None":
      return ICPRequest_ICPRequestKind.None;
    case 1:
    case "Transfer":
      return ICPRequest_ICPRequestKind.Transfer;
    case 2:
    case "TransferToStake":
      return ICPRequest_ICPRequestKind.TransferToStake;
    case 3:
    case "ClaimOrRefresh":
      return ICPRequest_ICPRequestKind.ClaimOrRefresh;
    case 4:
    case "SetAutoStakeRewards":
      return ICPRequest_ICPRequestKind.SetAutoStakeRewards;
    case 5:
    case "Follow":
      return ICPRequest_ICPRequestKind.Follow;
    case 6:
    case "SetDissolveDelay":
      return ICPRequest_ICPRequestKind.SetDissolveDelay;
    case 7:
    case "StartDissolving":
      return ICPRequest_ICPRequestKind.StartDissolving;
    case 8:
    case "Spawn":
      return ICPRequest_ICPRequestKind.Spawn;
    case 9:
    case "DisburseToPrimary":
      return ICPRequest_ICPRequestKind.DisburseToPrimary;
    case 10:
    case "Disburse":
      return ICPRequest_ICPRequestKind.Disburse;
    case 11:
    case "ListNeurons":
      return ICPRequest_ICPRequestKind.ListNeurons;
    case 12:
    case "ICRC1Transfer":
      return ICPRequest_ICPRequestKind.ICRC1Transfer;
    case 13:
    case "RefreshVotingPower":
      return ICPRequest_ICPRequestKind.RefreshVotingPower;
    case 14:
    case "DisburseMaturityToPrimary":
      return ICPRequest_ICPRequestKind.DisburseMaturityToPrimary;
    case -1:
    case "UNRECOGNIZED":
    default:
      return ICPRequest_ICPRequestKind.UNRECOGNIZED;
  }
}

export function iCPRequest_ICPRequestKindToJSON(object: ICPRequest_ICPRequestKind): string {
  switch (object) {
    case ICPRequest_ICPRequestKind.None:
      return "None";
    case ICPRequest_ICPRequestKind.Transfer:
      return "Transfer";
    case ICPRequest_ICPRequestKind.TransferToStake:
      return "TransferToStake";
    case ICPRequest_ICPRequestKind.ClaimOrRefresh:
      return "ClaimOrRefresh";
    case ICPRequest_ICPRequestKind.SetAutoStakeRewards:
      return "SetAutoStakeRewards";
    case ICPRequest_ICPRequestKind.Follow:
      return "Follow";
    case ICPRequest_ICPRequestKind.SetDissolveDelay:
      return "SetDissolveDelay";
    case ICPRequest_ICPRequestKind.StartDissolving:
      return "StartDissolving";
    case ICPRequest_ICPRequestKind.Spawn:
      return "Spawn";
    case ICPRequest_ICPRequestKind.DisburseToPrimary:
      return "DisburseToPrimary";
    case ICPRequest_ICPRequestKind.Disburse:
      return "Disburse";
    case ICPRequest_ICPRequestKind.ListNeurons:
      return "ListNeurons";
    case ICPRequest_ICPRequestKind.ICRC1Transfer:
      return "ICRC1Transfer";
    case ICPRequest_ICPRequestKind.RefreshVotingPower:
      return "RefreshVotingPower";
    case ICPRequest_ICPRequestKind.DisburseMaturityToPrimary:
      return "DisburseMaturityToPrimary";
    case ICPRequest_ICPRequestKind.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

export interface NEARProofOfReserveRequest {
  path: string;
  challenge: string;
}

export interface NEARAddressRequest {
  path: string;
}

export interface NEARTransactionsRequest {
  transactions: NEARTransaction[];
}

export interface NEARTransaction {
  id: string;
  from: string;
  nonce: number;
  to: string;
  blockHash: string;
  amount: Uint8Array;
  isNonceSet: boolean;
}

export interface NEARDepositAndStakeRequest {
  id: string;
  from: string;
  nonce: number;
  to: string;
  blockHash: string;
  amount: Uint8Array;
  gas: number;
  isNonceSet: boolean;
}

export interface NEARUnstakeRequest {
  id: string;
  from: string;
  nonce: number;
  to: string;
  blockHash: string;
  amount: Uint8Array;
  gas: number;
  isNonceSet: boolean;
}

export interface NEARWithdrawRequest {
  id: string;
  from: string;
  nonce: number;
  to: string;
  blockHash: string;
  amount: Uint8Array;
  gas: number;
  isNonceSet: boolean;
}

export interface ADAAddressRequest {
  path: string;
}

export interface ADAInput {
  path: string;
  hash: Uint8Array;
  index: number;
  value: ADAValue | undefined;
}

export interface ADANativeAsset {
  name: Uint8Array;
  amount: number;
}

export interface ADAAssetPolicy {
  policyId: Uint8Array;
  assets: ADANativeAsset[];
}

export interface ADAValue {
  amount: number;
  policies: ADAAssetPolicy[];
}

export interface ADAOutput {
  address: string;
  value: ADAValue | undefined;
}

export interface ADAChangeOutput {
  path: string;
  value: ADAValue | undefined;
}

export interface ADAWithdrawal {
  path: string;
  amount: number;
}

export interface ADATransactionRequest {
  id: string;
  inputs: ADAInput[];
  outputs: ADAOutput[];
  changeOutput: ADAChangeOutput | undefined;
  ttl: number;
  fee: number;
}

export interface ADAWithdrawalRequest {
  id: string;
  inputs: ADAInput[];
  withdrawal: ADAWithdrawal | undefined;
  changeOutput: ADAChangeOutput | undefined;
  ttl: number;
  fee: number;
}

export interface ADADrep {
  drepType: ADADrep_DRepType;
  /** CIP-0129 drepid to whom we are we delegating votes to, empty for Abstain or NoConfidence types */
  drep: string;
}

export enum ADADrep_DRepType {
  Abstain = 0,
  NoConfidence = 1,
  /** DrepId - Key Hash or script hash */
  DrepId = 2,
  UNRECOGNIZED = -1,
}

export function aDADrep_DRepTypeFromJSON(object: any): ADADrep_DRepType {
  switch (object) {
    case 0:
    case "Abstain":
      return ADADrep_DRepType.Abstain;
    case 1:
    case "NoConfidence":
      return ADADrep_DRepType.NoConfidence;
    case 2:
    case "DrepId":
      return ADADrep_DRepType.DrepId;
    case -1:
    case "UNRECOGNIZED":
    default:
      return ADADrep_DRepType.UNRECOGNIZED;
  }
}

export function aDADrep_DRepTypeToJSON(object: ADADrep_DRepType): string {
  switch (object) {
    case ADADrep_DRepType.Abstain:
      return "Abstain";
    case ADADrep_DRepType.NoConfidence:
      return "NoConfidence";
    case ADADrep_DRepType.DrepId:
      return "DrepId";
    case ADADrep_DRepType.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

export interface ADADelegationRequest {
  id: string;
  inputs: ADAInput[];
  changeOutput:
    | ADAChangeOutput
    | undefined;
  /** who are we delegating to */
  delegate: string;
  /** should we include a stake_registration? */
  first: boolean;
  ttl: number;
  fee: number;
  stakePoolRegistrationCertificate: Uint8Array;
  /** Deposit amount for stake registration if included (2025-currently 2 ADA but can change in later protocols) */
  keyDeposit: number;
  /** If set we include a drep vote delegation as well */
  drep: ADADrep | undefined;
}

export interface ADAUndelegationRequest {
  id: string;
  inputs: ADAInput[];
  changeOutput: ADAChangeOutput | undefined;
  withdrawal: ADAWithdrawal | undefined;
  ttl: number;
  fee: number;
  /** Deposit amount refunded by stake deregistration */
  keyDeposit: number;
}

export interface ADAVoteDelegationRequest {
  id: string;
  inputs: ADAInput[];
  changeOutput: ADAChangeOutput | undefined;
  drep: ADADrep | undefined;
  ttl: number;
  fee: number;
}

export interface ADAProofOfReserveRequest {
  path: string;
  challenge: string;
}

export interface ADAProofOfReserveResponse {
  address: string;
  path: string;
  challenge: string;
  /** public key for the curve. For p256 x::y, for ed25519, 32byte pubkey. */
  paymentPublicKey: Uint8Array;
  paymentChallengeResponse: Uint8Array;
  /** public key for the curve. For p256 x::y, for ed25519, 32byte pubkey. */
  stakePublicKey: Uint8Array;
  stakeChallengeResponse: Uint8Array;
}

export interface XLMAsset {
  type: XLMAsset_AssetType;
  alphanum: XLMAsset_Alphanum | undefined;
  pool: XLMAsset_LiquidityPoolParams | undefined;
}

export enum XLMAsset_AssetType {
  Native = 0,
  Alphanum4 = 1,
  Alphanum12 = 2,
  PoolShare = 3,
  UNRECOGNIZED = -1,
}

export function xLMAsset_AssetTypeFromJSON(object: any): XLMAsset_AssetType {
  switch (object) {
    case 0:
    case "Native":
      return XLMAsset_AssetType.Native;
    case 1:
    case "Alphanum4":
      return XLMAsset_AssetType.Alphanum4;
    case 2:
    case "Alphanum12":
      return XLMAsset_AssetType.Alphanum12;
    case 3:
    case "PoolShare":
      return XLMAsset_AssetType.PoolShare;
    case -1:
    case "UNRECOGNIZED":
    default:
      return XLMAsset_AssetType.UNRECOGNIZED;
  }
}

export function xLMAsset_AssetTypeToJSON(object: XLMAsset_AssetType): string {
  switch (object) {
    case XLMAsset_AssetType.Native:
      return "Native";
    case XLMAsset_AssetType.Alphanum4:
      return "Alphanum4";
    case XLMAsset_AssetType.Alphanum12:
      return "Alphanum12";
    case XLMAsset_AssetType.PoolShare:
      return "PoolShare";
    case XLMAsset_AssetType.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

export interface XLMAsset_Alphanum {
  assetID: string;
  issuer: string;
}

/** ConstantProductParams on Stellar XDR */
export interface XLMAsset_LiquidityPoolParams {
  assetA: XLMAsset | undefined;
  assetB:
    | XLMAsset
    | undefined;
  /** Fee is in basis points, so the actual rate is (fee/100)%. Example fee = 1 is 0.01% */
  fee: number;
}

export interface XLMLedgerEntry {
  type: XLMLedgerEntry_LedgerEntryType;
  account: string;
  asset: XLMAsset | undefined;
  offerId: number;
  dataName: string;
  claimableBalanceID: Uint8Array;
}

export enum XLMLedgerEntry_LedgerEntryType {
  TypeAccount = 0,
  TypeTrustline = 1,
  TypeOffer = 2,
  TypeData = 3,
  TypeClaimableBalance = 4,
  UNRECOGNIZED = -1,
}

export function xLMLedgerEntry_LedgerEntryTypeFromJSON(object: any): XLMLedgerEntry_LedgerEntryType {
  switch (object) {
    case 0:
    case "TypeAccount":
      return XLMLedgerEntry_LedgerEntryType.TypeAccount;
    case 1:
    case "TypeTrustline":
      return XLMLedgerEntry_LedgerEntryType.TypeTrustline;
    case 2:
    case "TypeOffer":
      return XLMLedgerEntry_LedgerEntryType.TypeOffer;
    case 3:
    case "TypeData":
      return XLMLedgerEntry_LedgerEntryType.TypeData;
    case 4:
    case "TypeClaimableBalance":
      return XLMLedgerEntry_LedgerEntryType.TypeClaimableBalance;
    case -1:
    case "UNRECOGNIZED":
    default:
      return XLMLedgerEntry_LedgerEntryType.UNRECOGNIZED;
  }
}

export function xLMLedgerEntry_LedgerEntryTypeToJSON(object: XLMLedgerEntry_LedgerEntryType): string {
  switch (object) {
    case XLMLedgerEntry_LedgerEntryType.TypeAccount:
      return "TypeAccount";
    case XLMLedgerEntry_LedgerEntryType.TypeTrustline:
      return "TypeTrustline";
    case XLMLedgerEntry_LedgerEntryType.TypeOffer:
      return "TypeOffer";
    case XLMLedgerEntry_LedgerEntryType.TypeData:
      return "TypeData";
    case XLMLedgerEntry_LedgerEntryType.TypeClaimableBalance:
      return "TypeClaimableBalance";
    case XLMLedgerEntry_LedgerEntryType.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

export interface XLMTransactionDetails {
  id: string;
  from: string;
  fee: number;
  minimumTime: number;
  maximumTime: number;
  memo: string;
  sequence: number;
  isSequenceSet: boolean;
  /** path of internal address sponsoring `from` account base reserve cost for the underlying operation */
  sponsoredBy: string;
}

export interface XLMMintAssetRequest {
  details: XLMTransactionDetails | undefined;
  assetId: string;
  amount: number;
  destination: string;
}

export interface XLMChangeTrustRequest {
  details: XLMTransactionDetails | undefined;
  asset: XLMAsset | undefined;
  limit: number;
}

export interface XLMSetTrustlineFlagsRequest {
  details: XLMTransactionDetails | undefined;
  trustor: string;
  asset: XLMAsset | undefined;
  setFlags: number;
  clearFlags: number;
}

export interface XLMPaymentsRequest {
  payments: XLMPayment[];
}

export interface XLMPayment {
  from: string;
  fee: number;
  minimumTime: number;
  maximumTime: number;
  /** Only MEMO_TEXT, ath most 28 characters */
  memo: string;
  /** Payment operation (at the moment the only asset is ASSET_TYPE_NATIVE) */
  to: string;
  amount: number;
  sequence: number;
  id: string;
  operation: XLMPayment_Operation;
  isSequenceSet: boolean;
  asset:
    | XLMAsset
    | undefined;
  /** as in details */
  sponsoredBy: string;
}

export enum XLMPayment_Operation {
  Payment = 0,
  CreateAccount = 1,
  UNRECOGNIZED = -1,
}

export function xLMPayment_OperationFromJSON(object: any): XLMPayment_Operation {
  switch (object) {
    case 0:
    case "Payment":
      return XLMPayment_Operation.Payment;
    case 1:
    case "CreateAccount":
      return XLMPayment_Operation.CreateAccount;
    case -1:
    case "UNRECOGNIZED":
    default:
      return XLMPayment_Operation.UNRECOGNIZED;
  }
}

export function xLMPayment_OperationToJSON(object: XLMPayment_Operation): string {
  switch (object) {
    case XLMPayment_Operation.Payment:
      return "Payment";
    case XLMPayment_Operation.CreateAccount:
      return "CreateAccount";
    case XLMPayment_Operation.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

export interface XLMAddressRequest {
  /** BIP 44 path */
  path: string;
}

export interface XLMProofOfReserveRequest {
  path: string;
  challenge: string;
}

export interface XLMSetOptionsRequest {
  details: XLMTransactionDetails | undefined;
  setFlags: number;
  clearFlags: number;
}

export interface XLMManageDataRequest {
  details: XLMTransactionDetails | undefined;
  name: string;
  valueData: Uint8Array;
}

export interface XLMClaimPredicate {
  type: XLMClaimPredicate_ClaimPredicateType;
  predicateUnconditional?:
    | XLMClaimPredicate_PredicateUnconditional
    | undefined;
  /**
   * PredicateAnd predicateAnd = 3;
   * PredicateOr predicateOr = 4;
   * PredicateNot predicateNot = 5;
   */
  predicateAbsBefore?: XLMClaimPredicate_PredicateAbsBefore | undefined;
  predicateRelBefore?: XLMClaimPredicate_PredicateRelBefore | undefined;
}

export enum XLMClaimPredicate_ClaimPredicateType {
  /**
   * Unconditional - And = 1;
   * Or = 2;
   * Not = 3;
   */
  Unconditional = 0,
  AbsBefore = 4,
  RelBefore = 5,
  UNRECOGNIZED = -1,
}

export function xLMClaimPredicate_ClaimPredicateTypeFromJSON(object: any): XLMClaimPredicate_ClaimPredicateType {
  switch (object) {
    case 0:
    case "Unconditional":
      return XLMClaimPredicate_ClaimPredicateType.Unconditional;
    case 4:
    case "AbsBefore":
      return XLMClaimPredicate_ClaimPredicateType.AbsBefore;
    case 5:
    case "RelBefore":
      return XLMClaimPredicate_ClaimPredicateType.RelBefore;
    case -1:
    case "UNRECOGNIZED":
    default:
      return XLMClaimPredicate_ClaimPredicateType.UNRECOGNIZED;
  }
}

export function xLMClaimPredicate_ClaimPredicateTypeToJSON(object: XLMClaimPredicate_ClaimPredicateType): string {
  switch (object) {
    case XLMClaimPredicate_ClaimPredicateType.Unconditional:
      return "Unconditional";
    case XLMClaimPredicate_ClaimPredicateType.AbsBefore:
      return "AbsBefore";
    case XLMClaimPredicate_ClaimPredicateType.RelBefore:
      return "RelBefore";
    case XLMClaimPredicate_ClaimPredicateType.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

/** void */
export interface XLMClaimPredicate_PredicateUnconditional {
}

export interface XLMClaimPredicate_PredicateAbsBefore {
  absBefore: number;
}

export interface XLMClaimPredicate_PredicateRelBefore {
  relBefore: number;
}

export interface XLMClaimant {
  versionKind: XLMClaimant_VersionKind;
  v0?: XLMClaimant_ClaimantV0 | undefined;
}

export enum XLMClaimant_VersionKind {
  kindV0 = 0,
  UNRECOGNIZED = -1,
}

export function xLMClaimant_VersionKindFromJSON(object: any): XLMClaimant_VersionKind {
  switch (object) {
    case 0:
    case "kindV0":
      return XLMClaimant_VersionKind.kindV0;
    case -1:
    case "UNRECOGNIZED":
    default:
      return XLMClaimant_VersionKind.UNRECOGNIZED;
  }
}

export function xLMClaimant_VersionKindToJSON(object: XLMClaimant_VersionKind): string {
  switch (object) {
    case XLMClaimant_VersionKind.kindV0:
      return "kindV0";
    case XLMClaimant_VersionKind.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

export interface XLMClaimant_ClaimantV0 {
  destination: string;
  claimPredicate: XLMClaimPredicate | undefined;
}

export interface XLMCreateClaimableBalanceRequest {
  details: XLMTransactionDetails | undefined;
  asset: XLMAsset | undefined;
  amount: number;
  claimant: XLMClaimant | undefined;
}

export interface XLMClaimClaimableBalanceRequest {
  details: XLMTransactionDetails | undefined;
  claimableBalanceID: Uint8Array;
}

export interface XLMClawbackClaimableBalanceRequest {
  details: XLMTransactionDetails | undefined;
  claimableBalanceID: Uint8Array;
}

export interface XLMRevokeSponsorshipRequest {
  details: XLMTransactionDetails | undefined;
  entry: XLMLedgerEntry | undefined;
}

export interface XLMClawbackRequest {
  details: XLMTransactionDetails | undefined;
  destination: string;
  asset: XLMAsset | undefined;
  amount: number;
}

export interface XLMPrice {
  numerator: number;
  denominator: number;
}

export interface XLMLiquidityPoolDepositRequest {
  details: XLMTransactionDetails | undefined;
  poolID: Uint8Array;
  /** maximum amount of first asset to deposit */
  maxAmountA: number;
  /** maximum amount of second asset to deposit */
  maxAmountB: number;
  /** minimum depositA/depositB */
  minPrice:
    | XLMPrice
    | undefined;
  /** maximum depositA/depositB */
  maxPrice: XLMPrice | undefined;
}

export interface XLMLiquidityPoolWithdrawRequest {
  details: XLMTransactionDetails | undefined;
  poolID: Uint8Array;
  /** amount of shares to withdraw */
  amount: number;
  minAmountA: number;
  minAmountB: number;
}

export interface XLMPathPaymentSendRequest {
  details: XLMTransactionDetails | undefined;
  destination: string;
  srcAsset: XLMAsset | undefined;
  dstAsset: XLMAsset | undefined;
  path: XLMAsset[];
  srcAmount: number;
  minDstAmount: number;
}

export interface XLMPathPaymentReceiveRequest {
  details: XLMTransactionDetails | undefined;
  destination: string;
  srcAsset: XLMAsset | undefined;
  dstAsset: XLMAsset | undefined;
  path: XLMAsset[];
  dstAmount: number;
  maxSrcAmount: number;
}

export interface XLMOfferRequest {
  details: XLMTransactionDetails | undefined;
  sellAsset: XLMAsset | undefined;
  buyAsset: XLMAsset | undefined;
  amount: number;
  price: XLMPrice | undefined;
  offerId: number;
  kind: XLMOfferRequest_OfferKind;
}

export enum XLMOfferRequest_OfferKind {
  Buy = 0,
  Sell = 1,
  Passive = 2,
  UNRECOGNIZED = -1,
}

export function xLMOfferRequest_OfferKindFromJSON(object: any): XLMOfferRequest_OfferKind {
  switch (object) {
    case 0:
    case "Buy":
      return XLMOfferRequest_OfferKind.Buy;
    case 1:
    case "Sell":
      return XLMOfferRequest_OfferKind.Sell;
    case 2:
    case "Passive":
      return XLMOfferRequest_OfferKind.Passive;
    case -1:
    case "UNRECOGNIZED":
    default:
      return XLMOfferRequest_OfferKind.UNRECOGNIZED;
  }
}

export function xLMOfferRequest_OfferKindToJSON(object: XLMOfferRequest_OfferKind): string {
  switch (object) {
    case XLMOfferRequest_OfferKind.Buy:
      return "Buy";
    case XLMOfferRequest_OfferKind.Sell:
      return "Sell";
    case XLMOfferRequest_OfferKind.Passive:
      return "Passive";
    case XLMOfferRequest_OfferKind.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

export interface XRPPaymentsRequest {
  payments: XRPPayment[];
}

export interface XRPPayment {
  from: string;
  sequence: number;
  destinationTag: Uint8Array;
  lastLedgerSequence: Uint8Array;
  to: string;
  fee: number;
  amount: number;
  id: string;
  isSequenceSet: boolean;
}

export interface XRPAddressRequest {
  path: string;
}

export interface XRPProofOfReserveRequest {
  path: string;
  challenge: string;
}

export interface XTZRevealRequest {
  id: string;
  branch: string;
  from: string;
  fee: number;
  counter: Uint8Array;
  gasLimit: Uint8Array;
}

export interface XTZDelegationsRequest {
  delegations: XTZDelegation[];
}

export interface XTZDelegation {
  id: string;
  branch: string;
  from: string;
  fee: number;
  counter: Uint8Array;
  gasLimit: Uint8Array;
  delegate: string;
  isNonceSet: boolean;
}

export interface XTZTransactionsRequest {
  transactions: XTZTransaction[];
}

export interface XTZTransaction {
  id: string;
  branch: string;
  from: string;
  fee: number;
  counter: Uint8Array;
  gasLimit: Uint8Array;
  storageLimit: Uint8Array;
  amount: number;
  to: string;
  parameters: Uint8Array;
  isNonceSet: boolean;
}

export interface XTZFA12TransfersRequest {
  transfers: XTZFA12Transfer[];
}

export interface XTZFA12Transfer {
  id: string;
  branch: string;
  from: string;
  fee: number;
  counter: Uint8Array;
  gasLimit: Uint8Array;
  storageLimit: Uint8Array;
  amount: number;
  to: string;
  contract: string;
  isNonceSet: boolean;
}

export interface XTZFA2TransfersRequest {
  transfers: XTZFA2Transfer[];
}

export interface XTZFA2Transfer {
  id: string;
  branch: string;
  from: string;
  fee: number;
  counter: Uint8Array;
  gasLimit: Uint8Array;
  storageLimit: Uint8Array;
  amount: number;
  to: string;
  contract: string;
  tokenId: Uint8Array;
  isNonceSet: boolean;
}

export interface XTZCreateContractRequest {
  id: string;
  branch: string;
  from: string;
  fee: number;
  counter: Uint8Array;
  gasLimit: Uint8Array;
  storageLimit: Uint8Array;
  amount: number;
  delegate: string;
  code: Uint8Array;
  storage: Uint8Array;
  isNonceSet: boolean;
}

export interface XTZStakeRequest {
  id: string;
  branch: string;
  from: string;
  fee: number;
  counter: Uint8Array;
  gasLimit: Uint8Array;
  amount: number;
  isNonceSet: boolean;
}

export interface XTZUnstakeRequest {
  id: string;
  branch: string;
  from: string;
  fee: number;
  counter: Uint8Array;
  gasLimit: Uint8Array;
  amount: number;
  isNonceSet: boolean;
}

export interface XTZFinalizeUnstakeRequest {
  id: string;
  branch: string;
  from: string;
  fee: number;
  counter: Uint8Array;
  gasLimit: Uint8Array;
  isNonceSet: boolean;
}

export interface XTZAddressRequest {
  path: string;
}

export interface XTZProofOfReserveRequest {
  path: string;
  challenge: string;
}

export interface XTZBlockHeaderRequest {
  id: string;
  path: string;
  payload: Uint8Array;
}

export interface ETHTransactionsRequest {
  transactions: ETHTransaction[];
}

export interface ETHTransaction {
  from: string;
  nonce: number;
  gasLimit: number;
  gasPrice: Uint8Array;
  to: string;
  amount: Uint8Array;
  payload: Uint8Array;
  id: string;
  isNonceSet: boolean;
  chainId: number;
}

export interface ETHCreateContractRequest {
  from: string;
  nonce: number;
  gasLimit: number;
  gasPrice: Uint8Array;
  amount: Uint8Array;
  payload: Uint8Array;
  id: string;
  isNonceSet: boolean;
  chainId: number;
}

export interface ETHAddressRequest {
  /** BIP 44 path */
  path: string;
}

export interface ETHProofOfReserveRequest {
  path: string;
  challenge: string;
}

export interface ETHTransactionsResponse {
  transactions: ETHTransactionsResponse_ETHTransactionResponse[];
}

export interface ETHTransactionsResponse_ETHTransactionResponse {
  id: string;
  transaction: string;
  publicKey: Uint8Array;
}

export interface ETHSignTextRequest {
  id: string;
  from: string;
  message: string;
}

export interface ETHSignTextResponse {
  id: string;
  /** r::s */
  signature: Uint8Array;
  publicKey: Uint8Array;
}

export interface ETHWrappedTransactionsRequest {
  transactions: ETHWrappedTransaction[];
}

export interface ETHWrappedTransaction {
  domainSeparator: Uint8Array;
  requestTypeHash: Uint8Array;
  from: string;
  to: string;
  nonce: number;
  gasLimit: number;
  payload: Uint8Array;
  id: string;
  isNonceSet: boolean;
  forwarder: string;
  deadline: number;
  forwarderKind: ETHWrappedTransaction_ForwarderKind;
}

export enum ETHWrappedTransaction_ForwarderKind {
  GSNForwarderV2 = 0,
  OpenZeppelinForwarder = 1,
  UNRECOGNIZED = -1,
}

export function eTHWrappedTransaction_ForwarderKindFromJSON(object: any): ETHWrappedTransaction_ForwarderKind {
  switch (object) {
    case 0:
    case "GSNForwarderV2":
      return ETHWrappedTransaction_ForwarderKind.GSNForwarderV2;
    case 1:
    case "OpenZeppelinForwarder":
      return ETHWrappedTransaction_ForwarderKind.OpenZeppelinForwarder;
    case -1:
    case "UNRECOGNIZED":
    default:
      return ETHWrappedTransaction_ForwarderKind.UNRECOGNIZED;
  }
}

export function eTHWrappedTransaction_ForwarderKindToJSON(object: ETHWrappedTransaction_ForwarderKind): string {
  switch (object) {
    case ETHWrappedTransaction_ForwarderKind.GSNForwarderV2:
      return "GSNForwarderV2";
    case ETHWrappedTransaction_ForwarderKind.OpenZeppelinForwarder:
      return "OpenZeppelinForwarder";
    case ETHWrappedTransaction_ForwarderKind.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

export interface ETHWrappedCreateContractRequest {
  domainSeparator: Uint8Array;
  requestTypeHash: Uint8Array;
  from: string;
  nonce: number;
  payload: Uint8Array;
  id: string;
  isNonceSet: boolean;
  creator: string;
}

export interface ETHWrappedTransactionsResponse {
  transactions: ETHWrappedTransactionsResponse_ETHWrappedTransactionResponse[];
}

export interface ETHWrappedTransactionsResponse_ETHWrappedTransactionResponse {
  id: string;
  transaction: string;
  publicKey: Uint8Array;
}

export interface ETHWrappedCreateContractResponse {
  id: string;
  transaction: string;
  publicKey: Uint8Array;
}

export interface BTCInput {
  path: string;
  addressType: BTCAddressType;
  txHash: Uint8Array;
  outputIndex: number;
  value: number;
  sequenceNumber: number;
}

export interface BTCOutput {
  destination: string;
  amount: number;
}

export interface BTCChangeOutput {
  /** A change address must be internal */
  path: string;
  addressType: BTCAddressType;
  amount: number;
}

export interface BTCTransactionRequest {
  inputs: BTCInput[];
  outputs: BTCOutput[];
  changeOutputs: BTCChangeOutput[];
  /**  */
  lockTime: number;
  hashType: BTCSigHashType;
  id: string;
  size: number;
}

export interface BTCAddressRequest {
  /** BIP 44 path */
  path: string;
  /** P2PKH or P2SH-P2WPKH */
  addressType: BTCAddressType;
}

export interface BTCProofOfReserveRequest {
  path: string;
  /** P2PKH or P2SH-P2WPKH */
  addressType: BTCAddressType;
  challenge: string;
}

export interface BTCSignTextRequest {
  id: string;
  /** BIP 44 path */
  from: string;
  /** message to sign, without the "\x18Bitcoin Signed Message:\n" prefix */
  message: string;
}

export interface BTCSignTextResponse {
  id: string;
  /** 64 bytes signature r::s */
  signature: Uint8Array;
  publicKey: Uint8Array;
}

export interface LTCInput {
  path: string;
  addressType: LTCAddressType;
  txHash: Uint8Array;
  outputIndex: number;
  value: number;
  sequenceNumber: number;
}

export interface LTCOutput {
  destination: string;
  amount: number;
}

export interface LTCChangeOutput {
  /** A change address must be internal */
  path: string;
  addressType: LTCAddressType;
  amount: number;
}

export interface LTCTransactionRequest {
  inputs: LTCInput[];
  outputs: LTCOutput[];
  changeOutputs: LTCChangeOutput[];
  /**  */
  lockTime: number;
  hashType: LTCSigHashType;
  id: string;
}

export interface LTCAddressRequest {
  /** BIP 44 path */
  path: string;
  /** P2PKH or P2SH-P2WPKH */
  addressType: LTCAddressType;
}

export interface LTCProofOfReserveRequest {
  path: string;
  /** P2PKH or P2SH-P2WPKH */
  addressType: LTCAddressType;
  challenge: string;
}

export interface BCHInput {
  path: string;
  addressType: BCHAddressType;
  txHash: Uint8Array;
  outputIndex: number;
  value: number;
  sequenceNumber: number;
}

export interface BCHOutput {
  destination: string;
  amount: number;
}

export interface BCHChangeOutput {
  /** A change address must be internal */
  path: string;
  addressType: BCHAddressType;
  amount: number;
}

export interface BCHTransactionRequest {
  inputs: BCHInput[];
  outputs: BCHOutput[];
  changeOutputs: BCHChangeOutput[];
  /**  */
  lockTime: number;
  hashType: BCHSigHashType;
  id: string;
}

export interface BCHAddressRequest {
  /** BIP 44 path */
  path: string;
  /** P2PKH or P2SH-P2WPKH */
  addressType: BCHAddressType;
}

export interface BCHProofOfReserveRequest {
  path: string;
  /** P2PKH or P2SH-P2WPKH */
  addressType: BCHAddressType;
  challenge: string;
}

export interface DOTExtrinsic {
  id: string;
  /** BIP 44 path */
  path: string;
  /** power of two in 4..4096 */
  validityPeriod: number;
  nonce: number;
  isNonceSet: boolean;
  /** bigint */
  tip: Uint8Array;
  specVersion: number;
  transVersion: number;
  genesisHash: Uint8Array;
  eraBlockHash: Uint8Array;
  eraBlockNumber: number;
  /** bigint */
  fee: Uint8Array;
  network: DOTExtrinsic_Network;
}

export enum DOTExtrinsic_Network {
  mainnet = 0,
  assethub = 1,
  westend = 2,
  assethubWestend = 3,
  UNRECOGNIZED = -1,
}

export function dOTExtrinsic_NetworkFromJSON(object: any): DOTExtrinsic_Network {
  switch (object) {
    case 0:
    case "mainnet":
      return DOTExtrinsic_Network.mainnet;
    case 1:
    case "assethub":
      return DOTExtrinsic_Network.assethub;
    case 2:
    case "westend":
      return DOTExtrinsic_Network.westend;
    case 3:
    case "assethubWestend":
      return DOTExtrinsic_Network.assethubWestend;
    case -1:
    case "UNRECOGNIZED":
    default:
      return DOTExtrinsic_Network.UNRECOGNIZED;
  }
}

export function dOTExtrinsic_NetworkToJSON(object: DOTExtrinsic_Network): string {
  switch (object) {
    case DOTExtrinsic_Network.mainnet:
      return "mainnet";
    case DOTExtrinsic_Network.assethub:
      return "assethub";
    case DOTExtrinsic_Network.westend:
      return "westend";
    case DOTExtrinsic_Network.assethubWestend:
      return "assethubWestend";
    case DOTExtrinsic_Network.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

export interface DOTAddressRequest {
  /** BIP 44 path */
  path: string;
}

export interface DOTTransactionsRequest {
  transactions: DOTTransaction[];
}

export interface DOTTransaction {
  destination: string;
  /** bigint */
  amount: Uint8Array;
  extrinsic:
    | DOTExtrinsic
    | undefined;
  /** Switch between transfer_keep_alive and transfer */
  unsafe: boolean;
}

export interface DOTProofOfReserveRequest {
  path: string;
  challenge: string;
}

export interface DOTPayoutStakersRequest {
  validator: string;
  era: number;
  extrinsic: DOTExtrinsic | undefined;
}

export interface DOTBondRequest {
  amount: Uint8Array;
  staked: boolean;
  extrinsic: DOTExtrinsic | undefined;
}

export interface DOTUnbondRequest {
  amount: Uint8Array;
  extrinsic: DOTExtrinsic | undefined;
}

export interface DOTBondExtraRequest {
  amount: Uint8Array;
  extrinsic: DOTExtrinsic | undefined;
}

export interface DOTChillRequest {
  extrinsic: DOTExtrinsic | undefined;
}

export interface DOTNominateRequest {
  nominees: string[];
  extrinsic: DOTExtrinsic | undefined;
}

export interface DOTWithdrawUnbondedRequest {
  s: number;
  extrinsic: DOTExtrinsic | undefined;
}

export interface TAOAddressRequest {
  /** BIP 44 path */
  path: string;
}

export interface TAOTransactionsRequest {
  transactions: TAOTransaction[];
}

export interface TAOTransaction {
  destination: string;
  /** bigint */
  amount: Uint8Array;
  extrinsic:
    | DOTExtrinsic
    | undefined;
  /** Switch between transfer_keep_alive and transfer */
  unsafe: boolean;
}

export interface TAOProofOfReserveRequest {
  path: string;
  challenge: string;
}

export interface TAOAddStakeRequest {
  /** ss58 formatted address, validator hotkey */
  destination: string;
  amount: Uint8Array;
  extrinsic: DOTExtrinsic | undefined;
}

export interface TAORemoveStakeRequest {
  /** ss58 formatted address, validator hotkey */
  destination: string;
  amount: Uint8Array;
  extrinsic: DOTExtrinsic | undefined;
}

export interface FTMTransactionsRequest {
  transactions: FTMTransaction[];
}

export interface FTMTransaction {
  from: string;
  nonce: number;
  gasLimit: number;
  gasPrice: Uint8Array;
  to: string;
  amount: Uint8Array;
  /** bytes payload = 7; */
  id: string;
  isNonceSet: boolean;
}

export interface FTMAddressRequest {
  /** BIP 44 path */
  path: string;
}

export interface FTMProofOfReserveRequest {
  path: string;
  challenge: string;
}

export interface FTMStakingDelegateRequest {
  tx: FTMTransaction | undefined;
  validatorId: number;
  operation: FTMStakingDelegateRequest_FTMDelegateOperation;
  withdrawalId: number;
  withdrawalAmount: Uint8Array;
}

export enum FTMStakingDelegateRequest_FTMDelegateOperation {
  Delegate = 0,
  Undelegate = 1,
  Withdraw = 2,
  UNRECOGNIZED = -1,
}

export function fTMStakingDelegateRequest_FTMDelegateOperationFromJSON(
  object: any,
): FTMStakingDelegateRequest_FTMDelegateOperation {
  switch (object) {
    case 0:
    case "Delegate":
      return FTMStakingDelegateRequest_FTMDelegateOperation.Delegate;
    case 1:
    case "Undelegate":
      return FTMStakingDelegateRequest_FTMDelegateOperation.Undelegate;
    case 2:
    case "Withdraw":
      return FTMStakingDelegateRequest_FTMDelegateOperation.Withdraw;
    case -1:
    case "UNRECOGNIZED":
    default:
      return FTMStakingDelegateRequest_FTMDelegateOperation.UNRECOGNIZED;
  }
}

export function fTMStakingDelegateRequest_FTMDelegateOperationToJSON(
  object: FTMStakingDelegateRequest_FTMDelegateOperation,
): string {
  switch (object) {
    case FTMStakingDelegateRequest_FTMDelegateOperation.Delegate:
      return "Delegate";
    case FTMStakingDelegateRequest_FTMDelegateOperation.Undelegate:
      return "Undelegate";
    case FTMStakingDelegateRequest_FTMDelegateOperation.Withdraw:
      return "Withdraw";
    case FTMStakingDelegateRequest_FTMDelegateOperation.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

export interface FTMStakingClaimRewardsRequest {
  tx: FTMTransaction | undefined;
  validatorId: number;
  restake: boolean;
}

export interface FTMStakingLockRequest {
  tx: FTMTransaction | undefined;
  validatorId: number;
  operation: FTMStakingLockRequest_FTMLockOperation;
  duration: number;
  lockAmount: Uint8Array;
}

export enum FTMStakingLockRequest_FTMLockOperation {
  Lock = 0,
  Relock = 1,
  Unlock = 2,
  UNRECOGNIZED = -1,
}

export function fTMStakingLockRequest_FTMLockOperationFromJSON(object: any): FTMStakingLockRequest_FTMLockOperation {
  switch (object) {
    case 0:
    case "Lock":
      return FTMStakingLockRequest_FTMLockOperation.Lock;
    case 1:
    case "Relock":
      return FTMStakingLockRequest_FTMLockOperation.Relock;
    case 2:
    case "Unlock":
      return FTMStakingLockRequest_FTMLockOperation.Unlock;
    case -1:
    case "UNRECOGNIZED":
    default:
      return FTMStakingLockRequest_FTMLockOperation.UNRECOGNIZED;
  }
}

export function fTMStakingLockRequest_FTMLockOperationToJSON(object: FTMStakingLockRequest_FTMLockOperation): string {
  switch (object) {
    case FTMStakingLockRequest_FTMLockOperation.Lock:
      return "Lock";
    case FTMStakingLockRequest_FTMLockOperation.Relock:
      return "Relock";
    case FTMStakingLockRequest_FTMLockOperation.Unlock:
      return "Unlock";
    case FTMStakingLockRequest_FTMLockOperation.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

export interface FTMTransactionsResponse {
  transactions: FTMTransactionsResponse_FTMTransactionResponse[];
}

export interface FTMTransactionsResponse_FTMTransactionResponse {
  id: string;
  transaction: string;
  publicKey: Uint8Array;
}

export interface SonicTransactionsRequest {
  transactions: SonicTransaction[];
}

export interface SonicTransaction {
  from: string;
  nonce: number;
  gasLimit: number;
  gasPrice: Uint8Array;
  to: string;
  amount: Uint8Array;
  /** bytes payload = 7; */
  id: string;
  isNonceSet: boolean;
}

export interface SonicAddressRequest {
  /** BIP 44 path */
  path: string;
}

export interface SonicProofOfReserveRequest {
  path: string;
  challenge: string;
}

export interface SonicStakingDelegateRequest {
  tx: SonicTransaction | undefined;
  validatorId: number;
  operation: SonicStakingDelegateRequest_SonicDelegateOperation;
  withdrawalId: number;
  withdrawalAmount: Uint8Array;
}

export enum SonicStakingDelegateRequest_SonicDelegateOperation {
  Delegate = 0,
  Undelegate = 1,
  Withdraw = 2,
  UNRECOGNIZED = -1,
}

export function sonicStakingDelegateRequest_SonicDelegateOperationFromJSON(
  object: any,
): SonicStakingDelegateRequest_SonicDelegateOperation {
  switch (object) {
    case 0:
    case "Delegate":
      return SonicStakingDelegateRequest_SonicDelegateOperation.Delegate;
    case 1:
    case "Undelegate":
      return SonicStakingDelegateRequest_SonicDelegateOperation.Undelegate;
    case 2:
    case "Withdraw":
      return SonicStakingDelegateRequest_SonicDelegateOperation.Withdraw;
    case -1:
    case "UNRECOGNIZED":
    default:
      return SonicStakingDelegateRequest_SonicDelegateOperation.UNRECOGNIZED;
  }
}

export function sonicStakingDelegateRequest_SonicDelegateOperationToJSON(
  object: SonicStakingDelegateRequest_SonicDelegateOperation,
): string {
  switch (object) {
    case SonicStakingDelegateRequest_SonicDelegateOperation.Delegate:
      return "Delegate";
    case SonicStakingDelegateRequest_SonicDelegateOperation.Undelegate:
      return "Undelegate";
    case SonicStakingDelegateRequest_SonicDelegateOperation.Withdraw:
      return "Withdraw";
    case SonicStakingDelegateRequest_SonicDelegateOperation.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

export interface SonicStakingClaimRewardsRequest {
  tx: SonicTransaction | undefined;
  validatorId: number;
  restake: boolean;
}

export interface SonicTransactionsResponse {
  transactions: SonicTransactionsResponse_SonicTransactionResponse[];
}

export interface SonicTransactionsResponse_SonicTransactionResponse {
  id: string;
  transaction: string;
  publicKey: Uint8Array;
}

export interface ALGOTransactionsRequest {
  transactions: ALGOTransaction[];
}

export interface ALGOTransactionMaterial {
  fee: number;
  fv: number;
  lv: number;
  /** 32 bytes */
  lx: Uint8Array;
  gen: string;
  /** 32 bytes */
  gh: Uint8Array;
  /** max 1kb */
  note: Uint8Array;
}

export interface ALGOTransaction {
  /** BIP 44 path */
  path: string;
  to: string;
  amount: number;
  material: ALGOTransactionMaterial | undefined;
  id: string;
}

export interface ALGOAddressRequest {
  /** BIP 44 path */
  path: string;
}

export interface ALGOProofOfReserveRequest {
  path: string;
  challenge: string;
}

export interface ALGOAssetOptinRequest {
  /** BIP 44 path */
  path: string;
  assetID: number;
  material: ALGOTransactionMaterial | undefined;
  id: string;
}

export interface ALGOAssetTransferRequest {
  transfers: ALGOAssetTransfer[];
}

export interface ALGOAssetTransfer {
  /** BIP 44 path */
  path: string;
  to: string;
  assetID: number;
  amount: number;
  material: ALGOTransactionMaterial | undefined;
  id: string;
}

export interface HederaAddressRequest {
  shardNum: number;
  realmNum: number;
  path: string;
}

export interface HederaTransactionsRequest {
  kind: HederaTransactionsRequest_OperationKind;
  transactions: HederaTransaction[];
}

export enum HederaTransactionsRequest_OperationKind {
  Invalid = 0,
  ContractCall = 7,
  ContractCreate = 8,
  ContractUpdate = 9,
  CryptoAddLiveHash = 10,
  CryptoCreate = 11,
  CryptoDelete = 12,
  CryptoDeleteLiveHash = 13,
  CryptoTransfer = 14,
  CryptoUpdate = 15,
  FileAppend = 16,
  FileCreate = 17,
  FileDelete = 18,
  FileUpdate = 19,
  SystemDelete = 20,
  SystemUndelete = 21,
  ContractDelete = 22,
  Freeze = 23,
  ConsensusCreateTopic = 24,
  ConsensusUpdateTopic = 25,
  ConsensusDeleteTopic = 26,
  ConsensusSubmitMessage = 27,
  UncheckedSubmitBody = 28,
  TokenCreate = 29,
  TokenFreezeAccount = 31,
  TokenUnfreezeAccount = 32,
  TokenGrantKyc = 33,
  TokenRevokeKyc = 34,
  TokenDelete = 35,
  TokenUpdate = 36,
  TokenMint = 37,
  TokenBurn = 38,
  TokenWipeAccount = 39,
  TokenAssociate = 40,
  TokenDissociate = 41,
  ScheduleCreate = 42,
  ScheduleDelete = 43,
  ScheduleSign = 44,
  TokenFeeScheduleUpdate = 45,
  TokenPause = 46,
  TokenUnpause = 47,
  CryptoApproveAllowance = 48,
  CryptoDeleteAllowance = 49,
  Ethereum = 50,
  NodeStakeUpdate = 51,
  UtilPrng = 52,
  TokenUpdateNfts = 53,
  NodeCreate = 54,
  NodeUpdate = 55,
  NodeDelete = 56,
  TokenReject = 57,
  TokenAirdrop = 58,
  TokenCancelAirdrop = 59,
  TokenClaimAirdrop = 60,
  UNRECOGNIZED = -1,
}

export function hederaTransactionsRequest_OperationKindFromJSON(object: any): HederaTransactionsRequest_OperationKind {
  switch (object) {
    case 0:
    case "Invalid":
      return HederaTransactionsRequest_OperationKind.Invalid;
    case 7:
    case "ContractCall":
      return HederaTransactionsRequest_OperationKind.ContractCall;
    case 8:
    case "ContractCreate":
      return HederaTransactionsRequest_OperationKind.ContractCreate;
    case 9:
    case "ContractUpdate":
      return HederaTransactionsRequest_OperationKind.ContractUpdate;
    case 10:
    case "CryptoAddLiveHash":
      return HederaTransactionsRequest_OperationKind.CryptoAddLiveHash;
    case 11:
    case "CryptoCreate":
      return HederaTransactionsRequest_OperationKind.CryptoCreate;
    case 12:
    case "CryptoDelete":
      return HederaTransactionsRequest_OperationKind.CryptoDelete;
    case 13:
    case "CryptoDeleteLiveHash":
      return HederaTransactionsRequest_OperationKind.CryptoDeleteLiveHash;
    case 14:
    case "CryptoTransfer":
      return HederaTransactionsRequest_OperationKind.CryptoTransfer;
    case 15:
    case "CryptoUpdate":
      return HederaTransactionsRequest_OperationKind.CryptoUpdate;
    case 16:
    case "FileAppend":
      return HederaTransactionsRequest_OperationKind.FileAppend;
    case 17:
    case "FileCreate":
      return HederaTransactionsRequest_OperationKind.FileCreate;
    case 18:
    case "FileDelete":
      return HederaTransactionsRequest_OperationKind.FileDelete;
    case 19:
    case "FileUpdate":
      return HederaTransactionsRequest_OperationKind.FileUpdate;
    case 20:
    case "SystemDelete":
      return HederaTransactionsRequest_OperationKind.SystemDelete;
    case 21:
    case "SystemUndelete":
      return HederaTransactionsRequest_OperationKind.SystemUndelete;
    case 22:
    case "ContractDelete":
      return HederaTransactionsRequest_OperationKind.ContractDelete;
    case 23:
    case "Freeze":
      return HederaTransactionsRequest_OperationKind.Freeze;
    case 24:
    case "ConsensusCreateTopic":
      return HederaTransactionsRequest_OperationKind.ConsensusCreateTopic;
    case 25:
    case "ConsensusUpdateTopic":
      return HederaTransactionsRequest_OperationKind.ConsensusUpdateTopic;
    case 26:
    case "ConsensusDeleteTopic":
      return HederaTransactionsRequest_OperationKind.ConsensusDeleteTopic;
    case 27:
    case "ConsensusSubmitMessage":
      return HederaTransactionsRequest_OperationKind.ConsensusSubmitMessage;
    case 28:
    case "UncheckedSubmitBody":
      return HederaTransactionsRequest_OperationKind.UncheckedSubmitBody;
    case 29:
    case "TokenCreate":
      return HederaTransactionsRequest_OperationKind.TokenCreate;
    case 31:
    case "TokenFreezeAccount":
      return HederaTransactionsRequest_OperationKind.TokenFreezeAccount;
    case 32:
    case "TokenUnfreezeAccount":
      return HederaTransactionsRequest_OperationKind.TokenUnfreezeAccount;
    case 33:
    case "TokenGrantKyc":
      return HederaTransactionsRequest_OperationKind.TokenGrantKyc;
    case 34:
    case "TokenRevokeKyc":
      return HederaTransactionsRequest_OperationKind.TokenRevokeKyc;
    case 35:
    case "TokenDelete":
      return HederaTransactionsRequest_OperationKind.TokenDelete;
    case 36:
    case "TokenUpdate":
      return HederaTransactionsRequest_OperationKind.TokenUpdate;
    case 37:
    case "TokenMint":
      return HederaTransactionsRequest_OperationKind.TokenMint;
    case 38:
    case "TokenBurn":
      return HederaTransactionsRequest_OperationKind.TokenBurn;
    case 39:
    case "TokenWipeAccount":
      return HederaTransactionsRequest_OperationKind.TokenWipeAccount;
    case 40:
    case "TokenAssociate":
      return HederaTransactionsRequest_OperationKind.TokenAssociate;
    case 41:
    case "TokenDissociate":
      return HederaTransactionsRequest_OperationKind.TokenDissociate;
    case 42:
    case "ScheduleCreate":
      return HederaTransactionsRequest_OperationKind.ScheduleCreate;
    case 43:
    case "ScheduleDelete":
      return HederaTransactionsRequest_OperationKind.ScheduleDelete;
    case 44:
    case "ScheduleSign":
      return HederaTransactionsRequest_OperationKind.ScheduleSign;
    case 45:
    case "TokenFeeScheduleUpdate":
      return HederaTransactionsRequest_OperationKind.TokenFeeScheduleUpdate;
    case 46:
    case "TokenPause":
      return HederaTransactionsRequest_OperationKind.TokenPause;
    case 47:
    case "TokenUnpause":
      return HederaTransactionsRequest_OperationKind.TokenUnpause;
    case 48:
    case "CryptoApproveAllowance":
      return HederaTransactionsRequest_OperationKind.CryptoApproveAllowance;
    case 49:
    case "CryptoDeleteAllowance":
      return HederaTransactionsRequest_OperationKind.CryptoDeleteAllowance;
    case 50:
    case "Ethereum":
      return HederaTransactionsRequest_OperationKind.Ethereum;
    case 51:
    case "NodeStakeUpdate":
      return HederaTransactionsRequest_OperationKind.NodeStakeUpdate;
    case 52:
    case "UtilPrng":
      return HederaTransactionsRequest_OperationKind.UtilPrng;
    case 53:
    case "TokenUpdateNfts":
      return HederaTransactionsRequest_OperationKind.TokenUpdateNfts;
    case 54:
    case "NodeCreate":
      return HederaTransactionsRequest_OperationKind.NodeCreate;
    case 55:
    case "NodeUpdate":
      return HederaTransactionsRequest_OperationKind.NodeUpdate;
    case 56:
    case "NodeDelete":
      return HederaTransactionsRequest_OperationKind.NodeDelete;
    case 57:
    case "TokenReject":
      return HederaTransactionsRequest_OperationKind.TokenReject;
    case 58:
    case "TokenAirdrop":
      return HederaTransactionsRequest_OperationKind.TokenAirdrop;
    case 59:
    case "TokenCancelAirdrop":
      return HederaTransactionsRequest_OperationKind.TokenCancelAirdrop;
    case 60:
    case "TokenClaimAirdrop":
      return HederaTransactionsRequest_OperationKind.TokenClaimAirdrop;
    case -1:
    case "UNRECOGNIZED":
    default:
      return HederaTransactionsRequest_OperationKind.UNRECOGNIZED;
  }
}

export function hederaTransactionsRequest_OperationKindToJSON(object: HederaTransactionsRequest_OperationKind): string {
  switch (object) {
    case HederaTransactionsRequest_OperationKind.Invalid:
      return "Invalid";
    case HederaTransactionsRequest_OperationKind.ContractCall:
      return "ContractCall";
    case HederaTransactionsRequest_OperationKind.ContractCreate:
      return "ContractCreate";
    case HederaTransactionsRequest_OperationKind.ContractUpdate:
      return "ContractUpdate";
    case HederaTransactionsRequest_OperationKind.CryptoAddLiveHash:
      return "CryptoAddLiveHash";
    case HederaTransactionsRequest_OperationKind.CryptoCreate:
      return "CryptoCreate";
    case HederaTransactionsRequest_OperationKind.CryptoDelete:
      return "CryptoDelete";
    case HederaTransactionsRequest_OperationKind.CryptoDeleteLiveHash:
      return "CryptoDeleteLiveHash";
    case HederaTransactionsRequest_OperationKind.CryptoTransfer:
      return "CryptoTransfer";
    case HederaTransactionsRequest_OperationKind.CryptoUpdate:
      return "CryptoUpdate";
    case HederaTransactionsRequest_OperationKind.FileAppend:
      return "FileAppend";
    case HederaTransactionsRequest_OperationKind.FileCreate:
      return "FileCreate";
    case HederaTransactionsRequest_OperationKind.FileDelete:
      return "FileDelete";
    case HederaTransactionsRequest_OperationKind.FileUpdate:
      return "FileUpdate";
    case HederaTransactionsRequest_OperationKind.SystemDelete:
      return "SystemDelete";
    case HederaTransactionsRequest_OperationKind.SystemUndelete:
      return "SystemUndelete";
    case HederaTransactionsRequest_OperationKind.ContractDelete:
      return "ContractDelete";
    case HederaTransactionsRequest_OperationKind.Freeze:
      return "Freeze";
    case HederaTransactionsRequest_OperationKind.ConsensusCreateTopic:
      return "ConsensusCreateTopic";
    case HederaTransactionsRequest_OperationKind.ConsensusUpdateTopic:
      return "ConsensusUpdateTopic";
    case HederaTransactionsRequest_OperationKind.ConsensusDeleteTopic:
      return "ConsensusDeleteTopic";
    case HederaTransactionsRequest_OperationKind.ConsensusSubmitMessage:
      return "ConsensusSubmitMessage";
    case HederaTransactionsRequest_OperationKind.UncheckedSubmitBody:
      return "UncheckedSubmitBody";
    case HederaTransactionsRequest_OperationKind.TokenCreate:
      return "TokenCreate";
    case HederaTransactionsRequest_OperationKind.TokenFreezeAccount:
      return "TokenFreezeAccount";
    case HederaTransactionsRequest_OperationKind.TokenUnfreezeAccount:
      return "TokenUnfreezeAccount";
    case HederaTransactionsRequest_OperationKind.TokenGrantKyc:
      return "TokenGrantKyc";
    case HederaTransactionsRequest_OperationKind.TokenRevokeKyc:
      return "TokenRevokeKyc";
    case HederaTransactionsRequest_OperationKind.TokenDelete:
      return "TokenDelete";
    case HederaTransactionsRequest_OperationKind.TokenUpdate:
      return "TokenUpdate";
    case HederaTransactionsRequest_OperationKind.TokenMint:
      return "TokenMint";
    case HederaTransactionsRequest_OperationKind.TokenBurn:
      return "TokenBurn";
    case HederaTransactionsRequest_OperationKind.TokenWipeAccount:
      return "TokenWipeAccount";
    case HederaTransactionsRequest_OperationKind.TokenAssociate:
      return "TokenAssociate";
    case HederaTransactionsRequest_OperationKind.TokenDissociate:
      return "TokenDissociate";
    case HederaTransactionsRequest_OperationKind.ScheduleCreate:
      return "ScheduleCreate";
    case HederaTransactionsRequest_OperationKind.ScheduleDelete:
      return "ScheduleDelete";
    case HederaTransactionsRequest_OperationKind.ScheduleSign:
      return "ScheduleSign";
    case HederaTransactionsRequest_OperationKind.TokenFeeScheduleUpdate:
      return "TokenFeeScheduleUpdate";
    case HederaTransactionsRequest_OperationKind.TokenPause:
      return "TokenPause";
    case HederaTransactionsRequest_OperationKind.TokenUnpause:
      return "TokenUnpause";
    case HederaTransactionsRequest_OperationKind.CryptoApproveAllowance:
      return "CryptoApproveAllowance";
    case HederaTransactionsRequest_OperationKind.CryptoDeleteAllowance:
      return "CryptoDeleteAllowance";
    case HederaTransactionsRequest_OperationKind.Ethereum:
      return "Ethereum";
    case HederaTransactionsRequest_OperationKind.NodeStakeUpdate:
      return "NodeStakeUpdate";
    case HederaTransactionsRequest_OperationKind.UtilPrng:
      return "UtilPrng";
    case HederaTransactionsRequest_OperationKind.TokenUpdateNfts:
      return "TokenUpdateNfts";
    case HederaTransactionsRequest_OperationKind.NodeCreate:
      return "NodeCreate";
    case HederaTransactionsRequest_OperationKind.NodeUpdate:
      return "NodeUpdate";
    case HederaTransactionsRequest_OperationKind.NodeDelete:
      return "NodeDelete";
    case HederaTransactionsRequest_OperationKind.TokenReject:
      return "TokenReject";
    case HederaTransactionsRequest_OperationKind.TokenAirdrop:
      return "TokenAirdrop";
    case HederaTransactionsRequest_OperationKind.TokenCancelAirdrop:
      return "TokenCancelAirdrop";
    case HederaTransactionsRequest_OperationKind.TokenClaimAirdrop:
      return "TokenClaimAirdrop";
    case HederaTransactionsRequest_OperationKind.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

export interface HederaAccount {
  shardNum: number;
  realmNum: number;
  accountID: number;
}

export interface HederaTimestamp {
  seconds: number;
  nanos: number;
}

export interface HederaTransaction {
  id: string;
  timestamp: HederaTimestamp | undefined;
  source: HederaAccount | undefined;
  sourcePath: string;
  node: HederaAccount | undefined;
  feeLimit: number;
  ttlSeconds: number;
  memo: string;
  operation: Uint8Array;
}

export interface HederaProofOfReserveRequest {
  shardNum: number;
  realmNum: number;
  path: string;
  challenge: string;
}

export interface SOLAddressRequest {
  /** BIP 44 path */
  path: string;
}

export interface SOLProofOfReserveRequest {
  path: string;
  challenge: string;
}

export interface SOLCleanupDerivedAccountRequest {
  blockHash: string;
  path: string;
  seed: string;
  program: string;
  amount: number;
  id: string;
}

export interface SOLTransfersRequest {
  transfers: SOLTransfer[];
}

export interface SOLTransfer {
  blockHash: string;
  path: string;
  to: string;
  amount: number;
  /** [deprecated = true] deprecated in favor of compute price + budget, but still needed for old HSMs */
  fee: number;
  id: string;
  /** priorityFee = computePrice * computeBudget / 1e6 */
  computePrice: number;
  /** in compute units */
  computeBudget: number;
}

export interface SOLDelegateStakeRequest {
  blockHash: string;
  path: string;
  createAccount: boolean;
  space: number;
  amount: number;
  voter: string;
  id: string;
  computePrice: number;
  computeBudget: number;
  /** index of the derivation path for the stake account */
  derivationIndex: number;
}

export interface SOLDeactivateStakeRequest {
  blockHash: string;
  path: string;
  id: string;
  computePrice: number;
  computeBudget: number;
  /** index of the derivation path for the stake account */
  derivationIndex: number;
}

export interface SOLPartialDeactivateStakeRequest {
  blockHash: string;
  path: string;
  /** index of the (existing) source account */
  sourceDerivationIndex: number;
  /** index of the (new) destination account */
  destinationDerivationIndex: number;
  space: number;
  rentExemptBalance: number;
  amount: number;
  /** which part of amount is currently inactive */
  inactiveAmount: number;
  id: string;
  computePrice: number;
  computeBudget: number;
}

export interface SOLWithdrawStakeRequest {
  blockHash: string;
  path: string;
  amount: number;
  id: string;
  computePrice: number;
  computeBudget: number;
  /** index of the derivation path for the stake account */
  derivationIndex: number;
}

export interface SOLMergeStakeRequest {
  blockHash: string;
  path: string;
  /** index of the (vanishing) source account */
  sourceDerivationIndex: number;
  /** index of the (remaining) destination account */
  destinationDerivationIndex: number;
  id: string;
  computePrice: number;
  computeBudget: number;
}

export interface SOLTokenCreateRequest {
  blockHash: string;
  path: string;
  program: string;
  seed: string;
  decimals: number;
  rentExemptBalance: number;
  name: string;
  symbol: string;
  uri: string;
  id: string;
  computePrice: number;
  computeBudget: number;
  enableFreeze: boolean;
}

export interface SOLTokenMintRequest {
  blockHash: string;
  path: string;
  program: string;
  mint: string;
  decimals: number;
  destination: string;
  createAccount: boolean;
  amount: number;
  id: string;
  computePrice: number;
  computeBudget: number;
}

export interface SOLTokenBurnRequest {
  blockHash: string;
  path: string;
  program: string;
  mint: string;
  decimals: number;
  amount: number;
  id: string;
  computePrice: number;
  computeBudget: number;
}

/** SOLTokenFreezeAccountRequest also handles the unfreeze (thaw) operation */
export interface SOLTokenFreezeAccountRequest {
  blockHash: string;
  path: string;
  destination: string;
  createAccount: boolean;
  program: string;
  mint: string;
  operation: SOLTokenFreezeAccountRequest_OperationKind;
  id: string;
  computePrice: number;
  computeBudget: number;
}

export enum SOLTokenFreezeAccountRequest_OperationKind {
  Freeze = 0,
  Unfreeze = 1,
  UNRECOGNIZED = -1,
}

export function sOLTokenFreezeAccountRequest_OperationKindFromJSON(
  object: any,
): SOLTokenFreezeAccountRequest_OperationKind {
  switch (object) {
    case 0:
    case "Freeze":
      return SOLTokenFreezeAccountRequest_OperationKind.Freeze;
    case 1:
    case "Unfreeze":
      return SOLTokenFreezeAccountRequest_OperationKind.Unfreeze;
    case -1:
    case "UNRECOGNIZED":
    default:
      return SOLTokenFreezeAccountRequest_OperationKind.UNRECOGNIZED;
  }
}

export function sOLTokenFreezeAccountRequest_OperationKindToJSON(
  object: SOLTokenFreezeAccountRequest_OperationKind,
): string {
  switch (object) {
    case SOLTokenFreezeAccountRequest_OperationKind.Freeze:
      return "Freeze";
    case SOLTokenFreezeAccountRequest_OperationKind.Unfreeze:
      return "Unfreeze";
    case SOLTokenFreezeAccountRequest_OperationKind.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

export interface SOLTokenTransfersRequest {
  transfers: SOLTokenTransfer[];
}

export interface SOLTokenTransfer {
  blockHash: string;
  path: string;
  to: string;
  amount: number;
  /** uint64 fee = 5; // deprecated in favor of compute price + budget */
  createDestination: boolean;
  mint: string;
  /** uint8 when unpacked */
  decimals: number;
  program: string;
  id: string;
  computePrice: number;
  computeBudget: number;
  /** optional. if set, rule SOLTokenTransferWithFeepayer is required. */
  feepayer: string;
}

export interface CosmosAddressRequest {
  path: string;
  prefix: string;
}

export interface CosmosProofOfReserveRequest {
  path: string;
  prefix: string;
  challenge: string;
}

export interface CosmosRequestDetails {
  chainId: string;
  signers: CosmosSigner[];
  gasLimit: number;
  feeDenom: string;
  feeAmount: Uint8Array;
  /** should be one of the signers */
  feePayer: string;
  memo: string;
  timeoutHeight: number;
  id: string;
  isNonceSet: boolean;
  isRawRequest: boolean;
  isTransferRequest: boolean;
}

export interface CosmosSigner {
  path: string;
  sequence: number;
  accountNumber: number;
}

export interface CosmosMessage {
  url: string;
  payload: Uint8Array;
}

/** Generic call requests */
export interface CosmosGenericCallRequest {
  details: CosmosRequestDetails | undefined;
  messages: CosmosMessage[];
}

export interface CosmosCancelRequest {
  details: CosmosRequestDetails | undefined;
  addressPrefix: string;
}

export interface PolygonTransactionsRequest {
  transactions: PolygonTransaction[];
}

export interface PolygonTransaction {
  from: string;
  nonce: number;
  gasLimit: number;
  gasPrice: Uint8Array;
  to: string;
  amount: Uint8Array;
  payload: Uint8Array;
  id: string;
  isNonceSet: boolean;
  chainId: number;
}

export interface PolygonCreateContractRequest {
  from: string;
  nonce: number;
  gasLimit: number;
  gasPrice: Uint8Array;
  amount: Uint8Array;
  payload: Uint8Array;
  id: string;
  isNonceSet: boolean;
  chainId: number;
}

export interface PolygonAddressRequest {
  /** BIP 44 path */
  path: string;
}

export interface PolygonProofOfReserveRequest {
  path: string;
  challenge: string;
}

export interface PolygonTransactionsResponse {
  transactions: PolygonTransactionsResponse_PolygonTransactionResponse[];
}

export interface PolygonTransactionsResponse_PolygonTransactionResponse {
  id: string;
  transaction: string;
  publicKey: Uint8Array;
}

export interface PolygonSignTextRequest {
  id: string;
  from: string;
  message: string;
}

export interface PolygonSignTextResponse {
  id: string;
  /** r::s */
  signature: Uint8Array;
  publicKey: Uint8Array;
}

export interface PolygonWrappedTransactionsRequest {
  transactions: PolygonWrappedTransaction[];
}

export interface PolygonWrappedTransaction {
  domainSeparator: Uint8Array;
  requestTypeHash: Uint8Array;
  from: string;
  to: string;
  nonce: number;
  gasLimit: number;
  payload: Uint8Array;
  id: string;
  isNonceSet: boolean;
  forwarder: string;
}

export interface PolygonWrappedCreateContractRequest {
  domainSeparator: Uint8Array;
  requestTypeHash: Uint8Array;
  from: string;
  nonce: number;
  payload: Uint8Array;
  id: string;
  isNonceSet: boolean;
  creator: string;
}

export interface PolygonWrappedTransactionsResponse {
  transactions: PolygonWrappedTransactionsResponse_PolygonWrappedTransactionResponse[];
}

export interface PolygonWrappedTransactionsResponse_PolygonWrappedTransactionResponse {
  id: string;
  transaction: string;
  publicKey: Uint8Array;
}

export interface PolygonWrappedCreateContractResponse {
  id: string;
  transaction: string;
  publicKey: Uint8Array;
}

export interface AvaxCChainTransactionsRequest {
  transactions: AvaxCChainTransaction[];
}

export interface AvaxCChainTransaction {
  from: string;
  nonce: number;
  gasLimit: number;
  gasPrice: Uint8Array;
  to: string;
  amount: Uint8Array;
  payload: Uint8Array;
  id: string;
  isNonceSet: boolean;
  chainId: number;
}

export interface AvaxCChainCreateContractRequest {
  from: string;
  nonce: number;
  gasLimit: number;
  gasPrice: Uint8Array;
  amount: Uint8Array;
  payload: Uint8Array;
  id: string;
  isNonceSet: boolean;
  chainId: number;
}

export interface AvaxCChainAddressRequest {
  /** BIP 44 path */
  path: string;
}

export interface AvaxCChainProofOfReserveRequest {
  path: string;
  challenge: string;
}

export interface AvaxCChainTransactionsResponse {
  transactions: AvaxCChainTransactionsResponse_AvaxCChainTransactionResponse[];
}

export interface AvaxCChainTransactionsResponse_AvaxCChainTransactionResponse {
  id: string;
  transaction: string;
  publicKey: Uint8Array;
}

export interface AvaxCChainSignTextRequest {
  id: string;
  from: string;
  message: string;
}

export interface AvaxCChainSignTextResponse {
  id: string;
  /** r::s */
  signature: Uint8Array;
  publicKey: Uint8Array;
}

export interface AvaxCChainWrappedTransactionsRequest {
  transactions: AvaxCChainWrappedTransaction[];
}

export interface AvaxCChainWrappedTransaction {
  domainSeparator: Uint8Array;
  requestTypeHash: Uint8Array;
  from: string;
  to: string;
  nonce: number;
  gasLimit: number;
  payload: Uint8Array;
  id: string;
  isNonceSet: boolean;
  forwarder: string;
}

export interface AvaxCChainWrappedCreateContractRequest {
  domainSeparator: Uint8Array;
  requestTypeHash: Uint8Array;
  from: string;
  nonce: number;
  payload: Uint8Array;
  id: string;
  isNonceSet: boolean;
  creator: string;
}

export interface AvaxCChainWrappedTransactionsResponse {
  transactions: AvaxCChainWrappedTransactionsResponse_AvaxCChainWrappedTransactionResponse[];
}

export interface AvaxCChainWrappedTransactionsResponse_AvaxCChainWrappedTransactionResponse {
  id: string;
  transaction: string;
  publicKey: Uint8Array;
}

export interface AvaxCChainWrappedCreateContractResponse {
  id: string;
  transaction: string;
  publicKey: Uint8Array;
}

export interface DOGEInput {
  path: string;
  addressType: DOGEAddressType;
  txHash: Uint8Array;
  outputIndex: number;
  value: number;
  sequenceNumber: number;
}

export interface DOGEOutput {
  destination: string;
  amount: number;
}

export interface DOGEChangeOutput {
  /** A change address must be internal */
  path: string;
  addressType: DOGEAddressType;
  amount: number;
}

export interface DOGETransactionRequest {
  inputs: DOGEInput[];
  outputs: DOGEOutput[];
  changeOutputs: DOGEChangeOutput[];
  lockTime: number;
  hashType: DOGESigHashType;
  id: string;
}

export interface DOGEAddressRequest {
  /** BIP 44 path */
  path: string;
  /** currently only P2PKH */
  addressType: DOGEAddressType;
}

export interface DOGEProofOfReserveRequest {
  path: string;
  /** currently only P2PKH */
  addressType: DOGEAddressType;
  challenge: string;
}

export interface MinaAddressRequest {
  path: string;
}

export interface MinaTxCommon {
  id: string;
  fee: number;
  nonce: number;
  validUntil: number;
  memo: string;
  networkId: number;
  networkPrefix: Uint8Array;
  source: string;
}

export interface MinaPayment {
  common: MinaTxCommon | undefined;
  destination: string;
  amount: number;
}

export interface MinaPaymentsRequest {
  payments: MinaPayment[];
}

export interface MinaDelegationRequest {
  common: MinaTxCommon | undefined;
  delegate: string;
}

export interface MinaProofOfReserveRequest {
  path: string;
  challenge: string;
}

export interface TRONAddressRequest {
  path: string;
}

export interface TRONProofOfReserveRequest {
  path: string;
  challenge: string;
}

export interface TRONTransactionsRequest {
  kind: TRONTransactionsRequest_OperationKind;
  transactions: TRONTransaction[];
}

export enum TRONTransactionsRequest_OperationKind {
  /** Invalid - Currently invalid, but will be replaced by AccountCreateContract if supported */
  Invalid = 0,
  TransferContract = 1,
  TriggerSmartContract = 31,
  UNRECOGNIZED = -1,
}

export function tRONTransactionsRequest_OperationKindFromJSON(object: any): TRONTransactionsRequest_OperationKind {
  switch (object) {
    case 0:
    case "Invalid":
      return TRONTransactionsRequest_OperationKind.Invalid;
    case 1:
    case "TransferContract":
      return TRONTransactionsRequest_OperationKind.TransferContract;
    case 31:
    case "TriggerSmartContract":
      return TRONTransactionsRequest_OperationKind.TriggerSmartContract;
    case -1:
    case "UNRECOGNIZED":
    default:
      return TRONTransactionsRequest_OperationKind.UNRECOGNIZED;
  }
}

export function tRONTransactionsRequest_OperationKindToJSON(object: TRONTransactionsRequest_OperationKind): string {
  switch (object) {
    case TRONTransactionsRequest_OperationKind.Invalid:
      return "Invalid";
    case TRONTransactionsRequest_OperationKind.TransferContract:
      return "TransferContract";
    case TRONTransactionsRequest_OperationKind.TriggerSmartContract:
      return "TriggerSmartContract";
    case TRONTransactionsRequest_OperationKind.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

export interface TRONTransaction {
  id: string;
  source: string;
  refBlockBytes: Uint8Array;
  refBlockHash: Uint8Array;
  expiration: number;
  timestamp: number;
  feeLimit: number;
  data: Uint8Array;
  operation: Uint8Array;
}

export interface TRONTransactionsResponse {
  transactions: TRONTransactionsResponse_TRONTransactionResponse[];
}

export interface TRONTransactionsResponse_TRONTransactionResponse {
  id: string;
  transaction: string;
  publicKey: Uint8Array;
}

export interface FilecoinTransactionsRequest {
  transactions: FilecoinTransaction[];
}

export interface FilecoinTransaction {
  id: string;
  from: string;
  addressType: FilecoinAddressType;
  to: string;
  nonce: number;
  amount: Uint8Array;
  /**
   * Gas pointers on filecoin https://spec.filecoin.io/systems/filecoin_vm/gas_fee/
   * https://www.starboard.ventures/post/gas-burning-in-filecoin-a-protocol-bidding-mechanism-to-advance-the-network-s-health
   */
  gasLimit: number;
  /** In attoFil per unit of gas. The Max fee can never exceed gasLimit * gasFeeCap */
  gasFeeCap: Uint8Array;
  /** In attoFil per unit of gas. PriorityFee on top of baseFee (dynamically set by the network) paid to the miner */
  gasPremium: Uint8Array;
  /** (gasLimit * gasPremium goes to the miner), should be gasFeeCap - baseFee */
  isNonceSet: boolean;
}

export interface FilecoinAddressRequest {
  /** BIP 44 path */
  path: string;
  addressType: FilecoinAddressType;
}

export interface FilecoinProofOfReserveRequest {
  path: string;
  addressType: FilecoinAddressType;
  challenge: string;
}

export interface FilecoinTransactionsResponse {
  transactions: FilecoinTransactionsResponse_FilecoinTransactionResponse[];
}

export interface FilecoinTransactionsResponse_FilecoinTransactionResponse {
  id: string;
  transaction: string;
  publicKey: Uint8Array;
}

export interface User {
  id: string;
  publicKey: string;
  roles: Role[];
  properties: { [key: string]: Uint8Array };
}

export interface User_PropertiesEntry {
  key: string;
  value: Uint8Array;
}

export interface Group {
  id: string;
  userIds: string[];
  properties: { [key: string]: Uint8Array };
}

export interface Group_PropertiesEntry {
  key: string;
  value: Uint8Array;
}

export interface RuleSourceInternalWallet {
  path: string;
}

export interface RuleSourceInternalAddress {
  address: string;
  path: string;
}

export interface RuleSourceExchange {
  label: string;
}

export interface RuleSourceExternalAddress {
  address: string;
  memo: string;
}

export interface RuleSource {
  type: RuleSource_RuleSourceType;
  payload: Uint8Array;
}

/** 1:1 mapping between enum and payload message */
export enum RuleSource_RuleSourceType {
  /** RuleSourceAny - payload is nil */
  RuleSourceAny = 0,
  /** RuleSourceInternalWallet - payload is  RuleSourceInternalWallet */
  RuleSourceInternalWallet = 1,
  /** RuleSourceInternalAddress - payload is RuleSourceInternalAddress */
  RuleSourceInternalAddress = 2,
  /** RuleSourceAnyExchange - payload is nil */
  RuleSourceAnyExchange = 3,
  /** RuleSourceExchange - payload is RuleSourceExchange */
  RuleSourceExchange = 4,
  /** RuleSourceExternalAddress - payload is RuleSourceExternalAddress */
  RuleSourceExternalAddress = 5,
  UNRECOGNIZED = -1,
}

export function ruleSource_RuleSourceTypeFromJSON(object: any): RuleSource_RuleSourceType {
  switch (object) {
    case 0:
    case "RuleSourceAny":
      return RuleSource_RuleSourceType.RuleSourceAny;
    case 1:
    case "RuleSourceInternalWallet":
      return RuleSource_RuleSourceType.RuleSourceInternalWallet;
    case 2:
    case "RuleSourceInternalAddress":
      return RuleSource_RuleSourceType.RuleSourceInternalAddress;
    case 3:
    case "RuleSourceAnyExchange":
      return RuleSource_RuleSourceType.RuleSourceAnyExchange;
    case 4:
    case "RuleSourceExchange":
      return RuleSource_RuleSourceType.RuleSourceExchange;
    case 5:
    case "RuleSourceExternalAddress":
      return RuleSource_RuleSourceType.RuleSourceExternalAddress;
    case -1:
    case "UNRECOGNIZED":
    default:
      return RuleSource_RuleSourceType.UNRECOGNIZED;
  }
}

export function ruleSource_RuleSourceTypeToJSON(object: RuleSource_RuleSourceType): string {
  switch (object) {
    case RuleSource_RuleSourceType.RuleSourceAny:
      return "RuleSourceAny";
    case RuleSource_RuleSourceType.RuleSourceInternalWallet:
      return "RuleSourceInternalWallet";
    case RuleSource_RuleSourceType.RuleSourceInternalAddress:
      return "RuleSourceInternalAddress";
    case RuleSource_RuleSourceType.RuleSourceAnyExchange:
      return "RuleSourceAnyExchange";
    case RuleSource_RuleSourceType.RuleSourceExchange:
      return "RuleSourceExchange";
    case RuleSource_RuleSourceType.RuleSourceExternalAddress:
      return "RuleSourceExternalAddress";
    case RuleSource_RuleSourceType.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

export interface RuleDestinationInternalWallet {
  path: string;
}

export interface RuleDestinationInternalAddress {
  address: string;
  path: string;
}

export interface RuleDestinationExternalAddress {
  address: string;
  memo: string;
}

export interface RuleDestinationContractAddress {
  address: string;
  name: string;
  symbol: string;
  blockchain: Blockchain;
}

export interface RuleDestinationExchange {
  label: string;
  memo: string;
}

export interface RuleDestination {
  type: RuleDestination_RuleDestinationType;
  payload: Uint8Array;
}

/** 1:1 mapping between enum and payload */
export enum RuleDestination_RuleDestinationType {
  /** RuleDestinationAny - payload is nil */
  RuleDestinationAny = 0,
  /** RuleDestinationInternalWallet - payload is RuleDestinationInternalWallet */
  RuleDestinationInternalWallet = 1,
  /** RuleDestinationInternalAddress - payload is RuleDestinationInternalAddress */
  RuleDestinationInternalAddress = 2,
  /** RuleDestinationExternalAddress - payload is RuleDestinationExternalAddress */
  RuleDestinationExternalAddress = 3,
  /** RuleDestinationAnyExchange - payload is nil */
  RuleDestinationAnyExchange = 4,
  /** RuleDestinationExchange - payload is RuleDestinationExchange */
  RuleDestinationExchange = 5,
  /** RuleDestinationContractAddress - payload is RuleDestinationContractAddress */
  RuleDestinationContractAddress = 6,
  /** RuleDestinationAnyExternalAddress - payload is nil */
  RuleDestinationAnyExternalAddress = 7,
  /** RuleDestinationAnyContractAddress - payload is nil */
  RuleDestinationAnyContractAddress = 8,
  UNRECOGNIZED = -1,
}

export function ruleDestination_RuleDestinationTypeFromJSON(object: any): RuleDestination_RuleDestinationType {
  switch (object) {
    case 0:
    case "RuleDestinationAny":
      return RuleDestination_RuleDestinationType.RuleDestinationAny;
    case 1:
    case "RuleDestinationInternalWallet":
      return RuleDestination_RuleDestinationType.RuleDestinationInternalWallet;
    case 2:
    case "RuleDestinationInternalAddress":
      return RuleDestination_RuleDestinationType.RuleDestinationInternalAddress;
    case 3:
    case "RuleDestinationExternalAddress":
      return RuleDestination_RuleDestinationType.RuleDestinationExternalAddress;
    case 4:
    case "RuleDestinationAnyExchange":
      return RuleDestination_RuleDestinationType.RuleDestinationAnyExchange;
    case 5:
    case "RuleDestinationExchange":
      return RuleDestination_RuleDestinationType.RuleDestinationExchange;
    case 6:
    case "RuleDestinationContractAddress":
      return RuleDestination_RuleDestinationType.RuleDestinationContractAddress;
    case 7:
    case "RuleDestinationAnyExternalAddress":
      return RuleDestination_RuleDestinationType.RuleDestinationAnyExternalAddress;
    case 8:
    case "RuleDestinationAnyContractAddress":
      return RuleDestination_RuleDestinationType.RuleDestinationAnyContractAddress;
    case -1:
    case "UNRECOGNIZED":
    default:
      return RuleDestination_RuleDestinationType.UNRECOGNIZED;
  }
}

export function ruleDestination_RuleDestinationTypeToJSON(object: RuleDestination_RuleDestinationType): string {
  switch (object) {
    case RuleDestination_RuleDestinationType.RuleDestinationAny:
      return "RuleDestinationAny";
    case RuleDestination_RuleDestinationType.RuleDestinationInternalWallet:
      return "RuleDestinationInternalWallet";
    case RuleDestination_RuleDestinationType.RuleDestinationInternalAddress:
      return "RuleDestinationInternalAddress";
    case RuleDestination_RuleDestinationType.RuleDestinationExternalAddress:
      return "RuleDestinationExternalAddress";
    case RuleDestination_RuleDestinationType.RuleDestinationAnyExchange:
      return "RuleDestinationAnyExchange";
    case RuleDestination_RuleDestinationType.RuleDestinationExchange:
      return "RuleDestinationExchange";
    case RuleDestination_RuleDestinationType.RuleDestinationContractAddress:
      return "RuleDestinationContractAddress";
    case RuleDestination_RuleDestinationType.RuleDestinationAnyExternalAddress:
      return "RuleDestinationAnyExternalAddress";
    case RuleDestination_RuleDestinationType.RuleDestinationAnyContractAddress:
      return "RuleDestinationAnyContractAddress";
    case RuleDestination_RuleDestinationType.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

export interface RuleWhitelistedContract {
  type: RuleWhitelistedContract_RuleWhitelistedContractType;
  payload: Uint8Array;
}

export enum RuleWhitelistedContract_RuleWhitelistedContractType {
  /** RuleWhitelistedContractAny - payload is nil */
  RuleWhitelistedContractAny = 0,
  /** RuleWhitelistedContract_RuleDestinationContractAddress - payload is RuleDestinationContractAddress */
  RuleWhitelistedContract_RuleDestinationContractAddress = 1,
  UNRECOGNIZED = -1,
}

export function ruleWhitelistedContract_RuleWhitelistedContractTypeFromJSON(
  object: any,
): RuleWhitelistedContract_RuleWhitelistedContractType {
  switch (object) {
    case 0:
    case "RuleWhitelistedContractAny":
      return RuleWhitelistedContract_RuleWhitelistedContractType.RuleWhitelistedContractAny;
    case 1:
    case "RuleWhitelistedContract_RuleDestinationContractAddress":
      return RuleWhitelistedContract_RuleWhitelistedContractType.RuleWhitelistedContract_RuleDestinationContractAddress;
    case -1:
    case "UNRECOGNIZED":
    default:
      return RuleWhitelistedContract_RuleWhitelistedContractType.UNRECOGNIZED;
  }
}

export function ruleWhitelistedContract_RuleWhitelistedContractTypeToJSON(
  object: RuleWhitelistedContract_RuleWhitelistedContractType,
): string {
  switch (object) {
    case RuleWhitelistedContract_RuleWhitelistedContractType.RuleWhitelistedContractAny:
      return "RuleWhitelistedContractAny";
    case RuleWhitelistedContract_RuleWhitelistedContractType.RuleWhitelistedContract_RuleDestinationContractAddress:
      return "RuleWhitelistedContract_RuleDestinationContractAddress";
    case RuleWhitelistedContract_RuleWhitelistedContractType.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

export interface RuleIntegerGreater {
  type: RuleIntegerGreater_RuleIntegerGreaterType;
  payload: Uint8Array;
}

/** 1:1 mapping between enum and payload message */
export enum RuleIntegerGreater_RuleIntegerGreaterType {
  RuleIntegerGreaterAny = 0,
  RuleIntegerGreaterValue = 1,
  RuleIntegerGreaterNegValue = 2,
  UNRECOGNIZED = -1,
}

export function ruleIntegerGreater_RuleIntegerGreaterTypeFromJSON(
  object: any,
): RuleIntegerGreater_RuleIntegerGreaterType {
  switch (object) {
    case 0:
    case "RuleIntegerGreaterAny":
      return RuleIntegerGreater_RuleIntegerGreaterType.RuleIntegerGreaterAny;
    case 1:
    case "RuleIntegerGreaterValue":
      return RuleIntegerGreater_RuleIntegerGreaterType.RuleIntegerGreaterValue;
    case 2:
    case "RuleIntegerGreaterNegValue":
      return RuleIntegerGreater_RuleIntegerGreaterType.RuleIntegerGreaterNegValue;
    case -1:
    case "UNRECOGNIZED":
    default:
      return RuleIntegerGreater_RuleIntegerGreaterType.UNRECOGNIZED;
  }
}

export function ruleIntegerGreater_RuleIntegerGreaterTypeToJSON(
  object: RuleIntegerGreater_RuleIntegerGreaterType,
): string {
  switch (object) {
    case RuleIntegerGreater_RuleIntegerGreaterType.RuleIntegerGreaterAny:
      return "RuleIntegerGreaterAny";
    case RuleIntegerGreater_RuleIntegerGreaterType.RuleIntegerGreaterValue:
      return "RuleIntegerGreaterValue";
    case RuleIntegerGreater_RuleIntegerGreaterType.RuleIntegerGreaterNegValue:
      return "RuleIntegerGreaterNegValue";
    case RuleIntegerGreater_RuleIntegerGreaterType.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

export interface RuleUIntegerGreater {
  type: RuleUIntegerGreater_RuleUIntegerGreaterType;
  payload: Uint8Array;
}

/** 1:1 mapping between enum and payload message */
export enum RuleUIntegerGreater_RuleUIntegerGreaterType {
  RuleUIntegerGreaterAny = 0,
  RuleUIntegerGreaterIsZero = 1,
  RuleUIntegerGreaterValue = 2,
  RuleUIntegerGreaterIsEqual = 3,
  UNRECOGNIZED = -1,
}

export function ruleUIntegerGreater_RuleUIntegerGreaterTypeFromJSON(
  object: any,
): RuleUIntegerGreater_RuleUIntegerGreaterType {
  switch (object) {
    case 0:
    case "RuleUIntegerGreaterAny":
      return RuleUIntegerGreater_RuleUIntegerGreaterType.RuleUIntegerGreaterAny;
    case 1:
    case "RuleUIntegerGreaterIsZero":
      return RuleUIntegerGreater_RuleUIntegerGreaterType.RuleUIntegerGreaterIsZero;
    case 2:
    case "RuleUIntegerGreaterValue":
      return RuleUIntegerGreater_RuleUIntegerGreaterType.RuleUIntegerGreaterValue;
    case 3:
    case "RuleUIntegerGreaterIsEqual":
      return RuleUIntegerGreater_RuleUIntegerGreaterType.RuleUIntegerGreaterIsEqual;
    case -1:
    case "UNRECOGNIZED":
    default:
      return RuleUIntegerGreater_RuleUIntegerGreaterType.UNRECOGNIZED;
  }
}

export function ruleUIntegerGreater_RuleUIntegerGreaterTypeToJSON(
  object: RuleUIntegerGreater_RuleUIntegerGreaterType,
): string {
  switch (object) {
    case RuleUIntegerGreater_RuleUIntegerGreaterType.RuleUIntegerGreaterAny:
      return "RuleUIntegerGreaterAny";
    case RuleUIntegerGreater_RuleUIntegerGreaterType.RuleUIntegerGreaterIsZero:
      return "RuleUIntegerGreaterIsZero";
    case RuleUIntegerGreater_RuleUIntegerGreaterType.RuleUIntegerGreaterValue:
      return "RuleUIntegerGreaterValue";
    case RuleUIntegerGreater_RuleUIntegerGreaterType.RuleUIntegerGreaterIsEqual:
      return "RuleUIntegerGreaterIsEqual";
    case RuleUIntegerGreater_RuleUIntegerGreaterType.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

export interface RuleFiatAmountRange {
  /** a string, containing a "double" to ease processing in the HSM (Non inclusive range) */
  minAmount: string;
  /** a string, containing a "double" to ease processing in the HSM (Inclusive range) */
  maxAmount: string;
}

export interface RuleFiatAmount {
  type: RuleFiatAmount_RuleFiatAmountType;
  payload: Uint8Array;
}

/** 1:1 mapping between enum and payload message */
export enum RuleFiatAmount_RuleFiatAmountType {
  /** RuleFiatAmountAny - payload is nil */
  RuleFiatAmountAny = 0,
  /** RuleFiatAmountIsZero - payload is nil */
  RuleFiatAmountIsZero = 1,
  /** RuleFiatAmountRange - payload is  RuleFiatAmountRangeValue */
  RuleFiatAmountRange = 2,
  UNRECOGNIZED = -1,
}

export function ruleFiatAmount_RuleFiatAmountTypeFromJSON(object: any): RuleFiatAmount_RuleFiatAmountType {
  switch (object) {
    case 0:
    case "RuleFiatAmountAny":
      return RuleFiatAmount_RuleFiatAmountType.RuleFiatAmountAny;
    case 1:
    case "RuleFiatAmountIsZero":
      return RuleFiatAmount_RuleFiatAmountType.RuleFiatAmountIsZero;
    case 2:
    case "RuleFiatAmountRange":
      return RuleFiatAmount_RuleFiatAmountType.RuleFiatAmountRange;
    case -1:
    case "UNRECOGNIZED":
    default:
      return RuleFiatAmount_RuleFiatAmountType.UNRECOGNIZED;
  }
}

export function ruleFiatAmount_RuleFiatAmountTypeToJSON(object: RuleFiatAmount_RuleFiatAmountType): string {
  switch (object) {
    case RuleFiatAmount_RuleFiatAmountType.RuleFiatAmountAny:
      return "RuleFiatAmountAny";
    case RuleFiatAmount_RuleFiatAmountType.RuleFiatAmountIsZero:
      return "RuleFiatAmountIsZero";
    case RuleFiatAmount_RuleFiatAmountType.RuleFiatAmountRange:
      return "RuleFiatAmountRange";
    case RuleFiatAmount_RuleFiatAmountType.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

export interface RuleStringEqual {
  type: RuleStringEqual_RuleStringEqualType;
  payload: Uint8Array;
}

/** 1:1 mapping between enum and payload message */
export enum RuleStringEqual_RuleStringEqualType {
  /** RuleStringEqualAny - payload is nil */
  RuleStringEqualAny = 0,
  /** RuleStringEqualEmpty - payload is nil */
  RuleStringEqualEmpty = 1,
  /** RuleStringEqualValue - payload is string */
  RuleStringEqualValue = 2,
  UNRECOGNIZED = -1,
}

export function ruleStringEqual_RuleStringEqualTypeFromJSON(object: any): RuleStringEqual_RuleStringEqualType {
  switch (object) {
    case 0:
    case "RuleStringEqualAny":
      return RuleStringEqual_RuleStringEqualType.RuleStringEqualAny;
    case 1:
    case "RuleStringEqualEmpty":
      return RuleStringEqual_RuleStringEqualType.RuleStringEqualEmpty;
    case 2:
    case "RuleStringEqualValue":
      return RuleStringEqual_RuleStringEqualType.RuleStringEqualValue;
    case -1:
    case "UNRECOGNIZED":
    default:
      return RuleStringEqual_RuleStringEqualType.UNRECOGNIZED;
  }
}

export function ruleStringEqual_RuleStringEqualTypeToJSON(object: RuleStringEqual_RuleStringEqualType): string {
  switch (object) {
    case RuleStringEqual_RuleStringEqualType.RuleStringEqualAny:
      return "RuleStringEqualAny";
    case RuleStringEqual_RuleStringEqualType.RuleStringEqualEmpty:
      return "RuleStringEqualEmpty";
    case RuleStringEqual_RuleStringEqualType.RuleStringEqualValue:
      return "RuleStringEqualValue";
    case RuleStringEqual_RuleStringEqualType.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

export interface RuleStringArrayEqualValue {
  values: string[];
}

export interface RuleStringArrayEqual {
  type: RuleStringArrayEqual_RuleStringArrayEqualType;
  payload: Uint8Array;
}

/** 1:1 mapping between enum and payload message */
export enum RuleStringArrayEqual_RuleStringArrayEqualType {
  /** RuleStringArrayEqualAny - payload is nil */
  RuleStringArrayEqualAny = 0,
  /** RuleStringArrayEqualEmpty - payload is nil */
  RuleStringArrayEqualEmpty = 1,
  /** RuleStringArrayEqualValue - payload is RuleStringArrayEqualValue */
  RuleStringArrayEqualValue = 2,
  UNRECOGNIZED = -1,
}

export function ruleStringArrayEqual_RuleStringArrayEqualTypeFromJSON(
  object: any,
): RuleStringArrayEqual_RuleStringArrayEqualType {
  switch (object) {
    case 0:
    case "RuleStringArrayEqualAny":
      return RuleStringArrayEqual_RuleStringArrayEqualType.RuleStringArrayEqualAny;
    case 1:
    case "RuleStringArrayEqualEmpty":
      return RuleStringArrayEqual_RuleStringArrayEqualType.RuleStringArrayEqualEmpty;
    case 2:
    case "RuleStringArrayEqualValue":
      return RuleStringArrayEqual_RuleStringArrayEqualType.RuleStringArrayEqualValue;
    case -1:
    case "UNRECOGNIZED":
    default:
      return RuleStringArrayEqual_RuleStringArrayEqualType.UNRECOGNIZED;
  }
}

export function ruleStringArrayEqual_RuleStringArrayEqualTypeToJSON(
  object: RuleStringArrayEqual_RuleStringArrayEqualType,
): string {
  switch (object) {
    case RuleStringArrayEqual_RuleStringArrayEqualType.RuleStringArrayEqualAny:
      return "RuleStringArrayEqualAny";
    case RuleStringArrayEqual_RuleStringArrayEqualType.RuleStringArrayEqualEmpty:
      return "RuleStringArrayEqualEmpty";
    case RuleStringArrayEqual_RuleStringArrayEqualType.RuleStringArrayEqualValue:
      return "RuleStringArrayEqualValue";
    case RuleStringArrayEqual_RuleStringArrayEqualType.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

export interface RuleBytesEqual {
  type: RuleBytesEqual_RuleBytesEqualType;
  payload: Uint8Array;
}

/** 1:1 mapping between enum and payload message */
export enum RuleBytesEqual_RuleBytesEqualType {
  /** RuleBytesEqualAny - payload is nil */
  RuleBytesEqualAny = 0,
  /** RuleBytesEqualEmpty - payload is nil */
  RuleBytesEqualEmpty = 1,
  /** RuleBytesEqualValue - payload is bytes */
  RuleBytesEqualValue = 2,
  UNRECOGNIZED = -1,
}

export function ruleBytesEqual_RuleBytesEqualTypeFromJSON(object: any): RuleBytesEqual_RuleBytesEqualType {
  switch (object) {
    case 0:
    case "RuleBytesEqualAny":
      return RuleBytesEqual_RuleBytesEqualType.RuleBytesEqualAny;
    case 1:
    case "RuleBytesEqualEmpty":
      return RuleBytesEqual_RuleBytesEqualType.RuleBytesEqualEmpty;
    case 2:
    case "RuleBytesEqualValue":
      return RuleBytesEqual_RuleBytesEqualType.RuleBytesEqualValue;
    case -1:
    case "UNRECOGNIZED":
    default:
      return RuleBytesEqual_RuleBytesEqualType.UNRECOGNIZED;
  }
}

export function ruleBytesEqual_RuleBytesEqualTypeToJSON(object: RuleBytesEqual_RuleBytesEqualType): string {
  switch (object) {
    case RuleBytesEqual_RuleBytesEqualType.RuleBytesEqualAny:
      return "RuleBytesEqualAny";
    case RuleBytesEqual_RuleBytesEqualType.RuleBytesEqualEmpty:
      return "RuleBytesEqualEmpty";
    case RuleBytesEqual_RuleBytesEqualType.RuleBytesEqualValue:
      return "RuleBytesEqualValue";
    case RuleBytesEqual_RuleBytesEqualType.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

export interface GroupThreshold {
  groupId: string;
  minimumSignatures: number;
}

export interface SequentialThresholds {
  thresholds: GroupThreshold[];
}

export interface RulesContainer {
  users: User[];
  groups: Group[];
  /** at least minimumDistinctUserSignatures users must have signed a request, despite any other rules */
  minimumDistinctUserSignatures: number;
  /** at least minimumDistinctGroupSignatures users of distinct groups must have signed a request, despite any other rules */
  minimumDistinctGroupSignatures: number;
  transactionRules: RulesContainer_TransactionRules[];
  addressWhitelistingRules: RulesContainer_AddressWhitelistingRules[];
  contractAddressWhitelistingRules: RulesContainer_ContractAddressWhitelistingRules[];
  enforcedRulesHash: string;
  properties: { [key: string]: Uint8Array };
  timestamp: number;
  minimumCommitmentSignatures: number;
  /** known HSM serial numbers from tenant. HSM will refure to process request if their serial is not in the list. */
  engineIdentities: string[];
  /** HSM slot ID that these rules are intended for. When this changes, rules must be re-signed. */
  hsmSlotId: number;
}

export enum RulesContainer_ColumnType {
  RuleSource = 0,
  RuleDestination = 1,
  RuleFiatAmount = 2,
  RuleBytesEqual = 3,
  RuleStringEqual = 4,
  RuleIntegerGreater = 5,
  RuleUIntegerGreater = 6,
  RuleAny = 7,
  RuleStringArrayEqual = 8,
  RuleWhitelistedContract = 9,
  UNRECOGNIZED = -1,
}

export function rulesContainer_ColumnTypeFromJSON(object: any): RulesContainer_ColumnType {
  switch (object) {
    case 0:
    case "RuleSource":
      return RulesContainer_ColumnType.RuleSource;
    case 1:
    case "RuleDestination":
      return RulesContainer_ColumnType.RuleDestination;
    case 2:
    case "RuleFiatAmount":
      return RulesContainer_ColumnType.RuleFiatAmount;
    case 3:
    case "RuleBytesEqual":
      return RulesContainer_ColumnType.RuleBytesEqual;
    case 4:
    case "RuleStringEqual":
      return RulesContainer_ColumnType.RuleStringEqual;
    case 5:
    case "RuleIntegerGreater":
      return RulesContainer_ColumnType.RuleIntegerGreater;
    case 6:
    case "RuleUIntegerGreater":
      return RulesContainer_ColumnType.RuleUIntegerGreater;
    case 7:
    case "RuleAny":
      return RulesContainer_ColumnType.RuleAny;
    case 8:
    case "RuleStringArrayEqual":
      return RulesContainer_ColumnType.RuleStringArrayEqual;
    case 9:
    case "RuleWhitelistedContract":
      return RulesContainer_ColumnType.RuleWhitelistedContract;
    case -1:
    case "UNRECOGNIZED":
    default:
      return RulesContainer_ColumnType.UNRECOGNIZED;
  }
}

export function rulesContainer_ColumnTypeToJSON(object: RulesContainer_ColumnType): string {
  switch (object) {
    case RulesContainer_ColumnType.RuleSource:
      return "RuleSource";
    case RulesContainer_ColumnType.RuleDestination:
      return "RuleDestination";
    case RulesContainer_ColumnType.RuleFiatAmount:
      return "RuleFiatAmount";
    case RulesContainer_ColumnType.RuleBytesEqual:
      return "RuleBytesEqual";
    case RulesContainer_ColumnType.RuleStringEqual:
      return "RuleStringEqual";
    case RulesContainer_ColumnType.RuleIntegerGreater:
      return "RuleIntegerGreater";
    case RulesContainer_ColumnType.RuleUIntegerGreater:
      return "RuleUIntegerGreater";
    case RulesContainer_ColumnType.RuleAny:
      return "RuleAny";
    case RulesContainer_ColumnType.RuleStringArrayEqual:
      return "RuleStringArrayEqual";
    case RulesContainer_ColumnType.RuleWhitelistedContract:
      return "RuleWhitelistedContract";
    case RulesContainer_ColumnType.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

export interface RulesContainer_Column {
  type: RulesContainer_ColumnType;
  name: string;
  metadataKey: string;
}

export interface RulesContainer_Line {
  /** rule inputs, len(Line.cells) == len (TransactionRules.columns) */
  cells: Uint8Array[];
  /** rule output */
  parallelThresholds: SequentialThresholds[];
  properties: { [key: string]: Uint8Array };
  /** used to sort rules, 0 is the lowest priority */
  priority: number;
}

export interface RulesContainer_Line_PropertiesEntry {
  key: string;
  value: Uint8Array;
}

export interface RulesContainer_TransactionRules {
  /** Should be unique */
  key: string;
  /** len(Line.cells) == len (TransactionRules.columns) */
  columns: RulesContainer_Column[];
  /** array is sorted */
  lines: RulesContainer_Line[];
  details: RulesContainer_TransactionRules_TransactionRuleDetails | undefined;
}

export interface RulesContainer_TransactionRules_TransactionRuleDetails {
  domain: RulesContainer_TransactionRules_TransactionRuleDetails_RuleDomain;
  subDomain: RulesContainer_TransactionRules_TransactionRuleDetails_RuleSubDomain;
  blockchain: string;
  network: string;
  evmCallContract: RulesContainer_TransactionRules_TransactionRuleDetails_EvmCallContract | undefined;
  xtzCallContract: RulesContainer_TransactionRules_TransactionRuleDetails_XtzCallContract | undefined;
  cashSettlement: RulesContainer_TransactionRules_TransactionRuleDetails_CashSettlement | undefined;
  cosmosDetails: RulesContainer_TransactionRules_TransactionRuleDetails_CosmosDetails | undefined;
}

export enum RulesContainer_TransactionRules_TransactionRuleDetails_RuleDomain {
  RuleDomainAny = 0,
  RuleDomainTransfer = 1,
  RuleDomainStaking = 2,
  RuleDomainOperation = 3,
  /** RuleDomainCallContract - EvmCallContract or XtzCallContract fields will be defined depending on blockchain */
  RuleDomainCallContract = 4,
  /** RuleDomainCashSettlement - CashSettlement field will be defined - represents the fiat providers requests */
  RuleDomainCashSettlement = 5,
  UNRECOGNIZED = -1,
}

export function rulesContainer_TransactionRules_TransactionRuleDetails_RuleDomainFromJSON(
  object: any,
): RulesContainer_TransactionRules_TransactionRuleDetails_RuleDomain {
  switch (object) {
    case 0:
    case "RuleDomainAny":
      return RulesContainer_TransactionRules_TransactionRuleDetails_RuleDomain.RuleDomainAny;
    case 1:
    case "RuleDomainTransfer":
      return RulesContainer_TransactionRules_TransactionRuleDetails_RuleDomain.RuleDomainTransfer;
    case 2:
    case "RuleDomainStaking":
      return RulesContainer_TransactionRules_TransactionRuleDetails_RuleDomain.RuleDomainStaking;
    case 3:
    case "RuleDomainOperation":
      return RulesContainer_TransactionRules_TransactionRuleDetails_RuleDomain.RuleDomainOperation;
    case 4:
    case "RuleDomainCallContract":
      return RulesContainer_TransactionRules_TransactionRuleDetails_RuleDomain.RuleDomainCallContract;
    case 5:
    case "RuleDomainCashSettlement":
      return RulesContainer_TransactionRules_TransactionRuleDetails_RuleDomain.RuleDomainCashSettlement;
    case -1:
    case "UNRECOGNIZED":
    default:
      return RulesContainer_TransactionRules_TransactionRuleDetails_RuleDomain.UNRECOGNIZED;
  }
}

export function rulesContainer_TransactionRules_TransactionRuleDetails_RuleDomainToJSON(
  object: RulesContainer_TransactionRules_TransactionRuleDetails_RuleDomain,
): string {
  switch (object) {
    case RulesContainer_TransactionRules_TransactionRuleDetails_RuleDomain.RuleDomainAny:
      return "RuleDomainAny";
    case RulesContainer_TransactionRules_TransactionRuleDetails_RuleDomain.RuleDomainTransfer:
      return "RuleDomainTransfer";
    case RulesContainer_TransactionRules_TransactionRuleDetails_RuleDomain.RuleDomainStaking:
      return "RuleDomainStaking";
    case RulesContainer_TransactionRules_TransactionRuleDetails_RuleDomain.RuleDomainOperation:
      return "RuleDomainOperation";
    case RulesContainer_TransactionRules_TransactionRuleDetails_RuleDomain.RuleDomainCallContract:
      return "RuleDomainCallContract";
    case RulesContainer_TransactionRules_TransactionRuleDetails_RuleDomain.RuleDomainCashSettlement:
      return "RuleDomainCashSettlement";
    case RulesContainer_TransactionRules_TransactionRuleDetails_RuleDomain.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

export enum RulesContainer_TransactionRules_TransactionRuleDetails_RuleSubDomain {
  RuleSubDomainAny = 0,
  /** RuleSubDomainNative - DomainTransfer */
  RuleSubDomainNative = 1,
  RuleSubDomainERC20 = 2,
  RuleSubDomainERC721 = 3,
  RuleSubDomainERC1155 = 4,
  RuleSubDomainFA12 = 5,
  RuleSubDomainFA2 = 6,
  RuleSubDomainFA2NFT = 7,
  RuleSubDomainASA = 8,
  RuleSubDomainCosmosMsgSend = 9,
  RuleSubDomainCancel = 10,
  RuleSubDomainXLMAsset = 27,
  RuleSubDomainXLMMintAsset = 40,
  RuleSubDomainXLMPathPaymentNativeToAsset = 44,
  RuleSubDomainXLMPathPaymentAssetToNative = 45,
  RuleSubDomainXLMPathPaymentAssetToAsset = 46,
  RuleSubDomainSOLTokenTransfer = 50,
  RuleSubDomainICRC1 = 51,
  RuleSubDomainHederaToken = 57,
  RuleSubDomainHederaNFT = 58,
  RuleSubDomainCryptoPunks = 60,
  RuleSubDomainTRC20 = 63,
  RuleSubDomainSOLTokenFreeze = 91,
  RuleSubDomainSOLTokenUnfreeze = 92,
  RuleSubDomainCIP56 = 94,
  /** RuleSubDomainDelegate - DomainStaking */
  RuleSubDomainDelegate = 11,
  /** RuleSubDomainUndelegate - includes DotChill, TaoRemoveStake */
  RuleSubDomainUndelegate = 12,
  RuleSubDomainWithdrawal = 13,
  RuleSubDomainClaimRewards = 14,
  RuleSubDomainDOTBond = 15,
  RuleSubDomainDOTBondExtra = 16,
  RuleSubDomainDOTUnbond = 17,
  RuleSubDomainFTMLock = 23,
  /**
   * RuleSubDomainICPSetDissolveDelay - RuleSubDomainSOLCreateStakeAddress = 24;     // no longer used
   * RuleSubDomainSOLTransferToStakeAddress = 25; // no longer used
   */
  RuleSubDomainICPSetDissolveDelay = 31,
  RuleSubDomainICPStartDissolving = 32,
  RuleSubDomainICPTransferToStake = 33,
  RuleSubDomainStake = 55,
  RuleSubDomainUnstake = 56,
  RuleSubDomainADAVoteDelegate = 59,
  RuleSubDomainSOLPartialDeactivate = 61,
  RuleSubDomainSOLMerge = 62,
  /** RuleSubDomainDeployContract - DomainOperation */
  RuleSubDomainDeployContract = 18,
  RuleSubDomainASAOptIn = 19,
  RuleSubDomainBlock = 20,
  RuleSubDomainCosmosSimplified = 21,
  RuleSubDomainCosmosGeneric = 22,
  RuleSubDomainXLMChangeTrust = 26,
  RuleSubDomainXLMSetOptions = 28,
  RuleSubDomainXLMSetTrustlineFlags = 29,
  RuleSubDomainXLMManageData = 30,
  RuleSubDomainXLMClaimClaimableBalance = 34,
  RuleSubDomainXLMClawbackClaimableBalance = 35,
  RuleSubDomainXLMCreateClaimableBalanceNative = 36,
  RuleSubDomainXLMCreateClaimableBalanceAsset = 37,
  RuleSubDomainXLMRevokeSponsorship = 38,
  RuleSubDomainXLMClawback = 39,
  RuleSubDomainXLMLiquidityPoolDeposit = 41,
  RuleSubDomainXLMLiquidityPoolWithdraw = 42,
  RuleSubDomainXLMChangeTrustLiquidityPool = 43,
  RuleSubDomainXLMOfferNativeForAsset = 47,
  RuleSubDomainXLMOfferAssetForNative = 48,
  RuleSubDomainXLMOfferAssetForAsset = 49,
  RuleSubDomainSOLTokenCreate = 52,
  RuleSubDomainSOLTokenMint = 53,
  RuleSubDomainSOLTokenBurn = 54,
  RuleSubDomainHederaCreateToken = 67,
  RuleSubDomainHederaUpdateToken = 68,
  RuleSubDomainHederaMintToken = 69,
  RuleSubDomainHederaMintNFT = 70,
  RuleSubDomainHederaBurnToken = 71,
  RuleSubDomainHederaBurnNFT = 72,
  RuleSubDomainHederaDeleteToken = 73,
  RuleSubDomainHederaWipeTokenAccount = 74,
  RuleSubDomainHederaWipeNFTTokenAccount = 75,
  RuleSubDomainHederaFreezeTokenAccount = 76,
  RuleSubDomainHederaUnfreezeTokenAccount = 77,
  RuleSubDomainHederaGrantKycToTokenAccount = 78,
  RuleSubDomainHederaRevokeKycFromTokenAccount = 79,
  RuleSubDomainHederaAssociateToken = 80,
  RuleSubDomainHederaDissociateToken = 81,
  RuleSubDomainHederaUpdateTokenFeeSchedule = 82,
  RuleSubDomainHederaPauseToken = 83,
  RuleSubDomainHederaUnpauseToken = 84,
  RuleSubDomainHederaUpdateNfts = 85,
  RuleSubDomainHederaRejectToken = 86,
  RuleSubDomainHederaAirdropToken = 87,
  RuleSubDomainHederaAirdropNFT = 88,
  RuleSubDomainHederaCancelAirdrop = 89,
  RuleSubDomainHederaClaimAirdrop = 90,
  /** RuleSubDomainFiatDeposit - Fiat provider */
  RuleSubDomainFiatDeposit = 64,
  /** RuleSubDomainFiatWithdrawal - e.g. Circle, Cubnet, Blinc */
  RuleSubDomainFiatWithdrawal = 65,
  /** RuleSubDomainFiatTransfer - e.g. Cubnet, Blinc */
  RuleSubDomainFiatTransfer = 66,
  UNRECOGNIZED = -1,
}

export function rulesContainer_TransactionRules_TransactionRuleDetails_RuleSubDomainFromJSON(
  object: any,
): RulesContainer_TransactionRules_TransactionRuleDetails_RuleSubDomain {
  switch (object) {
    case 0:
    case "RuleSubDomainAny":
      return RulesContainer_TransactionRules_TransactionRuleDetails_RuleSubDomain.RuleSubDomainAny;
    case 1:
    case "RuleSubDomainNative":
      return RulesContainer_TransactionRules_TransactionRuleDetails_RuleSubDomain.RuleSubDomainNative;
    case 2:
    case "RuleSubDomainERC20":
      return RulesContainer_TransactionRules_TransactionRuleDetails_RuleSubDomain.RuleSubDomainERC20;
    case 3:
    case "RuleSubDomainERC721":
      return RulesContainer_TransactionRules_TransactionRuleDetails_RuleSubDomain.RuleSubDomainERC721;
    case 4:
    case "RuleSubDomainERC1155":
      return RulesContainer_TransactionRules_TransactionRuleDetails_RuleSubDomain.RuleSubDomainERC1155;
    case 5:
    case "RuleSubDomainFA12":
      return RulesContainer_TransactionRules_TransactionRuleDetails_RuleSubDomain.RuleSubDomainFA12;
    case 6:
    case "RuleSubDomainFA2":
      return RulesContainer_TransactionRules_TransactionRuleDetails_RuleSubDomain.RuleSubDomainFA2;
    case 7:
    case "RuleSubDomainFA2NFT":
      return RulesContainer_TransactionRules_TransactionRuleDetails_RuleSubDomain.RuleSubDomainFA2NFT;
    case 8:
    case "RuleSubDomainASA":
      return RulesContainer_TransactionRules_TransactionRuleDetails_RuleSubDomain.RuleSubDomainASA;
    case 9:
    case "RuleSubDomainCosmosMsgSend":
      return RulesContainer_TransactionRules_TransactionRuleDetails_RuleSubDomain.RuleSubDomainCosmosMsgSend;
    case 10:
    case "RuleSubDomainCancel":
      return RulesContainer_TransactionRules_TransactionRuleDetails_RuleSubDomain.RuleSubDomainCancel;
    case 27:
    case "RuleSubDomainXLMAsset":
      return RulesContainer_TransactionRules_TransactionRuleDetails_RuleSubDomain.RuleSubDomainXLMAsset;
    case 40:
    case "RuleSubDomainXLMMintAsset":
      return RulesContainer_TransactionRules_TransactionRuleDetails_RuleSubDomain.RuleSubDomainXLMMintAsset;
    case 44:
    case "RuleSubDomainXLMPathPaymentNativeToAsset":
      return RulesContainer_TransactionRules_TransactionRuleDetails_RuleSubDomain
        .RuleSubDomainXLMPathPaymentNativeToAsset;
    case 45:
    case "RuleSubDomainXLMPathPaymentAssetToNative":
      return RulesContainer_TransactionRules_TransactionRuleDetails_RuleSubDomain
        .RuleSubDomainXLMPathPaymentAssetToNative;
    case 46:
    case "RuleSubDomainXLMPathPaymentAssetToAsset":
      return RulesContainer_TransactionRules_TransactionRuleDetails_RuleSubDomain
        .RuleSubDomainXLMPathPaymentAssetToAsset;
    case 50:
    case "RuleSubDomainSOLTokenTransfer":
      return RulesContainer_TransactionRules_TransactionRuleDetails_RuleSubDomain.RuleSubDomainSOLTokenTransfer;
    case 51:
    case "RuleSubDomainICRC1":
      return RulesContainer_TransactionRules_TransactionRuleDetails_RuleSubDomain.RuleSubDomainICRC1;
    case 57:
    case "RuleSubDomainHederaToken":
      return RulesContainer_TransactionRules_TransactionRuleDetails_RuleSubDomain.RuleSubDomainHederaToken;
    case 58:
    case "RuleSubDomainHederaNFT":
      return RulesContainer_TransactionRules_TransactionRuleDetails_RuleSubDomain.RuleSubDomainHederaNFT;
    case 60:
    case "RuleSubDomainCryptoPunks":
      return RulesContainer_TransactionRules_TransactionRuleDetails_RuleSubDomain.RuleSubDomainCryptoPunks;
    case 63:
    case "RuleSubDomainTRC20":
      return RulesContainer_TransactionRules_TransactionRuleDetails_RuleSubDomain.RuleSubDomainTRC20;
    case 91:
    case "RuleSubDomainSOLTokenFreeze":
      return RulesContainer_TransactionRules_TransactionRuleDetails_RuleSubDomain.RuleSubDomainSOLTokenFreeze;
    case 92:
    case "RuleSubDomainSOLTokenUnfreeze":
      return RulesContainer_TransactionRules_TransactionRuleDetails_RuleSubDomain.RuleSubDomainSOLTokenUnfreeze;
    case 94:
    case "RuleSubDomainCIP56":
      return RulesContainer_TransactionRules_TransactionRuleDetails_RuleSubDomain.RuleSubDomainCIP56;
    case 11:
    case "RuleSubDomainDelegate":
      return RulesContainer_TransactionRules_TransactionRuleDetails_RuleSubDomain.RuleSubDomainDelegate;
    case 12:
    case "RuleSubDomainUndelegate":
      return RulesContainer_TransactionRules_TransactionRuleDetails_RuleSubDomain.RuleSubDomainUndelegate;
    case 13:
    case "RuleSubDomainWithdrawal":
      return RulesContainer_TransactionRules_TransactionRuleDetails_RuleSubDomain.RuleSubDomainWithdrawal;
    case 14:
    case "RuleSubDomainClaimRewards":
      return RulesContainer_TransactionRules_TransactionRuleDetails_RuleSubDomain.RuleSubDomainClaimRewards;
    case 15:
    case "RuleSubDomainDOTBond":
      return RulesContainer_TransactionRules_TransactionRuleDetails_RuleSubDomain.RuleSubDomainDOTBond;
    case 16:
    case "RuleSubDomainDOTBondExtra":
      return RulesContainer_TransactionRules_TransactionRuleDetails_RuleSubDomain.RuleSubDomainDOTBondExtra;
    case 17:
    case "RuleSubDomainDOTUnbond":
      return RulesContainer_TransactionRules_TransactionRuleDetails_RuleSubDomain.RuleSubDomainDOTUnbond;
    case 23:
    case "RuleSubDomainFTMLock":
      return RulesContainer_TransactionRules_TransactionRuleDetails_RuleSubDomain.RuleSubDomainFTMLock;
    case 31:
    case "RuleSubDomainICPSetDissolveDelay":
      return RulesContainer_TransactionRules_TransactionRuleDetails_RuleSubDomain.RuleSubDomainICPSetDissolveDelay;
    case 32:
    case "RuleSubDomainICPStartDissolving":
      return RulesContainer_TransactionRules_TransactionRuleDetails_RuleSubDomain.RuleSubDomainICPStartDissolving;
    case 33:
    case "RuleSubDomainICPTransferToStake":
      return RulesContainer_TransactionRules_TransactionRuleDetails_RuleSubDomain.RuleSubDomainICPTransferToStake;
    case 55:
    case "RuleSubDomainStake":
      return RulesContainer_TransactionRules_TransactionRuleDetails_RuleSubDomain.RuleSubDomainStake;
    case 56:
    case "RuleSubDomainUnstake":
      return RulesContainer_TransactionRules_TransactionRuleDetails_RuleSubDomain.RuleSubDomainUnstake;
    case 59:
    case "RuleSubDomainADAVoteDelegate":
      return RulesContainer_TransactionRules_TransactionRuleDetails_RuleSubDomain.RuleSubDomainADAVoteDelegate;
    case 61:
    case "RuleSubDomainSOLPartialDeactivate":
      return RulesContainer_TransactionRules_TransactionRuleDetails_RuleSubDomain.RuleSubDomainSOLPartialDeactivate;
    case 62:
    case "RuleSubDomainSOLMerge":
      return RulesContainer_TransactionRules_TransactionRuleDetails_RuleSubDomain.RuleSubDomainSOLMerge;
    case 18:
    case "RuleSubDomainDeployContract":
      return RulesContainer_TransactionRules_TransactionRuleDetails_RuleSubDomain.RuleSubDomainDeployContract;
    case 19:
    case "RuleSubDomainASAOptIn":
      return RulesContainer_TransactionRules_TransactionRuleDetails_RuleSubDomain.RuleSubDomainASAOptIn;
    case 20:
    case "RuleSubDomainBlock":
      return RulesContainer_TransactionRules_TransactionRuleDetails_RuleSubDomain.RuleSubDomainBlock;
    case 21:
    case "RuleSubDomainCosmosSimplified":
      return RulesContainer_TransactionRules_TransactionRuleDetails_RuleSubDomain.RuleSubDomainCosmosSimplified;
    case 22:
    case "RuleSubDomainCosmosGeneric":
      return RulesContainer_TransactionRules_TransactionRuleDetails_RuleSubDomain.RuleSubDomainCosmosGeneric;
    case 26:
    case "RuleSubDomainXLMChangeTrust":
      return RulesContainer_TransactionRules_TransactionRuleDetails_RuleSubDomain.RuleSubDomainXLMChangeTrust;
    case 28:
    case "RuleSubDomainXLMSetOptions":
      return RulesContainer_TransactionRules_TransactionRuleDetails_RuleSubDomain.RuleSubDomainXLMSetOptions;
    case 29:
    case "RuleSubDomainXLMSetTrustlineFlags":
      return RulesContainer_TransactionRules_TransactionRuleDetails_RuleSubDomain.RuleSubDomainXLMSetTrustlineFlags;
    case 30:
    case "RuleSubDomainXLMManageData":
      return RulesContainer_TransactionRules_TransactionRuleDetails_RuleSubDomain.RuleSubDomainXLMManageData;
    case 34:
    case "RuleSubDomainXLMClaimClaimableBalance":
      return RulesContainer_TransactionRules_TransactionRuleDetails_RuleSubDomain.RuleSubDomainXLMClaimClaimableBalance;
    case 35:
    case "RuleSubDomainXLMClawbackClaimableBalance":
      return RulesContainer_TransactionRules_TransactionRuleDetails_RuleSubDomain
        .RuleSubDomainXLMClawbackClaimableBalance;
    case 36:
    case "RuleSubDomainXLMCreateClaimableBalanceNative":
      return RulesContainer_TransactionRules_TransactionRuleDetails_RuleSubDomain
        .RuleSubDomainXLMCreateClaimableBalanceNative;
    case 37:
    case "RuleSubDomainXLMCreateClaimableBalanceAsset":
      return RulesContainer_TransactionRules_TransactionRuleDetails_RuleSubDomain
        .RuleSubDomainXLMCreateClaimableBalanceAsset;
    case 38:
    case "RuleSubDomainXLMRevokeSponsorship":
      return RulesContainer_TransactionRules_TransactionRuleDetails_RuleSubDomain.RuleSubDomainXLMRevokeSponsorship;
    case 39:
    case "RuleSubDomainXLMClawback":
      return RulesContainer_TransactionRules_TransactionRuleDetails_RuleSubDomain.RuleSubDomainXLMClawback;
    case 41:
    case "RuleSubDomainXLMLiquidityPoolDeposit":
      return RulesContainer_TransactionRules_TransactionRuleDetails_RuleSubDomain.RuleSubDomainXLMLiquidityPoolDeposit;
    case 42:
    case "RuleSubDomainXLMLiquidityPoolWithdraw":
      return RulesContainer_TransactionRules_TransactionRuleDetails_RuleSubDomain.RuleSubDomainXLMLiquidityPoolWithdraw;
    case 43:
    case "RuleSubDomainXLMChangeTrustLiquidityPool":
      return RulesContainer_TransactionRules_TransactionRuleDetails_RuleSubDomain
        .RuleSubDomainXLMChangeTrustLiquidityPool;
    case 47:
    case "RuleSubDomainXLMOfferNativeForAsset":
      return RulesContainer_TransactionRules_TransactionRuleDetails_RuleSubDomain.RuleSubDomainXLMOfferNativeForAsset;
    case 48:
    case "RuleSubDomainXLMOfferAssetForNative":
      return RulesContainer_TransactionRules_TransactionRuleDetails_RuleSubDomain.RuleSubDomainXLMOfferAssetForNative;
    case 49:
    case "RuleSubDomainXLMOfferAssetForAsset":
      return RulesContainer_TransactionRules_TransactionRuleDetails_RuleSubDomain.RuleSubDomainXLMOfferAssetForAsset;
    case 52:
    case "RuleSubDomainSOLTokenCreate":
      return RulesContainer_TransactionRules_TransactionRuleDetails_RuleSubDomain.RuleSubDomainSOLTokenCreate;
    case 53:
    case "RuleSubDomainSOLTokenMint":
      return RulesContainer_TransactionRules_TransactionRuleDetails_RuleSubDomain.RuleSubDomainSOLTokenMint;
    case 54:
    case "RuleSubDomainSOLTokenBurn":
      return RulesContainer_TransactionRules_TransactionRuleDetails_RuleSubDomain.RuleSubDomainSOLTokenBurn;
    case 67:
    case "RuleSubDomainHederaCreateToken":
      return RulesContainer_TransactionRules_TransactionRuleDetails_RuleSubDomain.RuleSubDomainHederaCreateToken;
    case 68:
    case "RuleSubDomainHederaUpdateToken":
      return RulesContainer_TransactionRules_TransactionRuleDetails_RuleSubDomain.RuleSubDomainHederaUpdateToken;
    case 69:
    case "RuleSubDomainHederaMintToken":
      return RulesContainer_TransactionRules_TransactionRuleDetails_RuleSubDomain.RuleSubDomainHederaMintToken;
    case 70:
    case "RuleSubDomainHederaMintNFT":
      return RulesContainer_TransactionRules_TransactionRuleDetails_RuleSubDomain.RuleSubDomainHederaMintNFT;
    case 71:
    case "RuleSubDomainHederaBurnToken":
      return RulesContainer_TransactionRules_TransactionRuleDetails_RuleSubDomain.RuleSubDomainHederaBurnToken;
    case 72:
    case "RuleSubDomainHederaBurnNFT":
      return RulesContainer_TransactionRules_TransactionRuleDetails_RuleSubDomain.RuleSubDomainHederaBurnNFT;
    case 73:
    case "RuleSubDomainHederaDeleteToken":
      return RulesContainer_TransactionRules_TransactionRuleDetails_RuleSubDomain.RuleSubDomainHederaDeleteToken;
    case 74:
    case "RuleSubDomainHederaWipeTokenAccount":
      return RulesContainer_TransactionRules_TransactionRuleDetails_RuleSubDomain.RuleSubDomainHederaWipeTokenAccount;
    case 75:
    case "RuleSubDomainHederaWipeNFTTokenAccount":
      return RulesContainer_TransactionRules_TransactionRuleDetails_RuleSubDomain
        .RuleSubDomainHederaWipeNFTTokenAccount;
    case 76:
    case "RuleSubDomainHederaFreezeTokenAccount":
      return RulesContainer_TransactionRules_TransactionRuleDetails_RuleSubDomain.RuleSubDomainHederaFreezeTokenAccount;
    case 77:
    case "RuleSubDomainHederaUnfreezeTokenAccount":
      return RulesContainer_TransactionRules_TransactionRuleDetails_RuleSubDomain
        .RuleSubDomainHederaUnfreezeTokenAccount;
    case 78:
    case "RuleSubDomainHederaGrantKycToTokenAccount":
      return RulesContainer_TransactionRules_TransactionRuleDetails_RuleSubDomain
        .RuleSubDomainHederaGrantKycToTokenAccount;
    case 79:
    case "RuleSubDomainHederaRevokeKycFromTokenAccount":
      return RulesContainer_TransactionRules_TransactionRuleDetails_RuleSubDomain
        .RuleSubDomainHederaRevokeKycFromTokenAccount;
    case 80:
    case "RuleSubDomainHederaAssociateToken":
      return RulesContainer_TransactionRules_TransactionRuleDetails_RuleSubDomain.RuleSubDomainHederaAssociateToken;
    case 81:
    case "RuleSubDomainHederaDissociateToken":
      return RulesContainer_TransactionRules_TransactionRuleDetails_RuleSubDomain.RuleSubDomainHederaDissociateToken;
    case 82:
    case "RuleSubDomainHederaUpdateTokenFeeSchedule":
      return RulesContainer_TransactionRules_TransactionRuleDetails_RuleSubDomain
        .RuleSubDomainHederaUpdateTokenFeeSchedule;
    case 83:
    case "RuleSubDomainHederaPauseToken":
      return RulesContainer_TransactionRules_TransactionRuleDetails_RuleSubDomain.RuleSubDomainHederaPauseToken;
    case 84:
    case "RuleSubDomainHederaUnpauseToken":
      return RulesContainer_TransactionRules_TransactionRuleDetails_RuleSubDomain.RuleSubDomainHederaUnpauseToken;
    case 85:
    case "RuleSubDomainHederaUpdateNfts":
      return RulesContainer_TransactionRules_TransactionRuleDetails_RuleSubDomain.RuleSubDomainHederaUpdateNfts;
    case 86:
    case "RuleSubDomainHederaRejectToken":
      return RulesContainer_TransactionRules_TransactionRuleDetails_RuleSubDomain.RuleSubDomainHederaRejectToken;
    case 87:
    case "RuleSubDomainHederaAirdropToken":
      return RulesContainer_TransactionRules_TransactionRuleDetails_RuleSubDomain.RuleSubDomainHederaAirdropToken;
    case 88:
    case "RuleSubDomainHederaAirdropNFT":
      return RulesContainer_TransactionRules_TransactionRuleDetails_RuleSubDomain.RuleSubDomainHederaAirdropNFT;
    case 89:
    case "RuleSubDomainHederaCancelAirdrop":
      return RulesContainer_TransactionRules_TransactionRuleDetails_RuleSubDomain.RuleSubDomainHederaCancelAirdrop;
    case 90:
    case "RuleSubDomainHederaClaimAirdrop":
      return RulesContainer_TransactionRules_TransactionRuleDetails_RuleSubDomain.RuleSubDomainHederaClaimAirdrop;
    case 64:
    case "RuleSubDomainFiatDeposit":
      return RulesContainer_TransactionRules_TransactionRuleDetails_RuleSubDomain.RuleSubDomainFiatDeposit;
    case 65:
    case "RuleSubDomainFiatWithdrawal":
      return RulesContainer_TransactionRules_TransactionRuleDetails_RuleSubDomain.RuleSubDomainFiatWithdrawal;
    case 66:
    case "RuleSubDomainFiatTransfer":
      return RulesContainer_TransactionRules_TransactionRuleDetails_RuleSubDomain.RuleSubDomainFiatTransfer;
    case -1:
    case "UNRECOGNIZED":
    default:
      return RulesContainer_TransactionRules_TransactionRuleDetails_RuleSubDomain.UNRECOGNIZED;
  }
}

export function rulesContainer_TransactionRules_TransactionRuleDetails_RuleSubDomainToJSON(
  object: RulesContainer_TransactionRules_TransactionRuleDetails_RuleSubDomain,
): string {
  switch (object) {
    case RulesContainer_TransactionRules_TransactionRuleDetails_RuleSubDomain.RuleSubDomainAny:
      return "RuleSubDomainAny";
    case RulesContainer_TransactionRules_TransactionRuleDetails_RuleSubDomain.RuleSubDomainNative:
      return "RuleSubDomainNative";
    case RulesContainer_TransactionRules_TransactionRuleDetails_RuleSubDomain.RuleSubDomainERC20:
      return "RuleSubDomainERC20";
    case RulesContainer_TransactionRules_TransactionRuleDetails_RuleSubDomain.RuleSubDomainERC721:
      return "RuleSubDomainERC721";
    case RulesContainer_TransactionRules_TransactionRuleDetails_RuleSubDomain.RuleSubDomainERC1155:
      return "RuleSubDomainERC1155";
    case RulesContainer_TransactionRules_TransactionRuleDetails_RuleSubDomain.RuleSubDomainFA12:
      return "RuleSubDomainFA12";
    case RulesContainer_TransactionRules_TransactionRuleDetails_RuleSubDomain.RuleSubDomainFA2:
      return "RuleSubDomainFA2";
    case RulesContainer_TransactionRules_TransactionRuleDetails_RuleSubDomain.RuleSubDomainFA2NFT:
      return "RuleSubDomainFA2NFT";
    case RulesContainer_TransactionRules_TransactionRuleDetails_RuleSubDomain.RuleSubDomainASA:
      return "RuleSubDomainASA";
    case RulesContainer_TransactionRules_TransactionRuleDetails_RuleSubDomain.RuleSubDomainCosmosMsgSend:
      return "RuleSubDomainCosmosMsgSend";
    case RulesContainer_TransactionRules_TransactionRuleDetails_RuleSubDomain.RuleSubDomainCancel:
      return "RuleSubDomainCancel";
    case RulesContainer_TransactionRules_TransactionRuleDetails_RuleSubDomain.RuleSubDomainXLMAsset:
      return "RuleSubDomainXLMAsset";
    case RulesContainer_TransactionRules_TransactionRuleDetails_RuleSubDomain.RuleSubDomainXLMMintAsset:
      return "RuleSubDomainXLMMintAsset";
    case RulesContainer_TransactionRules_TransactionRuleDetails_RuleSubDomain.RuleSubDomainXLMPathPaymentNativeToAsset:
      return "RuleSubDomainXLMPathPaymentNativeToAsset";
    case RulesContainer_TransactionRules_TransactionRuleDetails_RuleSubDomain.RuleSubDomainXLMPathPaymentAssetToNative:
      return "RuleSubDomainXLMPathPaymentAssetToNative";
    case RulesContainer_TransactionRules_TransactionRuleDetails_RuleSubDomain.RuleSubDomainXLMPathPaymentAssetToAsset:
      return "RuleSubDomainXLMPathPaymentAssetToAsset";
    case RulesContainer_TransactionRules_TransactionRuleDetails_RuleSubDomain.RuleSubDomainSOLTokenTransfer:
      return "RuleSubDomainSOLTokenTransfer";
    case RulesContainer_TransactionRules_TransactionRuleDetails_RuleSubDomain.RuleSubDomainICRC1:
      return "RuleSubDomainICRC1";
    case RulesContainer_TransactionRules_TransactionRuleDetails_RuleSubDomain.RuleSubDomainHederaToken:
      return "RuleSubDomainHederaToken";
    case RulesContainer_TransactionRules_TransactionRuleDetails_RuleSubDomain.RuleSubDomainHederaNFT:
      return "RuleSubDomainHederaNFT";
    case RulesContainer_TransactionRules_TransactionRuleDetails_RuleSubDomain.RuleSubDomainCryptoPunks:
      return "RuleSubDomainCryptoPunks";
    case RulesContainer_TransactionRules_TransactionRuleDetails_RuleSubDomain.RuleSubDomainTRC20:
      return "RuleSubDomainTRC20";
    case RulesContainer_TransactionRules_TransactionRuleDetails_RuleSubDomain.RuleSubDomainSOLTokenFreeze:
      return "RuleSubDomainSOLTokenFreeze";
    case RulesContainer_TransactionRules_TransactionRuleDetails_RuleSubDomain.RuleSubDomainSOLTokenUnfreeze:
      return "RuleSubDomainSOLTokenUnfreeze";
    case RulesContainer_TransactionRules_TransactionRuleDetails_RuleSubDomain.RuleSubDomainCIP56:
      return "RuleSubDomainCIP56";
    case RulesContainer_TransactionRules_TransactionRuleDetails_RuleSubDomain.RuleSubDomainDelegate:
      return "RuleSubDomainDelegate";
    case RulesContainer_TransactionRules_TransactionRuleDetails_RuleSubDomain.RuleSubDomainUndelegate:
      return "RuleSubDomainUndelegate";
    case RulesContainer_TransactionRules_TransactionRuleDetails_RuleSubDomain.RuleSubDomainWithdrawal:
      return "RuleSubDomainWithdrawal";
    case RulesContainer_TransactionRules_TransactionRuleDetails_RuleSubDomain.RuleSubDomainClaimRewards:
      return "RuleSubDomainClaimRewards";
    case RulesContainer_TransactionRules_TransactionRuleDetails_RuleSubDomain.RuleSubDomainDOTBond:
      return "RuleSubDomainDOTBond";
    case RulesContainer_TransactionRules_TransactionRuleDetails_RuleSubDomain.RuleSubDomainDOTBondExtra:
      return "RuleSubDomainDOTBondExtra";
    case RulesContainer_TransactionRules_TransactionRuleDetails_RuleSubDomain.RuleSubDomainDOTUnbond:
      return "RuleSubDomainDOTUnbond";
    case RulesContainer_TransactionRules_TransactionRuleDetails_RuleSubDomain.RuleSubDomainFTMLock:
      return "RuleSubDomainFTMLock";
    case RulesContainer_TransactionRules_TransactionRuleDetails_RuleSubDomain.RuleSubDomainICPSetDissolveDelay:
      return "RuleSubDomainICPSetDissolveDelay";
    case RulesContainer_TransactionRules_TransactionRuleDetails_RuleSubDomain.RuleSubDomainICPStartDissolving:
      return "RuleSubDomainICPStartDissolving";
    case RulesContainer_TransactionRules_TransactionRuleDetails_RuleSubDomain.RuleSubDomainICPTransferToStake:
      return "RuleSubDomainICPTransferToStake";
    case RulesContainer_TransactionRules_TransactionRuleDetails_RuleSubDomain.RuleSubDomainStake:
      return "RuleSubDomainStake";
    case RulesContainer_TransactionRules_TransactionRuleDetails_RuleSubDomain.RuleSubDomainUnstake:
      return "RuleSubDomainUnstake";
    case RulesContainer_TransactionRules_TransactionRuleDetails_RuleSubDomain.RuleSubDomainADAVoteDelegate:
      return "RuleSubDomainADAVoteDelegate";
    case RulesContainer_TransactionRules_TransactionRuleDetails_RuleSubDomain.RuleSubDomainSOLPartialDeactivate:
      return "RuleSubDomainSOLPartialDeactivate";
    case RulesContainer_TransactionRules_TransactionRuleDetails_RuleSubDomain.RuleSubDomainSOLMerge:
      return "RuleSubDomainSOLMerge";
    case RulesContainer_TransactionRules_TransactionRuleDetails_RuleSubDomain.RuleSubDomainDeployContract:
      return "RuleSubDomainDeployContract";
    case RulesContainer_TransactionRules_TransactionRuleDetails_RuleSubDomain.RuleSubDomainASAOptIn:
      return "RuleSubDomainASAOptIn";
    case RulesContainer_TransactionRules_TransactionRuleDetails_RuleSubDomain.RuleSubDomainBlock:
      return "RuleSubDomainBlock";
    case RulesContainer_TransactionRules_TransactionRuleDetails_RuleSubDomain.RuleSubDomainCosmosSimplified:
      return "RuleSubDomainCosmosSimplified";
    case RulesContainer_TransactionRules_TransactionRuleDetails_RuleSubDomain.RuleSubDomainCosmosGeneric:
      return "RuleSubDomainCosmosGeneric";
    case RulesContainer_TransactionRules_TransactionRuleDetails_RuleSubDomain.RuleSubDomainXLMChangeTrust:
      return "RuleSubDomainXLMChangeTrust";
    case RulesContainer_TransactionRules_TransactionRuleDetails_RuleSubDomain.RuleSubDomainXLMSetOptions:
      return "RuleSubDomainXLMSetOptions";
    case RulesContainer_TransactionRules_TransactionRuleDetails_RuleSubDomain.RuleSubDomainXLMSetTrustlineFlags:
      return "RuleSubDomainXLMSetTrustlineFlags";
    case RulesContainer_TransactionRules_TransactionRuleDetails_RuleSubDomain.RuleSubDomainXLMManageData:
      return "RuleSubDomainXLMManageData";
    case RulesContainer_TransactionRules_TransactionRuleDetails_RuleSubDomain.RuleSubDomainXLMClaimClaimableBalance:
      return "RuleSubDomainXLMClaimClaimableBalance";
    case RulesContainer_TransactionRules_TransactionRuleDetails_RuleSubDomain.RuleSubDomainXLMClawbackClaimableBalance:
      return "RuleSubDomainXLMClawbackClaimableBalance";
    case RulesContainer_TransactionRules_TransactionRuleDetails_RuleSubDomain
      .RuleSubDomainXLMCreateClaimableBalanceNative:
      return "RuleSubDomainXLMCreateClaimableBalanceNative";
    case RulesContainer_TransactionRules_TransactionRuleDetails_RuleSubDomain
      .RuleSubDomainXLMCreateClaimableBalanceAsset:
      return "RuleSubDomainXLMCreateClaimableBalanceAsset";
    case RulesContainer_TransactionRules_TransactionRuleDetails_RuleSubDomain.RuleSubDomainXLMRevokeSponsorship:
      return "RuleSubDomainXLMRevokeSponsorship";
    case RulesContainer_TransactionRules_TransactionRuleDetails_RuleSubDomain.RuleSubDomainXLMClawback:
      return "RuleSubDomainXLMClawback";
    case RulesContainer_TransactionRules_TransactionRuleDetails_RuleSubDomain.RuleSubDomainXLMLiquidityPoolDeposit:
      return "RuleSubDomainXLMLiquidityPoolDeposit";
    case RulesContainer_TransactionRules_TransactionRuleDetails_RuleSubDomain.RuleSubDomainXLMLiquidityPoolWithdraw:
      return "RuleSubDomainXLMLiquidityPoolWithdraw";
    case RulesContainer_TransactionRules_TransactionRuleDetails_RuleSubDomain.RuleSubDomainXLMChangeTrustLiquidityPool:
      return "RuleSubDomainXLMChangeTrustLiquidityPool";
    case RulesContainer_TransactionRules_TransactionRuleDetails_RuleSubDomain.RuleSubDomainXLMOfferNativeForAsset:
      return "RuleSubDomainXLMOfferNativeForAsset";
    case RulesContainer_TransactionRules_TransactionRuleDetails_RuleSubDomain.RuleSubDomainXLMOfferAssetForNative:
      return "RuleSubDomainXLMOfferAssetForNative";
    case RulesContainer_TransactionRules_TransactionRuleDetails_RuleSubDomain.RuleSubDomainXLMOfferAssetForAsset:
      return "RuleSubDomainXLMOfferAssetForAsset";
    case RulesContainer_TransactionRules_TransactionRuleDetails_RuleSubDomain.RuleSubDomainSOLTokenCreate:
      return "RuleSubDomainSOLTokenCreate";
    case RulesContainer_TransactionRules_TransactionRuleDetails_RuleSubDomain.RuleSubDomainSOLTokenMint:
      return "RuleSubDomainSOLTokenMint";
    case RulesContainer_TransactionRules_TransactionRuleDetails_RuleSubDomain.RuleSubDomainSOLTokenBurn:
      return "RuleSubDomainSOLTokenBurn";
    case RulesContainer_TransactionRules_TransactionRuleDetails_RuleSubDomain.RuleSubDomainHederaCreateToken:
      return "RuleSubDomainHederaCreateToken";
    case RulesContainer_TransactionRules_TransactionRuleDetails_RuleSubDomain.RuleSubDomainHederaUpdateToken:
      return "RuleSubDomainHederaUpdateToken";
    case RulesContainer_TransactionRules_TransactionRuleDetails_RuleSubDomain.RuleSubDomainHederaMintToken:
      return "RuleSubDomainHederaMintToken";
    case RulesContainer_TransactionRules_TransactionRuleDetails_RuleSubDomain.RuleSubDomainHederaMintNFT:
      return "RuleSubDomainHederaMintNFT";
    case RulesContainer_TransactionRules_TransactionRuleDetails_RuleSubDomain.RuleSubDomainHederaBurnToken:
      return "RuleSubDomainHederaBurnToken";
    case RulesContainer_TransactionRules_TransactionRuleDetails_RuleSubDomain.RuleSubDomainHederaBurnNFT:
      return "RuleSubDomainHederaBurnNFT";
    case RulesContainer_TransactionRules_TransactionRuleDetails_RuleSubDomain.RuleSubDomainHederaDeleteToken:
      return "RuleSubDomainHederaDeleteToken";
    case RulesContainer_TransactionRules_TransactionRuleDetails_RuleSubDomain.RuleSubDomainHederaWipeTokenAccount:
      return "RuleSubDomainHederaWipeTokenAccount";
    case RulesContainer_TransactionRules_TransactionRuleDetails_RuleSubDomain.RuleSubDomainHederaWipeNFTTokenAccount:
      return "RuleSubDomainHederaWipeNFTTokenAccount";
    case RulesContainer_TransactionRules_TransactionRuleDetails_RuleSubDomain.RuleSubDomainHederaFreezeTokenAccount:
      return "RuleSubDomainHederaFreezeTokenAccount";
    case RulesContainer_TransactionRules_TransactionRuleDetails_RuleSubDomain.RuleSubDomainHederaUnfreezeTokenAccount:
      return "RuleSubDomainHederaUnfreezeTokenAccount";
    case RulesContainer_TransactionRules_TransactionRuleDetails_RuleSubDomain.RuleSubDomainHederaGrantKycToTokenAccount:
      return "RuleSubDomainHederaGrantKycToTokenAccount";
    case RulesContainer_TransactionRules_TransactionRuleDetails_RuleSubDomain
      .RuleSubDomainHederaRevokeKycFromTokenAccount:
      return "RuleSubDomainHederaRevokeKycFromTokenAccount";
    case RulesContainer_TransactionRules_TransactionRuleDetails_RuleSubDomain.RuleSubDomainHederaAssociateToken:
      return "RuleSubDomainHederaAssociateToken";
    case RulesContainer_TransactionRules_TransactionRuleDetails_RuleSubDomain.RuleSubDomainHederaDissociateToken:
      return "RuleSubDomainHederaDissociateToken";
    case RulesContainer_TransactionRules_TransactionRuleDetails_RuleSubDomain.RuleSubDomainHederaUpdateTokenFeeSchedule:
      return "RuleSubDomainHederaUpdateTokenFeeSchedule";
    case RulesContainer_TransactionRules_TransactionRuleDetails_RuleSubDomain.RuleSubDomainHederaPauseToken:
      return "RuleSubDomainHederaPauseToken";
    case RulesContainer_TransactionRules_TransactionRuleDetails_RuleSubDomain.RuleSubDomainHederaUnpauseToken:
      return "RuleSubDomainHederaUnpauseToken";
    case RulesContainer_TransactionRules_TransactionRuleDetails_RuleSubDomain.RuleSubDomainHederaUpdateNfts:
      return "RuleSubDomainHederaUpdateNfts";
    case RulesContainer_TransactionRules_TransactionRuleDetails_RuleSubDomain.RuleSubDomainHederaRejectToken:
      return "RuleSubDomainHederaRejectToken";
    case RulesContainer_TransactionRules_TransactionRuleDetails_RuleSubDomain.RuleSubDomainHederaAirdropToken:
      return "RuleSubDomainHederaAirdropToken";
    case RulesContainer_TransactionRules_TransactionRuleDetails_RuleSubDomain.RuleSubDomainHederaAirdropNFT:
      return "RuleSubDomainHederaAirdropNFT";
    case RulesContainer_TransactionRules_TransactionRuleDetails_RuleSubDomain.RuleSubDomainHederaCancelAirdrop:
      return "RuleSubDomainHederaCancelAirdrop";
    case RulesContainer_TransactionRules_TransactionRuleDetails_RuleSubDomain.RuleSubDomainHederaClaimAirdrop:
      return "RuleSubDomainHederaClaimAirdrop";
    case RulesContainer_TransactionRules_TransactionRuleDetails_RuleSubDomain.RuleSubDomainFiatDeposit:
      return "RuleSubDomainFiatDeposit";
    case RulesContainer_TransactionRules_TransactionRuleDetails_RuleSubDomain.RuleSubDomainFiatWithdrawal:
      return "RuleSubDomainFiatWithdrawal";
    case RulesContainer_TransactionRules_TransactionRuleDetails_RuleSubDomain.RuleSubDomainFiatTransfer:
      return "RuleSubDomainFiatTransfer";
    case RulesContainer_TransactionRules_TransactionRuleDetails_RuleSubDomain.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

export interface RulesContainer_TransactionRules_TransactionRuleDetails_EvmCallContract {
  /** GENERIC, ERC20, CMTAT, CMTA20... */
  contractType: string;
  methodSignature: string;
}

export interface RulesContainer_TransactionRules_TransactionRuleDetails_XtzCallContract {
  contractType: string;
  methodSignature: string;
}

export interface RulesContainer_TransactionRules_TransactionRuleDetails_CashSettlement {
  provider: string;
  requestType: string;
}

export interface RulesContainer_TransactionRules_TransactionRuleDetails_CosmosDetails {
  methodSignatures: string[];
}

export interface RulesContainer_AddressWhitelistingRules {
  /** Should be unique and actually represent a blockchain. If empty -> valid for all non-listed currencies */
  currency: string;
  parallelThresholds: SequentialThresholds[];
  properties: { [key: string]: Uint8Array };
  network: string;
  /**
   * For rules with a specified source. Rules without source specification (Any) are defined using the fields
   * at list level.
   */
  lines: RulesContainer_AddressWhitelistingRules_Line[];
}

export interface RulesContainer_AddressWhitelistingRules_Line {
  /** rule inputs (source restriction) */
  cells: Uint8Array[];
  /** rule output */
  parallelThresholds: SequentialThresholds[];
  properties: { [key: string]: Uint8Array };
}

export interface RulesContainer_AddressWhitelistingRules_Line_PropertiesEntry {
  key: string;
  value: Uint8Array;
}

export interface RulesContainer_AddressWhitelistingRules_PropertiesEntry {
  key: string;
  value: Uint8Array;
}

export interface RulesContainer_ContractAddressWhitelistingRules {
  blockchain: Blockchain;
  parallelThresholds: SequentialThresholds[];
  properties: { [key: string]: Uint8Array };
  network: string;
}

export interface RulesContainer_ContractAddressWhitelistingRules_PropertiesEntry {
  key: string;
  value: Uint8Array;
}

export interface RulesContainer_Policy {
  id: string;
  label: string;
  parallelThresholds: SequentialThresholds[];
  description: string;
}

export interface RulesContainer_Policies {
  policies: RulesContainer_Policy[];
}

export interface RulesContainer_PropertiesEntry {
  key: string;
  value: Uint8Array;
}

function createBaseStatus(): Status {
  return { code: 0, message: "" };
}

export const Status = {
  encode(message: Status, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.code !== 0) {
      writer.uint32(8).int32(message.code);
    }
    if (message.message !== "") {
      writer.uint32(18).string(message.message);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): Status {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseStatus();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.code = reader.int32() as any;
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.message = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Status {
    return {
      code: isSet(object.code) ? status_StatusCodeFromJSON(object.code) : 0,
      message: isSet(object.message) ? globalThis.String(object.message) : "",
    };
  },

  toJSON(message: Status): unknown {
    const obj: any = {};
    if (message.code !== 0) {
      obj.code = status_StatusCodeToJSON(message.code);
    }
    if (message.message !== "") {
      obj.message = message.message;
    }
    return obj;
  },

  create(base?: DeepPartial<Status>): Status {
    return Status.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<Status>): Status {
    const message = createBaseStatus();
    message.code = object.code ?? 0;
    message.message = object.message ?? "";
    return message;
  },
};

function createBaseTraces(): Traces {
  return { function: "", duration: 0, children: [], offset: 0 };
}

export const Traces = {
  encode(message: Traces, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.function !== "") {
      writer.uint32(10).string(message.function);
    }
    if (message.duration !== 0) {
      writer.uint32(16).uint64(message.duration);
    }
    for (const v of message.children) {
      Traces.encode(v!, writer.uint32(26).fork()).ldelim();
    }
    if (message.offset !== 0) {
      writer.uint32(32).uint64(message.offset);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): Traces {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseTraces();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.function = reader.string();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.duration = longToNumber(reader.uint64() as Long);
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.children.push(Traces.decode(reader, reader.uint32()));
          continue;
        case 4:
          if (tag !== 32) {
            break;
          }

          message.offset = longToNumber(reader.uint64() as Long);
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Traces {
    return {
      function: isSet(object.function) ? globalThis.String(object.function) : "",
      duration: isSet(object.duration) ? globalThis.Number(object.duration) : 0,
      children: globalThis.Array.isArray(object?.children) ? object.children.map((e: any) => Traces.fromJSON(e)) : [],
      offset: isSet(object.offset) ? globalThis.Number(object.offset) : 0,
    };
  },

  toJSON(message: Traces): unknown {
    const obj: any = {};
    if (message.function !== "") {
      obj.function = message.function;
    }
    if (message.duration !== 0) {
      obj.duration = Math.round(message.duration);
    }
    if (message.children?.length) {
      obj.children = message.children.map((e) => Traces.toJSON(e));
    }
    if (message.offset !== 0) {
      obj.offset = Math.round(message.offset);
    }
    return obj;
  },

  create(base?: DeepPartial<Traces>): Traces {
    return Traces.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<Traces>): Traces {
    const message = createBaseTraces();
    message.function = object.function ?? "";
    message.duration = object.duration ?? 0;
    message.children = object.children?.map((e) => Traces.fromPartial(e)) || [];
    message.offset = object.offset ?? 0;
    return message;
  },
};

function createBaseEncryptedRepliesContainer(): EncryptedRepliesContainer {
  return { iv: new Uint8Array(0), ciphertext: new Uint8Array(0), mac: new Uint8Array(0) };
}

export const EncryptedRepliesContainer = {
  encode(message: EncryptedRepliesContainer, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.iv.length !== 0) {
      writer.uint32(10).bytes(message.iv);
    }
    if (message.ciphertext.length !== 0) {
      writer.uint32(18).bytes(message.ciphertext);
    }
    if (message.mac.length !== 0) {
      writer.uint32(26).bytes(message.mac);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): EncryptedRepliesContainer {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseEncryptedRepliesContainer();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.iv = reader.bytes();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.ciphertext = reader.bytes();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.mac = reader.bytes();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): EncryptedRepliesContainer {
    return {
      iv: isSet(object.iv) ? bytesFromBase64(object.iv) : new Uint8Array(0),
      ciphertext: isSet(object.ciphertext) ? bytesFromBase64(object.ciphertext) : new Uint8Array(0),
      mac: isSet(object.mac) ? bytesFromBase64(object.mac) : new Uint8Array(0),
    };
  },

  toJSON(message: EncryptedRepliesContainer): unknown {
    const obj: any = {};
    if (message.iv.length !== 0) {
      obj.iv = base64FromBytes(message.iv);
    }
    if (message.ciphertext.length !== 0) {
      obj.ciphertext = base64FromBytes(message.ciphertext);
    }
    if (message.mac.length !== 0) {
      obj.mac = base64FromBytes(message.mac);
    }
    return obj;
  },

  create(base?: DeepPartial<EncryptedRepliesContainer>): EncryptedRepliesContainer {
    return EncryptedRepliesContainer.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<EncryptedRepliesContainer>): EncryptedRepliesContainer {
    const message = createBaseEncryptedRepliesContainer();
    message.iv = object.iv ?? new Uint8Array(0);
    message.ciphertext = object.ciphertext ?? new Uint8Array(0);
    message.mac = object.mac ?? new Uint8Array(0);
    return message;
  },
};

function createBaseSignedRepliesEnvelope(): SignedRepliesEnvelope {
  return {
    id: "",
    status: undefined,
    payloadSignature: new Uint8Array(0),
    payload: new Uint8Array(0),
    encryptedRepliesEnvelope: undefined,
    traces: undefined,
  };
}

export const SignedRepliesEnvelope = {
  encode(message: SignedRepliesEnvelope, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.id !== "") {
      writer.uint32(10).string(message.id);
    }
    if (message.status !== undefined) {
      Status.encode(message.status, writer.uint32(18).fork()).ldelim();
    }
    if (message.payloadSignature.length !== 0) {
      writer.uint32(26).bytes(message.payloadSignature);
    }
    if (message.payload.length !== 0) {
      writer.uint32(34).bytes(message.payload);
    }
    if (message.encryptedRepliesEnvelope !== undefined) {
      EncryptedRepliesContainer.encode(message.encryptedRepliesEnvelope, writer.uint32(8002).fork()).ldelim();
    }
    if (message.traces !== undefined) {
      Traces.encode(message.traces, writer.uint32(8010).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): SignedRepliesEnvelope {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSignedRepliesEnvelope();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.id = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.status = Status.decode(reader, reader.uint32());
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.payloadSignature = reader.bytes();
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.payload = reader.bytes();
          continue;
        case 1000:
          if (tag !== 8002) {
            break;
          }

          message.encryptedRepliesEnvelope = EncryptedRepliesContainer.decode(reader, reader.uint32());
          continue;
        case 1001:
          if (tag !== 8010) {
            break;
          }

          message.traces = Traces.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): SignedRepliesEnvelope {
    return {
      id: isSet(object.id) ? globalThis.String(object.id) : "",
      status: isSet(object.status) ? Status.fromJSON(object.status) : undefined,
      payloadSignature: isSet(object.payloadSignature) ? bytesFromBase64(object.payloadSignature) : new Uint8Array(0),
      payload: isSet(object.payload) ? bytesFromBase64(object.payload) : new Uint8Array(0),
      encryptedRepliesEnvelope: isSet(object.encryptedRepliesEnvelope)
        ? EncryptedRepliesContainer.fromJSON(object.encryptedRepliesEnvelope)
        : undefined,
      traces: isSet(object.traces) ? Traces.fromJSON(object.traces) : undefined,
    };
  },

  toJSON(message: SignedRepliesEnvelope): unknown {
    const obj: any = {};
    if (message.id !== "") {
      obj.id = message.id;
    }
    if (message.status !== undefined) {
      obj.status = Status.toJSON(message.status);
    }
    if (message.payloadSignature.length !== 0) {
      obj.payloadSignature = base64FromBytes(message.payloadSignature);
    }
    if (message.payload.length !== 0) {
      obj.payload = base64FromBytes(message.payload);
    }
    if (message.encryptedRepliesEnvelope !== undefined) {
      obj.encryptedRepliesEnvelope = EncryptedRepliesContainer.toJSON(message.encryptedRepliesEnvelope);
    }
    if (message.traces !== undefined) {
      obj.traces = Traces.toJSON(message.traces);
    }
    return obj;
  },

  create(base?: DeepPartial<SignedRepliesEnvelope>): SignedRepliesEnvelope {
    return SignedRepliesEnvelope.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<SignedRepliesEnvelope>): SignedRepliesEnvelope {
    const message = createBaseSignedRepliesEnvelope();
    message.id = object.id ?? "";
    message.status = (object.status !== undefined && object.status !== null)
      ? Status.fromPartial(object.status)
      : undefined;
    message.payloadSignature = object.payloadSignature ?? new Uint8Array(0);
    message.payload = object.payload ?? new Uint8Array(0);
    message.encryptedRepliesEnvelope =
      (object.encryptedRepliesEnvelope !== undefined && object.encryptedRepliesEnvelope !== null)
        ? EncryptedRepliesContainer.fromPartial(object.encryptedRepliesEnvelope)
        : undefined;
    message.traces = (object.traces !== undefined && object.traces !== null)
      ? Traces.fromPartial(object.traces)
      : undefined;
    return message;
  },
};

function createBaseReplies(): Replies {
  return { replies: [] };
}

export const Replies = {
  encode(message: Replies, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    for (const v of message.replies) {
      Reply.encode(v!, writer.uint32(10).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): Replies {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseReplies();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.replies.push(Reply.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Replies {
    return {
      replies: globalThis.Array.isArray(object?.replies) ? object.replies.map((e: any) => Reply.fromJSON(e)) : [],
    };
  },

  toJSON(message: Replies): unknown {
    const obj: any = {};
    if (message.replies?.length) {
      obj.replies = message.replies.map((e) => Reply.toJSON(e));
    }
    return obj;
  },

  create(base?: DeepPartial<Replies>): Replies {
    return Replies.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<Replies>): Replies {
    const message = createBaseReplies();
    message.replies = object.replies?.map((e) => Reply.fromPartial(e)) || [];
    return message;
  },
};

function createBaseReply(): Reply {
  return { id: "", status: undefined, payloadType: 0, payload: new Uint8Array(0) };
}

export const Reply = {
  encode(message: Reply, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.id !== "") {
      writer.uint32(10).string(message.id);
    }
    if (message.status !== undefined) {
      Status.encode(message.status, writer.uint32(18).fork()).ldelim();
    }
    if (message.payloadType !== 0) {
      writer.uint32(24).int32(message.payloadType);
    }
    if (message.payload.length !== 0) {
      writer.uint32(34).bytes(message.payload);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): Reply {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseReply();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.id = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.status = Status.decode(reader, reader.uint32());
          continue;
        case 3:
          if (tag !== 24) {
            break;
          }

          message.payloadType = reader.int32() as any;
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.payload = reader.bytes();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Reply {
    return {
      id: isSet(object.id) ? globalThis.String(object.id) : "",
      status: isSet(object.status) ? Status.fromJSON(object.status) : undefined,
      payloadType: isSet(object.payloadType) ? reply_PayloadTypeFromJSON(object.payloadType) : 0,
      payload: isSet(object.payload) ? bytesFromBase64(object.payload) : new Uint8Array(0),
    };
  },

  toJSON(message: Reply): unknown {
    const obj: any = {};
    if (message.id !== "") {
      obj.id = message.id;
    }
    if (message.status !== undefined) {
      obj.status = Status.toJSON(message.status);
    }
    if (message.payloadType !== 0) {
      obj.payloadType = reply_PayloadTypeToJSON(message.payloadType);
    }
    if (message.payload.length !== 0) {
      obj.payload = base64FromBytes(message.payload);
    }
    return obj;
  },

  create(base?: DeepPartial<Reply>): Reply {
    return Reply.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<Reply>): Reply {
    const message = createBaseReply();
    message.id = object.id ?? "";
    message.status = (object.status !== undefined && object.status !== null)
      ? Status.fromPartial(object.status)
      : undefined;
    message.payloadType = object.payloadType ?? 0;
    message.payload = object.payload ?? new Uint8Array(0);
    return message;
  },
};

function createBaseMonitoringResponse(): MonitoringResponse {
  return { payload: "", signature: "" };
}

export const MonitoringResponse = {
  encode(message: MonitoringResponse, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.payload !== "") {
      writer.uint32(10).string(message.payload);
    }
    if (message.signature !== "") {
      writer.uint32(18).string(message.signature);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): MonitoringResponse {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMonitoringResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.payload = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.signature = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): MonitoringResponse {
    return {
      payload: isSet(object.payload) ? globalThis.String(object.payload) : "",
      signature: isSet(object.signature) ? globalThis.String(object.signature) : "",
    };
  },

  toJSON(message: MonitoringResponse): unknown {
    const obj: any = {};
    if (message.payload !== "") {
      obj.payload = message.payload;
    }
    if (message.signature !== "") {
      obj.signature = message.signature;
    }
    return obj;
  },

  create(base?: DeepPartial<MonitoringResponse>): MonitoringResponse {
    return MonitoringResponse.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<MonitoringResponse>): MonitoringResponse {
    const message = createBaseMonitoringResponse();
    message.payload = object.payload ?? "";
    message.signature = object.signature ?? "";
    return message;
  },
};

function createBaseProofOfReserveResponse(): ProofOfReserveResponse {
  return {
    curve: 0,
    cipher: 0,
    address: "",
    path: "",
    publicKey: new Uint8Array(0),
    challenge: "",
    challengeResponse: new Uint8Array(0),
  };
}

export const ProofOfReserveResponse = {
  encode(message: ProofOfReserveResponse, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.curve !== 0) {
      writer.uint32(8).int32(message.curve);
    }
    if (message.cipher !== 0) {
      writer.uint32(16).int32(message.cipher);
    }
    if (message.address !== "") {
      writer.uint32(26).string(message.address);
    }
    if (message.path !== "") {
      writer.uint32(34).string(message.path);
    }
    if (message.publicKey.length !== 0) {
      writer.uint32(42).bytes(message.publicKey);
    }
    if (message.challenge !== "") {
      writer.uint32(50).string(message.challenge);
    }
    if (message.challengeResponse.length !== 0) {
      writer.uint32(58).bytes(message.challengeResponse);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): ProofOfReserveResponse {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseProofOfReserveResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.curve = reader.int32() as any;
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.cipher = reader.int32() as any;
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.address = reader.string();
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.path = reader.string();
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.publicKey = reader.bytes();
          continue;
        case 6:
          if (tag !== 50) {
            break;
          }

          message.challenge = reader.string();
          continue;
        case 7:
          if (tag !== 58) {
            break;
          }

          message.challengeResponse = reader.bytes();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ProofOfReserveResponse {
    return {
      curve: isSet(object.curve) ? proofOfReserveResponse_CurveFromJSON(object.curve) : 0,
      cipher: isSet(object.cipher) ? proofOfReserveResponse_CipherFromJSON(object.cipher) : 0,
      address: isSet(object.address) ? globalThis.String(object.address) : "",
      path: isSet(object.path) ? globalThis.String(object.path) : "",
      publicKey: isSet(object.publicKey) ? bytesFromBase64(object.publicKey) : new Uint8Array(0),
      challenge: isSet(object.challenge) ? globalThis.String(object.challenge) : "",
      challengeResponse: isSet(object.challengeResponse)
        ? bytesFromBase64(object.challengeResponse)
        : new Uint8Array(0),
    };
  },

  toJSON(message: ProofOfReserveResponse): unknown {
    const obj: any = {};
    if (message.curve !== 0) {
      obj.curve = proofOfReserveResponse_CurveToJSON(message.curve);
    }
    if (message.cipher !== 0) {
      obj.cipher = proofOfReserveResponse_CipherToJSON(message.cipher);
    }
    if (message.address !== "") {
      obj.address = message.address;
    }
    if (message.path !== "") {
      obj.path = message.path;
    }
    if (message.publicKey.length !== 0) {
      obj.publicKey = base64FromBytes(message.publicKey);
    }
    if (message.challenge !== "") {
      obj.challenge = message.challenge;
    }
    if (message.challengeResponse.length !== 0) {
      obj.challengeResponse = base64FromBytes(message.challengeResponse);
    }
    return obj;
  },

  create(base?: DeepPartial<ProofOfReserveResponse>): ProofOfReserveResponse {
    return ProofOfReserveResponse.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ProofOfReserveResponse>): ProofOfReserveResponse {
    const message = createBaseProofOfReserveResponse();
    message.curve = object.curve ?? 0;
    message.cipher = object.cipher ?? 0;
    message.address = object.address ?? "";
    message.path = object.path ?? "";
    message.publicKey = object.publicKey ?? new Uint8Array(0);
    message.challenge = object.challenge ?? "";
    message.challengeResponse = object.challengeResponse ?? new Uint8Array(0);
    return message;
  },
};

function createBaseTransactionsResponse(): TransactionsResponse {
  return { transactions: [] };
}

export const TransactionsResponse = {
  encode(message: TransactionsResponse, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    for (const v of message.transactions) {
      TransactionsResponse_Transaction.encode(v!, writer.uint32(10).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): TransactionsResponse {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseTransactionsResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.transactions.push(TransactionsResponse_Transaction.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): TransactionsResponse {
    return {
      transactions: globalThis.Array.isArray(object?.transactions)
        ? object.transactions.map((e: any) => TransactionsResponse_Transaction.fromJSON(e))
        : [],
    };
  },

  toJSON(message: TransactionsResponse): unknown {
    const obj: any = {};
    if (message.transactions?.length) {
      obj.transactions = message.transactions.map((e) => TransactionsResponse_Transaction.toJSON(e));
    }
    return obj;
  },

  create(base?: DeepPartial<TransactionsResponse>): TransactionsResponse {
    return TransactionsResponse.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<TransactionsResponse>): TransactionsResponse {
    const message = createBaseTransactionsResponse();
    message.transactions = object.transactions?.map((e) => TransactionsResponse_Transaction.fromPartial(e)) || [];
    return message;
  },
};

function createBaseTransactionsResponse_Transaction(): TransactionsResponse_Transaction {
  return { id: "", transaction: "" };
}

export const TransactionsResponse_Transaction = {
  encode(message: TransactionsResponse_Transaction, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.id !== "") {
      writer.uint32(10).string(message.id);
    }
    if (message.transaction !== "") {
      writer.uint32(18).string(message.transaction);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): TransactionsResponse_Transaction {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseTransactionsResponse_Transaction();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.id = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.transaction = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): TransactionsResponse_Transaction {
    return {
      id: isSet(object.id) ? globalThis.String(object.id) : "",
      transaction: isSet(object.transaction) ? globalThis.String(object.transaction) : "",
    };
  },

  toJSON(message: TransactionsResponse_Transaction): unknown {
    const obj: any = {};
    if (message.id !== "") {
      obj.id = message.id;
    }
    if (message.transaction !== "") {
      obj.transaction = message.transaction;
    }
    return obj;
  },

  create(base?: DeepPartial<TransactionsResponse_Transaction>): TransactionsResponse_Transaction {
    return TransactionsResponse_Transaction.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<TransactionsResponse_Transaction>): TransactionsResponse_Transaction {
    const message = createBaseTransactionsResponse_Transaction();
    message.id = object.id ?? "";
    message.transaction = object.transaction ?? "";
    return message;
  },
};

function createBaseSourceInternalWallet(): SourceInternalWallet {
  return { id: 0, name: "", path: "" };
}

export const SourceInternalWallet = {
  encode(message: SourceInternalWallet, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.id !== 0) {
      writer.uint32(8).uint64(message.id);
    }
    if (message.name !== "") {
      writer.uint32(18).string(message.name);
    }
    if (message.path !== "") {
      writer.uint32(26).string(message.path);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): SourceInternalWallet {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSourceInternalWallet();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.id = longToNumber(reader.uint64() as Long);
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.name = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.path = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): SourceInternalWallet {
    return {
      id: isSet(object.id) ? globalThis.Number(object.id) : 0,
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      path: isSet(object.path) ? globalThis.String(object.path) : "",
    };
  },

  toJSON(message: SourceInternalWallet): unknown {
    const obj: any = {};
    if (message.id !== 0) {
      obj.id = Math.round(message.id);
    }
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.path !== "") {
      obj.path = message.path;
    }
    return obj;
  },

  create(base?: DeepPartial<SourceInternalWallet>): SourceInternalWallet {
    return SourceInternalWallet.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<SourceInternalWallet>): SourceInternalWallet {
    const message = createBaseSourceInternalWallet();
    message.id = object.id ?? 0;
    message.name = object.name ?? "";
    message.path = object.path ?? "";
    return message;
  },
};

function createBaseSourceInternalAddress(): SourceInternalAddress {
  return { id: 0, address: "", label: "", path: "" };
}

export const SourceInternalAddress = {
  encode(message: SourceInternalAddress, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.id !== 0) {
      writer.uint32(8).uint64(message.id);
    }
    if (message.address !== "") {
      writer.uint32(18).string(message.address);
    }
    if (message.label !== "") {
      writer.uint32(26).string(message.label);
    }
    if (message.path !== "") {
      writer.uint32(34).string(message.path);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): SourceInternalAddress {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSourceInternalAddress();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.id = longToNumber(reader.uint64() as Long);
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.address = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.label = reader.string();
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.path = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): SourceInternalAddress {
    return {
      id: isSet(object.id) ? globalThis.Number(object.id) : 0,
      address: isSet(object.address) ? globalThis.String(object.address) : "",
      label: isSet(object.label) ? globalThis.String(object.label) : "",
      path: isSet(object.path) ? globalThis.String(object.path) : "",
    };
  },

  toJSON(message: SourceInternalAddress): unknown {
    const obj: any = {};
    if (message.id !== 0) {
      obj.id = Math.round(message.id);
    }
    if (message.address !== "") {
      obj.address = message.address;
    }
    if (message.label !== "") {
      obj.label = message.label;
    }
    if (message.path !== "") {
      obj.path = message.path;
    }
    return obj;
  },

  create(base?: DeepPartial<SourceInternalAddress>): SourceInternalAddress {
    return SourceInternalAddress.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<SourceInternalAddress>): SourceInternalAddress {
    const message = createBaseSourceInternalAddress();
    message.id = object.id ?? 0;
    message.address = object.address ?? "";
    message.label = object.label ?? "";
    message.path = object.path ?? "";
    return message;
  },
};

function createBaseSourceExchange(): SourceExchange {
  return { id: 0, label: "" };
}

export const SourceExchange = {
  encode(message: SourceExchange, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.id !== 0) {
      writer.uint32(8).uint64(message.id);
    }
    if (message.label !== "") {
      writer.uint32(18).string(message.label);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): SourceExchange {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSourceExchange();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.id = longToNumber(reader.uint64() as Long);
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.label = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): SourceExchange {
    return {
      id: isSet(object.id) ? globalThis.Number(object.id) : 0,
      label: isSet(object.label) ? globalThis.String(object.label) : "",
    };
  },

  toJSON(message: SourceExchange): unknown {
    const obj: any = {};
    if (message.id !== 0) {
      obj.id = Math.round(message.id);
    }
    if (message.label !== "") {
      obj.label = message.label;
    }
    return obj;
  },

  create(base?: DeepPartial<SourceExchange>): SourceExchange {
    return SourceExchange.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<SourceExchange>): SourceExchange {
    const message = createBaseSourceExchange();
    message.id = object.id ?? 0;
    message.label = object.label ?? "";
    return message;
  },
};

function createBaseSourceFiatProviderAccount(): SourceFiatProviderAccount {
  return { id: "", label: "", accountType: "", isCounterparty: false };
}

export const SourceFiatProviderAccount = {
  encode(message: SourceFiatProviderAccount, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.id !== "") {
      writer.uint32(10).string(message.id);
    }
    if (message.label !== "") {
      writer.uint32(18).string(message.label);
    }
    if (message.accountType !== "") {
      writer.uint32(26).string(message.accountType);
    }
    if (message.isCounterparty !== false) {
      writer.uint32(32).bool(message.isCounterparty);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): SourceFiatProviderAccount {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSourceFiatProviderAccount();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.id = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.label = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.accountType = reader.string();
          continue;
        case 4:
          if (tag !== 32) {
            break;
          }

          message.isCounterparty = reader.bool();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): SourceFiatProviderAccount {
    return {
      id: isSet(object.id) ? globalThis.String(object.id) : "",
      label: isSet(object.label) ? globalThis.String(object.label) : "",
      accountType: isSet(object.accountType) ? globalThis.String(object.accountType) : "",
      isCounterparty: isSet(object.isCounterparty) ? globalThis.Boolean(object.isCounterparty) : false,
    };
  },

  toJSON(message: SourceFiatProviderAccount): unknown {
    const obj: any = {};
    if (message.id !== "") {
      obj.id = message.id;
    }
    if (message.label !== "") {
      obj.label = message.label;
    }
    if (message.accountType !== "") {
      obj.accountType = message.accountType;
    }
    if (message.isCounterparty !== false) {
      obj.isCounterparty = message.isCounterparty;
    }
    return obj;
  },

  create(base?: DeepPartial<SourceFiatProviderAccount>): SourceFiatProviderAccount {
    return SourceFiatProviderAccount.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<SourceFiatProviderAccount>): SourceFiatProviderAccount {
    const message = createBaseSourceFiatProviderAccount();
    message.id = object.id ?? "";
    message.label = object.label ?? "";
    message.accountType = object.accountType ?? "";
    message.isCounterparty = object.isCounterparty ?? false;
    return message;
  },
};

function createBaseSourceExternalAddress(): SourceExternalAddress {
  return { id: 0, address: "", label: "", memo: "" };
}

export const SourceExternalAddress = {
  encode(message: SourceExternalAddress, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.id !== 0) {
      writer.uint32(8).uint64(message.id);
    }
    if (message.address !== "") {
      writer.uint32(18).string(message.address);
    }
    if (message.label !== "") {
      writer.uint32(26).string(message.label);
    }
    if (message.memo !== "") {
      writer.uint32(34).string(message.memo);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): SourceExternalAddress {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSourceExternalAddress();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.id = longToNumber(reader.uint64() as Long);
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.address = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.label = reader.string();
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.memo = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): SourceExternalAddress {
    return {
      id: isSet(object.id) ? globalThis.Number(object.id) : 0,
      address: isSet(object.address) ? globalThis.String(object.address) : "",
      label: isSet(object.label) ? globalThis.String(object.label) : "",
      memo: isSet(object.memo) ? globalThis.String(object.memo) : "",
    };
  },

  toJSON(message: SourceExternalAddress): unknown {
    const obj: any = {};
    if (message.id !== 0) {
      obj.id = Math.round(message.id);
    }
    if (message.address !== "") {
      obj.address = message.address;
    }
    if (message.label !== "") {
      obj.label = message.label;
    }
    if (message.memo !== "") {
      obj.memo = message.memo;
    }
    return obj;
  },

  create(base?: DeepPartial<SourceExternalAddress>): SourceExternalAddress {
    return SourceExternalAddress.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<SourceExternalAddress>): SourceExternalAddress {
    const message = createBaseSourceExternalAddress();
    message.id = object.id ?? 0;
    message.address = object.address ?? "";
    message.label = object.label ?? "";
    message.memo = object.memo ?? "";
    return message;
  },
};

function createBaseSource(): Source {
  return { type: 0, payload: new Uint8Array(0) };
}

export const Source = {
  encode(message: Source, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.type !== 0) {
      writer.uint32(8).int32(message.type);
    }
    if (message.payload.length !== 0) {
      writer.uint32(18).bytes(message.payload);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): Source {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSource();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.type = reader.int32() as any;
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.payload = reader.bytes();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Source {
    return {
      type: isSet(object.type) ? source_SourceTypeFromJSON(object.type) : 0,
      payload: isSet(object.payload) ? bytesFromBase64(object.payload) : new Uint8Array(0),
    };
  },

  toJSON(message: Source): unknown {
    const obj: any = {};
    if (message.type !== 0) {
      obj.type = source_SourceTypeToJSON(message.type);
    }
    if (message.payload.length !== 0) {
      obj.payload = base64FromBytes(message.payload);
    }
    return obj;
  },

  create(base?: DeepPartial<Source>): Source {
    return Source.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<Source>): Source {
    const message = createBaseSource();
    message.type = object.type ?? 0;
    message.payload = object.payload ?? new Uint8Array(0);
    return message;
  },
};

function createBaseDestinationInternalAddress(): DestinationInternalAddress {
  return { id: 0, address: "", label: "", path: "" };
}

export const DestinationInternalAddress = {
  encode(message: DestinationInternalAddress, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.id !== 0) {
      writer.uint32(8).uint64(message.id);
    }
    if (message.address !== "") {
      writer.uint32(18).string(message.address);
    }
    if (message.label !== "") {
      writer.uint32(26).string(message.label);
    }
    if (message.path !== "") {
      writer.uint32(34).string(message.path);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): DestinationInternalAddress {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseDestinationInternalAddress();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.id = longToNumber(reader.uint64() as Long);
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.address = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.label = reader.string();
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.path = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): DestinationInternalAddress {
    return {
      id: isSet(object.id) ? globalThis.Number(object.id) : 0,
      address: isSet(object.address) ? globalThis.String(object.address) : "",
      label: isSet(object.label) ? globalThis.String(object.label) : "",
      path: isSet(object.path) ? globalThis.String(object.path) : "",
    };
  },

  toJSON(message: DestinationInternalAddress): unknown {
    const obj: any = {};
    if (message.id !== 0) {
      obj.id = Math.round(message.id);
    }
    if (message.address !== "") {
      obj.address = message.address;
    }
    if (message.label !== "") {
      obj.label = message.label;
    }
    if (message.path !== "") {
      obj.path = message.path;
    }
    return obj;
  },

  create(base?: DeepPartial<DestinationInternalAddress>): DestinationInternalAddress {
    return DestinationInternalAddress.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<DestinationInternalAddress>): DestinationInternalAddress {
    const message = createBaseDestinationInternalAddress();
    message.id = object.id ?? 0;
    message.address = object.address ?? "";
    message.label = object.label ?? "";
    message.path = object.path ?? "";
    return message;
  },
};

function createBaseDestinationExternalAddress(): DestinationExternalAddress {
  return { id: 0, address: "", label: "", memo: "" };
}

export const DestinationExternalAddress = {
  encode(message: DestinationExternalAddress, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.id !== 0) {
      writer.uint32(8).uint64(message.id);
    }
    if (message.address !== "") {
      writer.uint32(18).string(message.address);
    }
    if (message.label !== "") {
      writer.uint32(26).string(message.label);
    }
    if (message.memo !== "") {
      writer.uint32(34).string(message.memo);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): DestinationExternalAddress {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseDestinationExternalAddress();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.id = longToNumber(reader.uint64() as Long);
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.address = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.label = reader.string();
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.memo = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): DestinationExternalAddress {
    return {
      id: isSet(object.id) ? globalThis.Number(object.id) : 0,
      address: isSet(object.address) ? globalThis.String(object.address) : "",
      label: isSet(object.label) ? globalThis.String(object.label) : "",
      memo: isSet(object.memo) ? globalThis.String(object.memo) : "",
    };
  },

  toJSON(message: DestinationExternalAddress): unknown {
    const obj: any = {};
    if (message.id !== 0) {
      obj.id = Math.round(message.id);
    }
    if (message.address !== "") {
      obj.address = message.address;
    }
    if (message.label !== "") {
      obj.label = message.label;
    }
    if (message.memo !== "") {
      obj.memo = message.memo;
    }
    return obj;
  },

  create(base?: DeepPartial<DestinationExternalAddress>): DestinationExternalAddress {
    return DestinationExternalAddress.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<DestinationExternalAddress>): DestinationExternalAddress {
    const message = createBaseDestinationExternalAddress();
    message.id = object.id ?? 0;
    message.address = object.address ?? "";
    message.label = object.label ?? "";
    message.memo = object.memo ?? "";
    return message;
  },
};

function createBaseDestinationExchangeAddress(): DestinationExchangeAddress {
  return { id: 0, address: "", label: "", exchangeAccountId: 0, exchangeAccountLabel: "", memo: "" };
}

export const DestinationExchangeAddress = {
  encode(message: DestinationExchangeAddress, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.id !== 0) {
      writer.uint32(8).uint64(message.id);
    }
    if (message.address !== "") {
      writer.uint32(18).string(message.address);
    }
    if (message.label !== "") {
      writer.uint32(26).string(message.label);
    }
    if (message.exchangeAccountId !== 0) {
      writer.uint32(32).uint64(message.exchangeAccountId);
    }
    if (message.exchangeAccountLabel !== "") {
      writer.uint32(42).string(message.exchangeAccountLabel);
    }
    if (message.memo !== "") {
      writer.uint32(50).string(message.memo);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): DestinationExchangeAddress {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseDestinationExchangeAddress();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.id = longToNumber(reader.uint64() as Long);
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.address = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.label = reader.string();
          continue;
        case 4:
          if (tag !== 32) {
            break;
          }

          message.exchangeAccountId = longToNumber(reader.uint64() as Long);
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.exchangeAccountLabel = reader.string();
          continue;
        case 6:
          if (tag !== 50) {
            break;
          }

          message.memo = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): DestinationExchangeAddress {
    return {
      id: isSet(object.id) ? globalThis.Number(object.id) : 0,
      address: isSet(object.address) ? globalThis.String(object.address) : "",
      label: isSet(object.label) ? globalThis.String(object.label) : "",
      exchangeAccountId: isSet(object.exchangeAccountId) ? globalThis.Number(object.exchangeAccountId) : 0,
      exchangeAccountLabel: isSet(object.exchangeAccountLabel) ? globalThis.String(object.exchangeAccountLabel) : "",
      memo: isSet(object.memo) ? globalThis.String(object.memo) : "",
    };
  },

  toJSON(message: DestinationExchangeAddress): unknown {
    const obj: any = {};
    if (message.id !== 0) {
      obj.id = Math.round(message.id);
    }
    if (message.address !== "") {
      obj.address = message.address;
    }
    if (message.label !== "") {
      obj.label = message.label;
    }
    if (message.exchangeAccountId !== 0) {
      obj.exchangeAccountId = Math.round(message.exchangeAccountId);
    }
    if (message.exchangeAccountLabel !== "") {
      obj.exchangeAccountLabel = message.exchangeAccountLabel;
    }
    if (message.memo !== "") {
      obj.memo = message.memo;
    }
    return obj;
  },

  create(base?: DeepPartial<DestinationExchangeAddress>): DestinationExchangeAddress {
    return DestinationExchangeAddress.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<DestinationExchangeAddress>): DestinationExchangeAddress {
    const message = createBaseDestinationExchangeAddress();
    message.id = object.id ?? 0;
    message.address = object.address ?? "";
    message.label = object.label ?? "";
    message.exchangeAccountId = object.exchangeAccountId ?? 0;
    message.exchangeAccountLabel = object.exchangeAccountLabel ?? "";
    message.memo = object.memo ?? "";
    return message;
  },
};

function createBaseDestinationFiatProviderAccount(): DestinationFiatProviderAccount {
  return { id: "", label: "", accountType: "", isCounterparty: false };
}

export const DestinationFiatProviderAccount = {
  encode(message: DestinationFiatProviderAccount, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.id !== "") {
      writer.uint32(10).string(message.id);
    }
    if (message.label !== "") {
      writer.uint32(18).string(message.label);
    }
    if (message.accountType !== "") {
      writer.uint32(26).string(message.accountType);
    }
    if (message.isCounterparty !== false) {
      writer.uint32(32).bool(message.isCounterparty);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): DestinationFiatProviderAccount {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseDestinationFiatProviderAccount();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.id = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.label = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.accountType = reader.string();
          continue;
        case 4:
          if (tag !== 32) {
            break;
          }

          message.isCounterparty = reader.bool();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): DestinationFiatProviderAccount {
    return {
      id: isSet(object.id) ? globalThis.String(object.id) : "",
      label: isSet(object.label) ? globalThis.String(object.label) : "",
      accountType: isSet(object.accountType) ? globalThis.String(object.accountType) : "",
      isCounterparty: isSet(object.isCounterparty) ? globalThis.Boolean(object.isCounterparty) : false,
    };
  },

  toJSON(message: DestinationFiatProviderAccount): unknown {
    const obj: any = {};
    if (message.id !== "") {
      obj.id = message.id;
    }
    if (message.label !== "") {
      obj.label = message.label;
    }
    if (message.accountType !== "") {
      obj.accountType = message.accountType;
    }
    if (message.isCounterparty !== false) {
      obj.isCounterparty = message.isCounterparty;
    }
    return obj;
  },

  create(base?: DeepPartial<DestinationFiatProviderAccount>): DestinationFiatProviderAccount {
    return DestinationFiatProviderAccount.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<DestinationFiatProviderAccount>): DestinationFiatProviderAccount {
    const message = createBaseDestinationFiatProviderAccount();
    message.id = object.id ?? "";
    message.label = object.label ?? "";
    message.accountType = object.accountType ?? "";
    message.isCounterparty = object.isCounterparty ?? false;
    return message;
  },
};

function createBaseDestinationContractAddress(): DestinationContractAddress {
  return { id: 0, address: "", name: "", symbol: "", blockchain: 0 };
}

export const DestinationContractAddress = {
  encode(message: DestinationContractAddress, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.id !== 0) {
      writer.uint32(8).uint64(message.id);
    }
    if (message.address !== "") {
      writer.uint32(18).string(message.address);
    }
    if (message.name !== "") {
      writer.uint32(26).string(message.name);
    }
    if (message.symbol !== "") {
      writer.uint32(34).string(message.symbol);
    }
    if (message.blockchain !== 0) {
      writer.uint32(40).int32(message.blockchain);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): DestinationContractAddress {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseDestinationContractAddress();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.id = longToNumber(reader.uint64() as Long);
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.address = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.name = reader.string();
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.symbol = reader.string();
          continue;
        case 5:
          if (tag !== 40) {
            break;
          }

          message.blockchain = reader.int32() as any;
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): DestinationContractAddress {
    return {
      id: isSet(object.id) ? globalThis.Number(object.id) : 0,
      address: isSet(object.address) ? globalThis.String(object.address) : "",
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      symbol: isSet(object.symbol) ? globalThis.String(object.symbol) : "",
      blockchain: isSet(object.blockchain) ? blockchainFromJSON(object.blockchain) : 0,
    };
  },

  toJSON(message: DestinationContractAddress): unknown {
    const obj: any = {};
    if (message.id !== 0) {
      obj.id = Math.round(message.id);
    }
    if (message.address !== "") {
      obj.address = message.address;
    }
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.symbol !== "") {
      obj.symbol = message.symbol;
    }
    if (message.blockchain !== 0) {
      obj.blockchain = blockchainToJSON(message.blockchain);
    }
    return obj;
  },

  create(base?: DeepPartial<DestinationContractAddress>): DestinationContractAddress {
    return DestinationContractAddress.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<DestinationContractAddress>): DestinationContractAddress {
    const message = createBaseDestinationContractAddress();
    message.id = object.id ?? 0;
    message.address = object.address ?? "";
    message.name = object.name ?? "";
    message.symbol = object.symbol ?? "";
    message.blockchain = object.blockchain ?? 0;
    return message;
  },
};

function createBaseDestination(): Destination {
  return { type: 0, payload: new Uint8Array(0) };
}

export const Destination = {
  encode(message: Destination, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.type !== 0) {
      writer.uint32(8).int32(message.type);
    }
    if (message.payload.length !== 0) {
      writer.uint32(18).bytes(message.payload);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): Destination {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseDestination();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.type = reader.int32() as any;
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.payload = reader.bytes();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Destination {
    return {
      type: isSet(object.type) ? destination_DestinationTypeFromJSON(object.type) : 0,
      payload: isSet(object.payload) ? bytesFromBase64(object.payload) : new Uint8Array(0),
    };
  },

  toJSON(message: Destination): unknown {
    const obj: any = {};
    if (message.type !== 0) {
      obj.type = destination_DestinationTypeToJSON(message.type);
    }
    if (message.payload.length !== 0) {
      obj.payload = base64FromBytes(message.payload);
    }
    return obj;
  },

  create(base?: DeepPartial<Destination>): Destination {
    return Destination.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<Destination>): Destination {
    const message = createBaseDestination();
    message.type = object.type ?? 0;
    message.payload = object.payload ?? new Uint8Array(0);
    return message;
  },
};

function createBaseWhitelistedContractAddressArray(): WhitelistedContractAddressArray {
  return { addresses: [] };
}

export const WhitelistedContractAddressArray = {
  encode(message: WhitelistedContractAddressArray, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    for (const v of message.addresses) {
      DestinationContractAddress.encode(v!, writer.uint32(10).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): WhitelistedContractAddressArray {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseWhitelistedContractAddressArray();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.addresses.push(DestinationContractAddress.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): WhitelistedContractAddressArray {
    return {
      addresses: globalThis.Array.isArray(object?.addresses)
        ? object.addresses.map((e: any) => DestinationContractAddress.fromJSON(e))
        : [],
    };
  },

  toJSON(message: WhitelistedContractAddressArray): unknown {
    const obj: any = {};
    if (message.addresses?.length) {
      obj.addresses = message.addresses.map((e) => DestinationContractAddress.toJSON(e));
    }
    return obj;
  },

  create(base?: DeepPartial<WhitelistedContractAddressArray>): WhitelistedContractAddressArray {
    return WhitelistedContractAddressArray.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<WhitelistedContractAddressArray>): WhitelistedContractAddressArray {
    const message = createBaseWhitelistedContractAddressArray();
    message.addresses = object.addresses?.map((e) => DestinationContractAddress.fromPartial(e)) || [];
    return message;
  },
};

function createBaseRequestMetadata(): RequestMetadata {
  return { key: "", type: 0, value: new Uint8Array(0), column: "", DeprecatedSecondaryCommit: false };
}

export const RequestMetadata = {
  encode(message: RequestMetadata, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.key !== "") {
      writer.uint32(10).string(message.key);
    }
    if (message.type !== 0) {
      writer.uint32(16).int32(message.type);
    }
    if (message.value.length !== 0) {
      writer.uint32(26).bytes(message.value);
    }
    if (message.column !== "") {
      writer.uint32(34).string(message.column);
    }
    if (message.DeprecatedSecondaryCommit !== false) {
      writer.uint32(40).bool(message.DeprecatedSecondaryCommit);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): RequestMetadata {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseRequestMetadata();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.key = reader.string();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.type = reader.int32() as any;
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.value = reader.bytes();
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.column = reader.string();
          continue;
        case 5:
          if (tag !== 40) {
            break;
          }

          message.DeprecatedSecondaryCommit = reader.bool();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): RequestMetadata {
    return {
      key: isSet(object.key) ? globalThis.String(object.key) : "",
      type: isSet(object.type) ? requestMetadata_MetadataTypeFromJSON(object.type) : 0,
      value: isSet(object.value) ? bytesFromBase64(object.value) : new Uint8Array(0),
      column: isSet(object.column) ? globalThis.String(object.column) : "",
      DeprecatedSecondaryCommit: isSet(object.DeprecatedSecondaryCommit)
        ? globalThis.Boolean(object.DeprecatedSecondaryCommit)
        : false,
    };
  },

  toJSON(message: RequestMetadata): unknown {
    const obj: any = {};
    if (message.key !== "") {
      obj.key = message.key;
    }
    if (message.type !== 0) {
      obj.type = requestMetadata_MetadataTypeToJSON(message.type);
    }
    if (message.value.length !== 0) {
      obj.value = base64FromBytes(message.value);
    }
    if (message.column !== "") {
      obj.column = message.column;
    }
    if (message.DeprecatedSecondaryCommit !== false) {
      obj.DeprecatedSecondaryCommit = message.DeprecatedSecondaryCommit;
    }
    return obj;
  },

  create(base?: DeepPartial<RequestMetadata>): RequestMetadata {
    return RequestMetadata.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<RequestMetadata>): RequestMetadata {
    const message = createBaseRequestMetadata();
    message.key = object.key ?? "";
    message.type = object.type ?? 0;
    message.value = object.value ?? new Uint8Array(0);
    message.column = object.column ?? "";
    message.DeprecatedSecondaryCommit = object.DeprecatedSecondaryCommit ?? false;
    return message;
  },
};

function createBaseRequestMetadata_ArrayElems(): RequestMetadata_ArrayElems {
  return { type: 0, value: [] };
}

export const RequestMetadata_ArrayElems = {
  encode(message: RequestMetadata_ArrayElems, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.type !== 0) {
      writer.uint32(8).int32(message.type);
    }
    for (const v of message.value) {
      writer.uint32(18).bytes(v!);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): RequestMetadata_ArrayElems {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseRequestMetadata_ArrayElems();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.type = reader.int32() as any;
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.value.push(reader.bytes());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): RequestMetadata_ArrayElems {
    return {
      type: isSet(object.type) ? requestMetadata_MetadataTypeFromJSON(object.type) : 0,
      value: globalThis.Array.isArray(object?.value) ? object.value.map((e: any) => bytesFromBase64(e)) : [],
    };
  },

  toJSON(message: RequestMetadata_ArrayElems): unknown {
    const obj: any = {};
    if (message.type !== 0) {
      obj.type = requestMetadata_MetadataTypeToJSON(message.type);
    }
    if (message.value?.length) {
      obj.value = message.value.map((e) => base64FromBytes(e));
    }
    return obj;
  },

  create(base?: DeepPartial<RequestMetadata_ArrayElems>): RequestMetadata_ArrayElems {
    return RequestMetadata_ArrayElems.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<RequestMetadata_ArrayElems>): RequestMetadata_ArrayElems {
    const message = createBaseRequestMetadata_ArrayElems();
    message.type = object.type ?? 0;
    message.value = object.value?.map((e) => e) || [];
    return message;
  },
};

function createBaseRequestMetadata_TupleElems(): RequestMetadata_TupleElems {
  return { elems: [] };
}

export const RequestMetadata_TupleElems = {
  encode(message: RequestMetadata_TupleElems, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    for (const v of message.elems) {
      RequestMetadata_TupleElems_Elem.encode(v!, writer.uint32(10).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): RequestMetadata_TupleElems {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseRequestMetadata_TupleElems();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.elems.push(RequestMetadata_TupleElems_Elem.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): RequestMetadata_TupleElems {
    return {
      elems: globalThis.Array.isArray(object?.elems)
        ? object.elems.map((e: any) => RequestMetadata_TupleElems_Elem.fromJSON(e))
        : [],
    };
  },

  toJSON(message: RequestMetadata_TupleElems): unknown {
    const obj: any = {};
    if (message.elems?.length) {
      obj.elems = message.elems.map((e) => RequestMetadata_TupleElems_Elem.toJSON(e));
    }
    return obj;
  },

  create(base?: DeepPartial<RequestMetadata_TupleElems>): RequestMetadata_TupleElems {
    return RequestMetadata_TupleElems.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<RequestMetadata_TupleElems>): RequestMetadata_TupleElems {
    const message = createBaseRequestMetadata_TupleElems();
    message.elems = object.elems?.map((e) => RequestMetadata_TupleElems_Elem.fromPartial(e)) || [];
    return message;
  },
};

function createBaseRequestMetadata_TupleElems_Elem(): RequestMetadata_TupleElems_Elem {
  return { type: 0, value: new Uint8Array(0) };
}

export const RequestMetadata_TupleElems_Elem = {
  encode(message: RequestMetadata_TupleElems_Elem, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.type !== 0) {
      writer.uint32(8).int32(message.type);
    }
    if (message.value.length !== 0) {
      writer.uint32(18).bytes(message.value);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): RequestMetadata_TupleElems_Elem {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseRequestMetadata_TupleElems_Elem();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.type = reader.int32() as any;
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.value = reader.bytes();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): RequestMetadata_TupleElems_Elem {
    return {
      type: isSet(object.type) ? requestMetadata_MetadataTypeFromJSON(object.type) : 0,
      value: isSet(object.value) ? bytesFromBase64(object.value) : new Uint8Array(0),
    };
  },

  toJSON(message: RequestMetadata_TupleElems_Elem): unknown {
    const obj: any = {};
    if (message.type !== 0) {
      obj.type = requestMetadata_MetadataTypeToJSON(message.type);
    }
    if (message.value.length !== 0) {
      obj.value = base64FromBytes(message.value);
    }
    return obj;
  },

  create(base?: DeepPartial<RequestMetadata_TupleElems_Elem>): RequestMetadata_TupleElems_Elem {
    return RequestMetadata_TupleElems_Elem.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<RequestMetadata_TupleElems_Elem>): RequestMetadata_TupleElems_Elem {
    const message = createBaseRequestMetadata_TupleElems_Elem();
    message.type = object.type ?? 0;
    message.value = object.value ?? new Uint8Array(0);
    return message;
  },
};

function createBaseRequestMetadata_XOperation(): RequestMetadata_XOperation {
  return { operation: "", arguments: [] };
}

export const RequestMetadata_XOperation = {
  encode(message: RequestMetadata_XOperation, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.operation !== "") {
      writer.uint32(10).string(message.operation);
    }
    for (const v of message.arguments) {
      RequestMetadata_XOperation_Arg.encode(v!, writer.uint32(18).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): RequestMetadata_XOperation {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseRequestMetadata_XOperation();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.operation = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.arguments.push(RequestMetadata_XOperation_Arg.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): RequestMetadata_XOperation {
    return {
      operation: isSet(object.operation) ? globalThis.String(object.operation) : "",
      arguments: globalThis.Array.isArray(object?.arguments)
        ? object.arguments.map((e: any) => RequestMetadata_XOperation_Arg.fromJSON(e))
        : [],
    };
  },

  toJSON(message: RequestMetadata_XOperation): unknown {
    const obj: any = {};
    if (message.operation !== "") {
      obj.operation = message.operation;
    }
    if (message.arguments?.length) {
      obj.arguments = message.arguments.map((e) => RequestMetadata_XOperation_Arg.toJSON(e));
    }
    return obj;
  },

  create(base?: DeepPartial<RequestMetadata_XOperation>): RequestMetadata_XOperation {
    return RequestMetadata_XOperation.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<RequestMetadata_XOperation>): RequestMetadata_XOperation {
    const message = createBaseRequestMetadata_XOperation();
    message.operation = object.operation ?? "";
    message.arguments = object.arguments?.map((e) => RequestMetadata_XOperation_Arg.fromPartial(e)) || [];
    return message;
  },
};

function createBaseRequestMetadata_XOperation_Arg(): RequestMetadata_XOperation_Arg {
  return { type: 0, value: new Uint8Array(0) };
}

export const RequestMetadata_XOperation_Arg = {
  encode(message: RequestMetadata_XOperation_Arg, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.type !== 0) {
      writer.uint32(8).int32(message.type);
    }
    if (message.value.length !== 0) {
      writer.uint32(18).bytes(message.value);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): RequestMetadata_XOperation_Arg {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseRequestMetadata_XOperation_Arg();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.type = reader.int32() as any;
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.value = reader.bytes();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): RequestMetadata_XOperation_Arg {
    return {
      type: isSet(object.type) ? requestMetadata_MetadataTypeFromJSON(object.type) : 0,
      value: isSet(object.value) ? bytesFromBase64(object.value) : new Uint8Array(0),
    };
  },

  toJSON(message: RequestMetadata_XOperation_Arg): unknown {
    const obj: any = {};
    if (message.type !== 0) {
      obj.type = requestMetadata_MetadataTypeToJSON(message.type);
    }
    if (message.value.length !== 0) {
      obj.value = base64FromBytes(message.value);
    }
    return obj;
  },

  create(base?: DeepPartial<RequestMetadata_XOperation_Arg>): RequestMetadata_XOperation_Arg {
    return RequestMetadata_XOperation_Arg.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<RequestMetadata_XOperation_Arg>): RequestMetadata_XOperation_Arg {
    const message = createBaseRequestMetadata_XOperation_Arg();
    message.type = object.type ?? 0;
    message.value = object.value ?? new Uint8Array(0);
    return message;
  },
};

function createBaseSignedBigInt(): SignedBigInt {
  return { negative: false, payload: new Uint8Array(0) };
}

export const SignedBigInt = {
  encode(message: SignedBigInt, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.negative !== false) {
      writer.uint32(8).bool(message.negative);
    }
    if (message.payload.length !== 0) {
      writer.uint32(18).bytes(message.payload);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): SignedBigInt {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSignedBigInt();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.negative = reader.bool();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.payload = reader.bytes();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): SignedBigInt {
    return {
      negative: isSet(object.negative) ? globalThis.Boolean(object.negative) : false,
      payload: isSet(object.payload) ? bytesFromBase64(object.payload) : new Uint8Array(0),
    };
  },

  toJSON(message: SignedBigInt): unknown {
    const obj: any = {};
    if (message.negative !== false) {
      obj.negative = message.negative;
    }
    if (message.payload.length !== 0) {
      obj.payload = base64FromBytes(message.payload);
    }
    return obj;
  },

  create(base?: DeepPartial<SignedBigInt>): SignedBigInt {
    return SignedBigInt.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<SignedBigInt>): SignedBigInt {
    const message = createBaseSignedBigInt();
    message.negative = object.negative ?? false;
    message.payload = object.payload ?? new Uint8Array(0);
    return message;
  },
};

function createBaseBytesArray(): BytesArray {
  return { payload: [] };
}

export const BytesArray = {
  encode(message: BytesArray, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    for (const v of message.payload) {
      writer.uint32(10).bytes(v!);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): BytesArray {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseBytesArray();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.payload.push(reader.bytes());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): BytesArray {
    return {
      payload: globalThis.Array.isArray(object?.payload) ? object.payload.map((e: any) => bytesFromBase64(e)) : [],
    };
  },

  toJSON(message: BytesArray): unknown {
    const obj: any = {};
    if (message.payload?.length) {
      obj.payload = message.payload.map((e) => base64FromBytes(e));
    }
    return obj;
  },

  create(base?: DeepPartial<BytesArray>): BytesArray {
    return BytesArray.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<BytesArray>): BytesArray {
    const message = createBaseBytesArray();
    message.payload = object.payload?.map((e) => e) || [];
    return message;
  },
};

function createBaseBigIntArray(): BigIntArray {
  return { payload: [] };
}

export const BigIntArray = {
  encode(message: BigIntArray, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    for (const v of message.payload) {
      writer.uint32(10).bytes(v!);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): BigIntArray {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseBigIntArray();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.payload.push(reader.bytes());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): BigIntArray {
    return {
      payload: globalThis.Array.isArray(object?.payload) ? object.payload.map((e: any) => bytesFromBase64(e)) : [],
    };
  },

  toJSON(message: BigIntArray): unknown {
    const obj: any = {};
    if (message.payload?.length) {
      obj.payload = message.payload.map((e) => base64FromBytes(e));
    }
    return obj;
  },

  create(base?: DeepPartial<BigIntArray>): BigIntArray {
    return BigIntArray.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<BigIntArray>): BigIntArray {
    const message = createBaseBigIntArray();
    message.payload = object.payload?.map((e) => e) || [];
    return message;
  },
};

function createBaseStringArray(): StringArray {
  return { payload: [] };
}

export const StringArray = {
  encode(message: StringArray, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    for (const v of message.payload) {
      writer.uint32(10).string(v!);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): StringArray {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseStringArray();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.payload.push(reader.string());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): StringArray {
    return {
      payload: globalThis.Array.isArray(object?.payload) ? object.payload.map((e: any) => globalThis.String(e)) : [],
    };
  },

  toJSON(message: StringArray): unknown {
    const obj: any = {};
    if (message.payload?.length) {
      obj.payload = message.payload;
    }
    return obj;
  },

  create(base?: DeepPartial<StringArray>): StringArray {
    return StringArray.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<StringArray>): StringArray {
    const message = createBaseStringArray();
    message.payload = object.payload?.map((e) => e) || [];
    return message;
  },
};

function createBaseAmount(): Amount {
  return {
    valueFrom: new Uint8Array(0),
    valueTo: "",
    rate: "",
    decimals: 0,
    currencyFrom: "",
    currencyTo: "",
    signatures: [],
  };
}

export const Amount = {
  encode(message: Amount, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.valueFrom.length !== 0) {
      writer.uint32(10).bytes(message.valueFrom);
    }
    if (message.valueTo !== "") {
      writer.uint32(18).string(message.valueTo);
    }
    if (message.rate !== "") {
      writer.uint32(26).string(message.rate);
    }
    if (message.decimals !== 0) {
      writer.uint32(32).uint32(message.decimals);
    }
    if (message.currencyFrom !== "") {
      writer.uint32(42).string(message.currencyFrom);
    }
    if (message.currencyTo !== "") {
      writer.uint32(50).string(message.currencyTo);
    }
    for (const v of message.signatures) {
      UserSignature.encode(v!, writer.uint32(58).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): Amount {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseAmount();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.valueFrom = reader.bytes();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.valueTo = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.rate = reader.string();
          continue;
        case 4:
          if (tag !== 32) {
            break;
          }

          message.decimals = reader.uint32();
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.currencyFrom = reader.string();
          continue;
        case 6:
          if (tag !== 50) {
            break;
          }

          message.currencyTo = reader.string();
          continue;
        case 7:
          if (tag !== 58) {
            break;
          }

          message.signatures.push(UserSignature.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Amount {
    return {
      valueFrom: isSet(object.valueFrom) ? bytesFromBase64(object.valueFrom) : new Uint8Array(0),
      valueTo: isSet(object.valueTo) ? globalThis.String(object.valueTo) : "",
      rate: isSet(object.rate) ? globalThis.String(object.rate) : "",
      decimals: isSet(object.decimals) ? globalThis.Number(object.decimals) : 0,
      currencyFrom: isSet(object.currencyFrom) ? globalThis.String(object.currencyFrom) : "",
      currencyTo: isSet(object.currencyTo) ? globalThis.String(object.currencyTo) : "",
      signatures: globalThis.Array.isArray(object?.signatures)
        ? object.signatures.map((e: any) => UserSignature.fromJSON(e))
        : [],
    };
  },

  toJSON(message: Amount): unknown {
    const obj: any = {};
    if (message.valueFrom.length !== 0) {
      obj.valueFrom = base64FromBytes(message.valueFrom);
    }
    if (message.valueTo !== "") {
      obj.valueTo = message.valueTo;
    }
    if (message.rate !== "") {
      obj.rate = message.rate;
    }
    if (message.decimals !== 0) {
      obj.decimals = Math.round(message.decimals);
    }
    if (message.currencyFrom !== "") {
      obj.currencyFrom = message.currencyFrom;
    }
    if (message.currencyTo !== "") {
      obj.currencyTo = message.currencyTo;
    }
    if (message.signatures?.length) {
      obj.signatures = message.signatures.map((e) => UserSignature.toJSON(e));
    }
    return obj;
  },

  create(base?: DeepPartial<Amount>): Amount {
    return Amount.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<Amount>): Amount {
    const message = createBaseAmount();
    message.valueFrom = object.valueFrom ?? new Uint8Array(0);
    message.valueTo = object.valueTo ?? "";
    message.rate = object.rate ?? "";
    message.decimals = object.decimals ?? 0;
    message.currencyFrom = object.currencyFrom ?? "";
    message.currencyTo = object.currencyTo ?? "";
    message.signatures = object.signatures?.map((e) => UserSignature.fromPartial(e)) || [];
    return message;
  },
};

function createBaseUserSignatures(): UserSignatures {
  return { signatures: [] };
}

export const UserSignatures = {
  encode(message: UserSignatures, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    for (const v of message.signatures) {
      UserSignature.encode(v!, writer.uint32(10).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): UserSignatures {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseUserSignatures();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.signatures.push(UserSignature.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): UserSignatures {
    return {
      signatures: globalThis.Array.isArray(object?.signatures)
        ? object.signatures.map((e: any) => UserSignature.fromJSON(e))
        : [],
    };
  },

  toJSON(message: UserSignatures): unknown {
    const obj: any = {};
    if (message.signatures?.length) {
      obj.signatures = message.signatures.map((e) => UserSignature.toJSON(e));
    }
    return obj;
  },

  create(base?: DeepPartial<UserSignatures>): UserSignatures {
    return UserSignatures.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<UserSignatures>): UserSignatures {
    const message = createBaseUserSignatures();
    message.signatures = object.signatures?.map((e) => UserSignature.fromPartial(e)) || [];
    return message;
  },
};

function createBaseUserSignature(): UserSignature {
  return { userId: "", signature: new Uint8Array(0), comment: "" };
}

export const UserSignature = {
  encode(message: UserSignature, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.userId !== "") {
      writer.uint32(10).string(message.userId);
    }
    if (message.signature.length !== 0) {
      writer.uint32(18).bytes(message.signature);
    }
    if (message.comment !== "") {
      writer.uint32(26).string(message.comment);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): UserSignature {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseUserSignature();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.userId = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.signature = reader.bytes();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.comment = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): UserSignature {
    return {
      userId: isSet(object.userId) ? globalThis.String(object.userId) : "",
      signature: isSet(object.signature) ? bytesFromBase64(object.signature) : new Uint8Array(0),
      comment: isSet(object.comment) ? globalThis.String(object.comment) : "",
    };
  },

  toJSON(message: UserSignature): unknown {
    const obj: any = {};
    if (message.userId !== "") {
      obj.userId = message.userId;
    }
    if (message.signature.length !== 0) {
      obj.signature = base64FromBytes(message.signature);
    }
    if (message.comment !== "") {
      obj.comment = message.comment;
    }
    return obj;
  },

  create(base?: DeepPartial<UserSignature>): UserSignature {
    return UserSignature.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<UserSignature>): UserSignature {
    const message = createBaseUserSignature();
    message.userId = object.userId ?? "";
    message.signature = object.signature ?? new Uint8Array(0);
    message.comment = object.comment ?? "";
    return message;
  },
};

function createBaseSignedRequestsEnvelope(): SignedRequestsEnvelope {
  return {
    id: "",
    payloadSignature: undefined,
    payload: new Uint8Array(0),
    encryptedPayload: undefined,
    enableTracing: false,
  };
}

export const SignedRequestsEnvelope = {
  encode(message: SignedRequestsEnvelope, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.id !== "") {
      writer.uint32(10).string(message.id);
    }
    if (message.payloadSignature !== undefined) {
      UserSignature.encode(message.payloadSignature, writer.uint32(18).fork()).ldelim();
    }
    if (message.payload.length !== 0) {
      writer.uint32(26).bytes(message.payload);
    }
    if (message.encryptedPayload !== undefined) {
      EncryptedSignedRequestsEnvelope.encode(message.encryptedPayload, writer.uint32(8002).fork()).ldelim();
    }
    if (message.enableTracing !== false) {
      writer.uint32(8008).bool(message.enableTracing);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): SignedRequestsEnvelope {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSignedRequestsEnvelope();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.id = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.payloadSignature = UserSignature.decode(reader, reader.uint32());
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.payload = reader.bytes();
          continue;
        case 1000:
          if (tag !== 8002) {
            break;
          }

          message.encryptedPayload = EncryptedSignedRequestsEnvelope.decode(reader, reader.uint32());
          continue;
        case 1001:
          if (tag !== 8008) {
            break;
          }

          message.enableTracing = reader.bool();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): SignedRequestsEnvelope {
    return {
      id: isSet(object.id) ? globalThis.String(object.id) : "",
      payloadSignature: isSet(object.payloadSignature) ? UserSignature.fromJSON(object.payloadSignature) : undefined,
      payload: isSet(object.payload) ? bytesFromBase64(object.payload) : new Uint8Array(0),
      encryptedPayload: isSet(object.encryptedPayload)
        ? EncryptedSignedRequestsEnvelope.fromJSON(object.encryptedPayload)
        : undefined,
      enableTracing: isSet(object.enableTracing) ? globalThis.Boolean(object.enableTracing) : false,
    };
  },

  toJSON(message: SignedRequestsEnvelope): unknown {
    const obj: any = {};
    if (message.id !== "") {
      obj.id = message.id;
    }
    if (message.payloadSignature !== undefined) {
      obj.payloadSignature = UserSignature.toJSON(message.payloadSignature);
    }
    if (message.payload.length !== 0) {
      obj.payload = base64FromBytes(message.payload);
    }
    if (message.encryptedPayload !== undefined) {
      obj.encryptedPayload = EncryptedSignedRequestsEnvelope.toJSON(message.encryptedPayload);
    }
    if (message.enableTracing !== false) {
      obj.enableTracing = message.enableTracing;
    }
    return obj;
  },

  create(base?: DeepPartial<SignedRequestsEnvelope>): SignedRequestsEnvelope {
    return SignedRequestsEnvelope.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<SignedRequestsEnvelope>): SignedRequestsEnvelope {
    const message = createBaseSignedRequestsEnvelope();
    message.id = object.id ?? "";
    message.payloadSignature = (object.payloadSignature !== undefined && object.payloadSignature !== null)
      ? UserSignature.fromPartial(object.payloadSignature)
      : undefined;
    message.payload = object.payload ?? new Uint8Array(0);
    message.encryptedPayload = (object.encryptedPayload !== undefined && object.encryptedPayload !== null)
      ? EncryptedSignedRequestsEnvelope.fromPartial(object.encryptedPayload)
      : undefined;
    message.enableTracing = object.enableTracing ?? false;
    return message;
  },
};

function createBaseEncryptedSignedRequestsEnvelope(): EncryptedSignedRequestsEnvelope {
  return {
    tenant: 0,
    iv: new Uint8Array(0),
    ciphertext: new Uint8Array(0),
    ecPoint: new Uint8Array(0),
    mac: new Uint8Array(0),
  };
}

export const EncryptedSignedRequestsEnvelope = {
  encode(message: EncryptedSignedRequestsEnvelope, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.tenant !== 0) {
      writer.uint32(8).uint32(message.tenant);
    }
    if (message.iv.length !== 0) {
      writer.uint32(18).bytes(message.iv);
    }
    if (message.ciphertext.length !== 0) {
      writer.uint32(26).bytes(message.ciphertext);
    }
    if (message.ecPoint.length !== 0) {
      writer.uint32(34).bytes(message.ecPoint);
    }
    if (message.mac.length !== 0) {
      writer.uint32(42).bytes(message.mac);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): EncryptedSignedRequestsEnvelope {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseEncryptedSignedRequestsEnvelope();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.tenant = reader.uint32();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.iv = reader.bytes();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.ciphertext = reader.bytes();
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.ecPoint = reader.bytes();
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.mac = reader.bytes();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): EncryptedSignedRequestsEnvelope {
    return {
      tenant: isSet(object.tenant) ? globalThis.Number(object.tenant) : 0,
      iv: isSet(object.iv) ? bytesFromBase64(object.iv) : new Uint8Array(0),
      ciphertext: isSet(object.ciphertext) ? bytesFromBase64(object.ciphertext) : new Uint8Array(0),
      ecPoint: isSet(object.ecPoint) ? bytesFromBase64(object.ecPoint) : new Uint8Array(0),
      mac: isSet(object.mac) ? bytesFromBase64(object.mac) : new Uint8Array(0),
    };
  },

  toJSON(message: EncryptedSignedRequestsEnvelope): unknown {
    const obj: any = {};
    if (message.tenant !== 0) {
      obj.tenant = Math.round(message.tenant);
    }
    if (message.iv.length !== 0) {
      obj.iv = base64FromBytes(message.iv);
    }
    if (message.ciphertext.length !== 0) {
      obj.ciphertext = base64FromBytes(message.ciphertext);
    }
    if (message.ecPoint.length !== 0) {
      obj.ecPoint = base64FromBytes(message.ecPoint);
    }
    if (message.mac.length !== 0) {
      obj.mac = base64FromBytes(message.mac);
    }
    return obj;
  },

  create(base?: DeepPartial<EncryptedSignedRequestsEnvelope>): EncryptedSignedRequestsEnvelope {
    return EncryptedSignedRequestsEnvelope.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<EncryptedSignedRequestsEnvelope>): EncryptedSignedRequestsEnvelope {
    const message = createBaseEncryptedSignedRequestsEnvelope();
    message.tenant = object.tenant ?? 0;
    message.iv = object.iv ?? new Uint8Array(0);
    message.ciphertext = object.ciphertext ?? new Uint8Array(0);
    message.ecPoint = object.ecPoint ?? new Uint8Array(0);
    message.mac = object.mac ?? new Uint8Array(0);
    return message;
  },
};

function createBaseRequestsEnvelope(): RequestsEnvelope {
  return { ts: 0, slot: 0, rulesSignatures: [], rules: new Uint8Array(0), requests: [] };
}

export const RequestsEnvelope = {
  encode(message: RequestsEnvelope, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.ts !== 0) {
      writer.uint32(8).uint64(message.ts);
    }
    if (message.slot !== 0) {
      writer.uint32(16).uint32(message.slot);
    }
    for (const v of message.rulesSignatures) {
      UserSignature.encode(v!, writer.uint32(26).fork()).ldelim();
    }
    if (message.rules.length !== 0) {
      writer.uint32(34).bytes(message.rules);
    }
    for (const v of message.requests) {
      RequestEnvelope.encode(v!, writer.uint32(42).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): RequestsEnvelope {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseRequestsEnvelope();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.ts = longToNumber(reader.uint64() as Long);
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.slot = reader.uint32();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.rulesSignatures.push(UserSignature.decode(reader, reader.uint32()));
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.rules = reader.bytes();
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.requests.push(RequestEnvelope.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): RequestsEnvelope {
    return {
      ts: isSet(object.ts) ? globalThis.Number(object.ts) : 0,
      slot: isSet(object.slot) ? globalThis.Number(object.slot) : 0,
      rulesSignatures: globalThis.Array.isArray(object?.rulesSignatures)
        ? object.rulesSignatures.map((e: any) => UserSignature.fromJSON(e))
        : [],
      rules: isSet(object.rules) ? bytesFromBase64(object.rules) : new Uint8Array(0),
      requests: globalThis.Array.isArray(object?.requests)
        ? object.requests.map((e: any) => RequestEnvelope.fromJSON(e))
        : [],
    };
  },

  toJSON(message: RequestsEnvelope): unknown {
    const obj: any = {};
    if (message.ts !== 0) {
      obj.ts = Math.round(message.ts);
    }
    if (message.slot !== 0) {
      obj.slot = Math.round(message.slot);
    }
    if (message.rulesSignatures?.length) {
      obj.rulesSignatures = message.rulesSignatures.map((e) => UserSignature.toJSON(e));
    }
    if (message.rules.length !== 0) {
      obj.rules = base64FromBytes(message.rules);
    }
    if (message.requests?.length) {
      obj.requests = message.requests.map((e) => RequestEnvelope.toJSON(e));
    }
    return obj;
  },

  create(base?: DeepPartial<RequestsEnvelope>): RequestsEnvelope {
    return RequestsEnvelope.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<RequestsEnvelope>): RequestsEnvelope {
    const message = createBaseRequestsEnvelope();
    message.ts = object.ts ?? 0;
    message.slot = object.slot ?? 0;
    message.rulesSignatures = object.rulesSignatures?.map((e) => UserSignature.fromPartial(e)) || [];
    message.rules = object.rules ?? new Uint8Array(0);
    message.requests = object.requests?.map((e) => RequestEnvelope.fromPartial(e)) || [];
    return message;
  },
};

function createBaseRequestEnvelope(): RequestEnvelope {
  return { id: "", ts: 0, blockchain: 0, payloadType: 0, payload: new Uint8Array(0), network: 0, networkId: "" };
}

export const RequestEnvelope = {
  encode(message: RequestEnvelope, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.id !== "") {
      writer.uint32(10).string(message.id);
    }
    if (message.ts !== 0) {
      writer.uint32(16).uint64(message.ts);
    }
    if (message.blockchain !== 0) {
      writer.uint32(24).int32(message.blockchain);
    }
    if (message.payloadType !== 0) {
      writer.uint32(32).int32(message.payloadType);
    }
    if (message.payload.length !== 0) {
      writer.uint32(42).bytes(message.payload);
    }
    if (message.network !== 0) {
      writer.uint32(48).int32(message.network);
    }
    if (message.networkId !== "") {
      writer.uint32(58).string(message.networkId);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): RequestEnvelope {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseRequestEnvelope();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.id = reader.string();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.ts = longToNumber(reader.uint64() as Long);
          continue;
        case 3:
          if (tag !== 24) {
            break;
          }

          message.blockchain = reader.int32() as any;
          continue;
        case 4:
          if (tag !== 32) {
            break;
          }

          message.payloadType = reader.int32() as any;
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.payload = reader.bytes();
          continue;
        case 6:
          if (tag !== 48) {
            break;
          }

          message.network = reader.int32() as any;
          continue;
        case 7:
          if (tag !== 58) {
            break;
          }

          message.networkId = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): RequestEnvelope {
    return {
      id: isSet(object.id) ? globalThis.String(object.id) : "",
      ts: isSet(object.ts) ? globalThis.Number(object.ts) : 0,
      blockchain: isSet(object.blockchain) ? blockchainFromJSON(object.blockchain) : 0,
      payloadType: isSet(object.payloadType) ? requestEnvelope_PayloadTypeFromJSON(object.payloadType) : 0,
      payload: isSet(object.payload) ? bytesFromBase64(object.payload) : new Uint8Array(0),
      network: isSet(object.network) ? requestEnvelope_NetworkFromJSON(object.network) : 0,
      networkId: isSet(object.networkId) ? globalThis.String(object.networkId) : "",
    };
  },

  toJSON(message: RequestEnvelope): unknown {
    const obj: any = {};
    if (message.id !== "") {
      obj.id = message.id;
    }
    if (message.ts !== 0) {
      obj.ts = Math.round(message.ts);
    }
    if (message.blockchain !== 0) {
      obj.blockchain = blockchainToJSON(message.blockchain);
    }
    if (message.payloadType !== 0) {
      obj.payloadType = requestEnvelope_PayloadTypeToJSON(message.payloadType);
    }
    if (message.payload.length !== 0) {
      obj.payload = base64FromBytes(message.payload);
    }
    if (message.network !== 0) {
      obj.network = requestEnvelope_NetworkToJSON(message.network);
    }
    if (message.networkId !== "") {
      obj.networkId = message.networkId;
    }
    return obj;
  },

  create(base?: DeepPartial<RequestEnvelope>): RequestEnvelope {
    return RequestEnvelope.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<RequestEnvelope>): RequestEnvelope {
    const message = createBaseRequestEnvelope();
    message.id = object.id ?? "";
    message.ts = object.ts ?? 0;
    message.blockchain = object.blockchain ?? 0;
    message.payloadType = object.payloadType ?? 0;
    message.payload = object.payload ?? new Uint8Array(0);
    message.network = object.network ?? 0;
    message.networkId = object.networkId ?? "";
    return message;
  },
};

function createBaseRequestSignature(): RequestSignature {
  return { signature: undefined, hashes: [] };
}

export const RequestSignature = {
  encode(message: RequestSignature, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.signature !== undefined) {
      UserSignature.encode(message.signature, writer.uint32(10).fork()).ldelim();
    }
    for (const v of message.hashes) {
      writer.uint32(18).string(v!);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): RequestSignature {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseRequestSignature();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.signature = UserSignature.decode(reader, reader.uint32());
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.hashes.push(reader.string());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): RequestSignature {
    return {
      signature: isSet(object.signature) ? UserSignature.fromJSON(object.signature) : undefined,
      hashes: globalThis.Array.isArray(object?.hashes) ? object.hashes.map((e: any) => globalThis.String(e)) : [],
    };
  },

  toJSON(message: RequestSignature): unknown {
    const obj: any = {};
    if (message.signature !== undefined) {
      obj.signature = UserSignature.toJSON(message.signature);
    }
    if (message.hashes?.length) {
      obj.hashes = message.hashes;
    }
    return obj;
  },

  create(base?: DeepPartial<RequestSignature>): RequestSignature {
    return RequestSignature.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<RequestSignature>): RequestSignature {
    const message = createBaseRequestSignature();
    message.signature = (object.signature !== undefined && object.signature !== null)
      ? UserSignature.fromPartial(object.signature)
      : undefined;
    message.hashes = object.hashes?.map((e) => e) || [];
    return message;
  },
};

function createBaseHMACRequest(): HMACRequest {
  return { type: 0, label: "", payload: new Uint8Array(0), signatures: [], metadata: [] };
}

export const HMACRequest = {
  encode(message: HMACRequest, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.type !== 0) {
      writer.uint32(8).int32(message.type);
    }
    if (message.label !== "") {
      writer.uint32(18).string(message.label);
    }
    if (message.payload.length !== 0) {
      writer.uint32(26).bytes(message.payload);
    }
    for (const v of message.signatures) {
      RequestSignature.encode(v!, writer.uint32(34).fork()).ldelim();
    }
    for (const v of message.metadata) {
      RequestMetadata.encode(v!, writer.uint32(42).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): HMACRequest {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseHMACRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.type = reader.int32() as any;
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.label = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.payload = reader.bytes();
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.signatures.push(RequestSignature.decode(reader, reader.uint32()));
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.metadata.push(RequestMetadata.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): HMACRequest {
    return {
      type: isSet(object.type) ? hMACRequest_HMACTypeFromJSON(object.type) : 0,
      label: isSet(object.label) ? globalThis.String(object.label) : "",
      payload: isSet(object.payload) ? bytesFromBase64(object.payload) : new Uint8Array(0),
      signatures: globalThis.Array.isArray(object?.signatures)
        ? object.signatures.map((e: any) => RequestSignature.fromJSON(e))
        : [],
      metadata: globalThis.Array.isArray(object?.metadata)
        ? object.metadata.map((e: any) => RequestMetadata.fromJSON(e))
        : [],
    };
  },

  toJSON(message: HMACRequest): unknown {
    const obj: any = {};
    if (message.type !== 0) {
      obj.type = hMACRequest_HMACTypeToJSON(message.type);
    }
    if (message.label !== "") {
      obj.label = message.label;
    }
    if (message.payload.length !== 0) {
      obj.payload = base64FromBytes(message.payload);
    }
    if (message.signatures?.length) {
      obj.signatures = message.signatures.map((e) => RequestSignature.toJSON(e));
    }
    if (message.metadata?.length) {
      obj.metadata = message.metadata.map((e) => RequestMetadata.toJSON(e));
    }
    return obj;
  },

  create(base?: DeepPartial<HMACRequest>): HMACRequest {
    return HMACRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<HMACRequest>): HMACRequest {
    const message = createBaseHMACRequest();
    message.type = object.type ?? 0;
    message.label = object.label ?? "";
    message.payload = object.payload ?? new Uint8Array(0);
    message.signatures = object.signatures?.map((e) => RequestSignature.fromPartial(e)) || [];
    message.metadata = object.metadata?.map((e) => RequestMetadata.fromPartial(e)) || [];
    return message;
  },
};

function createBaseNoSignatureNeededRequest(): NoSignatureNeededRequest {
  return { type: 0, signatures: [], metadata: [] };
}

export const NoSignatureNeededRequest = {
  encode(message: NoSignatureNeededRequest, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.type !== 0) {
      writer.uint32(8).int32(message.type);
    }
    for (const v of message.signatures) {
      RequestSignature.encode(v!, writer.uint32(18).fork()).ldelim();
    }
    for (const v of message.metadata) {
      RequestMetadata.encode(v!, writer.uint32(26).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): NoSignatureNeededRequest {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseNoSignatureNeededRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.type = reader.int32() as any;
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.signatures.push(RequestSignature.decode(reader, reader.uint32()));
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.metadata.push(RequestMetadata.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): NoSignatureNeededRequest {
    return {
      type: isSet(object.type) ? noSignatureNeededRequest_RequestTypeFromJSON(object.type) : 0,
      signatures: globalThis.Array.isArray(object?.signatures)
        ? object.signatures.map((e: any) => RequestSignature.fromJSON(e))
        : [],
      metadata: globalThis.Array.isArray(object?.metadata)
        ? object.metadata.map((e: any) => RequestMetadata.fromJSON(e))
        : [],
    };
  },

  toJSON(message: NoSignatureNeededRequest): unknown {
    const obj: any = {};
    if (message.type !== 0) {
      obj.type = noSignatureNeededRequest_RequestTypeToJSON(message.type);
    }
    if (message.signatures?.length) {
      obj.signatures = message.signatures.map((e) => RequestSignature.toJSON(e));
    }
    if (message.metadata?.length) {
      obj.metadata = message.metadata.map((e) => RequestMetadata.toJSON(e));
    }
    return obj;
  },

  create(base?: DeepPartial<NoSignatureNeededRequest>): NoSignatureNeededRequest {
    return NoSignatureNeededRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<NoSignatureNeededRequest>): NoSignatureNeededRequest {
    const message = createBaseNoSignatureNeededRequest();
    message.type = object.type ?? 0;
    message.signatures = object.signatures?.map((e) => RequestSignature.fromPartial(e)) || [];
    message.metadata = object.metadata?.map((e) => RequestMetadata.fromPartial(e)) || [];
    return message;
  },
};

function createBaseCommitment(): Commitment {
  return { kind: 0, commitment: new Uint8Array(0), intent: new Uint8Array(0), signatures: [] };
}

export const Commitment = {
  encode(message: Commitment, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.kind !== 0) {
      writer.uint32(8).int32(message.kind);
    }
    if (message.commitment.length !== 0) {
      writer.uint32(18).bytes(message.commitment);
    }
    if (message.intent.length !== 0) {
      writer.uint32(26).bytes(message.intent);
    }
    for (const v of message.signatures) {
      UserSignature.encode(v!, writer.uint32(34).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): Commitment {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCommitment();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.kind = reader.int32() as any;
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.commitment = reader.bytes();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.intent = reader.bytes();
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.signatures.push(UserSignature.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Commitment {
    return {
      kind: isSet(object.kind) ? commitmentKindFromJSON(object.kind) : 0,
      commitment: isSet(object.commitment) ? bytesFromBase64(object.commitment) : new Uint8Array(0),
      intent: isSet(object.intent) ? bytesFromBase64(object.intent) : new Uint8Array(0),
      signatures: globalThis.Array.isArray(object?.signatures)
        ? object.signatures.map((e: any) => UserSignature.fromJSON(e))
        : [],
    };
  },

  toJSON(message: Commitment): unknown {
    const obj: any = {};
    if (message.kind !== 0) {
      obj.kind = commitmentKindToJSON(message.kind);
    }
    if (message.commitment.length !== 0) {
      obj.commitment = base64FromBytes(message.commitment);
    }
    if (message.intent.length !== 0) {
      obj.intent = base64FromBytes(message.intent);
    }
    if (message.signatures?.length) {
      obj.signatures = message.signatures.map((e) => UserSignature.toJSON(e));
    }
    return obj;
  },

  create(base?: DeepPartial<Commitment>): Commitment {
    return Commitment.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<Commitment>): Commitment {
    const message = createBaseCommitment();
    message.kind = object.kind ?? 0;
    message.commitment = object.commitment ?? new Uint8Array(0);
    message.intent = object.intent ?? new Uint8Array(0);
    message.signatures = object.signatures?.map((e) => UserSignature.fromPartial(e)) || [];
    return message;
  },
};

function createBaseTnPledgeActionRequest(): TnPledgeActionRequest {
  return { action: 0, signatures: [], metadata: [] };
}

export const TnPledgeActionRequest = {
  encode(message: TnPledgeActionRequest, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.action !== 0) {
      writer.uint32(8).int32(message.action);
    }
    for (const v of message.signatures) {
      RequestSignature.encode(v!, writer.uint32(18).fork()).ldelim();
    }
    for (const v of message.metadata) {
      RequestMetadata.encode(v!, writer.uint32(26).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): TnPledgeActionRequest {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseTnPledgeActionRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.action = reader.int32() as any;
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.signatures.push(RequestSignature.decode(reader, reader.uint32()));
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.metadata.push(RequestMetadata.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): TnPledgeActionRequest {
    return {
      action: isSet(object.action) ? tnPledgeActionRequest_PledgeActionFromJSON(object.action) : 0,
      signatures: globalThis.Array.isArray(object?.signatures)
        ? object.signatures.map((e: any) => RequestSignature.fromJSON(e))
        : [],
      metadata: globalThis.Array.isArray(object?.metadata)
        ? object.metadata.map((e: any) => RequestMetadata.fromJSON(e))
        : [],
    };
  },

  toJSON(message: TnPledgeActionRequest): unknown {
    const obj: any = {};
    if (message.action !== 0) {
      obj.action = tnPledgeActionRequest_PledgeActionToJSON(message.action);
    }
    if (message.signatures?.length) {
      obj.signatures = message.signatures.map((e) => RequestSignature.toJSON(e));
    }
    if (message.metadata?.length) {
      obj.metadata = message.metadata.map((e) => RequestMetadata.toJSON(e));
    }
    return obj;
  },

  create(base?: DeepPartial<TnPledgeActionRequest>): TnPledgeActionRequest {
    return TnPledgeActionRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<TnPledgeActionRequest>): TnPledgeActionRequest {
    const message = createBaseTnPledgeActionRequest();
    message.action = object.action ?? 0;
    message.signatures = object.signatures?.map((e) => RequestSignature.fromPartial(e)) || [];
    message.metadata = object.metadata?.map((e) => RequestMetadata.fromPartial(e)) || [];
    return message;
  },
};

function createBaseMonitoringRequest(): MonitoringRequest {
  return {};
}

export const MonitoringRequest = {
  encode(_: MonitoringRequest, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): MonitoringRequest {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMonitoringRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(_: any): MonitoringRequest {
    return {};
  },

  toJSON(_: MonitoringRequest): unknown {
    const obj: any = {};
    return obj;
  },

  create(base?: DeepPartial<MonitoringRequest>): MonitoringRequest {
    return MonitoringRequest.fromPartial(base ?? {});
  },
  fromPartial(_: DeepPartial<MonitoringRequest>): MonitoringRequest {
    const message = createBaseMonitoringRequest();
    return message;
  },
};

function createBaseTransactionRequest(): TransactionRequest {
  return { payloadType: 0, payload: new Uint8Array(0), signatures: [], metadata: [], commitment: undefined };
}

export const TransactionRequest = {
  encode(message: TransactionRequest, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.payloadType !== 0) {
      writer.uint32(8).int32(message.payloadType);
    }
    if (message.payload.length !== 0) {
      writer.uint32(18).bytes(message.payload);
    }
    for (const v of message.signatures) {
      RequestSignature.encode(v!, writer.uint32(26).fork()).ldelim();
    }
    for (const v of message.metadata) {
      RequestMetadata.encode(v!, writer.uint32(34).fork()).ldelim();
    }
    if (message.commitment !== undefined) {
      Commitment.encode(message.commitment, writer.uint32(66).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): TransactionRequest {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseTransactionRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.payloadType = reader.int32() as any;
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.payload = reader.bytes();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.signatures.push(RequestSignature.decode(reader, reader.uint32()));
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.metadata.push(RequestMetadata.decode(reader, reader.uint32()));
          continue;
        case 8:
          if (tag !== 66) {
            break;
          }

          message.commitment = Commitment.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): TransactionRequest {
    return {
      payloadType: isSet(object.payloadType) ? transactionRequest_PayloadTypeFromJSON(object.payloadType) : 0,
      payload: isSet(object.payload) ? bytesFromBase64(object.payload) : new Uint8Array(0),
      signatures: globalThis.Array.isArray(object?.signatures)
        ? object.signatures.map((e: any) => RequestSignature.fromJSON(e))
        : [],
      metadata: globalThis.Array.isArray(object?.metadata)
        ? object.metadata.map((e: any) => RequestMetadata.fromJSON(e))
        : [],
      commitment: isSet(object.commitment) ? Commitment.fromJSON(object.commitment) : undefined,
    };
  },

  toJSON(message: TransactionRequest): unknown {
    const obj: any = {};
    if (message.payloadType !== 0) {
      obj.payloadType = transactionRequest_PayloadTypeToJSON(message.payloadType);
    }
    if (message.payload.length !== 0) {
      obj.payload = base64FromBytes(message.payload);
    }
    if (message.signatures?.length) {
      obj.signatures = message.signatures.map((e) => RequestSignature.toJSON(e));
    }
    if (message.metadata?.length) {
      obj.metadata = message.metadata.map((e) => RequestMetadata.toJSON(e));
    }
    if (message.commitment !== undefined) {
      obj.commitment = Commitment.toJSON(message.commitment);
    }
    return obj;
  },

  create(base?: DeepPartial<TransactionRequest>): TransactionRequest {
    return TransactionRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<TransactionRequest>): TransactionRequest {
    const message = createBaseTransactionRequest();
    message.payloadType = object.payloadType ?? 0;
    message.payload = object.payload ?? new Uint8Array(0);
    message.signatures = object.signatures?.map((e) => RequestSignature.fromPartial(e)) || [];
    message.metadata = object.metadata?.map((e) => RequestMetadata.fromPartial(e)) || [];
    message.commitment = (object.commitment !== undefined && object.commitment !== null)
      ? Commitment.fromPartial(object.commitment)
      : undefined;
    return message;
  },
};

function createBaseBundleTransactionRequest(): BundleTransactionRequest {
  return { id: "", bundle: [], signatures: [] };
}

export const BundleTransactionRequest = {
  encode(message: BundleTransactionRequest, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.id !== "") {
      writer.uint32(10).string(message.id);
    }
    for (const v of message.bundle) {
      TransactionRequest.encode(v!, writer.uint32(18).fork()).ldelim();
    }
    for (const v of message.signatures) {
      RequestSignature.encode(v!, writer.uint32(26).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): BundleTransactionRequest {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseBundleTransactionRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.id = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.bundle.push(TransactionRequest.decode(reader, reader.uint32()));
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.signatures.push(RequestSignature.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): BundleTransactionRequest {
    return {
      id: isSet(object.id) ? globalThis.String(object.id) : "",
      bundle: globalThis.Array.isArray(object?.bundle)
        ? object.bundle.map((e: any) => TransactionRequest.fromJSON(e))
        : [],
      signatures: globalThis.Array.isArray(object?.signatures)
        ? object.signatures.map((e: any) => RequestSignature.fromJSON(e))
        : [],
    };
  },

  toJSON(message: BundleTransactionRequest): unknown {
    const obj: any = {};
    if (message.id !== "") {
      obj.id = message.id;
    }
    if (message.bundle?.length) {
      obj.bundle = message.bundle.map((e) => TransactionRequest.toJSON(e));
    }
    if (message.signatures?.length) {
      obj.signatures = message.signatures.map((e) => RequestSignature.toJSON(e));
    }
    return obj;
  },

  create(base?: DeepPartial<BundleTransactionRequest>): BundleTransactionRequest {
    return BundleTransactionRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<BundleTransactionRequest>): BundleTransactionRequest {
    const message = createBaseBundleTransactionRequest();
    message.id = object.id ?? "";
    message.bundle = object.bundle?.map((e) => TransactionRequest.fromPartial(e)) || [];
    message.signatures = object.signatures?.map((e) => RequestSignature.fromPartial(e)) || [];
    return message;
  },
};

function createBaseAddressResponse(): AddressResponse {
  return { address: "", signature: new Uint8Array(0) };
}

export const AddressResponse = {
  encode(message: AddressResponse, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.address !== "") {
      writer.uint32(10).string(message.address);
    }
    if (message.signature.length !== 0) {
      writer.uint32(18).bytes(message.signature);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): AddressResponse {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseAddressResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.address = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.signature = reader.bytes();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): AddressResponse {
    return {
      address: isSet(object.address) ? globalThis.String(object.address) : "",
      signature: isSet(object.signature) ? bytesFromBase64(object.signature) : new Uint8Array(0),
    };
  },

  toJSON(message: AddressResponse): unknown {
    const obj: any = {};
    if (message.address !== "") {
      obj.address = message.address;
    }
    if (message.signature.length !== 0) {
      obj.signature = base64FromBytes(message.signature);
    }
    return obj;
  },

  create(base?: DeepPartial<AddressResponse>): AddressResponse {
    return AddressResponse.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<AddressResponse>): AddressResponse {
    const message = createBaseAddressResponse();
    message.address = object.address ?? "";
    message.signature = object.signature ?? new Uint8Array(0);
    return message;
  },
};

function createBaseCantonAddressRequest(): CantonAddressRequest {
  return { prefix: "", path: "", forParticipantID: "" };
}

export const CantonAddressRequest = {
  encode(message: CantonAddressRequest, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.prefix !== "") {
      writer.uint32(10).string(message.prefix);
    }
    if (message.path !== "") {
      writer.uint32(18).string(message.path);
    }
    if (message.forParticipantID !== "") {
      writer.uint32(26).string(message.forParticipantID);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CantonAddressRequest {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCantonAddressRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.prefix = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.path = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.forParticipantID = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CantonAddressRequest {
    return {
      prefix: isSet(object.prefix) ? globalThis.String(object.prefix) : "",
      path: isSet(object.path) ? globalThis.String(object.path) : "",
      forParticipantID: isSet(object.forParticipantID) ? globalThis.String(object.forParticipantID) : "",
    };
  },

  toJSON(message: CantonAddressRequest): unknown {
    const obj: any = {};
    if (message.prefix !== "") {
      obj.prefix = message.prefix;
    }
    if (message.path !== "") {
      obj.path = message.path;
    }
    if (message.forParticipantID !== "") {
      obj.forParticipantID = message.forParticipantID;
    }
    return obj;
  },

  create(base?: DeepPartial<CantonAddressRequest>): CantonAddressRequest {
    return CantonAddressRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CantonAddressRequest>): CantonAddressRequest {
    const message = createBaseCantonAddressRequest();
    message.prefix = object.prefix ?? "";
    message.path = object.path ?? "";
    message.forParticipantID = object.forParticipantID ?? "";
    return message;
  },
};

function createBaseCantonAddressResponse(): CantonAddressResponse {
  return { party: "", partySignature: new Uint8Array(0), signedTopologyTransactions: new Uint8Array(0) };
}

export const CantonAddressResponse = {
  encode(message: CantonAddressResponse, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.party !== "") {
      writer.uint32(10).string(message.party);
    }
    if (message.partySignature.length !== 0) {
      writer.uint32(18).bytes(message.partySignature);
    }
    if (message.signedTopologyTransactions.length !== 0) {
      writer.uint32(26).bytes(message.signedTopologyTransactions);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CantonAddressResponse {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCantonAddressResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.party = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.partySignature = reader.bytes();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.signedTopologyTransactions = reader.bytes();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CantonAddressResponse {
    return {
      party: isSet(object.party) ? globalThis.String(object.party) : "",
      partySignature: isSet(object.partySignature) ? bytesFromBase64(object.partySignature) : new Uint8Array(0),
      signedTopologyTransactions: isSet(object.signedTopologyTransactions)
        ? bytesFromBase64(object.signedTopologyTransactions)
        : new Uint8Array(0),
    };
  },

  toJSON(message: CantonAddressResponse): unknown {
    const obj: any = {};
    if (message.party !== "") {
      obj.party = message.party;
    }
    if (message.partySignature.length !== 0) {
      obj.partySignature = base64FromBytes(message.partySignature);
    }
    if (message.signedTopologyTransactions.length !== 0) {
      obj.signedTopologyTransactions = base64FromBytes(message.signedTopologyTransactions);
    }
    return obj;
  },

  create(base?: DeepPartial<CantonAddressResponse>): CantonAddressResponse {
    return CantonAddressResponse.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CantonAddressResponse>): CantonAddressResponse {
    const message = createBaseCantonAddressResponse();
    message.party = object.party ?? "";
    message.partySignature = object.partySignature ?? new Uint8Array(0);
    message.signedTopologyTransactions = object.signedTopologyTransactions ?? new Uint8Array(0);
    return message;
  },
};

function createBaseCantonTransaction(): CantonTransaction {
  return {
    id: "",
    source: "",
    partyPrefix: "",
    preparedSubmission: new Uint8Array(0),
    choiceArguments: new Uint8Array(0),
    commandID: "",
    party: "",
  };
}

export const CantonTransaction = {
  encode(message: CantonTransaction, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.id !== "") {
      writer.uint32(10).string(message.id);
    }
    if (message.source !== "") {
      writer.uint32(18).string(message.source);
    }
    if (message.partyPrefix !== "") {
      writer.uint32(26).string(message.partyPrefix);
    }
    if (message.preparedSubmission.length !== 0) {
      writer.uint32(34).bytes(message.preparedSubmission);
    }
    if (message.choiceArguments.length !== 0) {
      writer.uint32(8002).bytes(message.choiceArguments);
    }
    if (message.commandID !== "") {
      writer.uint32(8010).string(message.commandID);
    }
    if (message.party !== "") {
      writer.uint32(8018).string(message.party);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CantonTransaction {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCantonTransaction();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.id = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.source = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.partyPrefix = reader.string();
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.preparedSubmission = reader.bytes();
          continue;
        case 1000:
          if (tag !== 8002) {
            break;
          }

          message.choiceArguments = reader.bytes();
          continue;
        case 1001:
          if (tag !== 8010) {
            break;
          }

          message.commandID = reader.string();
          continue;
        case 1002:
          if (tag !== 8018) {
            break;
          }

          message.party = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CantonTransaction {
    return {
      id: isSet(object.id) ? globalThis.String(object.id) : "",
      source: isSet(object.source) ? globalThis.String(object.source) : "",
      partyPrefix: isSet(object.partyPrefix) ? globalThis.String(object.partyPrefix) : "",
      preparedSubmission: isSet(object.preparedSubmission)
        ? bytesFromBase64(object.preparedSubmission)
        : new Uint8Array(0),
      choiceArguments: isSet(object.choiceArguments) ? bytesFromBase64(object.choiceArguments) : new Uint8Array(0),
      commandID: isSet(object.commandID) ? globalThis.String(object.commandID) : "",
      party: isSet(object.party) ? globalThis.String(object.party) : "",
    };
  },

  toJSON(message: CantonTransaction): unknown {
    const obj: any = {};
    if (message.id !== "") {
      obj.id = message.id;
    }
    if (message.source !== "") {
      obj.source = message.source;
    }
    if (message.partyPrefix !== "") {
      obj.partyPrefix = message.partyPrefix;
    }
    if (message.preparedSubmission.length !== 0) {
      obj.preparedSubmission = base64FromBytes(message.preparedSubmission);
    }
    if (message.choiceArguments.length !== 0) {
      obj.choiceArguments = base64FromBytes(message.choiceArguments);
    }
    if (message.commandID !== "") {
      obj.commandID = message.commandID;
    }
    if (message.party !== "") {
      obj.party = message.party;
    }
    return obj;
  },

  create(base?: DeepPartial<CantonTransaction>): CantonTransaction {
    return CantonTransaction.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CantonTransaction>): CantonTransaction {
    const message = createBaseCantonTransaction();
    message.id = object.id ?? "";
    message.source = object.source ?? "";
    message.partyPrefix = object.partyPrefix ?? "";
    message.preparedSubmission = object.preparedSubmission ?? new Uint8Array(0);
    message.choiceArguments = object.choiceArguments ?? new Uint8Array(0);
    message.commandID = object.commandID ?? "";
    message.party = object.party ?? "";
    return message;
  },
};

function createBaseCantonTransactionsRequest(): CantonTransactionsRequest {
  return { kind: 0, transactions: [] };
}

export const CantonTransactionsRequest = {
  encode(message: CantonTransactionsRequest, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.kind !== 0) {
      writer.uint32(8).int32(message.kind);
    }
    for (const v of message.transactions) {
      CantonTransaction.encode(v!, writer.uint32(18).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CantonTransactionsRequest {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCantonTransactionsRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.kind = reader.int32() as any;
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.transactions.push(CantonTransaction.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CantonTransactionsRequest {
    return {
      kind: isSet(object.kind) ? cantonTransactionsRequest_CantonOperationKindFromJSON(object.kind) : 0,
      transactions: globalThis.Array.isArray(object?.transactions)
        ? object.transactions.map((e: any) => CantonTransaction.fromJSON(e))
        : [],
    };
  },

  toJSON(message: CantonTransactionsRequest): unknown {
    const obj: any = {};
    if (message.kind !== 0) {
      obj.kind = cantonTransactionsRequest_CantonOperationKindToJSON(message.kind);
    }
    if (message.transactions?.length) {
      obj.transactions = message.transactions.map((e) => CantonTransaction.toJSON(e));
    }
    return obj;
  },

  create(base?: DeepPartial<CantonTransactionsRequest>): CantonTransactionsRequest {
    return CantonTransactionsRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CantonTransactionsRequest>): CantonTransactionsRequest {
    const message = createBaseCantonTransactionsRequest();
    message.kind = object.kind ?? 0;
    message.transactions = object.transactions?.map((e) => CantonTransaction.fromPartial(e)) || [];
    return message;
  },
};

function createBaseCantonProofOfReserveRequest(): CantonProofOfReserveRequest {
  return { path: "", prefix: "", challenge: "" };
}

export const CantonProofOfReserveRequest = {
  encode(message: CantonProofOfReserveRequest, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.path !== "") {
      writer.uint32(10).string(message.path);
    }
    if (message.prefix !== "") {
      writer.uint32(18).string(message.prefix);
    }
    if (message.challenge !== "") {
      writer.uint32(26).string(message.challenge);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CantonProofOfReserveRequest {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCantonProofOfReserveRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.path = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.prefix = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.challenge = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CantonProofOfReserveRequest {
    return {
      path: isSet(object.path) ? globalThis.String(object.path) : "",
      prefix: isSet(object.prefix) ? globalThis.String(object.prefix) : "",
      challenge: isSet(object.challenge) ? globalThis.String(object.challenge) : "",
    };
  },

  toJSON(message: CantonProofOfReserveRequest): unknown {
    const obj: any = {};
    if (message.path !== "") {
      obj.path = message.path;
    }
    if (message.prefix !== "") {
      obj.prefix = message.prefix;
    }
    if (message.challenge !== "") {
      obj.challenge = message.challenge;
    }
    return obj;
  },

  create(base?: DeepPartial<CantonProofOfReserveRequest>): CantonProofOfReserveRequest {
    return CantonProofOfReserveRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CantonProofOfReserveRequest>): CantonProofOfReserveRequest {
    const message = createBaseCantonProofOfReserveRequest();
    message.path = object.path ?? "";
    message.prefix = object.prefix ?? "";
    message.challenge = object.challenge ?? "";
    return message;
  },
};

function createBaseICPAddressResponse(): ICPAddressResponse {
  return { accountIdentifier: "", accountIdentifierSignature: new Uint8Array(0), principal: "", subAccount: "" };
}

export const ICPAddressResponse = {
  encode(message: ICPAddressResponse, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.accountIdentifier !== "") {
      writer.uint32(10).string(message.accountIdentifier);
    }
    if (message.accountIdentifierSignature.length !== 0) {
      writer.uint32(18).bytes(message.accountIdentifierSignature);
    }
    if (message.principal !== "") {
      writer.uint32(26).string(message.principal);
    }
    if (message.subAccount !== "") {
      writer.uint32(34).string(message.subAccount);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): ICPAddressResponse {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseICPAddressResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.accountIdentifier = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.accountIdentifierSignature = reader.bytes();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.principal = reader.string();
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.subAccount = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ICPAddressResponse {
    return {
      accountIdentifier: isSet(object.accountIdentifier) ? globalThis.String(object.accountIdentifier) : "",
      accountIdentifierSignature: isSet(object.accountIdentifierSignature)
        ? bytesFromBase64(object.accountIdentifierSignature)
        : new Uint8Array(0),
      principal: isSet(object.principal) ? globalThis.String(object.principal) : "",
      subAccount: isSet(object.subAccount) ? globalThis.String(object.subAccount) : "",
    };
  },

  toJSON(message: ICPAddressResponse): unknown {
    const obj: any = {};
    if (message.accountIdentifier !== "") {
      obj.accountIdentifier = message.accountIdentifier;
    }
    if (message.accountIdentifierSignature.length !== 0) {
      obj.accountIdentifierSignature = base64FromBytes(message.accountIdentifierSignature);
    }
    if (message.principal !== "") {
      obj.principal = message.principal;
    }
    if (message.subAccount !== "") {
      obj.subAccount = message.subAccount;
    }
    return obj;
  },

  create(base?: DeepPartial<ICPAddressResponse>): ICPAddressResponse {
    return ICPAddressResponse.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ICPAddressResponse>): ICPAddressResponse {
    const message = createBaseICPAddressResponse();
    message.accountIdentifier = object.accountIdentifier ?? "";
    message.accountIdentifierSignature = object.accountIdentifierSignature ?? new Uint8Array(0);
    message.principal = object.principal ?? "";
    message.subAccount = object.subAccount ?? "";
    return message;
  },
};

function createBaseICPProofOfReserveRequest(): ICPProofOfReserveRequest {
  return { path: "", challenge: "" };
}

export const ICPProofOfReserveRequest = {
  encode(message: ICPProofOfReserveRequest, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.path !== "") {
      writer.uint32(10).string(message.path);
    }
    if (message.challenge !== "") {
      writer.uint32(18).string(message.challenge);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): ICPProofOfReserveRequest {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseICPProofOfReserveRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.path = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.challenge = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ICPProofOfReserveRequest {
    return {
      path: isSet(object.path) ? globalThis.String(object.path) : "",
      challenge: isSet(object.challenge) ? globalThis.String(object.challenge) : "",
    };
  },

  toJSON(message: ICPProofOfReserveRequest): unknown {
    const obj: any = {};
    if (message.path !== "") {
      obj.path = message.path;
    }
    if (message.challenge !== "") {
      obj.challenge = message.challenge;
    }
    return obj;
  },

  create(base?: DeepPartial<ICPProofOfReserveRequest>): ICPProofOfReserveRequest {
    return ICPProofOfReserveRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ICPProofOfReserveRequest>): ICPProofOfReserveRequest {
    const message = createBaseICPProofOfReserveRequest();
    message.path = object.path ?? "";
    message.challenge = object.challenge ?? "";
    return message;
  },
};

function createBaseICPAddressRequest(): ICPAddressRequest {
  return { path: "" };
}

export const ICPAddressRequest = {
  encode(message: ICPAddressRequest, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.path !== "") {
      writer.uint32(10).string(message.path);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): ICPAddressRequest {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseICPAddressRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.path = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ICPAddressRequest {
    return { path: isSet(object.path) ? globalThis.String(object.path) : "" };
  },

  toJSON(message: ICPAddressRequest): unknown {
    const obj: any = {};
    if (message.path !== "") {
      obj.path = message.path;
    }
    return obj;
  },

  create(base?: DeepPartial<ICPAddressRequest>): ICPAddressRequest {
    return ICPAddressRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ICPAddressRequest>): ICPAddressRequest {
    const message = createBaseICPAddressRequest();
    message.path = object.path ?? "";
    return message;
  },
};

function createBaseICPRequestsRequest(): ICPRequestsRequest {
  return { requests: [] };
}

export const ICPRequestsRequest = {
  encode(message: ICPRequestsRequest, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    for (const v of message.requests) {
      ICPRequest.encode(v!, writer.uint32(10).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): ICPRequestsRequest {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseICPRequestsRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.requests.push(ICPRequest.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ICPRequestsRequest {
    return {
      requests: globalThis.Array.isArray(object?.requests)
        ? object.requests.map((e: any) => ICPRequest.fromJSON(e))
        : [],
    };
  },

  toJSON(message: ICPRequestsRequest): unknown {
    const obj: any = {};
    if (message.requests?.length) {
      obj.requests = message.requests.map((e) => ICPRequest.toJSON(e));
    }
    return obj;
  },

  create(base?: DeepPartial<ICPRequestsRequest>): ICPRequestsRequest {
    return ICPRequestsRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ICPRequestsRequest>): ICPRequestsRequest {
    const message = createBaseICPRequestsRequest();
    message.requests = object.requests?.map((e) => ICPRequest.fromPartial(e)) || [];
    return message;
  },
};

function createBaseICPRequestsResponse(): ICPRequestsResponse {
  return { requests: [] };
}

export const ICPRequestsResponse = {
  encode(message: ICPRequestsResponse, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    for (const v of message.requests) {
      ICPRequestsResponse_ICPRequestResponse.encode(v!, writer.uint32(10).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): ICPRequestsResponse {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseICPRequestsResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.requests.push(ICPRequestsResponse_ICPRequestResponse.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ICPRequestsResponse {
    return {
      requests: globalThis.Array.isArray(object?.requests)
        ? object.requests.map((e: any) => ICPRequestsResponse_ICPRequestResponse.fromJSON(e))
        : [],
    };
  },

  toJSON(message: ICPRequestsResponse): unknown {
    const obj: any = {};
    if (message.requests?.length) {
      obj.requests = message.requests.map((e) => ICPRequestsResponse_ICPRequestResponse.toJSON(e));
    }
    return obj;
  },

  create(base?: DeepPartial<ICPRequestsResponse>): ICPRequestsResponse {
    return ICPRequestsResponse.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ICPRequestsResponse>): ICPRequestsResponse {
    const message = createBaseICPRequestsResponse();
    message.requests = object.requests?.map((e) => ICPRequestsResponse_ICPRequestResponse.fromPartial(e)) || [];
    return message;
  },
};

function createBaseICPRequestsResponse_ICPRequestResponse(): ICPRequestsResponse_ICPRequestResponse {
  return { id: "", operationRequest: "", statusRequest: "" };
}

export const ICPRequestsResponse_ICPRequestResponse = {
  encode(message: ICPRequestsResponse_ICPRequestResponse, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.id !== "") {
      writer.uint32(10).string(message.id);
    }
    if (message.operationRequest !== "") {
      writer.uint32(18).string(message.operationRequest);
    }
    if (message.statusRequest !== "") {
      writer.uint32(26).string(message.statusRequest);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): ICPRequestsResponse_ICPRequestResponse {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseICPRequestsResponse_ICPRequestResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.id = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.operationRequest = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.statusRequest = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ICPRequestsResponse_ICPRequestResponse {
    return {
      id: isSet(object.id) ? globalThis.String(object.id) : "",
      operationRequest: isSet(object.operationRequest) ? globalThis.String(object.operationRequest) : "",
      statusRequest: isSet(object.statusRequest) ? globalThis.String(object.statusRequest) : "",
    };
  },

  toJSON(message: ICPRequestsResponse_ICPRequestResponse): unknown {
    const obj: any = {};
    if (message.id !== "") {
      obj.id = message.id;
    }
    if (message.operationRequest !== "") {
      obj.operationRequest = message.operationRequest;
    }
    if (message.statusRequest !== "") {
      obj.statusRequest = message.statusRequest;
    }
    return obj;
  },

  create(base?: DeepPartial<ICPRequestsResponse_ICPRequestResponse>): ICPRequestsResponse_ICPRequestResponse {
    return ICPRequestsResponse_ICPRequestResponse.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ICPRequestsResponse_ICPRequestResponse>): ICPRequestsResponse_ICPRequestResponse {
    const message = createBaseICPRequestsResponse_ICPRequestResponse();
    message.id = object.id ?? "";
    message.operationRequest = object.operationRequest ?? "";
    message.statusRequest = object.statusRequest ?? "";
    return message;
  },
};

function createBaseICPTransfer(): ICPTransfer {
  return { from: "", to: "", amount: 0, fee: 0, memo: 0, createdAtTime: 0 };
}

export const ICPTransfer = {
  encode(message: ICPTransfer, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.from !== "") {
      writer.uint32(10).string(message.from);
    }
    if (message.to !== "") {
      writer.uint32(18).string(message.to);
    }
    if (message.amount !== 0) {
      writer.uint32(24).uint64(message.amount);
    }
    if (message.fee !== 0) {
      writer.uint32(32).uint64(message.fee);
    }
    if (message.memo !== 0) {
      writer.uint32(40).uint64(message.memo);
    }
    if (message.createdAtTime !== 0) {
      writer.uint32(48).uint64(message.createdAtTime);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): ICPTransfer {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseICPTransfer();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.from = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.to = reader.string();
          continue;
        case 3:
          if (tag !== 24) {
            break;
          }

          message.amount = longToNumber(reader.uint64() as Long);
          continue;
        case 4:
          if (tag !== 32) {
            break;
          }

          message.fee = longToNumber(reader.uint64() as Long);
          continue;
        case 5:
          if (tag !== 40) {
            break;
          }

          message.memo = longToNumber(reader.uint64() as Long);
          continue;
        case 6:
          if (tag !== 48) {
            break;
          }

          message.createdAtTime = longToNumber(reader.uint64() as Long);
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ICPTransfer {
    return {
      from: isSet(object.from) ? globalThis.String(object.from) : "",
      to: isSet(object.to) ? globalThis.String(object.to) : "",
      amount: isSet(object.amount) ? globalThis.Number(object.amount) : 0,
      fee: isSet(object.fee) ? globalThis.Number(object.fee) : 0,
      memo: isSet(object.memo) ? globalThis.Number(object.memo) : 0,
      createdAtTime: isSet(object.createdAtTime) ? globalThis.Number(object.createdAtTime) : 0,
    };
  },

  toJSON(message: ICPTransfer): unknown {
    const obj: any = {};
    if (message.from !== "") {
      obj.from = message.from;
    }
    if (message.to !== "") {
      obj.to = message.to;
    }
    if (message.amount !== 0) {
      obj.amount = Math.round(message.amount);
    }
    if (message.fee !== 0) {
      obj.fee = Math.round(message.fee);
    }
    if (message.memo !== 0) {
      obj.memo = Math.round(message.memo);
    }
    if (message.createdAtTime !== 0) {
      obj.createdAtTime = Math.round(message.createdAtTime);
    }
    return obj;
  },

  create(base?: DeepPartial<ICPTransfer>): ICPTransfer {
    return ICPTransfer.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ICPTransfer>): ICPTransfer {
    const message = createBaseICPTransfer();
    message.from = object.from ?? "";
    message.to = object.to ?? "";
    message.amount = object.amount ?? 0;
    message.fee = object.fee ?? 0;
    message.memo = object.memo ?? 0;
    message.createdAtTime = object.createdAtTime ?? 0;
    return message;
  },
};

function createBaseICPTransferToStake(): ICPTransferToStake {
  return { from: "", amount: 0, fee: 0, memo: 0, createdAtTime: 0 };
}

export const ICPTransferToStake = {
  encode(message: ICPTransferToStake, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.from !== "") {
      writer.uint32(10).string(message.from);
    }
    if (message.amount !== 0) {
      writer.uint32(16).uint64(message.amount);
    }
    if (message.fee !== 0) {
      writer.uint32(24).uint64(message.fee);
    }
    if (message.memo !== 0) {
      writer.uint32(32).uint64(message.memo);
    }
    if (message.createdAtTime !== 0) {
      writer.uint32(40).uint64(message.createdAtTime);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): ICPTransferToStake {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseICPTransferToStake();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.from = reader.string();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.amount = longToNumber(reader.uint64() as Long);
          continue;
        case 3:
          if (tag !== 24) {
            break;
          }

          message.fee = longToNumber(reader.uint64() as Long);
          continue;
        case 4:
          if (tag !== 32) {
            break;
          }

          message.memo = longToNumber(reader.uint64() as Long);
          continue;
        case 5:
          if (tag !== 40) {
            break;
          }

          message.createdAtTime = longToNumber(reader.uint64() as Long);
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ICPTransferToStake {
    return {
      from: isSet(object.from) ? globalThis.String(object.from) : "",
      amount: isSet(object.amount) ? globalThis.Number(object.amount) : 0,
      fee: isSet(object.fee) ? globalThis.Number(object.fee) : 0,
      memo: isSet(object.memo) ? globalThis.Number(object.memo) : 0,
      createdAtTime: isSet(object.createdAtTime) ? globalThis.Number(object.createdAtTime) : 0,
    };
  },

  toJSON(message: ICPTransferToStake): unknown {
    const obj: any = {};
    if (message.from !== "") {
      obj.from = message.from;
    }
    if (message.amount !== 0) {
      obj.amount = Math.round(message.amount);
    }
    if (message.fee !== 0) {
      obj.fee = Math.round(message.fee);
    }
    if (message.memo !== 0) {
      obj.memo = Math.round(message.memo);
    }
    if (message.createdAtTime !== 0) {
      obj.createdAtTime = Math.round(message.createdAtTime);
    }
    return obj;
  },

  create(base?: DeepPartial<ICPTransferToStake>): ICPTransferToStake {
    return ICPTransferToStake.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ICPTransferToStake>): ICPTransferToStake {
    const message = createBaseICPTransferToStake();
    message.from = object.from ?? "";
    message.amount = object.amount ?? 0;
    message.fee = object.fee ?? 0;
    message.memo = object.memo ?? 0;
    message.createdAtTime = object.createdAtTime ?? 0;
    return message;
  },
};

function createBaseICPFollow(): ICPFollow {
  return { from: "", followees: [], topic: 0 };
}

export const ICPFollow = {
  encode(message: ICPFollow, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.from !== "") {
      writer.uint32(10).string(message.from);
    }
    writer.uint32(18).fork();
    for (const v of message.followees) {
      writer.uint64(v);
    }
    writer.ldelim();
    if (message.topic !== 0) {
      writer.uint32(24).uint64(message.topic);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): ICPFollow {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseICPFollow();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.from = reader.string();
          continue;
        case 2:
          if (tag === 16) {
            message.followees.push(longToNumber(reader.uint64() as Long));

            continue;
          }

          if (tag === 18) {
            const end2 = reader.uint32() + reader.pos;
            while (reader.pos < end2) {
              message.followees.push(longToNumber(reader.uint64() as Long));
            }

            continue;
          }

          break;
        case 3:
          if (tag !== 24) {
            break;
          }

          message.topic = longToNumber(reader.uint64() as Long);
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ICPFollow {
    return {
      from: isSet(object.from) ? globalThis.String(object.from) : "",
      followees: globalThis.Array.isArray(object?.followees)
        ? object.followees.map((e: any) => globalThis.Number(e))
        : [],
      topic: isSet(object.topic) ? globalThis.Number(object.topic) : 0,
    };
  },

  toJSON(message: ICPFollow): unknown {
    const obj: any = {};
    if (message.from !== "") {
      obj.from = message.from;
    }
    if (message.followees?.length) {
      obj.followees = message.followees.map((e) => Math.round(e));
    }
    if (message.topic !== 0) {
      obj.topic = Math.round(message.topic);
    }
    return obj;
  },

  create(base?: DeepPartial<ICPFollow>): ICPFollow {
    return ICPFollow.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ICPFollow>): ICPFollow {
    const message = createBaseICPFollow();
    message.from = object.from ?? "";
    message.followees = object.followees?.map((e) => e) || [];
    message.topic = object.topic ?? 0;
    return message;
  },
};

function createBaseICPClaimOrRefresh(): ICPClaimOrRefresh {
  return { from: "" };
}

export const ICPClaimOrRefresh = {
  encode(message: ICPClaimOrRefresh, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.from !== "") {
      writer.uint32(10).string(message.from);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): ICPClaimOrRefresh {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseICPClaimOrRefresh();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.from = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ICPClaimOrRefresh {
    return { from: isSet(object.from) ? globalThis.String(object.from) : "" };
  },

  toJSON(message: ICPClaimOrRefresh): unknown {
    const obj: any = {};
    if (message.from !== "") {
      obj.from = message.from;
    }
    return obj;
  },

  create(base?: DeepPartial<ICPClaimOrRefresh>): ICPClaimOrRefresh {
    return ICPClaimOrRefresh.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ICPClaimOrRefresh>): ICPClaimOrRefresh {
    const message = createBaseICPClaimOrRefresh();
    message.from = object.from ?? "";
    return message;
  },
};

function createBaseICPSetAutoStakeRewards(): ICPSetAutoStakeRewards {
  return { from: "" };
}

export const ICPSetAutoStakeRewards = {
  encode(message: ICPSetAutoStakeRewards, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.from !== "") {
      writer.uint32(10).string(message.from);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): ICPSetAutoStakeRewards {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseICPSetAutoStakeRewards();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.from = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ICPSetAutoStakeRewards {
    return { from: isSet(object.from) ? globalThis.String(object.from) : "" };
  },

  toJSON(message: ICPSetAutoStakeRewards): unknown {
    const obj: any = {};
    if (message.from !== "") {
      obj.from = message.from;
    }
    return obj;
  },

  create(base?: DeepPartial<ICPSetAutoStakeRewards>): ICPSetAutoStakeRewards {
    return ICPSetAutoStakeRewards.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ICPSetAutoStakeRewards>): ICPSetAutoStakeRewards {
    const message = createBaseICPSetAutoStakeRewards();
    message.from = object.from ?? "";
    return message;
  },
};

function createBaseICPSetDissolveDelay(): ICPSetDissolveDelay {
  return { from: "", nowTimestampSeconds: 0, delayTimestampSeconds: 0 };
}

export const ICPSetDissolveDelay = {
  encode(message: ICPSetDissolveDelay, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.from !== "") {
      writer.uint32(10).string(message.from);
    }
    if (message.nowTimestampSeconds !== 0) {
      writer.uint32(16).uint64(message.nowTimestampSeconds);
    }
    if (message.delayTimestampSeconds !== 0) {
      writer.uint32(24).uint64(message.delayTimestampSeconds);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): ICPSetDissolveDelay {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseICPSetDissolveDelay();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.from = reader.string();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.nowTimestampSeconds = longToNumber(reader.uint64() as Long);
          continue;
        case 3:
          if (tag !== 24) {
            break;
          }

          message.delayTimestampSeconds = longToNumber(reader.uint64() as Long);
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ICPSetDissolveDelay {
    return {
      from: isSet(object.from) ? globalThis.String(object.from) : "",
      nowTimestampSeconds: isSet(object.nowTimestampSeconds) ? globalThis.Number(object.nowTimestampSeconds) : 0,
      delayTimestampSeconds: isSet(object.delayTimestampSeconds) ? globalThis.Number(object.delayTimestampSeconds) : 0,
    };
  },

  toJSON(message: ICPSetDissolveDelay): unknown {
    const obj: any = {};
    if (message.from !== "") {
      obj.from = message.from;
    }
    if (message.nowTimestampSeconds !== 0) {
      obj.nowTimestampSeconds = Math.round(message.nowTimestampSeconds);
    }
    if (message.delayTimestampSeconds !== 0) {
      obj.delayTimestampSeconds = Math.round(message.delayTimestampSeconds);
    }
    return obj;
  },

  create(base?: DeepPartial<ICPSetDissolveDelay>): ICPSetDissolveDelay {
    return ICPSetDissolveDelay.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ICPSetDissolveDelay>): ICPSetDissolveDelay {
    const message = createBaseICPSetDissolveDelay();
    message.from = object.from ?? "";
    message.nowTimestampSeconds = object.nowTimestampSeconds ?? 0;
    message.delayTimestampSeconds = object.delayTimestampSeconds ?? 0;
    return message;
  },
};

function createBaseICPSpawn(): ICPSpawn {
  return { from: "", nonce: 0 };
}

export const ICPSpawn = {
  encode(message: ICPSpawn, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.from !== "") {
      writer.uint32(10).string(message.from);
    }
    if (message.nonce !== 0) {
      writer.uint32(16).uint64(message.nonce);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): ICPSpawn {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseICPSpawn();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.from = reader.string();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.nonce = longToNumber(reader.uint64() as Long);
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ICPSpawn {
    return {
      from: isSet(object.from) ? globalThis.String(object.from) : "",
      nonce: isSet(object.nonce) ? globalThis.Number(object.nonce) : 0,
    };
  },

  toJSON(message: ICPSpawn): unknown {
    const obj: any = {};
    if (message.from !== "") {
      obj.from = message.from;
    }
    if (message.nonce !== 0) {
      obj.nonce = Math.round(message.nonce);
    }
    return obj;
  },

  create(base?: DeepPartial<ICPSpawn>): ICPSpawn {
    return ICPSpawn.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ICPSpawn>): ICPSpawn {
    const message = createBaseICPSpawn();
    message.from = object.from ?? "";
    message.nonce = object.nonce ?? 0;
    return message;
  },
};

function createBaseICPDisburseToPrimary(): ICPDisburseToPrimary {
  return { from: "", nonce: 0, amount: 0 };
}

export const ICPDisburseToPrimary = {
  encode(message: ICPDisburseToPrimary, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.from !== "") {
      writer.uint32(10).string(message.from);
    }
    if (message.nonce !== 0) {
      writer.uint32(16).uint64(message.nonce);
    }
    if (message.amount !== 0) {
      writer.uint32(24).uint64(message.amount);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): ICPDisburseToPrimary {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseICPDisburseToPrimary();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.from = reader.string();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.nonce = longToNumber(reader.uint64() as Long);
          continue;
        case 3:
          if (tag !== 24) {
            break;
          }

          message.amount = longToNumber(reader.uint64() as Long);
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ICPDisburseToPrimary {
    return {
      from: isSet(object.from) ? globalThis.String(object.from) : "",
      nonce: isSet(object.nonce) ? globalThis.Number(object.nonce) : 0,
      amount: isSet(object.amount) ? globalThis.Number(object.amount) : 0,
    };
  },

  toJSON(message: ICPDisburseToPrimary): unknown {
    const obj: any = {};
    if (message.from !== "") {
      obj.from = message.from;
    }
    if (message.nonce !== 0) {
      obj.nonce = Math.round(message.nonce);
    }
    if (message.amount !== 0) {
      obj.amount = Math.round(message.amount);
    }
    return obj;
  },

  create(base?: DeepPartial<ICPDisburseToPrimary>): ICPDisburseToPrimary {
    return ICPDisburseToPrimary.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ICPDisburseToPrimary>): ICPDisburseToPrimary {
    const message = createBaseICPDisburseToPrimary();
    message.from = object.from ?? "";
    message.nonce = object.nonce ?? 0;
    message.amount = object.amount ?? 0;
    return message;
  },
};

function createBaseICPStartDissolving(): ICPStartDissolving {
  return { from: "" };
}

export const ICPStartDissolving = {
  encode(message: ICPStartDissolving, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.from !== "") {
      writer.uint32(10).string(message.from);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): ICPStartDissolving {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseICPStartDissolving();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.from = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ICPStartDissolving {
    return { from: isSet(object.from) ? globalThis.String(object.from) : "" };
  },

  toJSON(message: ICPStartDissolving): unknown {
    const obj: any = {};
    if (message.from !== "") {
      obj.from = message.from;
    }
    return obj;
  },

  create(base?: DeepPartial<ICPStartDissolving>): ICPStartDissolving {
    return ICPStartDissolving.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ICPStartDissolving>): ICPStartDissolving {
    const message = createBaseICPStartDissolving();
    message.from = object.from ?? "";
    return message;
  },
};

function createBaseICPDisburse(): ICPDisburse {
  return { from: "", amount: 0 };
}

export const ICPDisburse = {
  encode(message: ICPDisburse, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.from !== "") {
      writer.uint32(10).string(message.from);
    }
    if (message.amount !== 0) {
      writer.uint32(16).uint64(message.amount);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): ICPDisburse {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseICPDisburse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.from = reader.string();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.amount = longToNumber(reader.uint64() as Long);
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ICPDisburse {
    return {
      from: isSet(object.from) ? globalThis.String(object.from) : "",
      amount: isSet(object.amount) ? globalThis.Number(object.amount) : 0,
    };
  },

  toJSON(message: ICPDisburse): unknown {
    const obj: any = {};
    if (message.from !== "") {
      obj.from = message.from;
    }
    if (message.amount !== 0) {
      obj.amount = Math.round(message.amount);
    }
    return obj;
  },

  create(base?: DeepPartial<ICPDisburse>): ICPDisburse {
    return ICPDisburse.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ICPDisburse>): ICPDisburse {
    const message = createBaseICPDisburse();
    message.from = object.from ?? "";
    message.amount = object.amount ?? 0;
    return message;
  },
};

function createBaseICPListNeurons(): ICPListNeurons {
  return { from: "" };
}

export const ICPListNeurons = {
  encode(message: ICPListNeurons, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.from !== "") {
      writer.uint32(10).string(message.from);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): ICPListNeurons {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseICPListNeurons();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.from = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ICPListNeurons {
    return { from: isSet(object.from) ? globalThis.String(object.from) : "" };
  },

  toJSON(message: ICPListNeurons): unknown {
    const obj: any = {};
    if (message.from !== "") {
      obj.from = message.from;
    }
    return obj;
  },

  create(base?: DeepPartial<ICPListNeurons>): ICPListNeurons {
    return ICPListNeurons.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ICPListNeurons>): ICPListNeurons {
    const message = createBaseICPListNeurons();
    message.from = object.from ?? "";
    return message;
  },
};

function createBaseICPRefreshVotingPower(): ICPRefreshVotingPower {
  return { from: "" };
}

export const ICPRefreshVotingPower = {
  encode(message: ICPRefreshVotingPower, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.from !== "") {
      writer.uint32(10).string(message.from);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): ICPRefreshVotingPower {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseICPRefreshVotingPower();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.from = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ICPRefreshVotingPower {
    return { from: isSet(object.from) ? globalThis.String(object.from) : "" };
  },

  toJSON(message: ICPRefreshVotingPower): unknown {
    const obj: any = {};
    if (message.from !== "") {
      obj.from = message.from;
    }
    return obj;
  },

  create(base?: DeepPartial<ICPRefreshVotingPower>): ICPRefreshVotingPower {
    return ICPRefreshVotingPower.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ICPRefreshVotingPower>): ICPRefreshVotingPower {
    const message = createBaseICPRefreshVotingPower();
    message.from = object.from ?? "";
    return message;
  },
};

function createBaseICPDisburseMaturityToPrimary(): ICPDisburseMaturityToPrimary {
  return { from: "" };
}

export const ICPDisburseMaturityToPrimary = {
  encode(message: ICPDisburseMaturityToPrimary, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.from !== "") {
      writer.uint32(10).string(message.from);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): ICPDisburseMaturityToPrimary {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseICPDisburseMaturityToPrimary();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.from = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ICPDisburseMaturityToPrimary {
    return { from: isSet(object.from) ? globalThis.String(object.from) : "" };
  },

  toJSON(message: ICPDisburseMaturityToPrimary): unknown {
    const obj: any = {};
    if (message.from !== "") {
      obj.from = message.from;
    }
    return obj;
  },

  create(base?: DeepPartial<ICPDisburseMaturityToPrimary>): ICPDisburseMaturityToPrimary {
    return ICPDisburseMaturityToPrimary.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ICPDisburseMaturityToPrimary>): ICPDisburseMaturityToPrimary {
    const message = createBaseICPDisburseMaturityToPrimary();
    message.from = object.from ?? "";
    return message;
  },
};

function createBaseICRC1Transfer(): ICRC1Transfer {
  return {
    to: "",
    amount: 0,
    fee: 0,
    memo: "",
    createdAtTime: 0,
    natAmount: new Uint8Array(0),
    natFee: new Uint8Array(0),
  };
}

export const ICRC1Transfer = {
  encode(message: ICRC1Transfer, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.to !== "") {
      writer.uint32(10).string(message.to);
    }
    if (message.amount !== 0) {
      writer.uint32(16).uint64(message.amount);
    }
    if (message.fee !== 0) {
      writer.uint32(24).uint64(message.fee);
    }
    if (message.memo !== "") {
      writer.uint32(34).string(message.memo);
    }
    if (message.createdAtTime !== 0) {
      writer.uint32(40).uint64(message.createdAtTime);
    }
    if (message.natAmount.length !== 0) {
      writer.uint32(50).bytes(message.natAmount);
    }
    if (message.natFee.length !== 0) {
      writer.uint32(58).bytes(message.natFee);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): ICRC1Transfer {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseICRC1Transfer();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.to = reader.string();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.amount = longToNumber(reader.uint64() as Long);
          continue;
        case 3:
          if (tag !== 24) {
            break;
          }

          message.fee = longToNumber(reader.uint64() as Long);
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.memo = reader.string();
          continue;
        case 5:
          if (tag !== 40) {
            break;
          }

          message.createdAtTime = longToNumber(reader.uint64() as Long);
          continue;
        case 6:
          if (tag !== 50) {
            break;
          }

          message.natAmount = reader.bytes();
          continue;
        case 7:
          if (tag !== 58) {
            break;
          }

          message.natFee = reader.bytes();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ICRC1Transfer {
    return {
      to: isSet(object.to) ? globalThis.String(object.to) : "",
      amount: isSet(object.amount) ? globalThis.Number(object.amount) : 0,
      fee: isSet(object.fee) ? globalThis.Number(object.fee) : 0,
      memo: isSet(object.memo) ? globalThis.String(object.memo) : "",
      createdAtTime: isSet(object.createdAtTime) ? globalThis.Number(object.createdAtTime) : 0,
      natAmount: isSet(object.natAmount) ? bytesFromBase64(object.natAmount) : new Uint8Array(0),
      natFee: isSet(object.natFee) ? bytesFromBase64(object.natFee) : new Uint8Array(0),
    };
  },

  toJSON(message: ICRC1Transfer): unknown {
    const obj: any = {};
    if (message.to !== "") {
      obj.to = message.to;
    }
    if (message.amount !== 0) {
      obj.amount = Math.round(message.amount);
    }
    if (message.fee !== 0) {
      obj.fee = Math.round(message.fee);
    }
    if (message.memo !== "") {
      obj.memo = message.memo;
    }
    if (message.createdAtTime !== 0) {
      obj.createdAtTime = Math.round(message.createdAtTime);
    }
    if (message.natAmount.length !== 0) {
      obj.natAmount = base64FromBytes(message.natAmount);
    }
    if (message.natFee.length !== 0) {
      obj.natFee = base64FromBytes(message.natFee);
    }
    return obj;
  },

  create(base?: DeepPartial<ICRC1Transfer>): ICRC1Transfer {
    return ICRC1Transfer.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ICRC1Transfer>): ICRC1Transfer {
    const message = createBaseICRC1Transfer();
    message.to = object.to ?? "";
    message.amount = object.amount ?? 0;
    message.fee = object.fee ?? 0;
    message.memo = object.memo ?? "";
    message.createdAtTime = object.createdAtTime ?? 0;
    message.natAmount = object.natAmount ?? new Uint8Array(0);
    message.natFee = object.natFee ?? new Uint8Array(0);
    return message;
  },
};

function createBaseICPRequest(): ICPRequest {
  return {
    id: "",
    sender: "",
    nonce: new Uint8Array(0),
    ingressExpiry: 0,
    canisterId: "",
    kind: 0,
    payload: new Uint8Array(0),
    encodeAsCandid: false,
  };
}

export const ICPRequest = {
  encode(message: ICPRequest, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.id !== "") {
      writer.uint32(10).string(message.id);
    }
    if (message.sender !== "") {
      writer.uint32(18).string(message.sender);
    }
    if (message.nonce.length !== 0) {
      writer.uint32(26).bytes(message.nonce);
    }
    if (message.ingressExpiry !== 0) {
      writer.uint32(32).uint64(message.ingressExpiry);
    }
    if (message.canisterId !== "") {
      writer.uint32(42).string(message.canisterId);
    }
    if (message.kind !== 0) {
      writer.uint32(48).int32(message.kind);
    }
    if (message.payload.length !== 0) {
      writer.uint32(58).bytes(message.payload);
    }
    if (message.encodeAsCandid !== false) {
      writer.uint32(64).bool(message.encodeAsCandid);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): ICPRequest {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseICPRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.id = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.sender = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.nonce = reader.bytes();
          continue;
        case 4:
          if (tag !== 32) {
            break;
          }

          message.ingressExpiry = longToNumber(reader.uint64() as Long);
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.canisterId = reader.string();
          continue;
        case 6:
          if (tag !== 48) {
            break;
          }

          message.kind = reader.int32() as any;
          continue;
        case 7:
          if (tag !== 58) {
            break;
          }

          message.payload = reader.bytes();
          continue;
        case 8:
          if (tag !== 64) {
            break;
          }

          message.encodeAsCandid = reader.bool();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ICPRequest {
    return {
      id: isSet(object.id) ? globalThis.String(object.id) : "",
      sender: isSet(object.sender) ? globalThis.String(object.sender) : "",
      nonce: isSet(object.nonce) ? bytesFromBase64(object.nonce) : new Uint8Array(0),
      ingressExpiry: isSet(object.ingressExpiry) ? globalThis.Number(object.ingressExpiry) : 0,
      canisterId: isSet(object.canisterId) ? globalThis.String(object.canisterId) : "",
      kind: isSet(object.kind) ? iCPRequest_ICPRequestKindFromJSON(object.kind) : 0,
      payload: isSet(object.payload) ? bytesFromBase64(object.payload) : new Uint8Array(0),
      encodeAsCandid: isSet(object.encodeAsCandid) ? globalThis.Boolean(object.encodeAsCandid) : false,
    };
  },

  toJSON(message: ICPRequest): unknown {
    const obj: any = {};
    if (message.id !== "") {
      obj.id = message.id;
    }
    if (message.sender !== "") {
      obj.sender = message.sender;
    }
    if (message.nonce.length !== 0) {
      obj.nonce = base64FromBytes(message.nonce);
    }
    if (message.ingressExpiry !== 0) {
      obj.ingressExpiry = Math.round(message.ingressExpiry);
    }
    if (message.canisterId !== "") {
      obj.canisterId = message.canisterId;
    }
    if (message.kind !== 0) {
      obj.kind = iCPRequest_ICPRequestKindToJSON(message.kind);
    }
    if (message.payload.length !== 0) {
      obj.payload = base64FromBytes(message.payload);
    }
    if (message.encodeAsCandid !== false) {
      obj.encodeAsCandid = message.encodeAsCandid;
    }
    return obj;
  },

  create(base?: DeepPartial<ICPRequest>): ICPRequest {
    return ICPRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ICPRequest>): ICPRequest {
    const message = createBaseICPRequest();
    message.id = object.id ?? "";
    message.sender = object.sender ?? "";
    message.nonce = object.nonce ?? new Uint8Array(0);
    message.ingressExpiry = object.ingressExpiry ?? 0;
    message.canisterId = object.canisterId ?? "";
    message.kind = object.kind ?? 0;
    message.payload = object.payload ?? new Uint8Array(0);
    message.encodeAsCandid = object.encodeAsCandid ?? false;
    return message;
  },
};

function createBaseNEARProofOfReserveRequest(): NEARProofOfReserveRequest {
  return { path: "", challenge: "" };
}

export const NEARProofOfReserveRequest = {
  encode(message: NEARProofOfReserveRequest, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.path !== "") {
      writer.uint32(10).string(message.path);
    }
    if (message.challenge !== "") {
      writer.uint32(18).string(message.challenge);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): NEARProofOfReserveRequest {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseNEARProofOfReserveRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.path = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.challenge = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): NEARProofOfReserveRequest {
    return {
      path: isSet(object.path) ? globalThis.String(object.path) : "",
      challenge: isSet(object.challenge) ? globalThis.String(object.challenge) : "",
    };
  },

  toJSON(message: NEARProofOfReserveRequest): unknown {
    const obj: any = {};
    if (message.path !== "") {
      obj.path = message.path;
    }
    if (message.challenge !== "") {
      obj.challenge = message.challenge;
    }
    return obj;
  },

  create(base?: DeepPartial<NEARProofOfReserveRequest>): NEARProofOfReserveRequest {
    return NEARProofOfReserveRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<NEARProofOfReserveRequest>): NEARProofOfReserveRequest {
    const message = createBaseNEARProofOfReserveRequest();
    message.path = object.path ?? "";
    message.challenge = object.challenge ?? "";
    return message;
  },
};

function createBaseNEARAddressRequest(): NEARAddressRequest {
  return { path: "" };
}

export const NEARAddressRequest = {
  encode(message: NEARAddressRequest, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.path !== "") {
      writer.uint32(10).string(message.path);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): NEARAddressRequest {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseNEARAddressRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.path = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): NEARAddressRequest {
    return { path: isSet(object.path) ? globalThis.String(object.path) : "" };
  },

  toJSON(message: NEARAddressRequest): unknown {
    const obj: any = {};
    if (message.path !== "") {
      obj.path = message.path;
    }
    return obj;
  },

  create(base?: DeepPartial<NEARAddressRequest>): NEARAddressRequest {
    return NEARAddressRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<NEARAddressRequest>): NEARAddressRequest {
    const message = createBaseNEARAddressRequest();
    message.path = object.path ?? "";
    return message;
  },
};

function createBaseNEARTransactionsRequest(): NEARTransactionsRequest {
  return { transactions: [] };
}

export const NEARTransactionsRequest = {
  encode(message: NEARTransactionsRequest, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    for (const v of message.transactions) {
      NEARTransaction.encode(v!, writer.uint32(10).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): NEARTransactionsRequest {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseNEARTransactionsRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.transactions.push(NEARTransaction.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): NEARTransactionsRequest {
    return {
      transactions: globalThis.Array.isArray(object?.transactions)
        ? object.transactions.map((e: any) => NEARTransaction.fromJSON(e))
        : [],
    };
  },

  toJSON(message: NEARTransactionsRequest): unknown {
    const obj: any = {};
    if (message.transactions?.length) {
      obj.transactions = message.transactions.map((e) => NEARTransaction.toJSON(e));
    }
    return obj;
  },

  create(base?: DeepPartial<NEARTransactionsRequest>): NEARTransactionsRequest {
    return NEARTransactionsRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<NEARTransactionsRequest>): NEARTransactionsRequest {
    const message = createBaseNEARTransactionsRequest();
    message.transactions = object.transactions?.map((e) => NEARTransaction.fromPartial(e)) || [];
    return message;
  },
};

function createBaseNEARTransaction(): NEARTransaction {
  return { id: "", from: "", nonce: 0, to: "", blockHash: "", amount: new Uint8Array(0), isNonceSet: false };
}

export const NEARTransaction = {
  encode(message: NEARTransaction, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.id !== "") {
      writer.uint32(10).string(message.id);
    }
    if (message.from !== "") {
      writer.uint32(18).string(message.from);
    }
    if (message.nonce !== 0) {
      writer.uint32(24).uint64(message.nonce);
    }
    if (message.to !== "") {
      writer.uint32(34).string(message.to);
    }
    if (message.blockHash !== "") {
      writer.uint32(42).string(message.blockHash);
    }
    if (message.amount.length !== 0) {
      writer.uint32(50).bytes(message.amount);
    }
    if (message.isNonceSet !== false) {
      writer.uint32(56).bool(message.isNonceSet);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): NEARTransaction {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseNEARTransaction();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.id = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.from = reader.string();
          continue;
        case 3:
          if (tag !== 24) {
            break;
          }

          message.nonce = longToNumber(reader.uint64() as Long);
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.to = reader.string();
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.blockHash = reader.string();
          continue;
        case 6:
          if (tag !== 50) {
            break;
          }

          message.amount = reader.bytes();
          continue;
        case 7:
          if (tag !== 56) {
            break;
          }

          message.isNonceSet = reader.bool();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): NEARTransaction {
    return {
      id: isSet(object.id) ? globalThis.String(object.id) : "",
      from: isSet(object.from) ? globalThis.String(object.from) : "",
      nonce: isSet(object.nonce) ? globalThis.Number(object.nonce) : 0,
      to: isSet(object.to) ? globalThis.String(object.to) : "",
      blockHash: isSet(object.blockHash) ? globalThis.String(object.blockHash) : "",
      amount: isSet(object.amount) ? bytesFromBase64(object.amount) : new Uint8Array(0),
      isNonceSet: isSet(object.isNonceSet) ? globalThis.Boolean(object.isNonceSet) : false,
    };
  },

  toJSON(message: NEARTransaction): unknown {
    const obj: any = {};
    if (message.id !== "") {
      obj.id = message.id;
    }
    if (message.from !== "") {
      obj.from = message.from;
    }
    if (message.nonce !== 0) {
      obj.nonce = Math.round(message.nonce);
    }
    if (message.to !== "") {
      obj.to = message.to;
    }
    if (message.blockHash !== "") {
      obj.blockHash = message.blockHash;
    }
    if (message.amount.length !== 0) {
      obj.amount = base64FromBytes(message.amount);
    }
    if (message.isNonceSet !== false) {
      obj.isNonceSet = message.isNonceSet;
    }
    return obj;
  },

  create(base?: DeepPartial<NEARTransaction>): NEARTransaction {
    return NEARTransaction.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<NEARTransaction>): NEARTransaction {
    const message = createBaseNEARTransaction();
    message.id = object.id ?? "";
    message.from = object.from ?? "";
    message.nonce = object.nonce ?? 0;
    message.to = object.to ?? "";
    message.blockHash = object.blockHash ?? "";
    message.amount = object.amount ?? new Uint8Array(0);
    message.isNonceSet = object.isNonceSet ?? false;
    return message;
  },
};

function createBaseNEARDepositAndStakeRequest(): NEARDepositAndStakeRequest {
  return { id: "", from: "", nonce: 0, to: "", blockHash: "", amount: new Uint8Array(0), gas: 0, isNonceSet: false };
}

export const NEARDepositAndStakeRequest = {
  encode(message: NEARDepositAndStakeRequest, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.id !== "") {
      writer.uint32(10).string(message.id);
    }
    if (message.from !== "") {
      writer.uint32(18).string(message.from);
    }
    if (message.nonce !== 0) {
      writer.uint32(24).uint64(message.nonce);
    }
    if (message.to !== "") {
      writer.uint32(34).string(message.to);
    }
    if (message.blockHash !== "") {
      writer.uint32(42).string(message.blockHash);
    }
    if (message.amount.length !== 0) {
      writer.uint32(50).bytes(message.amount);
    }
    if (message.gas !== 0) {
      writer.uint32(56).uint64(message.gas);
    }
    if (message.isNonceSet !== false) {
      writer.uint32(64).bool(message.isNonceSet);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): NEARDepositAndStakeRequest {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseNEARDepositAndStakeRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.id = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.from = reader.string();
          continue;
        case 3:
          if (tag !== 24) {
            break;
          }

          message.nonce = longToNumber(reader.uint64() as Long);
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.to = reader.string();
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.blockHash = reader.string();
          continue;
        case 6:
          if (tag !== 50) {
            break;
          }

          message.amount = reader.bytes();
          continue;
        case 7:
          if (tag !== 56) {
            break;
          }

          message.gas = longToNumber(reader.uint64() as Long);
          continue;
        case 8:
          if (tag !== 64) {
            break;
          }

          message.isNonceSet = reader.bool();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): NEARDepositAndStakeRequest {
    return {
      id: isSet(object.id) ? globalThis.String(object.id) : "",
      from: isSet(object.from) ? globalThis.String(object.from) : "",
      nonce: isSet(object.nonce) ? globalThis.Number(object.nonce) : 0,
      to: isSet(object.to) ? globalThis.String(object.to) : "",
      blockHash: isSet(object.blockHash) ? globalThis.String(object.blockHash) : "",
      amount: isSet(object.amount) ? bytesFromBase64(object.amount) : new Uint8Array(0),
      gas: isSet(object.gas) ? globalThis.Number(object.gas) : 0,
      isNonceSet: isSet(object.isNonceSet) ? globalThis.Boolean(object.isNonceSet) : false,
    };
  },

  toJSON(message: NEARDepositAndStakeRequest): unknown {
    const obj: any = {};
    if (message.id !== "") {
      obj.id = message.id;
    }
    if (message.from !== "") {
      obj.from = message.from;
    }
    if (message.nonce !== 0) {
      obj.nonce = Math.round(message.nonce);
    }
    if (message.to !== "") {
      obj.to = message.to;
    }
    if (message.blockHash !== "") {
      obj.blockHash = message.blockHash;
    }
    if (message.amount.length !== 0) {
      obj.amount = base64FromBytes(message.amount);
    }
    if (message.gas !== 0) {
      obj.gas = Math.round(message.gas);
    }
    if (message.isNonceSet !== false) {
      obj.isNonceSet = message.isNonceSet;
    }
    return obj;
  },

  create(base?: DeepPartial<NEARDepositAndStakeRequest>): NEARDepositAndStakeRequest {
    return NEARDepositAndStakeRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<NEARDepositAndStakeRequest>): NEARDepositAndStakeRequest {
    const message = createBaseNEARDepositAndStakeRequest();
    message.id = object.id ?? "";
    message.from = object.from ?? "";
    message.nonce = object.nonce ?? 0;
    message.to = object.to ?? "";
    message.blockHash = object.blockHash ?? "";
    message.amount = object.amount ?? new Uint8Array(0);
    message.gas = object.gas ?? 0;
    message.isNonceSet = object.isNonceSet ?? false;
    return message;
  },
};

function createBaseNEARUnstakeRequest(): NEARUnstakeRequest {
  return { id: "", from: "", nonce: 0, to: "", blockHash: "", amount: new Uint8Array(0), gas: 0, isNonceSet: false };
}

export const NEARUnstakeRequest = {
  encode(message: NEARUnstakeRequest, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.id !== "") {
      writer.uint32(10).string(message.id);
    }
    if (message.from !== "") {
      writer.uint32(18).string(message.from);
    }
    if (message.nonce !== 0) {
      writer.uint32(24).uint64(message.nonce);
    }
    if (message.to !== "") {
      writer.uint32(34).string(message.to);
    }
    if (message.blockHash !== "") {
      writer.uint32(42).string(message.blockHash);
    }
    if (message.amount.length !== 0) {
      writer.uint32(50).bytes(message.amount);
    }
    if (message.gas !== 0) {
      writer.uint32(56).uint64(message.gas);
    }
    if (message.isNonceSet !== false) {
      writer.uint32(64).bool(message.isNonceSet);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): NEARUnstakeRequest {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseNEARUnstakeRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.id = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.from = reader.string();
          continue;
        case 3:
          if (tag !== 24) {
            break;
          }

          message.nonce = longToNumber(reader.uint64() as Long);
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.to = reader.string();
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.blockHash = reader.string();
          continue;
        case 6:
          if (tag !== 50) {
            break;
          }

          message.amount = reader.bytes();
          continue;
        case 7:
          if (tag !== 56) {
            break;
          }

          message.gas = longToNumber(reader.uint64() as Long);
          continue;
        case 8:
          if (tag !== 64) {
            break;
          }

          message.isNonceSet = reader.bool();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): NEARUnstakeRequest {
    return {
      id: isSet(object.id) ? globalThis.String(object.id) : "",
      from: isSet(object.from) ? globalThis.String(object.from) : "",
      nonce: isSet(object.nonce) ? globalThis.Number(object.nonce) : 0,
      to: isSet(object.to) ? globalThis.String(object.to) : "",
      blockHash: isSet(object.blockHash) ? globalThis.String(object.blockHash) : "",
      amount: isSet(object.amount) ? bytesFromBase64(object.amount) : new Uint8Array(0),
      gas: isSet(object.gas) ? globalThis.Number(object.gas) : 0,
      isNonceSet: isSet(object.isNonceSet) ? globalThis.Boolean(object.isNonceSet) : false,
    };
  },

  toJSON(message: NEARUnstakeRequest): unknown {
    const obj: any = {};
    if (message.id !== "") {
      obj.id = message.id;
    }
    if (message.from !== "") {
      obj.from = message.from;
    }
    if (message.nonce !== 0) {
      obj.nonce = Math.round(message.nonce);
    }
    if (message.to !== "") {
      obj.to = message.to;
    }
    if (message.blockHash !== "") {
      obj.blockHash = message.blockHash;
    }
    if (message.amount.length !== 0) {
      obj.amount = base64FromBytes(message.amount);
    }
    if (message.gas !== 0) {
      obj.gas = Math.round(message.gas);
    }
    if (message.isNonceSet !== false) {
      obj.isNonceSet = message.isNonceSet;
    }
    return obj;
  },

  create(base?: DeepPartial<NEARUnstakeRequest>): NEARUnstakeRequest {
    return NEARUnstakeRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<NEARUnstakeRequest>): NEARUnstakeRequest {
    const message = createBaseNEARUnstakeRequest();
    message.id = object.id ?? "";
    message.from = object.from ?? "";
    message.nonce = object.nonce ?? 0;
    message.to = object.to ?? "";
    message.blockHash = object.blockHash ?? "";
    message.amount = object.amount ?? new Uint8Array(0);
    message.gas = object.gas ?? 0;
    message.isNonceSet = object.isNonceSet ?? false;
    return message;
  },
};

function createBaseNEARWithdrawRequest(): NEARWithdrawRequest {
  return { id: "", from: "", nonce: 0, to: "", blockHash: "", amount: new Uint8Array(0), gas: 0, isNonceSet: false };
}

export const NEARWithdrawRequest = {
  encode(message: NEARWithdrawRequest, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.id !== "") {
      writer.uint32(10).string(message.id);
    }
    if (message.from !== "") {
      writer.uint32(18).string(message.from);
    }
    if (message.nonce !== 0) {
      writer.uint32(24).uint64(message.nonce);
    }
    if (message.to !== "") {
      writer.uint32(34).string(message.to);
    }
    if (message.blockHash !== "") {
      writer.uint32(42).string(message.blockHash);
    }
    if (message.amount.length !== 0) {
      writer.uint32(50).bytes(message.amount);
    }
    if (message.gas !== 0) {
      writer.uint32(56).uint64(message.gas);
    }
    if (message.isNonceSet !== false) {
      writer.uint32(64).bool(message.isNonceSet);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): NEARWithdrawRequest {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseNEARWithdrawRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.id = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.from = reader.string();
          continue;
        case 3:
          if (tag !== 24) {
            break;
          }

          message.nonce = longToNumber(reader.uint64() as Long);
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.to = reader.string();
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.blockHash = reader.string();
          continue;
        case 6:
          if (tag !== 50) {
            break;
          }

          message.amount = reader.bytes();
          continue;
        case 7:
          if (tag !== 56) {
            break;
          }

          message.gas = longToNumber(reader.uint64() as Long);
          continue;
        case 8:
          if (tag !== 64) {
            break;
          }

          message.isNonceSet = reader.bool();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): NEARWithdrawRequest {
    return {
      id: isSet(object.id) ? globalThis.String(object.id) : "",
      from: isSet(object.from) ? globalThis.String(object.from) : "",
      nonce: isSet(object.nonce) ? globalThis.Number(object.nonce) : 0,
      to: isSet(object.to) ? globalThis.String(object.to) : "",
      blockHash: isSet(object.blockHash) ? globalThis.String(object.blockHash) : "",
      amount: isSet(object.amount) ? bytesFromBase64(object.amount) : new Uint8Array(0),
      gas: isSet(object.gas) ? globalThis.Number(object.gas) : 0,
      isNonceSet: isSet(object.isNonceSet) ? globalThis.Boolean(object.isNonceSet) : false,
    };
  },

  toJSON(message: NEARWithdrawRequest): unknown {
    const obj: any = {};
    if (message.id !== "") {
      obj.id = message.id;
    }
    if (message.from !== "") {
      obj.from = message.from;
    }
    if (message.nonce !== 0) {
      obj.nonce = Math.round(message.nonce);
    }
    if (message.to !== "") {
      obj.to = message.to;
    }
    if (message.blockHash !== "") {
      obj.blockHash = message.blockHash;
    }
    if (message.amount.length !== 0) {
      obj.amount = base64FromBytes(message.amount);
    }
    if (message.gas !== 0) {
      obj.gas = Math.round(message.gas);
    }
    if (message.isNonceSet !== false) {
      obj.isNonceSet = message.isNonceSet;
    }
    return obj;
  },

  create(base?: DeepPartial<NEARWithdrawRequest>): NEARWithdrawRequest {
    return NEARWithdrawRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<NEARWithdrawRequest>): NEARWithdrawRequest {
    const message = createBaseNEARWithdrawRequest();
    message.id = object.id ?? "";
    message.from = object.from ?? "";
    message.nonce = object.nonce ?? 0;
    message.to = object.to ?? "";
    message.blockHash = object.blockHash ?? "";
    message.amount = object.amount ?? new Uint8Array(0);
    message.gas = object.gas ?? 0;
    message.isNonceSet = object.isNonceSet ?? false;
    return message;
  },
};

function createBaseADAAddressRequest(): ADAAddressRequest {
  return { path: "" };
}

export const ADAAddressRequest = {
  encode(message: ADAAddressRequest, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.path !== "") {
      writer.uint32(10).string(message.path);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): ADAAddressRequest {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseADAAddressRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.path = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ADAAddressRequest {
    return { path: isSet(object.path) ? globalThis.String(object.path) : "" };
  },

  toJSON(message: ADAAddressRequest): unknown {
    const obj: any = {};
    if (message.path !== "") {
      obj.path = message.path;
    }
    return obj;
  },

  create(base?: DeepPartial<ADAAddressRequest>): ADAAddressRequest {
    return ADAAddressRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ADAAddressRequest>): ADAAddressRequest {
    const message = createBaseADAAddressRequest();
    message.path = object.path ?? "";
    return message;
  },
};

function createBaseADAInput(): ADAInput {
  return { path: "", hash: new Uint8Array(0), index: 0, value: undefined };
}

export const ADAInput = {
  encode(message: ADAInput, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.path !== "") {
      writer.uint32(10).string(message.path);
    }
    if (message.hash.length !== 0) {
      writer.uint32(18).bytes(message.hash);
    }
    if (message.index !== 0) {
      writer.uint32(24).uint64(message.index);
    }
    if (message.value !== undefined) {
      ADAValue.encode(message.value, writer.uint32(34).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): ADAInput {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseADAInput();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.path = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.hash = reader.bytes();
          continue;
        case 3:
          if (tag !== 24) {
            break;
          }

          message.index = longToNumber(reader.uint64() as Long);
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.value = ADAValue.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ADAInput {
    return {
      path: isSet(object.path) ? globalThis.String(object.path) : "",
      hash: isSet(object.hash) ? bytesFromBase64(object.hash) : new Uint8Array(0),
      index: isSet(object.index) ? globalThis.Number(object.index) : 0,
      value: isSet(object.value) ? ADAValue.fromJSON(object.value) : undefined,
    };
  },

  toJSON(message: ADAInput): unknown {
    const obj: any = {};
    if (message.path !== "") {
      obj.path = message.path;
    }
    if (message.hash.length !== 0) {
      obj.hash = base64FromBytes(message.hash);
    }
    if (message.index !== 0) {
      obj.index = Math.round(message.index);
    }
    if (message.value !== undefined) {
      obj.value = ADAValue.toJSON(message.value);
    }
    return obj;
  },

  create(base?: DeepPartial<ADAInput>): ADAInput {
    return ADAInput.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ADAInput>): ADAInput {
    const message = createBaseADAInput();
    message.path = object.path ?? "";
    message.hash = object.hash ?? new Uint8Array(0);
    message.index = object.index ?? 0;
    message.value = (object.value !== undefined && object.value !== null)
      ? ADAValue.fromPartial(object.value)
      : undefined;
    return message;
  },
};

function createBaseADANativeAsset(): ADANativeAsset {
  return { name: new Uint8Array(0), amount: 0 };
}

export const ADANativeAsset = {
  encode(message: ADANativeAsset, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.name.length !== 0) {
      writer.uint32(10).bytes(message.name);
    }
    if (message.amount !== 0) {
      writer.uint32(16).uint64(message.amount);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): ADANativeAsset {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseADANativeAsset();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.name = reader.bytes();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.amount = longToNumber(reader.uint64() as Long);
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ADANativeAsset {
    return {
      name: isSet(object.name) ? bytesFromBase64(object.name) : new Uint8Array(0),
      amount: isSet(object.amount) ? globalThis.Number(object.amount) : 0,
    };
  },

  toJSON(message: ADANativeAsset): unknown {
    const obj: any = {};
    if (message.name.length !== 0) {
      obj.name = base64FromBytes(message.name);
    }
    if (message.amount !== 0) {
      obj.amount = Math.round(message.amount);
    }
    return obj;
  },

  create(base?: DeepPartial<ADANativeAsset>): ADANativeAsset {
    return ADANativeAsset.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ADANativeAsset>): ADANativeAsset {
    const message = createBaseADANativeAsset();
    message.name = object.name ?? new Uint8Array(0);
    message.amount = object.amount ?? 0;
    return message;
  },
};

function createBaseADAAssetPolicy(): ADAAssetPolicy {
  return { policyId: new Uint8Array(0), assets: [] };
}

export const ADAAssetPolicy = {
  encode(message: ADAAssetPolicy, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.policyId.length !== 0) {
      writer.uint32(10).bytes(message.policyId);
    }
    for (const v of message.assets) {
      ADANativeAsset.encode(v!, writer.uint32(18).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): ADAAssetPolicy {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseADAAssetPolicy();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.policyId = reader.bytes();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.assets.push(ADANativeAsset.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ADAAssetPolicy {
    return {
      policyId: isSet(object.policyId) ? bytesFromBase64(object.policyId) : new Uint8Array(0),
      assets: globalThis.Array.isArray(object?.assets) ? object.assets.map((e: any) => ADANativeAsset.fromJSON(e)) : [],
    };
  },

  toJSON(message: ADAAssetPolicy): unknown {
    const obj: any = {};
    if (message.policyId.length !== 0) {
      obj.policyId = base64FromBytes(message.policyId);
    }
    if (message.assets?.length) {
      obj.assets = message.assets.map((e) => ADANativeAsset.toJSON(e));
    }
    return obj;
  },

  create(base?: DeepPartial<ADAAssetPolicy>): ADAAssetPolicy {
    return ADAAssetPolicy.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ADAAssetPolicy>): ADAAssetPolicy {
    const message = createBaseADAAssetPolicy();
    message.policyId = object.policyId ?? new Uint8Array(0);
    message.assets = object.assets?.map((e) => ADANativeAsset.fromPartial(e)) || [];
    return message;
  },
};

function createBaseADAValue(): ADAValue {
  return { amount: 0, policies: [] };
}

export const ADAValue = {
  encode(message: ADAValue, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.amount !== 0) {
      writer.uint32(8).uint64(message.amount);
    }
    for (const v of message.policies) {
      ADAAssetPolicy.encode(v!, writer.uint32(18).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): ADAValue {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseADAValue();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.amount = longToNumber(reader.uint64() as Long);
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.policies.push(ADAAssetPolicy.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ADAValue {
    return {
      amount: isSet(object.amount) ? globalThis.Number(object.amount) : 0,
      policies: globalThis.Array.isArray(object?.policies)
        ? object.policies.map((e: any) => ADAAssetPolicy.fromJSON(e))
        : [],
    };
  },

  toJSON(message: ADAValue): unknown {
    const obj: any = {};
    if (message.amount !== 0) {
      obj.amount = Math.round(message.amount);
    }
    if (message.policies?.length) {
      obj.policies = message.policies.map((e) => ADAAssetPolicy.toJSON(e));
    }
    return obj;
  },

  create(base?: DeepPartial<ADAValue>): ADAValue {
    return ADAValue.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ADAValue>): ADAValue {
    const message = createBaseADAValue();
    message.amount = object.amount ?? 0;
    message.policies = object.policies?.map((e) => ADAAssetPolicy.fromPartial(e)) || [];
    return message;
  },
};

function createBaseADAOutput(): ADAOutput {
  return { address: "", value: undefined };
}

export const ADAOutput = {
  encode(message: ADAOutput, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.address !== "") {
      writer.uint32(10).string(message.address);
    }
    if (message.value !== undefined) {
      ADAValue.encode(message.value, writer.uint32(18).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): ADAOutput {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseADAOutput();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.address = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.value = ADAValue.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ADAOutput {
    return {
      address: isSet(object.address) ? globalThis.String(object.address) : "",
      value: isSet(object.value) ? ADAValue.fromJSON(object.value) : undefined,
    };
  },

  toJSON(message: ADAOutput): unknown {
    const obj: any = {};
    if (message.address !== "") {
      obj.address = message.address;
    }
    if (message.value !== undefined) {
      obj.value = ADAValue.toJSON(message.value);
    }
    return obj;
  },

  create(base?: DeepPartial<ADAOutput>): ADAOutput {
    return ADAOutput.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ADAOutput>): ADAOutput {
    const message = createBaseADAOutput();
    message.address = object.address ?? "";
    message.value = (object.value !== undefined && object.value !== null)
      ? ADAValue.fromPartial(object.value)
      : undefined;
    return message;
  },
};

function createBaseADAChangeOutput(): ADAChangeOutput {
  return { path: "", value: undefined };
}

export const ADAChangeOutput = {
  encode(message: ADAChangeOutput, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.path !== "") {
      writer.uint32(10).string(message.path);
    }
    if (message.value !== undefined) {
      ADAValue.encode(message.value, writer.uint32(18).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): ADAChangeOutput {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseADAChangeOutput();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.path = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.value = ADAValue.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ADAChangeOutput {
    return {
      path: isSet(object.path) ? globalThis.String(object.path) : "",
      value: isSet(object.value) ? ADAValue.fromJSON(object.value) : undefined,
    };
  },

  toJSON(message: ADAChangeOutput): unknown {
    const obj: any = {};
    if (message.path !== "") {
      obj.path = message.path;
    }
    if (message.value !== undefined) {
      obj.value = ADAValue.toJSON(message.value);
    }
    return obj;
  },

  create(base?: DeepPartial<ADAChangeOutput>): ADAChangeOutput {
    return ADAChangeOutput.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ADAChangeOutput>): ADAChangeOutput {
    const message = createBaseADAChangeOutput();
    message.path = object.path ?? "";
    message.value = (object.value !== undefined && object.value !== null)
      ? ADAValue.fromPartial(object.value)
      : undefined;
    return message;
  },
};

function createBaseADAWithdrawal(): ADAWithdrawal {
  return { path: "", amount: 0 };
}

export const ADAWithdrawal = {
  encode(message: ADAWithdrawal, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.path !== "") {
      writer.uint32(10).string(message.path);
    }
    if (message.amount !== 0) {
      writer.uint32(16).uint64(message.amount);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): ADAWithdrawal {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseADAWithdrawal();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.path = reader.string();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.amount = longToNumber(reader.uint64() as Long);
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ADAWithdrawal {
    return {
      path: isSet(object.path) ? globalThis.String(object.path) : "",
      amount: isSet(object.amount) ? globalThis.Number(object.amount) : 0,
    };
  },

  toJSON(message: ADAWithdrawal): unknown {
    const obj: any = {};
    if (message.path !== "") {
      obj.path = message.path;
    }
    if (message.amount !== 0) {
      obj.amount = Math.round(message.amount);
    }
    return obj;
  },

  create(base?: DeepPartial<ADAWithdrawal>): ADAWithdrawal {
    return ADAWithdrawal.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ADAWithdrawal>): ADAWithdrawal {
    const message = createBaseADAWithdrawal();
    message.path = object.path ?? "";
    message.amount = object.amount ?? 0;
    return message;
  },
};

function createBaseADATransactionRequest(): ADATransactionRequest {
  return { id: "", inputs: [], outputs: [], changeOutput: undefined, ttl: 0, fee: 0 };
}

export const ADATransactionRequest = {
  encode(message: ADATransactionRequest, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.id !== "") {
      writer.uint32(10).string(message.id);
    }
    for (const v of message.inputs) {
      ADAInput.encode(v!, writer.uint32(18).fork()).ldelim();
    }
    for (const v of message.outputs) {
      ADAOutput.encode(v!, writer.uint32(26).fork()).ldelim();
    }
    if (message.changeOutput !== undefined) {
      ADAChangeOutput.encode(message.changeOutput, writer.uint32(34).fork()).ldelim();
    }
    if (message.ttl !== 0) {
      writer.uint32(40).uint64(message.ttl);
    }
    if (message.fee !== 0) {
      writer.uint32(48).uint64(message.fee);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): ADATransactionRequest {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseADATransactionRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.id = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.inputs.push(ADAInput.decode(reader, reader.uint32()));
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.outputs.push(ADAOutput.decode(reader, reader.uint32()));
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.changeOutput = ADAChangeOutput.decode(reader, reader.uint32());
          continue;
        case 5:
          if (tag !== 40) {
            break;
          }

          message.ttl = longToNumber(reader.uint64() as Long);
          continue;
        case 6:
          if (tag !== 48) {
            break;
          }

          message.fee = longToNumber(reader.uint64() as Long);
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ADATransactionRequest {
    return {
      id: isSet(object.id) ? globalThis.String(object.id) : "",
      inputs: globalThis.Array.isArray(object?.inputs) ? object.inputs.map((e: any) => ADAInput.fromJSON(e)) : [],
      outputs: globalThis.Array.isArray(object?.outputs) ? object.outputs.map((e: any) => ADAOutput.fromJSON(e)) : [],
      changeOutput: isSet(object.changeOutput) ? ADAChangeOutput.fromJSON(object.changeOutput) : undefined,
      ttl: isSet(object.ttl) ? globalThis.Number(object.ttl) : 0,
      fee: isSet(object.fee) ? globalThis.Number(object.fee) : 0,
    };
  },

  toJSON(message: ADATransactionRequest): unknown {
    const obj: any = {};
    if (message.id !== "") {
      obj.id = message.id;
    }
    if (message.inputs?.length) {
      obj.inputs = message.inputs.map((e) => ADAInput.toJSON(e));
    }
    if (message.outputs?.length) {
      obj.outputs = message.outputs.map((e) => ADAOutput.toJSON(e));
    }
    if (message.changeOutput !== undefined) {
      obj.changeOutput = ADAChangeOutput.toJSON(message.changeOutput);
    }
    if (message.ttl !== 0) {
      obj.ttl = Math.round(message.ttl);
    }
    if (message.fee !== 0) {
      obj.fee = Math.round(message.fee);
    }
    return obj;
  },

  create(base?: DeepPartial<ADATransactionRequest>): ADATransactionRequest {
    return ADATransactionRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ADATransactionRequest>): ADATransactionRequest {
    const message = createBaseADATransactionRequest();
    message.id = object.id ?? "";
    message.inputs = object.inputs?.map((e) => ADAInput.fromPartial(e)) || [];
    message.outputs = object.outputs?.map((e) => ADAOutput.fromPartial(e)) || [];
    message.changeOutput = (object.changeOutput !== undefined && object.changeOutput !== null)
      ? ADAChangeOutput.fromPartial(object.changeOutput)
      : undefined;
    message.ttl = object.ttl ?? 0;
    message.fee = object.fee ?? 0;
    return message;
  },
};

function createBaseADAWithdrawalRequest(): ADAWithdrawalRequest {
  return { id: "", inputs: [], withdrawal: undefined, changeOutput: undefined, ttl: 0, fee: 0 };
}

export const ADAWithdrawalRequest = {
  encode(message: ADAWithdrawalRequest, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.id !== "") {
      writer.uint32(10).string(message.id);
    }
    for (const v of message.inputs) {
      ADAInput.encode(v!, writer.uint32(18).fork()).ldelim();
    }
    if (message.withdrawal !== undefined) {
      ADAWithdrawal.encode(message.withdrawal, writer.uint32(26).fork()).ldelim();
    }
    if (message.changeOutput !== undefined) {
      ADAChangeOutput.encode(message.changeOutput, writer.uint32(34).fork()).ldelim();
    }
    if (message.ttl !== 0) {
      writer.uint32(40).uint64(message.ttl);
    }
    if (message.fee !== 0) {
      writer.uint32(48).uint64(message.fee);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): ADAWithdrawalRequest {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseADAWithdrawalRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.id = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.inputs.push(ADAInput.decode(reader, reader.uint32()));
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.withdrawal = ADAWithdrawal.decode(reader, reader.uint32());
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.changeOutput = ADAChangeOutput.decode(reader, reader.uint32());
          continue;
        case 5:
          if (tag !== 40) {
            break;
          }

          message.ttl = longToNumber(reader.uint64() as Long);
          continue;
        case 6:
          if (tag !== 48) {
            break;
          }

          message.fee = longToNumber(reader.uint64() as Long);
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ADAWithdrawalRequest {
    return {
      id: isSet(object.id) ? globalThis.String(object.id) : "",
      inputs: globalThis.Array.isArray(object?.inputs) ? object.inputs.map((e: any) => ADAInput.fromJSON(e)) : [],
      withdrawal: isSet(object.withdrawal) ? ADAWithdrawal.fromJSON(object.withdrawal) : undefined,
      changeOutput: isSet(object.changeOutput) ? ADAChangeOutput.fromJSON(object.changeOutput) : undefined,
      ttl: isSet(object.ttl) ? globalThis.Number(object.ttl) : 0,
      fee: isSet(object.fee) ? globalThis.Number(object.fee) : 0,
    };
  },

  toJSON(message: ADAWithdrawalRequest): unknown {
    const obj: any = {};
    if (message.id !== "") {
      obj.id = message.id;
    }
    if (message.inputs?.length) {
      obj.inputs = message.inputs.map((e) => ADAInput.toJSON(e));
    }
    if (message.withdrawal !== undefined) {
      obj.withdrawal = ADAWithdrawal.toJSON(message.withdrawal);
    }
    if (message.changeOutput !== undefined) {
      obj.changeOutput = ADAChangeOutput.toJSON(message.changeOutput);
    }
    if (message.ttl !== 0) {
      obj.ttl = Math.round(message.ttl);
    }
    if (message.fee !== 0) {
      obj.fee = Math.round(message.fee);
    }
    return obj;
  },

  create(base?: DeepPartial<ADAWithdrawalRequest>): ADAWithdrawalRequest {
    return ADAWithdrawalRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ADAWithdrawalRequest>): ADAWithdrawalRequest {
    const message = createBaseADAWithdrawalRequest();
    message.id = object.id ?? "";
    message.inputs = object.inputs?.map((e) => ADAInput.fromPartial(e)) || [];
    message.withdrawal = (object.withdrawal !== undefined && object.withdrawal !== null)
      ? ADAWithdrawal.fromPartial(object.withdrawal)
      : undefined;
    message.changeOutput = (object.changeOutput !== undefined && object.changeOutput !== null)
      ? ADAChangeOutput.fromPartial(object.changeOutput)
      : undefined;
    message.ttl = object.ttl ?? 0;
    message.fee = object.fee ?? 0;
    return message;
  },
};

function createBaseADADrep(): ADADrep {
  return { drepType: 0, drep: "" };
}

export const ADADrep = {
  encode(message: ADADrep, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.drepType !== 0) {
      writer.uint32(8).int32(message.drepType);
    }
    if (message.drep !== "") {
      writer.uint32(18).string(message.drep);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): ADADrep {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseADADrep();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.drepType = reader.int32() as any;
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.drep = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ADADrep {
    return {
      drepType: isSet(object.drepType) ? aDADrep_DRepTypeFromJSON(object.drepType) : 0,
      drep: isSet(object.drep) ? globalThis.String(object.drep) : "",
    };
  },

  toJSON(message: ADADrep): unknown {
    const obj: any = {};
    if (message.drepType !== 0) {
      obj.drepType = aDADrep_DRepTypeToJSON(message.drepType);
    }
    if (message.drep !== "") {
      obj.drep = message.drep;
    }
    return obj;
  },

  create(base?: DeepPartial<ADADrep>): ADADrep {
    return ADADrep.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ADADrep>): ADADrep {
    const message = createBaseADADrep();
    message.drepType = object.drepType ?? 0;
    message.drep = object.drep ?? "";
    return message;
  },
};

function createBaseADADelegationRequest(): ADADelegationRequest {
  return {
    id: "",
    inputs: [],
    changeOutput: undefined,
    delegate: "",
    first: false,
    ttl: 0,
    fee: 0,
    stakePoolRegistrationCertificate: new Uint8Array(0),
    keyDeposit: 0,
    drep: undefined,
  };
}

export const ADADelegationRequest = {
  encode(message: ADADelegationRequest, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.id !== "") {
      writer.uint32(10).string(message.id);
    }
    for (const v of message.inputs) {
      ADAInput.encode(v!, writer.uint32(18).fork()).ldelim();
    }
    if (message.changeOutput !== undefined) {
      ADAChangeOutput.encode(message.changeOutput, writer.uint32(26).fork()).ldelim();
    }
    if (message.delegate !== "") {
      writer.uint32(34).string(message.delegate);
    }
    if (message.first !== false) {
      writer.uint32(40).bool(message.first);
    }
    if (message.ttl !== 0) {
      writer.uint32(48).uint64(message.ttl);
    }
    if (message.fee !== 0) {
      writer.uint32(56).uint64(message.fee);
    }
    if (message.stakePoolRegistrationCertificate.length !== 0) {
      writer.uint32(66).bytes(message.stakePoolRegistrationCertificate);
    }
    if (message.keyDeposit !== 0) {
      writer.uint32(72).uint64(message.keyDeposit);
    }
    if (message.drep !== undefined) {
      ADADrep.encode(message.drep, writer.uint32(82).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): ADADelegationRequest {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseADADelegationRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.id = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.inputs.push(ADAInput.decode(reader, reader.uint32()));
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.changeOutput = ADAChangeOutput.decode(reader, reader.uint32());
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.delegate = reader.string();
          continue;
        case 5:
          if (tag !== 40) {
            break;
          }

          message.first = reader.bool();
          continue;
        case 6:
          if (tag !== 48) {
            break;
          }

          message.ttl = longToNumber(reader.uint64() as Long);
          continue;
        case 7:
          if (tag !== 56) {
            break;
          }

          message.fee = longToNumber(reader.uint64() as Long);
          continue;
        case 8:
          if (tag !== 66) {
            break;
          }

          message.stakePoolRegistrationCertificate = reader.bytes();
          continue;
        case 9:
          if (tag !== 72) {
            break;
          }

          message.keyDeposit = longToNumber(reader.uint64() as Long);
          continue;
        case 10:
          if (tag !== 82) {
            break;
          }

          message.drep = ADADrep.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ADADelegationRequest {
    return {
      id: isSet(object.id) ? globalThis.String(object.id) : "",
      inputs: globalThis.Array.isArray(object?.inputs) ? object.inputs.map((e: any) => ADAInput.fromJSON(e)) : [],
      changeOutput: isSet(object.changeOutput) ? ADAChangeOutput.fromJSON(object.changeOutput) : undefined,
      delegate: isSet(object.delegate) ? globalThis.String(object.delegate) : "",
      first: isSet(object.first) ? globalThis.Boolean(object.first) : false,
      ttl: isSet(object.ttl) ? globalThis.Number(object.ttl) : 0,
      fee: isSet(object.fee) ? globalThis.Number(object.fee) : 0,
      stakePoolRegistrationCertificate: isSet(object.stakePoolRegistrationCertificate)
        ? bytesFromBase64(object.stakePoolRegistrationCertificate)
        : new Uint8Array(0),
      keyDeposit: isSet(object.keyDeposit) ? globalThis.Number(object.keyDeposit) : 0,
      drep: isSet(object.drep) ? ADADrep.fromJSON(object.drep) : undefined,
    };
  },

  toJSON(message: ADADelegationRequest): unknown {
    const obj: any = {};
    if (message.id !== "") {
      obj.id = message.id;
    }
    if (message.inputs?.length) {
      obj.inputs = message.inputs.map((e) => ADAInput.toJSON(e));
    }
    if (message.changeOutput !== undefined) {
      obj.changeOutput = ADAChangeOutput.toJSON(message.changeOutput);
    }
    if (message.delegate !== "") {
      obj.delegate = message.delegate;
    }
    if (message.first !== false) {
      obj.first = message.first;
    }
    if (message.ttl !== 0) {
      obj.ttl = Math.round(message.ttl);
    }
    if (message.fee !== 0) {
      obj.fee = Math.round(message.fee);
    }
    if (message.stakePoolRegistrationCertificate.length !== 0) {
      obj.stakePoolRegistrationCertificate = base64FromBytes(message.stakePoolRegistrationCertificate);
    }
    if (message.keyDeposit !== 0) {
      obj.keyDeposit = Math.round(message.keyDeposit);
    }
    if (message.drep !== undefined) {
      obj.drep = ADADrep.toJSON(message.drep);
    }
    return obj;
  },

  create(base?: DeepPartial<ADADelegationRequest>): ADADelegationRequest {
    return ADADelegationRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ADADelegationRequest>): ADADelegationRequest {
    const message = createBaseADADelegationRequest();
    message.id = object.id ?? "";
    message.inputs = object.inputs?.map((e) => ADAInput.fromPartial(e)) || [];
    message.changeOutput = (object.changeOutput !== undefined && object.changeOutput !== null)
      ? ADAChangeOutput.fromPartial(object.changeOutput)
      : undefined;
    message.delegate = object.delegate ?? "";
    message.first = object.first ?? false;
    message.ttl = object.ttl ?? 0;
    message.fee = object.fee ?? 0;
    message.stakePoolRegistrationCertificate = object.stakePoolRegistrationCertificate ?? new Uint8Array(0);
    message.keyDeposit = object.keyDeposit ?? 0;
    message.drep = (object.drep !== undefined && object.drep !== null) ? ADADrep.fromPartial(object.drep) : undefined;
    return message;
  },
};

function createBaseADAUndelegationRequest(): ADAUndelegationRequest {
  return { id: "", inputs: [], changeOutput: undefined, withdrawal: undefined, ttl: 0, fee: 0, keyDeposit: 0 };
}

export const ADAUndelegationRequest = {
  encode(message: ADAUndelegationRequest, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.id !== "") {
      writer.uint32(10).string(message.id);
    }
    for (const v of message.inputs) {
      ADAInput.encode(v!, writer.uint32(18).fork()).ldelim();
    }
    if (message.changeOutput !== undefined) {
      ADAChangeOutput.encode(message.changeOutput, writer.uint32(26).fork()).ldelim();
    }
    if (message.withdrawal !== undefined) {
      ADAWithdrawal.encode(message.withdrawal, writer.uint32(34).fork()).ldelim();
    }
    if (message.ttl !== 0) {
      writer.uint32(40).uint64(message.ttl);
    }
    if (message.fee !== 0) {
      writer.uint32(48).uint64(message.fee);
    }
    if (message.keyDeposit !== 0) {
      writer.uint32(56).uint64(message.keyDeposit);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): ADAUndelegationRequest {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseADAUndelegationRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.id = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.inputs.push(ADAInput.decode(reader, reader.uint32()));
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.changeOutput = ADAChangeOutput.decode(reader, reader.uint32());
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.withdrawal = ADAWithdrawal.decode(reader, reader.uint32());
          continue;
        case 5:
          if (tag !== 40) {
            break;
          }

          message.ttl = longToNumber(reader.uint64() as Long);
          continue;
        case 6:
          if (tag !== 48) {
            break;
          }

          message.fee = longToNumber(reader.uint64() as Long);
          continue;
        case 7:
          if (tag !== 56) {
            break;
          }

          message.keyDeposit = longToNumber(reader.uint64() as Long);
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ADAUndelegationRequest {
    return {
      id: isSet(object.id) ? globalThis.String(object.id) : "",
      inputs: globalThis.Array.isArray(object?.inputs) ? object.inputs.map((e: any) => ADAInput.fromJSON(e)) : [],
      changeOutput: isSet(object.changeOutput) ? ADAChangeOutput.fromJSON(object.changeOutput) : undefined,
      withdrawal: isSet(object.withdrawal) ? ADAWithdrawal.fromJSON(object.withdrawal) : undefined,
      ttl: isSet(object.ttl) ? globalThis.Number(object.ttl) : 0,
      fee: isSet(object.fee) ? globalThis.Number(object.fee) : 0,
      keyDeposit: isSet(object.keyDeposit) ? globalThis.Number(object.keyDeposit) : 0,
    };
  },

  toJSON(message: ADAUndelegationRequest): unknown {
    const obj: any = {};
    if (message.id !== "") {
      obj.id = message.id;
    }
    if (message.inputs?.length) {
      obj.inputs = message.inputs.map((e) => ADAInput.toJSON(e));
    }
    if (message.changeOutput !== undefined) {
      obj.changeOutput = ADAChangeOutput.toJSON(message.changeOutput);
    }
    if (message.withdrawal !== undefined) {
      obj.withdrawal = ADAWithdrawal.toJSON(message.withdrawal);
    }
    if (message.ttl !== 0) {
      obj.ttl = Math.round(message.ttl);
    }
    if (message.fee !== 0) {
      obj.fee = Math.round(message.fee);
    }
    if (message.keyDeposit !== 0) {
      obj.keyDeposit = Math.round(message.keyDeposit);
    }
    return obj;
  },

  create(base?: DeepPartial<ADAUndelegationRequest>): ADAUndelegationRequest {
    return ADAUndelegationRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ADAUndelegationRequest>): ADAUndelegationRequest {
    const message = createBaseADAUndelegationRequest();
    message.id = object.id ?? "";
    message.inputs = object.inputs?.map((e) => ADAInput.fromPartial(e)) || [];
    message.changeOutput = (object.changeOutput !== undefined && object.changeOutput !== null)
      ? ADAChangeOutput.fromPartial(object.changeOutput)
      : undefined;
    message.withdrawal = (object.withdrawal !== undefined && object.withdrawal !== null)
      ? ADAWithdrawal.fromPartial(object.withdrawal)
      : undefined;
    message.ttl = object.ttl ?? 0;
    message.fee = object.fee ?? 0;
    message.keyDeposit = object.keyDeposit ?? 0;
    return message;
  },
};

function createBaseADAVoteDelegationRequest(): ADAVoteDelegationRequest {
  return { id: "", inputs: [], changeOutput: undefined, drep: undefined, ttl: 0, fee: 0 };
}

export const ADAVoteDelegationRequest = {
  encode(message: ADAVoteDelegationRequest, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.id !== "") {
      writer.uint32(10).string(message.id);
    }
    for (const v of message.inputs) {
      ADAInput.encode(v!, writer.uint32(18).fork()).ldelim();
    }
    if (message.changeOutput !== undefined) {
      ADAChangeOutput.encode(message.changeOutput, writer.uint32(26).fork()).ldelim();
    }
    if (message.drep !== undefined) {
      ADADrep.encode(message.drep, writer.uint32(34).fork()).ldelim();
    }
    if (message.ttl !== 0) {
      writer.uint32(40).uint64(message.ttl);
    }
    if (message.fee !== 0) {
      writer.uint32(48).uint64(message.fee);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): ADAVoteDelegationRequest {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseADAVoteDelegationRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.id = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.inputs.push(ADAInput.decode(reader, reader.uint32()));
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.changeOutput = ADAChangeOutput.decode(reader, reader.uint32());
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.drep = ADADrep.decode(reader, reader.uint32());
          continue;
        case 5:
          if (tag !== 40) {
            break;
          }

          message.ttl = longToNumber(reader.uint64() as Long);
          continue;
        case 6:
          if (tag !== 48) {
            break;
          }

          message.fee = longToNumber(reader.uint64() as Long);
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ADAVoteDelegationRequest {
    return {
      id: isSet(object.id) ? globalThis.String(object.id) : "",
      inputs: globalThis.Array.isArray(object?.inputs) ? object.inputs.map((e: any) => ADAInput.fromJSON(e)) : [],
      changeOutput: isSet(object.changeOutput) ? ADAChangeOutput.fromJSON(object.changeOutput) : undefined,
      drep: isSet(object.drep) ? ADADrep.fromJSON(object.drep) : undefined,
      ttl: isSet(object.ttl) ? globalThis.Number(object.ttl) : 0,
      fee: isSet(object.fee) ? globalThis.Number(object.fee) : 0,
    };
  },

  toJSON(message: ADAVoteDelegationRequest): unknown {
    const obj: any = {};
    if (message.id !== "") {
      obj.id = message.id;
    }
    if (message.inputs?.length) {
      obj.inputs = message.inputs.map((e) => ADAInput.toJSON(e));
    }
    if (message.changeOutput !== undefined) {
      obj.changeOutput = ADAChangeOutput.toJSON(message.changeOutput);
    }
    if (message.drep !== undefined) {
      obj.drep = ADADrep.toJSON(message.drep);
    }
    if (message.ttl !== 0) {
      obj.ttl = Math.round(message.ttl);
    }
    if (message.fee !== 0) {
      obj.fee = Math.round(message.fee);
    }
    return obj;
  },

  create(base?: DeepPartial<ADAVoteDelegationRequest>): ADAVoteDelegationRequest {
    return ADAVoteDelegationRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ADAVoteDelegationRequest>): ADAVoteDelegationRequest {
    const message = createBaseADAVoteDelegationRequest();
    message.id = object.id ?? "";
    message.inputs = object.inputs?.map((e) => ADAInput.fromPartial(e)) || [];
    message.changeOutput = (object.changeOutput !== undefined && object.changeOutput !== null)
      ? ADAChangeOutput.fromPartial(object.changeOutput)
      : undefined;
    message.drep = (object.drep !== undefined && object.drep !== null) ? ADADrep.fromPartial(object.drep) : undefined;
    message.ttl = object.ttl ?? 0;
    message.fee = object.fee ?? 0;
    return message;
  },
};

function createBaseADAProofOfReserveRequest(): ADAProofOfReserveRequest {
  return { path: "", challenge: "" };
}

export const ADAProofOfReserveRequest = {
  encode(message: ADAProofOfReserveRequest, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.path !== "") {
      writer.uint32(10).string(message.path);
    }
    if (message.challenge !== "") {
      writer.uint32(18).string(message.challenge);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): ADAProofOfReserveRequest {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseADAProofOfReserveRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.path = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.challenge = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ADAProofOfReserveRequest {
    return {
      path: isSet(object.path) ? globalThis.String(object.path) : "",
      challenge: isSet(object.challenge) ? globalThis.String(object.challenge) : "",
    };
  },

  toJSON(message: ADAProofOfReserveRequest): unknown {
    const obj: any = {};
    if (message.path !== "") {
      obj.path = message.path;
    }
    if (message.challenge !== "") {
      obj.challenge = message.challenge;
    }
    return obj;
  },

  create(base?: DeepPartial<ADAProofOfReserveRequest>): ADAProofOfReserveRequest {
    return ADAProofOfReserveRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ADAProofOfReserveRequest>): ADAProofOfReserveRequest {
    const message = createBaseADAProofOfReserveRequest();
    message.path = object.path ?? "";
    message.challenge = object.challenge ?? "";
    return message;
  },
};

function createBaseADAProofOfReserveResponse(): ADAProofOfReserveResponse {
  return {
    address: "",
    path: "",
    challenge: "",
    paymentPublicKey: new Uint8Array(0),
    paymentChallengeResponse: new Uint8Array(0),
    stakePublicKey: new Uint8Array(0),
    stakeChallengeResponse: new Uint8Array(0),
  };
}

export const ADAProofOfReserveResponse = {
  encode(message: ADAProofOfReserveResponse, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.address !== "") {
      writer.uint32(26).string(message.address);
    }
    if (message.path !== "") {
      writer.uint32(34).string(message.path);
    }
    if (message.challenge !== "") {
      writer.uint32(42).string(message.challenge);
    }
    if (message.paymentPublicKey.length !== 0) {
      writer.uint32(50).bytes(message.paymentPublicKey);
    }
    if (message.paymentChallengeResponse.length !== 0) {
      writer.uint32(58).bytes(message.paymentChallengeResponse);
    }
    if (message.stakePublicKey.length !== 0) {
      writer.uint32(66).bytes(message.stakePublicKey);
    }
    if (message.stakeChallengeResponse.length !== 0) {
      writer.uint32(74).bytes(message.stakeChallengeResponse);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): ADAProofOfReserveResponse {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseADAProofOfReserveResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 3:
          if (tag !== 26) {
            break;
          }

          message.address = reader.string();
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.path = reader.string();
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.challenge = reader.string();
          continue;
        case 6:
          if (tag !== 50) {
            break;
          }

          message.paymentPublicKey = reader.bytes();
          continue;
        case 7:
          if (tag !== 58) {
            break;
          }

          message.paymentChallengeResponse = reader.bytes();
          continue;
        case 8:
          if (tag !== 66) {
            break;
          }

          message.stakePublicKey = reader.bytes();
          continue;
        case 9:
          if (tag !== 74) {
            break;
          }

          message.stakeChallengeResponse = reader.bytes();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ADAProofOfReserveResponse {
    return {
      address: isSet(object.address) ? globalThis.String(object.address) : "",
      path: isSet(object.path) ? globalThis.String(object.path) : "",
      challenge: isSet(object.challenge) ? globalThis.String(object.challenge) : "",
      paymentPublicKey: isSet(object.paymentPublicKey) ? bytesFromBase64(object.paymentPublicKey) : new Uint8Array(0),
      paymentChallengeResponse: isSet(object.paymentChallengeResponse)
        ? bytesFromBase64(object.paymentChallengeResponse)
        : new Uint8Array(0),
      stakePublicKey: isSet(object.stakePublicKey) ? bytesFromBase64(object.stakePublicKey) : new Uint8Array(0),
      stakeChallengeResponse: isSet(object.stakeChallengeResponse)
        ? bytesFromBase64(object.stakeChallengeResponse)
        : new Uint8Array(0),
    };
  },

  toJSON(message: ADAProofOfReserveResponse): unknown {
    const obj: any = {};
    if (message.address !== "") {
      obj.address = message.address;
    }
    if (message.path !== "") {
      obj.path = message.path;
    }
    if (message.challenge !== "") {
      obj.challenge = message.challenge;
    }
    if (message.paymentPublicKey.length !== 0) {
      obj.paymentPublicKey = base64FromBytes(message.paymentPublicKey);
    }
    if (message.paymentChallengeResponse.length !== 0) {
      obj.paymentChallengeResponse = base64FromBytes(message.paymentChallengeResponse);
    }
    if (message.stakePublicKey.length !== 0) {
      obj.stakePublicKey = base64FromBytes(message.stakePublicKey);
    }
    if (message.stakeChallengeResponse.length !== 0) {
      obj.stakeChallengeResponse = base64FromBytes(message.stakeChallengeResponse);
    }
    return obj;
  },

  create(base?: DeepPartial<ADAProofOfReserveResponse>): ADAProofOfReserveResponse {
    return ADAProofOfReserveResponse.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ADAProofOfReserveResponse>): ADAProofOfReserveResponse {
    const message = createBaseADAProofOfReserveResponse();
    message.address = object.address ?? "";
    message.path = object.path ?? "";
    message.challenge = object.challenge ?? "";
    message.paymentPublicKey = object.paymentPublicKey ?? new Uint8Array(0);
    message.paymentChallengeResponse = object.paymentChallengeResponse ?? new Uint8Array(0);
    message.stakePublicKey = object.stakePublicKey ?? new Uint8Array(0);
    message.stakeChallengeResponse = object.stakeChallengeResponse ?? new Uint8Array(0);
    return message;
  },
};

function createBaseXLMAsset(): XLMAsset {
  return { type: 0, alphanum: undefined, pool: undefined };
}

export const XLMAsset = {
  encode(message: XLMAsset, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.type !== 0) {
      writer.uint32(8).int32(message.type);
    }
    if (message.alphanum !== undefined) {
      XLMAsset_Alphanum.encode(message.alphanum, writer.uint32(18).fork()).ldelim();
    }
    if (message.pool !== undefined) {
      XLMAsset_LiquidityPoolParams.encode(message.pool, writer.uint32(26).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): XLMAsset {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseXLMAsset();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.type = reader.int32() as any;
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.alphanum = XLMAsset_Alphanum.decode(reader, reader.uint32());
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.pool = XLMAsset_LiquidityPoolParams.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): XLMAsset {
    return {
      type: isSet(object.type) ? xLMAsset_AssetTypeFromJSON(object.type) : 0,
      alphanum: isSet(object.alphanum) ? XLMAsset_Alphanum.fromJSON(object.alphanum) : undefined,
      pool: isSet(object.pool) ? XLMAsset_LiquidityPoolParams.fromJSON(object.pool) : undefined,
    };
  },

  toJSON(message: XLMAsset): unknown {
    const obj: any = {};
    if (message.type !== 0) {
      obj.type = xLMAsset_AssetTypeToJSON(message.type);
    }
    if (message.alphanum !== undefined) {
      obj.alphanum = XLMAsset_Alphanum.toJSON(message.alphanum);
    }
    if (message.pool !== undefined) {
      obj.pool = XLMAsset_LiquidityPoolParams.toJSON(message.pool);
    }
    return obj;
  },

  create(base?: DeepPartial<XLMAsset>): XLMAsset {
    return XLMAsset.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<XLMAsset>): XLMAsset {
    const message = createBaseXLMAsset();
    message.type = object.type ?? 0;
    message.alphanum = (object.alphanum !== undefined && object.alphanum !== null)
      ? XLMAsset_Alphanum.fromPartial(object.alphanum)
      : undefined;
    message.pool = (object.pool !== undefined && object.pool !== null)
      ? XLMAsset_LiquidityPoolParams.fromPartial(object.pool)
      : undefined;
    return message;
  },
};

function createBaseXLMAsset_Alphanum(): XLMAsset_Alphanum {
  return { assetID: "", issuer: "" };
}

export const XLMAsset_Alphanum = {
  encode(message: XLMAsset_Alphanum, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.assetID !== "") {
      writer.uint32(10).string(message.assetID);
    }
    if (message.issuer !== "") {
      writer.uint32(18).string(message.issuer);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): XLMAsset_Alphanum {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseXLMAsset_Alphanum();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.assetID = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.issuer = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): XLMAsset_Alphanum {
    return {
      assetID: isSet(object.assetID) ? globalThis.String(object.assetID) : "",
      issuer: isSet(object.issuer) ? globalThis.String(object.issuer) : "",
    };
  },

  toJSON(message: XLMAsset_Alphanum): unknown {
    const obj: any = {};
    if (message.assetID !== "") {
      obj.assetID = message.assetID;
    }
    if (message.issuer !== "") {
      obj.issuer = message.issuer;
    }
    return obj;
  },

  create(base?: DeepPartial<XLMAsset_Alphanum>): XLMAsset_Alphanum {
    return XLMAsset_Alphanum.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<XLMAsset_Alphanum>): XLMAsset_Alphanum {
    const message = createBaseXLMAsset_Alphanum();
    message.assetID = object.assetID ?? "";
    message.issuer = object.issuer ?? "";
    return message;
  },
};

function createBaseXLMAsset_LiquidityPoolParams(): XLMAsset_LiquidityPoolParams {
  return { assetA: undefined, assetB: undefined, fee: 0 };
}

export const XLMAsset_LiquidityPoolParams = {
  encode(message: XLMAsset_LiquidityPoolParams, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.assetA !== undefined) {
      XLMAsset.encode(message.assetA, writer.uint32(10).fork()).ldelim();
    }
    if (message.assetB !== undefined) {
      XLMAsset.encode(message.assetB, writer.uint32(18).fork()).ldelim();
    }
    if (message.fee !== 0) {
      writer.uint32(24).int32(message.fee);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): XLMAsset_LiquidityPoolParams {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseXLMAsset_LiquidityPoolParams();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.assetA = XLMAsset.decode(reader, reader.uint32());
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.assetB = XLMAsset.decode(reader, reader.uint32());
          continue;
        case 3:
          if (tag !== 24) {
            break;
          }

          message.fee = reader.int32();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): XLMAsset_LiquidityPoolParams {
    return {
      assetA: isSet(object.assetA) ? XLMAsset.fromJSON(object.assetA) : undefined,
      assetB: isSet(object.assetB) ? XLMAsset.fromJSON(object.assetB) : undefined,
      fee: isSet(object.fee) ? globalThis.Number(object.fee) : 0,
    };
  },

  toJSON(message: XLMAsset_LiquidityPoolParams): unknown {
    const obj: any = {};
    if (message.assetA !== undefined) {
      obj.assetA = XLMAsset.toJSON(message.assetA);
    }
    if (message.assetB !== undefined) {
      obj.assetB = XLMAsset.toJSON(message.assetB);
    }
    if (message.fee !== 0) {
      obj.fee = Math.round(message.fee);
    }
    return obj;
  },

  create(base?: DeepPartial<XLMAsset_LiquidityPoolParams>): XLMAsset_LiquidityPoolParams {
    return XLMAsset_LiquidityPoolParams.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<XLMAsset_LiquidityPoolParams>): XLMAsset_LiquidityPoolParams {
    const message = createBaseXLMAsset_LiquidityPoolParams();
    message.assetA = (object.assetA !== undefined && object.assetA !== null)
      ? XLMAsset.fromPartial(object.assetA)
      : undefined;
    message.assetB = (object.assetB !== undefined && object.assetB !== null)
      ? XLMAsset.fromPartial(object.assetB)
      : undefined;
    message.fee = object.fee ?? 0;
    return message;
  },
};

function createBaseXLMLedgerEntry(): XLMLedgerEntry {
  return { type: 0, account: "", asset: undefined, offerId: 0, dataName: "", claimableBalanceID: new Uint8Array(0) };
}

export const XLMLedgerEntry = {
  encode(message: XLMLedgerEntry, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.type !== 0) {
      writer.uint32(8).int32(message.type);
    }
    if (message.account !== "") {
      writer.uint32(18).string(message.account);
    }
    if (message.asset !== undefined) {
      XLMAsset.encode(message.asset, writer.uint32(26).fork()).ldelim();
    }
    if (message.offerId !== 0) {
      writer.uint32(32).int64(message.offerId);
    }
    if (message.dataName !== "") {
      writer.uint32(42).string(message.dataName);
    }
    if (message.claimableBalanceID.length !== 0) {
      writer.uint32(50).bytes(message.claimableBalanceID);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): XLMLedgerEntry {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseXLMLedgerEntry();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.type = reader.int32() as any;
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.account = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.asset = XLMAsset.decode(reader, reader.uint32());
          continue;
        case 4:
          if (tag !== 32) {
            break;
          }

          message.offerId = longToNumber(reader.int64() as Long);
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.dataName = reader.string();
          continue;
        case 6:
          if (tag !== 50) {
            break;
          }

          message.claimableBalanceID = reader.bytes();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): XLMLedgerEntry {
    return {
      type: isSet(object.type) ? xLMLedgerEntry_LedgerEntryTypeFromJSON(object.type) : 0,
      account: isSet(object.account) ? globalThis.String(object.account) : "",
      asset: isSet(object.asset) ? XLMAsset.fromJSON(object.asset) : undefined,
      offerId: isSet(object.offerId) ? globalThis.Number(object.offerId) : 0,
      dataName: isSet(object.dataName) ? globalThis.String(object.dataName) : "",
      claimableBalanceID: isSet(object.claimableBalanceID)
        ? bytesFromBase64(object.claimableBalanceID)
        : new Uint8Array(0),
    };
  },

  toJSON(message: XLMLedgerEntry): unknown {
    const obj: any = {};
    if (message.type !== 0) {
      obj.type = xLMLedgerEntry_LedgerEntryTypeToJSON(message.type);
    }
    if (message.account !== "") {
      obj.account = message.account;
    }
    if (message.asset !== undefined) {
      obj.asset = XLMAsset.toJSON(message.asset);
    }
    if (message.offerId !== 0) {
      obj.offerId = Math.round(message.offerId);
    }
    if (message.dataName !== "") {
      obj.dataName = message.dataName;
    }
    if (message.claimableBalanceID.length !== 0) {
      obj.claimableBalanceID = base64FromBytes(message.claimableBalanceID);
    }
    return obj;
  },

  create(base?: DeepPartial<XLMLedgerEntry>): XLMLedgerEntry {
    return XLMLedgerEntry.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<XLMLedgerEntry>): XLMLedgerEntry {
    const message = createBaseXLMLedgerEntry();
    message.type = object.type ?? 0;
    message.account = object.account ?? "";
    message.asset = (object.asset !== undefined && object.asset !== null)
      ? XLMAsset.fromPartial(object.asset)
      : undefined;
    message.offerId = object.offerId ?? 0;
    message.dataName = object.dataName ?? "";
    message.claimableBalanceID = object.claimableBalanceID ?? new Uint8Array(0);
    return message;
  },
};

function createBaseXLMTransactionDetails(): XLMTransactionDetails {
  return {
    id: "",
    from: "",
    fee: 0,
    minimumTime: 0,
    maximumTime: 0,
    memo: "",
    sequence: 0,
    isSequenceSet: false,
    sponsoredBy: "",
  };
}

export const XLMTransactionDetails = {
  encode(message: XLMTransactionDetails, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.id !== "") {
      writer.uint32(10).string(message.id);
    }
    if (message.from !== "") {
      writer.uint32(18).string(message.from);
    }
    if (message.fee !== 0) {
      writer.uint32(24).uint64(message.fee);
    }
    if (message.minimumTime !== 0) {
      writer.uint32(32).uint64(message.minimumTime);
    }
    if (message.maximumTime !== 0) {
      writer.uint32(40).uint64(message.maximumTime);
    }
    if (message.memo !== "") {
      writer.uint32(50).string(message.memo);
    }
    if (message.sequence !== 0) {
      writer.uint32(56).uint64(message.sequence);
    }
    if (message.isSequenceSet !== false) {
      writer.uint32(64).bool(message.isSequenceSet);
    }
    if (message.sponsoredBy !== "") {
      writer.uint32(74).string(message.sponsoredBy);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): XLMTransactionDetails {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseXLMTransactionDetails();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.id = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.from = reader.string();
          continue;
        case 3:
          if (tag !== 24) {
            break;
          }

          message.fee = longToNumber(reader.uint64() as Long);
          continue;
        case 4:
          if (tag !== 32) {
            break;
          }

          message.minimumTime = longToNumber(reader.uint64() as Long);
          continue;
        case 5:
          if (tag !== 40) {
            break;
          }

          message.maximumTime = longToNumber(reader.uint64() as Long);
          continue;
        case 6:
          if (tag !== 50) {
            break;
          }

          message.memo = reader.string();
          continue;
        case 7:
          if (tag !== 56) {
            break;
          }

          message.sequence = longToNumber(reader.uint64() as Long);
          continue;
        case 8:
          if (tag !== 64) {
            break;
          }

          message.isSequenceSet = reader.bool();
          continue;
        case 9:
          if (tag !== 74) {
            break;
          }

          message.sponsoredBy = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): XLMTransactionDetails {
    return {
      id: isSet(object.id) ? globalThis.String(object.id) : "",
      from: isSet(object.from) ? globalThis.String(object.from) : "",
      fee: isSet(object.fee) ? globalThis.Number(object.fee) : 0,
      minimumTime: isSet(object.minimumTime) ? globalThis.Number(object.minimumTime) : 0,
      maximumTime: isSet(object.maximumTime) ? globalThis.Number(object.maximumTime) : 0,
      memo: isSet(object.memo) ? globalThis.String(object.memo) : "",
      sequence: isSet(object.sequence) ? globalThis.Number(object.sequence) : 0,
      isSequenceSet: isSet(object.isSequenceSet) ? globalThis.Boolean(object.isSequenceSet) : false,
      sponsoredBy: isSet(object.sponsoredBy) ? globalThis.String(object.sponsoredBy) : "",
    };
  },

  toJSON(message: XLMTransactionDetails): unknown {
    const obj: any = {};
    if (message.id !== "") {
      obj.id = message.id;
    }
    if (message.from !== "") {
      obj.from = message.from;
    }
    if (message.fee !== 0) {
      obj.fee = Math.round(message.fee);
    }
    if (message.minimumTime !== 0) {
      obj.minimumTime = Math.round(message.minimumTime);
    }
    if (message.maximumTime !== 0) {
      obj.maximumTime = Math.round(message.maximumTime);
    }
    if (message.memo !== "") {
      obj.memo = message.memo;
    }
    if (message.sequence !== 0) {
      obj.sequence = Math.round(message.sequence);
    }
    if (message.isSequenceSet !== false) {
      obj.isSequenceSet = message.isSequenceSet;
    }
    if (message.sponsoredBy !== "") {
      obj.sponsoredBy = message.sponsoredBy;
    }
    return obj;
  },

  create(base?: DeepPartial<XLMTransactionDetails>): XLMTransactionDetails {
    return XLMTransactionDetails.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<XLMTransactionDetails>): XLMTransactionDetails {
    const message = createBaseXLMTransactionDetails();
    message.id = object.id ?? "";
    message.from = object.from ?? "";
    message.fee = object.fee ?? 0;
    message.minimumTime = object.minimumTime ?? 0;
    message.maximumTime = object.maximumTime ?? 0;
    message.memo = object.memo ?? "";
    message.sequence = object.sequence ?? 0;
    message.isSequenceSet = object.isSequenceSet ?? false;
    message.sponsoredBy = object.sponsoredBy ?? "";
    return message;
  },
};

function createBaseXLMMintAssetRequest(): XLMMintAssetRequest {
  return { details: undefined, assetId: "", amount: 0, destination: "" };
}

export const XLMMintAssetRequest = {
  encode(message: XLMMintAssetRequest, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.details !== undefined) {
      XLMTransactionDetails.encode(message.details, writer.uint32(10).fork()).ldelim();
    }
    if (message.assetId !== "") {
      writer.uint32(18).string(message.assetId);
    }
    if (message.amount !== 0) {
      writer.uint32(24).uint64(message.amount);
    }
    if (message.destination !== "") {
      writer.uint32(34).string(message.destination);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): XLMMintAssetRequest {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseXLMMintAssetRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.details = XLMTransactionDetails.decode(reader, reader.uint32());
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.assetId = reader.string();
          continue;
        case 3:
          if (tag !== 24) {
            break;
          }

          message.amount = longToNumber(reader.uint64() as Long);
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.destination = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): XLMMintAssetRequest {
    return {
      details: isSet(object.details) ? XLMTransactionDetails.fromJSON(object.details) : undefined,
      assetId: isSet(object.assetId) ? globalThis.String(object.assetId) : "",
      amount: isSet(object.amount) ? globalThis.Number(object.amount) : 0,
      destination: isSet(object.destination) ? globalThis.String(object.destination) : "",
    };
  },

  toJSON(message: XLMMintAssetRequest): unknown {
    const obj: any = {};
    if (message.details !== undefined) {
      obj.details = XLMTransactionDetails.toJSON(message.details);
    }
    if (message.assetId !== "") {
      obj.assetId = message.assetId;
    }
    if (message.amount !== 0) {
      obj.amount = Math.round(message.amount);
    }
    if (message.destination !== "") {
      obj.destination = message.destination;
    }
    return obj;
  },

  create(base?: DeepPartial<XLMMintAssetRequest>): XLMMintAssetRequest {
    return XLMMintAssetRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<XLMMintAssetRequest>): XLMMintAssetRequest {
    const message = createBaseXLMMintAssetRequest();
    message.details = (object.details !== undefined && object.details !== null)
      ? XLMTransactionDetails.fromPartial(object.details)
      : undefined;
    message.assetId = object.assetId ?? "";
    message.amount = object.amount ?? 0;
    message.destination = object.destination ?? "";
    return message;
  },
};

function createBaseXLMChangeTrustRequest(): XLMChangeTrustRequest {
  return { details: undefined, asset: undefined, limit: 0 };
}

export const XLMChangeTrustRequest = {
  encode(message: XLMChangeTrustRequest, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.details !== undefined) {
      XLMTransactionDetails.encode(message.details, writer.uint32(10).fork()).ldelim();
    }
    if (message.asset !== undefined) {
      XLMAsset.encode(message.asset, writer.uint32(18).fork()).ldelim();
    }
    if (message.limit !== 0) {
      writer.uint32(24).uint64(message.limit);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): XLMChangeTrustRequest {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseXLMChangeTrustRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.details = XLMTransactionDetails.decode(reader, reader.uint32());
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.asset = XLMAsset.decode(reader, reader.uint32());
          continue;
        case 3:
          if (tag !== 24) {
            break;
          }

          message.limit = longToNumber(reader.uint64() as Long);
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): XLMChangeTrustRequest {
    return {
      details: isSet(object.details) ? XLMTransactionDetails.fromJSON(object.details) : undefined,
      asset: isSet(object.asset) ? XLMAsset.fromJSON(object.asset) : undefined,
      limit: isSet(object.limit) ? globalThis.Number(object.limit) : 0,
    };
  },

  toJSON(message: XLMChangeTrustRequest): unknown {
    const obj: any = {};
    if (message.details !== undefined) {
      obj.details = XLMTransactionDetails.toJSON(message.details);
    }
    if (message.asset !== undefined) {
      obj.asset = XLMAsset.toJSON(message.asset);
    }
    if (message.limit !== 0) {
      obj.limit = Math.round(message.limit);
    }
    return obj;
  },

  create(base?: DeepPartial<XLMChangeTrustRequest>): XLMChangeTrustRequest {
    return XLMChangeTrustRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<XLMChangeTrustRequest>): XLMChangeTrustRequest {
    const message = createBaseXLMChangeTrustRequest();
    message.details = (object.details !== undefined && object.details !== null)
      ? XLMTransactionDetails.fromPartial(object.details)
      : undefined;
    message.asset = (object.asset !== undefined && object.asset !== null)
      ? XLMAsset.fromPartial(object.asset)
      : undefined;
    message.limit = object.limit ?? 0;
    return message;
  },
};

function createBaseXLMSetTrustlineFlagsRequest(): XLMSetTrustlineFlagsRequest {
  return { details: undefined, trustor: "", asset: undefined, setFlags: 0, clearFlags: 0 };
}

export const XLMSetTrustlineFlagsRequest = {
  encode(message: XLMSetTrustlineFlagsRequest, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.details !== undefined) {
      XLMTransactionDetails.encode(message.details, writer.uint32(10).fork()).ldelim();
    }
    if (message.trustor !== "") {
      writer.uint32(18).string(message.trustor);
    }
    if (message.asset !== undefined) {
      XLMAsset.encode(message.asset, writer.uint32(26).fork()).ldelim();
    }
    if (message.setFlags !== 0) {
      writer.uint32(32).uint32(message.setFlags);
    }
    if (message.clearFlags !== 0) {
      writer.uint32(40).uint32(message.clearFlags);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): XLMSetTrustlineFlagsRequest {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseXLMSetTrustlineFlagsRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.details = XLMTransactionDetails.decode(reader, reader.uint32());
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.trustor = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.asset = XLMAsset.decode(reader, reader.uint32());
          continue;
        case 4:
          if (tag !== 32) {
            break;
          }

          message.setFlags = reader.uint32();
          continue;
        case 5:
          if (tag !== 40) {
            break;
          }

          message.clearFlags = reader.uint32();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): XLMSetTrustlineFlagsRequest {
    return {
      details: isSet(object.details) ? XLMTransactionDetails.fromJSON(object.details) : undefined,
      trustor: isSet(object.trustor) ? globalThis.String(object.trustor) : "",
      asset: isSet(object.asset) ? XLMAsset.fromJSON(object.asset) : undefined,
      setFlags: isSet(object.setFlags) ? globalThis.Number(object.setFlags) : 0,
      clearFlags: isSet(object.clearFlags) ? globalThis.Number(object.clearFlags) : 0,
    };
  },

  toJSON(message: XLMSetTrustlineFlagsRequest): unknown {
    const obj: any = {};
    if (message.details !== undefined) {
      obj.details = XLMTransactionDetails.toJSON(message.details);
    }
    if (message.trustor !== "") {
      obj.trustor = message.trustor;
    }
    if (message.asset !== undefined) {
      obj.asset = XLMAsset.toJSON(message.asset);
    }
    if (message.setFlags !== 0) {
      obj.setFlags = Math.round(message.setFlags);
    }
    if (message.clearFlags !== 0) {
      obj.clearFlags = Math.round(message.clearFlags);
    }
    return obj;
  },

  create(base?: DeepPartial<XLMSetTrustlineFlagsRequest>): XLMSetTrustlineFlagsRequest {
    return XLMSetTrustlineFlagsRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<XLMSetTrustlineFlagsRequest>): XLMSetTrustlineFlagsRequest {
    const message = createBaseXLMSetTrustlineFlagsRequest();
    message.details = (object.details !== undefined && object.details !== null)
      ? XLMTransactionDetails.fromPartial(object.details)
      : undefined;
    message.trustor = object.trustor ?? "";
    message.asset = (object.asset !== undefined && object.asset !== null)
      ? XLMAsset.fromPartial(object.asset)
      : undefined;
    message.setFlags = object.setFlags ?? 0;
    message.clearFlags = object.clearFlags ?? 0;
    return message;
  },
};

function createBaseXLMPaymentsRequest(): XLMPaymentsRequest {
  return { payments: [] };
}

export const XLMPaymentsRequest = {
  encode(message: XLMPaymentsRequest, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    for (const v of message.payments) {
      XLMPayment.encode(v!, writer.uint32(10).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): XLMPaymentsRequest {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseXLMPaymentsRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.payments.push(XLMPayment.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): XLMPaymentsRequest {
    return {
      payments: globalThis.Array.isArray(object?.payments)
        ? object.payments.map((e: any) => XLMPayment.fromJSON(e))
        : [],
    };
  },

  toJSON(message: XLMPaymentsRequest): unknown {
    const obj: any = {};
    if (message.payments?.length) {
      obj.payments = message.payments.map((e) => XLMPayment.toJSON(e));
    }
    return obj;
  },

  create(base?: DeepPartial<XLMPaymentsRequest>): XLMPaymentsRequest {
    return XLMPaymentsRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<XLMPaymentsRequest>): XLMPaymentsRequest {
    const message = createBaseXLMPaymentsRequest();
    message.payments = object.payments?.map((e) => XLMPayment.fromPartial(e)) || [];
    return message;
  },
};

function createBaseXLMPayment(): XLMPayment {
  return {
    from: "",
    fee: 0,
    minimumTime: 0,
    maximumTime: 0,
    memo: "",
    to: "",
    amount: 0,
    sequence: 0,
    id: "",
    operation: 0,
    isSequenceSet: false,
    asset: undefined,
    sponsoredBy: "",
  };
}

export const XLMPayment = {
  encode(message: XLMPayment, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.from !== "") {
      writer.uint32(10).string(message.from);
    }
    if (message.fee !== 0) {
      writer.uint32(16).uint64(message.fee);
    }
    if (message.minimumTime !== 0) {
      writer.uint32(24).uint64(message.minimumTime);
    }
    if (message.maximumTime !== 0) {
      writer.uint32(32).uint64(message.maximumTime);
    }
    if (message.memo !== "") {
      writer.uint32(42).string(message.memo);
    }
    if (message.to !== "") {
      writer.uint32(50).string(message.to);
    }
    if (message.amount !== 0) {
      writer.uint32(56).uint64(message.amount);
    }
    if (message.sequence !== 0) {
      writer.uint32(64).uint64(message.sequence);
    }
    if (message.id !== "") {
      writer.uint32(74).string(message.id);
    }
    if (message.operation !== 0) {
      writer.uint32(80).int32(message.operation);
    }
    if (message.isSequenceSet !== false) {
      writer.uint32(88).bool(message.isSequenceSet);
    }
    if (message.asset !== undefined) {
      XLMAsset.encode(message.asset, writer.uint32(98).fork()).ldelim();
    }
    if (message.sponsoredBy !== "") {
      writer.uint32(106).string(message.sponsoredBy);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): XLMPayment {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseXLMPayment();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.from = reader.string();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.fee = longToNumber(reader.uint64() as Long);
          continue;
        case 3:
          if (tag !== 24) {
            break;
          }

          message.minimumTime = longToNumber(reader.uint64() as Long);
          continue;
        case 4:
          if (tag !== 32) {
            break;
          }

          message.maximumTime = longToNumber(reader.uint64() as Long);
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.memo = reader.string();
          continue;
        case 6:
          if (tag !== 50) {
            break;
          }

          message.to = reader.string();
          continue;
        case 7:
          if (tag !== 56) {
            break;
          }

          message.amount = longToNumber(reader.uint64() as Long);
          continue;
        case 8:
          if (tag !== 64) {
            break;
          }

          message.sequence = longToNumber(reader.uint64() as Long);
          continue;
        case 9:
          if (tag !== 74) {
            break;
          }

          message.id = reader.string();
          continue;
        case 10:
          if (tag !== 80) {
            break;
          }

          message.operation = reader.int32() as any;
          continue;
        case 11:
          if (tag !== 88) {
            break;
          }

          message.isSequenceSet = reader.bool();
          continue;
        case 12:
          if (tag !== 98) {
            break;
          }

          message.asset = XLMAsset.decode(reader, reader.uint32());
          continue;
        case 13:
          if (tag !== 106) {
            break;
          }

          message.sponsoredBy = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): XLMPayment {
    return {
      from: isSet(object.from) ? globalThis.String(object.from) : "",
      fee: isSet(object.fee) ? globalThis.Number(object.fee) : 0,
      minimumTime: isSet(object.minimumTime) ? globalThis.Number(object.minimumTime) : 0,
      maximumTime: isSet(object.maximumTime) ? globalThis.Number(object.maximumTime) : 0,
      memo: isSet(object.memo) ? globalThis.String(object.memo) : "",
      to: isSet(object.to) ? globalThis.String(object.to) : "",
      amount: isSet(object.amount) ? globalThis.Number(object.amount) : 0,
      sequence: isSet(object.sequence) ? globalThis.Number(object.sequence) : 0,
      id: isSet(object.id) ? globalThis.String(object.id) : "",
      operation: isSet(object.operation) ? xLMPayment_OperationFromJSON(object.operation) : 0,
      isSequenceSet: isSet(object.isSequenceSet) ? globalThis.Boolean(object.isSequenceSet) : false,
      asset: isSet(object.asset) ? XLMAsset.fromJSON(object.asset) : undefined,
      sponsoredBy: isSet(object.sponsoredBy) ? globalThis.String(object.sponsoredBy) : "",
    };
  },

  toJSON(message: XLMPayment): unknown {
    const obj: any = {};
    if (message.from !== "") {
      obj.from = message.from;
    }
    if (message.fee !== 0) {
      obj.fee = Math.round(message.fee);
    }
    if (message.minimumTime !== 0) {
      obj.minimumTime = Math.round(message.minimumTime);
    }
    if (message.maximumTime !== 0) {
      obj.maximumTime = Math.round(message.maximumTime);
    }
    if (message.memo !== "") {
      obj.memo = message.memo;
    }
    if (message.to !== "") {
      obj.to = message.to;
    }
    if (message.amount !== 0) {
      obj.amount = Math.round(message.amount);
    }
    if (message.sequence !== 0) {
      obj.sequence = Math.round(message.sequence);
    }
    if (message.id !== "") {
      obj.id = message.id;
    }
    if (message.operation !== 0) {
      obj.operation = xLMPayment_OperationToJSON(message.operation);
    }
    if (message.isSequenceSet !== false) {
      obj.isSequenceSet = message.isSequenceSet;
    }
    if (message.asset !== undefined) {
      obj.asset = XLMAsset.toJSON(message.asset);
    }
    if (message.sponsoredBy !== "") {
      obj.sponsoredBy = message.sponsoredBy;
    }
    return obj;
  },

  create(base?: DeepPartial<XLMPayment>): XLMPayment {
    return XLMPayment.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<XLMPayment>): XLMPayment {
    const message = createBaseXLMPayment();
    message.from = object.from ?? "";
    message.fee = object.fee ?? 0;
    message.minimumTime = object.minimumTime ?? 0;
    message.maximumTime = object.maximumTime ?? 0;
    message.memo = object.memo ?? "";
    message.to = object.to ?? "";
    message.amount = object.amount ?? 0;
    message.sequence = object.sequence ?? 0;
    message.id = object.id ?? "";
    message.operation = object.operation ?? 0;
    message.isSequenceSet = object.isSequenceSet ?? false;
    message.asset = (object.asset !== undefined && object.asset !== null)
      ? XLMAsset.fromPartial(object.asset)
      : undefined;
    message.sponsoredBy = object.sponsoredBy ?? "";
    return message;
  },
};

function createBaseXLMAddressRequest(): XLMAddressRequest {
  return { path: "" };
}

export const XLMAddressRequest = {
  encode(message: XLMAddressRequest, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.path !== "") {
      writer.uint32(10).string(message.path);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): XLMAddressRequest {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseXLMAddressRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.path = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): XLMAddressRequest {
    return { path: isSet(object.path) ? globalThis.String(object.path) : "" };
  },

  toJSON(message: XLMAddressRequest): unknown {
    const obj: any = {};
    if (message.path !== "") {
      obj.path = message.path;
    }
    return obj;
  },

  create(base?: DeepPartial<XLMAddressRequest>): XLMAddressRequest {
    return XLMAddressRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<XLMAddressRequest>): XLMAddressRequest {
    const message = createBaseXLMAddressRequest();
    message.path = object.path ?? "";
    return message;
  },
};

function createBaseXLMProofOfReserveRequest(): XLMProofOfReserveRequest {
  return { path: "", challenge: "" };
}

export const XLMProofOfReserveRequest = {
  encode(message: XLMProofOfReserveRequest, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.path !== "") {
      writer.uint32(10).string(message.path);
    }
    if (message.challenge !== "") {
      writer.uint32(18).string(message.challenge);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): XLMProofOfReserveRequest {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseXLMProofOfReserveRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.path = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.challenge = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): XLMProofOfReserveRequest {
    return {
      path: isSet(object.path) ? globalThis.String(object.path) : "",
      challenge: isSet(object.challenge) ? globalThis.String(object.challenge) : "",
    };
  },

  toJSON(message: XLMProofOfReserveRequest): unknown {
    const obj: any = {};
    if (message.path !== "") {
      obj.path = message.path;
    }
    if (message.challenge !== "") {
      obj.challenge = message.challenge;
    }
    return obj;
  },

  create(base?: DeepPartial<XLMProofOfReserveRequest>): XLMProofOfReserveRequest {
    return XLMProofOfReserveRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<XLMProofOfReserveRequest>): XLMProofOfReserveRequest {
    const message = createBaseXLMProofOfReserveRequest();
    message.path = object.path ?? "";
    message.challenge = object.challenge ?? "";
    return message;
  },
};

function createBaseXLMSetOptionsRequest(): XLMSetOptionsRequest {
  return { details: undefined, setFlags: 0, clearFlags: 0 };
}

export const XLMSetOptionsRequest = {
  encode(message: XLMSetOptionsRequest, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.details !== undefined) {
      XLMTransactionDetails.encode(message.details, writer.uint32(10).fork()).ldelim();
    }
    if (message.setFlags !== 0) {
      writer.uint32(16).uint32(message.setFlags);
    }
    if (message.clearFlags !== 0) {
      writer.uint32(24).uint32(message.clearFlags);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): XLMSetOptionsRequest {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseXLMSetOptionsRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.details = XLMTransactionDetails.decode(reader, reader.uint32());
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.setFlags = reader.uint32();
          continue;
        case 3:
          if (tag !== 24) {
            break;
          }

          message.clearFlags = reader.uint32();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): XLMSetOptionsRequest {
    return {
      details: isSet(object.details) ? XLMTransactionDetails.fromJSON(object.details) : undefined,
      setFlags: isSet(object.setFlags) ? globalThis.Number(object.setFlags) : 0,
      clearFlags: isSet(object.clearFlags) ? globalThis.Number(object.clearFlags) : 0,
    };
  },

  toJSON(message: XLMSetOptionsRequest): unknown {
    const obj: any = {};
    if (message.details !== undefined) {
      obj.details = XLMTransactionDetails.toJSON(message.details);
    }
    if (message.setFlags !== 0) {
      obj.setFlags = Math.round(message.setFlags);
    }
    if (message.clearFlags !== 0) {
      obj.clearFlags = Math.round(message.clearFlags);
    }
    return obj;
  },

  create(base?: DeepPartial<XLMSetOptionsRequest>): XLMSetOptionsRequest {
    return XLMSetOptionsRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<XLMSetOptionsRequest>): XLMSetOptionsRequest {
    const message = createBaseXLMSetOptionsRequest();
    message.details = (object.details !== undefined && object.details !== null)
      ? XLMTransactionDetails.fromPartial(object.details)
      : undefined;
    message.setFlags = object.setFlags ?? 0;
    message.clearFlags = object.clearFlags ?? 0;
    return message;
  },
};

function createBaseXLMManageDataRequest(): XLMManageDataRequest {
  return { details: undefined, name: "", valueData: new Uint8Array(0) };
}

export const XLMManageDataRequest = {
  encode(message: XLMManageDataRequest, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.details !== undefined) {
      XLMTransactionDetails.encode(message.details, writer.uint32(10).fork()).ldelim();
    }
    if (message.name !== "") {
      writer.uint32(18).string(message.name);
    }
    if (message.valueData.length !== 0) {
      writer.uint32(34).bytes(message.valueData);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): XLMManageDataRequest {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseXLMManageDataRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.details = XLMTransactionDetails.decode(reader, reader.uint32());
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.name = reader.string();
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.valueData = reader.bytes();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): XLMManageDataRequest {
    return {
      details: isSet(object.details) ? XLMTransactionDetails.fromJSON(object.details) : undefined,
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      valueData: isSet(object.valueData) ? bytesFromBase64(object.valueData) : new Uint8Array(0),
    };
  },

  toJSON(message: XLMManageDataRequest): unknown {
    const obj: any = {};
    if (message.details !== undefined) {
      obj.details = XLMTransactionDetails.toJSON(message.details);
    }
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.valueData.length !== 0) {
      obj.valueData = base64FromBytes(message.valueData);
    }
    return obj;
  },

  create(base?: DeepPartial<XLMManageDataRequest>): XLMManageDataRequest {
    return XLMManageDataRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<XLMManageDataRequest>): XLMManageDataRequest {
    const message = createBaseXLMManageDataRequest();
    message.details = (object.details !== undefined && object.details !== null)
      ? XLMTransactionDetails.fromPartial(object.details)
      : undefined;
    message.name = object.name ?? "";
    message.valueData = object.valueData ?? new Uint8Array(0);
    return message;
  },
};

function createBaseXLMClaimPredicate(): XLMClaimPredicate {
  return { type: 0, predicateUnconditional: undefined, predicateAbsBefore: undefined, predicateRelBefore: undefined };
}

export const XLMClaimPredicate = {
  encode(message: XLMClaimPredicate, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.type !== 0) {
      writer.uint32(8).int32(message.type);
    }
    if (message.predicateUnconditional !== undefined) {
      XLMClaimPredicate_PredicateUnconditional.encode(message.predicateUnconditional, writer.uint32(18).fork())
        .ldelim();
    }
    if (message.predicateAbsBefore !== undefined) {
      XLMClaimPredicate_PredicateAbsBefore.encode(message.predicateAbsBefore, writer.uint32(50).fork()).ldelim();
    }
    if (message.predicateRelBefore !== undefined) {
      XLMClaimPredicate_PredicateRelBefore.encode(message.predicateRelBefore, writer.uint32(58).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): XLMClaimPredicate {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseXLMClaimPredicate();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.type = reader.int32() as any;
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.predicateUnconditional = XLMClaimPredicate_PredicateUnconditional.decode(reader, reader.uint32());
          continue;
        case 6:
          if (tag !== 50) {
            break;
          }

          message.predicateAbsBefore = XLMClaimPredicate_PredicateAbsBefore.decode(reader, reader.uint32());
          continue;
        case 7:
          if (tag !== 58) {
            break;
          }

          message.predicateRelBefore = XLMClaimPredicate_PredicateRelBefore.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): XLMClaimPredicate {
    return {
      type: isSet(object.type) ? xLMClaimPredicate_ClaimPredicateTypeFromJSON(object.type) : 0,
      predicateUnconditional: isSet(object.predicateUnconditional)
        ? XLMClaimPredicate_PredicateUnconditional.fromJSON(object.predicateUnconditional)
        : undefined,
      predicateAbsBefore: isSet(object.predicateAbsBefore)
        ? XLMClaimPredicate_PredicateAbsBefore.fromJSON(object.predicateAbsBefore)
        : undefined,
      predicateRelBefore: isSet(object.predicateRelBefore)
        ? XLMClaimPredicate_PredicateRelBefore.fromJSON(object.predicateRelBefore)
        : undefined,
    };
  },

  toJSON(message: XLMClaimPredicate): unknown {
    const obj: any = {};
    if (message.type !== 0) {
      obj.type = xLMClaimPredicate_ClaimPredicateTypeToJSON(message.type);
    }
    if (message.predicateUnconditional !== undefined) {
      obj.predicateUnconditional = XLMClaimPredicate_PredicateUnconditional.toJSON(message.predicateUnconditional);
    }
    if (message.predicateAbsBefore !== undefined) {
      obj.predicateAbsBefore = XLMClaimPredicate_PredicateAbsBefore.toJSON(message.predicateAbsBefore);
    }
    if (message.predicateRelBefore !== undefined) {
      obj.predicateRelBefore = XLMClaimPredicate_PredicateRelBefore.toJSON(message.predicateRelBefore);
    }
    return obj;
  },

  create(base?: DeepPartial<XLMClaimPredicate>): XLMClaimPredicate {
    return XLMClaimPredicate.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<XLMClaimPredicate>): XLMClaimPredicate {
    const message = createBaseXLMClaimPredicate();
    message.type = object.type ?? 0;
    message.predicateUnconditional =
      (object.predicateUnconditional !== undefined && object.predicateUnconditional !== null)
        ? XLMClaimPredicate_PredicateUnconditional.fromPartial(object.predicateUnconditional)
        : undefined;
    message.predicateAbsBefore = (object.predicateAbsBefore !== undefined && object.predicateAbsBefore !== null)
      ? XLMClaimPredicate_PredicateAbsBefore.fromPartial(object.predicateAbsBefore)
      : undefined;
    message.predicateRelBefore = (object.predicateRelBefore !== undefined && object.predicateRelBefore !== null)
      ? XLMClaimPredicate_PredicateRelBefore.fromPartial(object.predicateRelBefore)
      : undefined;
    return message;
  },
};

function createBaseXLMClaimPredicate_PredicateUnconditional(): XLMClaimPredicate_PredicateUnconditional {
  return {};
}

export const XLMClaimPredicate_PredicateUnconditional = {
  encode(_: XLMClaimPredicate_PredicateUnconditional, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): XLMClaimPredicate_PredicateUnconditional {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseXLMClaimPredicate_PredicateUnconditional();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(_: any): XLMClaimPredicate_PredicateUnconditional {
    return {};
  },

  toJSON(_: XLMClaimPredicate_PredicateUnconditional): unknown {
    const obj: any = {};
    return obj;
  },

  create(base?: DeepPartial<XLMClaimPredicate_PredicateUnconditional>): XLMClaimPredicate_PredicateUnconditional {
    return XLMClaimPredicate_PredicateUnconditional.fromPartial(base ?? {});
  },
  fromPartial(_: DeepPartial<XLMClaimPredicate_PredicateUnconditional>): XLMClaimPredicate_PredicateUnconditional {
    const message = createBaseXLMClaimPredicate_PredicateUnconditional();
    return message;
  },
};

function createBaseXLMClaimPredicate_PredicateAbsBefore(): XLMClaimPredicate_PredicateAbsBefore {
  return { absBefore: 0 };
}

export const XLMClaimPredicate_PredicateAbsBefore = {
  encode(message: XLMClaimPredicate_PredicateAbsBefore, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.absBefore !== 0) {
      writer.uint32(8).uint64(message.absBefore);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): XLMClaimPredicate_PredicateAbsBefore {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseXLMClaimPredicate_PredicateAbsBefore();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.absBefore = longToNumber(reader.uint64() as Long);
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): XLMClaimPredicate_PredicateAbsBefore {
    return { absBefore: isSet(object.absBefore) ? globalThis.Number(object.absBefore) : 0 };
  },

  toJSON(message: XLMClaimPredicate_PredicateAbsBefore): unknown {
    const obj: any = {};
    if (message.absBefore !== 0) {
      obj.absBefore = Math.round(message.absBefore);
    }
    return obj;
  },

  create(base?: DeepPartial<XLMClaimPredicate_PredicateAbsBefore>): XLMClaimPredicate_PredicateAbsBefore {
    return XLMClaimPredicate_PredicateAbsBefore.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<XLMClaimPredicate_PredicateAbsBefore>): XLMClaimPredicate_PredicateAbsBefore {
    const message = createBaseXLMClaimPredicate_PredicateAbsBefore();
    message.absBefore = object.absBefore ?? 0;
    return message;
  },
};

function createBaseXLMClaimPredicate_PredicateRelBefore(): XLMClaimPredicate_PredicateRelBefore {
  return { relBefore: 0 };
}

export const XLMClaimPredicate_PredicateRelBefore = {
  encode(message: XLMClaimPredicate_PredicateRelBefore, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.relBefore !== 0) {
      writer.uint32(8).uint64(message.relBefore);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): XLMClaimPredicate_PredicateRelBefore {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseXLMClaimPredicate_PredicateRelBefore();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.relBefore = longToNumber(reader.uint64() as Long);
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): XLMClaimPredicate_PredicateRelBefore {
    return { relBefore: isSet(object.relBefore) ? globalThis.Number(object.relBefore) : 0 };
  },

  toJSON(message: XLMClaimPredicate_PredicateRelBefore): unknown {
    const obj: any = {};
    if (message.relBefore !== 0) {
      obj.relBefore = Math.round(message.relBefore);
    }
    return obj;
  },

  create(base?: DeepPartial<XLMClaimPredicate_PredicateRelBefore>): XLMClaimPredicate_PredicateRelBefore {
    return XLMClaimPredicate_PredicateRelBefore.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<XLMClaimPredicate_PredicateRelBefore>): XLMClaimPredicate_PredicateRelBefore {
    const message = createBaseXLMClaimPredicate_PredicateRelBefore();
    message.relBefore = object.relBefore ?? 0;
    return message;
  },
};

function createBaseXLMClaimant(): XLMClaimant {
  return { versionKind: 0, v0: undefined };
}

export const XLMClaimant = {
  encode(message: XLMClaimant, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.versionKind !== 0) {
      writer.uint32(8).int32(message.versionKind);
    }
    if (message.v0 !== undefined) {
      XLMClaimant_ClaimantV0.encode(message.v0, writer.uint32(18).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): XLMClaimant {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseXLMClaimant();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.versionKind = reader.int32() as any;
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.v0 = XLMClaimant_ClaimantV0.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): XLMClaimant {
    return {
      versionKind: isSet(object.versionKind) ? xLMClaimant_VersionKindFromJSON(object.versionKind) : 0,
      v0: isSet(object.v0) ? XLMClaimant_ClaimantV0.fromJSON(object.v0) : undefined,
    };
  },

  toJSON(message: XLMClaimant): unknown {
    const obj: any = {};
    if (message.versionKind !== 0) {
      obj.versionKind = xLMClaimant_VersionKindToJSON(message.versionKind);
    }
    if (message.v0 !== undefined) {
      obj.v0 = XLMClaimant_ClaimantV0.toJSON(message.v0);
    }
    return obj;
  },

  create(base?: DeepPartial<XLMClaimant>): XLMClaimant {
    return XLMClaimant.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<XLMClaimant>): XLMClaimant {
    const message = createBaseXLMClaimant();
    message.versionKind = object.versionKind ?? 0;
    message.v0 = (object.v0 !== undefined && object.v0 !== null)
      ? XLMClaimant_ClaimantV0.fromPartial(object.v0)
      : undefined;
    return message;
  },
};

function createBaseXLMClaimant_ClaimantV0(): XLMClaimant_ClaimantV0 {
  return { destination: "", claimPredicate: undefined };
}

export const XLMClaimant_ClaimantV0 = {
  encode(message: XLMClaimant_ClaimantV0, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.destination !== "") {
      writer.uint32(10).string(message.destination);
    }
    if (message.claimPredicate !== undefined) {
      XLMClaimPredicate.encode(message.claimPredicate, writer.uint32(18).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): XLMClaimant_ClaimantV0 {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseXLMClaimant_ClaimantV0();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.destination = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.claimPredicate = XLMClaimPredicate.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): XLMClaimant_ClaimantV0 {
    return {
      destination: isSet(object.destination) ? globalThis.String(object.destination) : "",
      claimPredicate: isSet(object.claimPredicate) ? XLMClaimPredicate.fromJSON(object.claimPredicate) : undefined,
    };
  },

  toJSON(message: XLMClaimant_ClaimantV0): unknown {
    const obj: any = {};
    if (message.destination !== "") {
      obj.destination = message.destination;
    }
    if (message.claimPredicate !== undefined) {
      obj.claimPredicate = XLMClaimPredicate.toJSON(message.claimPredicate);
    }
    return obj;
  },

  create(base?: DeepPartial<XLMClaimant_ClaimantV0>): XLMClaimant_ClaimantV0 {
    return XLMClaimant_ClaimantV0.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<XLMClaimant_ClaimantV0>): XLMClaimant_ClaimantV0 {
    const message = createBaseXLMClaimant_ClaimantV0();
    message.destination = object.destination ?? "";
    message.claimPredicate = (object.claimPredicate !== undefined && object.claimPredicate !== null)
      ? XLMClaimPredicate.fromPartial(object.claimPredicate)
      : undefined;
    return message;
  },
};

function createBaseXLMCreateClaimableBalanceRequest(): XLMCreateClaimableBalanceRequest {
  return { details: undefined, asset: undefined, amount: 0, claimant: undefined };
}

export const XLMCreateClaimableBalanceRequest = {
  encode(message: XLMCreateClaimableBalanceRequest, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.details !== undefined) {
      XLMTransactionDetails.encode(message.details, writer.uint32(10).fork()).ldelim();
    }
    if (message.asset !== undefined) {
      XLMAsset.encode(message.asset, writer.uint32(18).fork()).ldelim();
    }
    if (message.amount !== 0) {
      writer.uint32(24).uint64(message.amount);
    }
    if (message.claimant !== undefined) {
      XLMClaimant.encode(message.claimant, writer.uint32(34).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): XLMCreateClaimableBalanceRequest {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseXLMCreateClaimableBalanceRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.details = XLMTransactionDetails.decode(reader, reader.uint32());
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.asset = XLMAsset.decode(reader, reader.uint32());
          continue;
        case 3:
          if (tag !== 24) {
            break;
          }

          message.amount = longToNumber(reader.uint64() as Long);
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.claimant = XLMClaimant.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): XLMCreateClaimableBalanceRequest {
    return {
      details: isSet(object.details) ? XLMTransactionDetails.fromJSON(object.details) : undefined,
      asset: isSet(object.asset) ? XLMAsset.fromJSON(object.asset) : undefined,
      amount: isSet(object.amount) ? globalThis.Number(object.amount) : 0,
      claimant: isSet(object.claimant) ? XLMClaimant.fromJSON(object.claimant) : undefined,
    };
  },

  toJSON(message: XLMCreateClaimableBalanceRequest): unknown {
    const obj: any = {};
    if (message.details !== undefined) {
      obj.details = XLMTransactionDetails.toJSON(message.details);
    }
    if (message.asset !== undefined) {
      obj.asset = XLMAsset.toJSON(message.asset);
    }
    if (message.amount !== 0) {
      obj.amount = Math.round(message.amount);
    }
    if (message.claimant !== undefined) {
      obj.claimant = XLMClaimant.toJSON(message.claimant);
    }
    return obj;
  },

  create(base?: DeepPartial<XLMCreateClaimableBalanceRequest>): XLMCreateClaimableBalanceRequest {
    return XLMCreateClaimableBalanceRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<XLMCreateClaimableBalanceRequest>): XLMCreateClaimableBalanceRequest {
    const message = createBaseXLMCreateClaimableBalanceRequest();
    message.details = (object.details !== undefined && object.details !== null)
      ? XLMTransactionDetails.fromPartial(object.details)
      : undefined;
    message.asset = (object.asset !== undefined && object.asset !== null)
      ? XLMAsset.fromPartial(object.asset)
      : undefined;
    message.amount = object.amount ?? 0;
    message.claimant = (object.claimant !== undefined && object.claimant !== null)
      ? XLMClaimant.fromPartial(object.claimant)
      : undefined;
    return message;
  },
};

function createBaseXLMClaimClaimableBalanceRequest(): XLMClaimClaimableBalanceRequest {
  return { details: undefined, claimableBalanceID: new Uint8Array(0) };
}

export const XLMClaimClaimableBalanceRequest = {
  encode(message: XLMClaimClaimableBalanceRequest, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.details !== undefined) {
      XLMTransactionDetails.encode(message.details, writer.uint32(10).fork()).ldelim();
    }
    if (message.claimableBalanceID.length !== 0) {
      writer.uint32(18).bytes(message.claimableBalanceID);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): XLMClaimClaimableBalanceRequest {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseXLMClaimClaimableBalanceRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.details = XLMTransactionDetails.decode(reader, reader.uint32());
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.claimableBalanceID = reader.bytes();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): XLMClaimClaimableBalanceRequest {
    return {
      details: isSet(object.details) ? XLMTransactionDetails.fromJSON(object.details) : undefined,
      claimableBalanceID: isSet(object.claimableBalanceID)
        ? bytesFromBase64(object.claimableBalanceID)
        : new Uint8Array(0),
    };
  },

  toJSON(message: XLMClaimClaimableBalanceRequest): unknown {
    const obj: any = {};
    if (message.details !== undefined) {
      obj.details = XLMTransactionDetails.toJSON(message.details);
    }
    if (message.claimableBalanceID.length !== 0) {
      obj.claimableBalanceID = base64FromBytes(message.claimableBalanceID);
    }
    return obj;
  },

  create(base?: DeepPartial<XLMClaimClaimableBalanceRequest>): XLMClaimClaimableBalanceRequest {
    return XLMClaimClaimableBalanceRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<XLMClaimClaimableBalanceRequest>): XLMClaimClaimableBalanceRequest {
    const message = createBaseXLMClaimClaimableBalanceRequest();
    message.details = (object.details !== undefined && object.details !== null)
      ? XLMTransactionDetails.fromPartial(object.details)
      : undefined;
    message.claimableBalanceID = object.claimableBalanceID ?? new Uint8Array(0);
    return message;
  },
};

function createBaseXLMClawbackClaimableBalanceRequest(): XLMClawbackClaimableBalanceRequest {
  return { details: undefined, claimableBalanceID: new Uint8Array(0) };
}

export const XLMClawbackClaimableBalanceRequest = {
  encode(message: XLMClawbackClaimableBalanceRequest, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.details !== undefined) {
      XLMTransactionDetails.encode(message.details, writer.uint32(10).fork()).ldelim();
    }
    if (message.claimableBalanceID.length !== 0) {
      writer.uint32(18).bytes(message.claimableBalanceID);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): XLMClawbackClaimableBalanceRequest {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseXLMClawbackClaimableBalanceRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.details = XLMTransactionDetails.decode(reader, reader.uint32());
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.claimableBalanceID = reader.bytes();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): XLMClawbackClaimableBalanceRequest {
    return {
      details: isSet(object.details) ? XLMTransactionDetails.fromJSON(object.details) : undefined,
      claimableBalanceID: isSet(object.claimableBalanceID)
        ? bytesFromBase64(object.claimableBalanceID)
        : new Uint8Array(0),
    };
  },

  toJSON(message: XLMClawbackClaimableBalanceRequest): unknown {
    const obj: any = {};
    if (message.details !== undefined) {
      obj.details = XLMTransactionDetails.toJSON(message.details);
    }
    if (message.claimableBalanceID.length !== 0) {
      obj.claimableBalanceID = base64FromBytes(message.claimableBalanceID);
    }
    return obj;
  },

  create(base?: DeepPartial<XLMClawbackClaimableBalanceRequest>): XLMClawbackClaimableBalanceRequest {
    return XLMClawbackClaimableBalanceRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<XLMClawbackClaimableBalanceRequest>): XLMClawbackClaimableBalanceRequest {
    const message = createBaseXLMClawbackClaimableBalanceRequest();
    message.details = (object.details !== undefined && object.details !== null)
      ? XLMTransactionDetails.fromPartial(object.details)
      : undefined;
    message.claimableBalanceID = object.claimableBalanceID ?? new Uint8Array(0);
    return message;
  },
};

function createBaseXLMRevokeSponsorshipRequest(): XLMRevokeSponsorshipRequest {
  return { details: undefined, entry: undefined };
}

export const XLMRevokeSponsorshipRequest = {
  encode(message: XLMRevokeSponsorshipRequest, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.details !== undefined) {
      XLMTransactionDetails.encode(message.details, writer.uint32(10).fork()).ldelim();
    }
    if (message.entry !== undefined) {
      XLMLedgerEntry.encode(message.entry, writer.uint32(18).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): XLMRevokeSponsorshipRequest {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseXLMRevokeSponsorshipRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.details = XLMTransactionDetails.decode(reader, reader.uint32());
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.entry = XLMLedgerEntry.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): XLMRevokeSponsorshipRequest {
    return {
      details: isSet(object.details) ? XLMTransactionDetails.fromJSON(object.details) : undefined,
      entry: isSet(object.entry) ? XLMLedgerEntry.fromJSON(object.entry) : undefined,
    };
  },

  toJSON(message: XLMRevokeSponsorshipRequest): unknown {
    const obj: any = {};
    if (message.details !== undefined) {
      obj.details = XLMTransactionDetails.toJSON(message.details);
    }
    if (message.entry !== undefined) {
      obj.entry = XLMLedgerEntry.toJSON(message.entry);
    }
    return obj;
  },

  create(base?: DeepPartial<XLMRevokeSponsorshipRequest>): XLMRevokeSponsorshipRequest {
    return XLMRevokeSponsorshipRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<XLMRevokeSponsorshipRequest>): XLMRevokeSponsorshipRequest {
    const message = createBaseXLMRevokeSponsorshipRequest();
    message.details = (object.details !== undefined && object.details !== null)
      ? XLMTransactionDetails.fromPartial(object.details)
      : undefined;
    message.entry = (object.entry !== undefined && object.entry !== null)
      ? XLMLedgerEntry.fromPartial(object.entry)
      : undefined;
    return message;
  },
};

function createBaseXLMClawbackRequest(): XLMClawbackRequest {
  return { details: undefined, destination: "", asset: undefined, amount: 0 };
}

export const XLMClawbackRequest = {
  encode(message: XLMClawbackRequest, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.details !== undefined) {
      XLMTransactionDetails.encode(message.details, writer.uint32(10).fork()).ldelim();
    }
    if (message.destination !== "") {
      writer.uint32(18).string(message.destination);
    }
    if (message.asset !== undefined) {
      XLMAsset.encode(message.asset, writer.uint32(26).fork()).ldelim();
    }
    if (message.amount !== 0) {
      writer.uint32(32).uint64(message.amount);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): XLMClawbackRequest {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseXLMClawbackRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.details = XLMTransactionDetails.decode(reader, reader.uint32());
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.destination = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.asset = XLMAsset.decode(reader, reader.uint32());
          continue;
        case 4:
          if (tag !== 32) {
            break;
          }

          message.amount = longToNumber(reader.uint64() as Long);
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): XLMClawbackRequest {
    return {
      details: isSet(object.details) ? XLMTransactionDetails.fromJSON(object.details) : undefined,
      destination: isSet(object.destination) ? globalThis.String(object.destination) : "",
      asset: isSet(object.asset) ? XLMAsset.fromJSON(object.asset) : undefined,
      amount: isSet(object.amount) ? globalThis.Number(object.amount) : 0,
    };
  },

  toJSON(message: XLMClawbackRequest): unknown {
    const obj: any = {};
    if (message.details !== undefined) {
      obj.details = XLMTransactionDetails.toJSON(message.details);
    }
    if (message.destination !== "") {
      obj.destination = message.destination;
    }
    if (message.asset !== undefined) {
      obj.asset = XLMAsset.toJSON(message.asset);
    }
    if (message.amount !== 0) {
      obj.amount = Math.round(message.amount);
    }
    return obj;
  },

  create(base?: DeepPartial<XLMClawbackRequest>): XLMClawbackRequest {
    return XLMClawbackRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<XLMClawbackRequest>): XLMClawbackRequest {
    const message = createBaseXLMClawbackRequest();
    message.details = (object.details !== undefined && object.details !== null)
      ? XLMTransactionDetails.fromPartial(object.details)
      : undefined;
    message.destination = object.destination ?? "";
    message.asset = (object.asset !== undefined && object.asset !== null)
      ? XLMAsset.fromPartial(object.asset)
      : undefined;
    message.amount = object.amount ?? 0;
    return message;
  },
};

function createBaseXLMPrice(): XLMPrice {
  return { numerator: 0, denominator: 0 };
}

export const XLMPrice = {
  encode(message: XLMPrice, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.numerator !== 0) {
      writer.uint32(8).int32(message.numerator);
    }
    if (message.denominator !== 0) {
      writer.uint32(16).int32(message.denominator);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): XLMPrice {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseXLMPrice();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.numerator = reader.int32();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.denominator = reader.int32();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): XLMPrice {
    return {
      numerator: isSet(object.numerator) ? globalThis.Number(object.numerator) : 0,
      denominator: isSet(object.denominator) ? globalThis.Number(object.denominator) : 0,
    };
  },

  toJSON(message: XLMPrice): unknown {
    const obj: any = {};
    if (message.numerator !== 0) {
      obj.numerator = Math.round(message.numerator);
    }
    if (message.denominator !== 0) {
      obj.denominator = Math.round(message.denominator);
    }
    return obj;
  },

  create(base?: DeepPartial<XLMPrice>): XLMPrice {
    return XLMPrice.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<XLMPrice>): XLMPrice {
    const message = createBaseXLMPrice();
    message.numerator = object.numerator ?? 0;
    message.denominator = object.denominator ?? 0;
    return message;
  },
};

function createBaseXLMLiquidityPoolDepositRequest(): XLMLiquidityPoolDepositRequest {
  return {
    details: undefined,
    poolID: new Uint8Array(0),
    maxAmountA: 0,
    maxAmountB: 0,
    minPrice: undefined,
    maxPrice: undefined,
  };
}

export const XLMLiquidityPoolDepositRequest = {
  encode(message: XLMLiquidityPoolDepositRequest, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.details !== undefined) {
      XLMTransactionDetails.encode(message.details, writer.uint32(10).fork()).ldelim();
    }
    if (message.poolID.length !== 0) {
      writer.uint32(18).bytes(message.poolID);
    }
    if (message.maxAmountA !== 0) {
      writer.uint32(24).int64(message.maxAmountA);
    }
    if (message.maxAmountB !== 0) {
      writer.uint32(32).int64(message.maxAmountB);
    }
    if (message.minPrice !== undefined) {
      XLMPrice.encode(message.minPrice, writer.uint32(42).fork()).ldelim();
    }
    if (message.maxPrice !== undefined) {
      XLMPrice.encode(message.maxPrice, writer.uint32(50).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): XLMLiquidityPoolDepositRequest {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseXLMLiquidityPoolDepositRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.details = XLMTransactionDetails.decode(reader, reader.uint32());
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.poolID = reader.bytes();
          continue;
        case 3:
          if (tag !== 24) {
            break;
          }

          message.maxAmountA = longToNumber(reader.int64() as Long);
          continue;
        case 4:
          if (tag !== 32) {
            break;
          }

          message.maxAmountB = longToNumber(reader.int64() as Long);
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.minPrice = XLMPrice.decode(reader, reader.uint32());
          continue;
        case 6:
          if (tag !== 50) {
            break;
          }

          message.maxPrice = XLMPrice.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): XLMLiquidityPoolDepositRequest {
    return {
      details: isSet(object.details) ? XLMTransactionDetails.fromJSON(object.details) : undefined,
      poolID: isSet(object.poolID) ? bytesFromBase64(object.poolID) : new Uint8Array(0),
      maxAmountA: isSet(object.maxAmountA) ? globalThis.Number(object.maxAmountA) : 0,
      maxAmountB: isSet(object.maxAmountB) ? globalThis.Number(object.maxAmountB) : 0,
      minPrice: isSet(object.minPrice) ? XLMPrice.fromJSON(object.minPrice) : undefined,
      maxPrice: isSet(object.maxPrice) ? XLMPrice.fromJSON(object.maxPrice) : undefined,
    };
  },

  toJSON(message: XLMLiquidityPoolDepositRequest): unknown {
    const obj: any = {};
    if (message.details !== undefined) {
      obj.details = XLMTransactionDetails.toJSON(message.details);
    }
    if (message.poolID.length !== 0) {
      obj.poolID = base64FromBytes(message.poolID);
    }
    if (message.maxAmountA !== 0) {
      obj.maxAmountA = Math.round(message.maxAmountA);
    }
    if (message.maxAmountB !== 0) {
      obj.maxAmountB = Math.round(message.maxAmountB);
    }
    if (message.minPrice !== undefined) {
      obj.minPrice = XLMPrice.toJSON(message.minPrice);
    }
    if (message.maxPrice !== undefined) {
      obj.maxPrice = XLMPrice.toJSON(message.maxPrice);
    }
    return obj;
  },

  create(base?: DeepPartial<XLMLiquidityPoolDepositRequest>): XLMLiquidityPoolDepositRequest {
    return XLMLiquidityPoolDepositRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<XLMLiquidityPoolDepositRequest>): XLMLiquidityPoolDepositRequest {
    const message = createBaseXLMLiquidityPoolDepositRequest();
    message.details = (object.details !== undefined && object.details !== null)
      ? XLMTransactionDetails.fromPartial(object.details)
      : undefined;
    message.poolID = object.poolID ?? new Uint8Array(0);
    message.maxAmountA = object.maxAmountA ?? 0;
    message.maxAmountB = object.maxAmountB ?? 0;
    message.minPrice = (object.minPrice !== undefined && object.minPrice !== null)
      ? XLMPrice.fromPartial(object.minPrice)
      : undefined;
    message.maxPrice = (object.maxPrice !== undefined && object.maxPrice !== null)
      ? XLMPrice.fromPartial(object.maxPrice)
      : undefined;
    return message;
  },
};

function createBaseXLMLiquidityPoolWithdrawRequest(): XLMLiquidityPoolWithdrawRequest {
  return { details: undefined, poolID: new Uint8Array(0), amount: 0, minAmountA: 0, minAmountB: 0 };
}

export const XLMLiquidityPoolWithdrawRequest = {
  encode(message: XLMLiquidityPoolWithdrawRequest, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.details !== undefined) {
      XLMTransactionDetails.encode(message.details, writer.uint32(10).fork()).ldelim();
    }
    if (message.poolID.length !== 0) {
      writer.uint32(18).bytes(message.poolID);
    }
    if (message.amount !== 0) {
      writer.uint32(24).int64(message.amount);
    }
    if (message.minAmountA !== 0) {
      writer.uint32(40).int64(message.minAmountA);
    }
    if (message.minAmountB !== 0) {
      writer.uint32(48).int64(message.minAmountB);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): XLMLiquidityPoolWithdrawRequest {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseXLMLiquidityPoolWithdrawRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.details = XLMTransactionDetails.decode(reader, reader.uint32());
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.poolID = reader.bytes();
          continue;
        case 3:
          if (tag !== 24) {
            break;
          }

          message.amount = longToNumber(reader.int64() as Long);
          continue;
        case 5:
          if (tag !== 40) {
            break;
          }

          message.minAmountA = longToNumber(reader.int64() as Long);
          continue;
        case 6:
          if (tag !== 48) {
            break;
          }

          message.minAmountB = longToNumber(reader.int64() as Long);
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): XLMLiquidityPoolWithdrawRequest {
    return {
      details: isSet(object.details) ? XLMTransactionDetails.fromJSON(object.details) : undefined,
      poolID: isSet(object.poolID) ? bytesFromBase64(object.poolID) : new Uint8Array(0),
      amount: isSet(object.amount) ? globalThis.Number(object.amount) : 0,
      minAmountA: isSet(object.minAmountA) ? globalThis.Number(object.minAmountA) : 0,
      minAmountB: isSet(object.minAmountB) ? globalThis.Number(object.minAmountB) : 0,
    };
  },

  toJSON(message: XLMLiquidityPoolWithdrawRequest): unknown {
    const obj: any = {};
    if (message.details !== undefined) {
      obj.details = XLMTransactionDetails.toJSON(message.details);
    }
    if (message.poolID.length !== 0) {
      obj.poolID = base64FromBytes(message.poolID);
    }
    if (message.amount !== 0) {
      obj.amount = Math.round(message.amount);
    }
    if (message.minAmountA !== 0) {
      obj.minAmountA = Math.round(message.minAmountA);
    }
    if (message.minAmountB !== 0) {
      obj.minAmountB = Math.round(message.minAmountB);
    }
    return obj;
  },

  create(base?: DeepPartial<XLMLiquidityPoolWithdrawRequest>): XLMLiquidityPoolWithdrawRequest {
    return XLMLiquidityPoolWithdrawRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<XLMLiquidityPoolWithdrawRequest>): XLMLiquidityPoolWithdrawRequest {
    const message = createBaseXLMLiquidityPoolWithdrawRequest();
    message.details = (object.details !== undefined && object.details !== null)
      ? XLMTransactionDetails.fromPartial(object.details)
      : undefined;
    message.poolID = object.poolID ?? new Uint8Array(0);
    message.amount = object.amount ?? 0;
    message.minAmountA = object.minAmountA ?? 0;
    message.minAmountB = object.minAmountB ?? 0;
    return message;
  },
};

function createBaseXLMPathPaymentSendRequest(): XLMPathPaymentSendRequest {
  return {
    details: undefined,
    destination: "",
    srcAsset: undefined,
    dstAsset: undefined,
    path: [],
    srcAmount: 0,
    minDstAmount: 0,
  };
}

export const XLMPathPaymentSendRequest = {
  encode(message: XLMPathPaymentSendRequest, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.details !== undefined) {
      XLMTransactionDetails.encode(message.details, writer.uint32(10).fork()).ldelim();
    }
    if (message.destination !== "") {
      writer.uint32(18).string(message.destination);
    }
    if (message.srcAsset !== undefined) {
      XLMAsset.encode(message.srcAsset, writer.uint32(26).fork()).ldelim();
    }
    if (message.dstAsset !== undefined) {
      XLMAsset.encode(message.dstAsset, writer.uint32(34).fork()).ldelim();
    }
    for (const v of message.path) {
      XLMAsset.encode(v!, writer.uint32(42).fork()).ldelim();
    }
    if (message.srcAmount !== 0) {
      writer.uint32(48).uint64(message.srcAmount);
    }
    if (message.minDstAmount !== 0) {
      writer.uint32(56).uint64(message.minDstAmount);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): XLMPathPaymentSendRequest {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseXLMPathPaymentSendRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.details = XLMTransactionDetails.decode(reader, reader.uint32());
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.destination = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.srcAsset = XLMAsset.decode(reader, reader.uint32());
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.dstAsset = XLMAsset.decode(reader, reader.uint32());
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.path.push(XLMAsset.decode(reader, reader.uint32()));
          continue;
        case 6:
          if (tag !== 48) {
            break;
          }

          message.srcAmount = longToNumber(reader.uint64() as Long);
          continue;
        case 7:
          if (tag !== 56) {
            break;
          }

          message.minDstAmount = longToNumber(reader.uint64() as Long);
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): XLMPathPaymentSendRequest {
    return {
      details: isSet(object.details) ? XLMTransactionDetails.fromJSON(object.details) : undefined,
      destination: isSet(object.destination) ? globalThis.String(object.destination) : "",
      srcAsset: isSet(object.srcAsset) ? XLMAsset.fromJSON(object.srcAsset) : undefined,
      dstAsset: isSet(object.dstAsset) ? XLMAsset.fromJSON(object.dstAsset) : undefined,
      path: globalThis.Array.isArray(object?.path) ? object.path.map((e: any) => XLMAsset.fromJSON(e)) : [],
      srcAmount: isSet(object.srcAmount) ? globalThis.Number(object.srcAmount) : 0,
      minDstAmount: isSet(object.minDstAmount) ? globalThis.Number(object.minDstAmount) : 0,
    };
  },

  toJSON(message: XLMPathPaymentSendRequest): unknown {
    const obj: any = {};
    if (message.details !== undefined) {
      obj.details = XLMTransactionDetails.toJSON(message.details);
    }
    if (message.destination !== "") {
      obj.destination = message.destination;
    }
    if (message.srcAsset !== undefined) {
      obj.srcAsset = XLMAsset.toJSON(message.srcAsset);
    }
    if (message.dstAsset !== undefined) {
      obj.dstAsset = XLMAsset.toJSON(message.dstAsset);
    }
    if (message.path?.length) {
      obj.path = message.path.map((e) => XLMAsset.toJSON(e));
    }
    if (message.srcAmount !== 0) {
      obj.srcAmount = Math.round(message.srcAmount);
    }
    if (message.minDstAmount !== 0) {
      obj.minDstAmount = Math.round(message.minDstAmount);
    }
    return obj;
  },

  create(base?: DeepPartial<XLMPathPaymentSendRequest>): XLMPathPaymentSendRequest {
    return XLMPathPaymentSendRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<XLMPathPaymentSendRequest>): XLMPathPaymentSendRequest {
    const message = createBaseXLMPathPaymentSendRequest();
    message.details = (object.details !== undefined && object.details !== null)
      ? XLMTransactionDetails.fromPartial(object.details)
      : undefined;
    message.destination = object.destination ?? "";
    message.srcAsset = (object.srcAsset !== undefined && object.srcAsset !== null)
      ? XLMAsset.fromPartial(object.srcAsset)
      : undefined;
    message.dstAsset = (object.dstAsset !== undefined && object.dstAsset !== null)
      ? XLMAsset.fromPartial(object.dstAsset)
      : undefined;
    message.path = object.path?.map((e) => XLMAsset.fromPartial(e)) || [];
    message.srcAmount = object.srcAmount ?? 0;
    message.minDstAmount = object.minDstAmount ?? 0;
    return message;
  },
};

function createBaseXLMPathPaymentReceiveRequest(): XLMPathPaymentReceiveRequest {
  return {
    details: undefined,
    destination: "",
    srcAsset: undefined,
    dstAsset: undefined,
    path: [],
    dstAmount: 0,
    maxSrcAmount: 0,
  };
}

export const XLMPathPaymentReceiveRequest = {
  encode(message: XLMPathPaymentReceiveRequest, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.details !== undefined) {
      XLMTransactionDetails.encode(message.details, writer.uint32(10).fork()).ldelim();
    }
    if (message.destination !== "") {
      writer.uint32(18).string(message.destination);
    }
    if (message.srcAsset !== undefined) {
      XLMAsset.encode(message.srcAsset, writer.uint32(26).fork()).ldelim();
    }
    if (message.dstAsset !== undefined) {
      XLMAsset.encode(message.dstAsset, writer.uint32(34).fork()).ldelim();
    }
    for (const v of message.path) {
      XLMAsset.encode(v!, writer.uint32(42).fork()).ldelim();
    }
    if (message.dstAmount !== 0) {
      writer.uint32(48).uint64(message.dstAmount);
    }
    if (message.maxSrcAmount !== 0) {
      writer.uint32(56).uint64(message.maxSrcAmount);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): XLMPathPaymentReceiveRequest {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseXLMPathPaymentReceiveRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.details = XLMTransactionDetails.decode(reader, reader.uint32());
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.destination = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.srcAsset = XLMAsset.decode(reader, reader.uint32());
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.dstAsset = XLMAsset.decode(reader, reader.uint32());
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.path.push(XLMAsset.decode(reader, reader.uint32()));
          continue;
        case 6:
          if (tag !== 48) {
            break;
          }

          message.dstAmount = longToNumber(reader.uint64() as Long);
          continue;
        case 7:
          if (tag !== 56) {
            break;
          }

          message.maxSrcAmount = longToNumber(reader.uint64() as Long);
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): XLMPathPaymentReceiveRequest {
    return {
      details: isSet(object.details) ? XLMTransactionDetails.fromJSON(object.details) : undefined,
      destination: isSet(object.destination) ? globalThis.String(object.destination) : "",
      srcAsset: isSet(object.srcAsset) ? XLMAsset.fromJSON(object.srcAsset) : undefined,
      dstAsset: isSet(object.dstAsset) ? XLMAsset.fromJSON(object.dstAsset) : undefined,
      path: globalThis.Array.isArray(object?.path) ? object.path.map((e: any) => XLMAsset.fromJSON(e)) : [],
      dstAmount: isSet(object.dstAmount) ? globalThis.Number(object.dstAmount) : 0,
      maxSrcAmount: isSet(object.maxSrcAmount) ? globalThis.Number(object.maxSrcAmount) : 0,
    };
  },

  toJSON(message: XLMPathPaymentReceiveRequest): unknown {
    const obj: any = {};
    if (message.details !== undefined) {
      obj.details = XLMTransactionDetails.toJSON(message.details);
    }
    if (message.destination !== "") {
      obj.destination = message.destination;
    }
    if (message.srcAsset !== undefined) {
      obj.srcAsset = XLMAsset.toJSON(message.srcAsset);
    }
    if (message.dstAsset !== undefined) {
      obj.dstAsset = XLMAsset.toJSON(message.dstAsset);
    }
    if (message.path?.length) {
      obj.path = message.path.map((e) => XLMAsset.toJSON(e));
    }
    if (message.dstAmount !== 0) {
      obj.dstAmount = Math.round(message.dstAmount);
    }
    if (message.maxSrcAmount !== 0) {
      obj.maxSrcAmount = Math.round(message.maxSrcAmount);
    }
    return obj;
  },

  create(base?: DeepPartial<XLMPathPaymentReceiveRequest>): XLMPathPaymentReceiveRequest {
    return XLMPathPaymentReceiveRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<XLMPathPaymentReceiveRequest>): XLMPathPaymentReceiveRequest {
    const message = createBaseXLMPathPaymentReceiveRequest();
    message.details = (object.details !== undefined && object.details !== null)
      ? XLMTransactionDetails.fromPartial(object.details)
      : undefined;
    message.destination = object.destination ?? "";
    message.srcAsset = (object.srcAsset !== undefined && object.srcAsset !== null)
      ? XLMAsset.fromPartial(object.srcAsset)
      : undefined;
    message.dstAsset = (object.dstAsset !== undefined && object.dstAsset !== null)
      ? XLMAsset.fromPartial(object.dstAsset)
      : undefined;
    message.path = object.path?.map((e) => XLMAsset.fromPartial(e)) || [];
    message.dstAmount = object.dstAmount ?? 0;
    message.maxSrcAmount = object.maxSrcAmount ?? 0;
    return message;
  },
};

function createBaseXLMOfferRequest(): XLMOfferRequest {
  return {
    details: undefined,
    sellAsset: undefined,
    buyAsset: undefined,
    amount: 0,
    price: undefined,
    offerId: 0,
    kind: 0,
  };
}

export const XLMOfferRequest = {
  encode(message: XLMOfferRequest, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.details !== undefined) {
      XLMTransactionDetails.encode(message.details, writer.uint32(10).fork()).ldelim();
    }
    if (message.sellAsset !== undefined) {
      XLMAsset.encode(message.sellAsset, writer.uint32(18).fork()).ldelim();
    }
    if (message.buyAsset !== undefined) {
      XLMAsset.encode(message.buyAsset, writer.uint32(26).fork()).ldelim();
    }
    if (message.amount !== 0) {
      writer.uint32(32).uint64(message.amount);
    }
    if (message.price !== undefined) {
      XLMPrice.encode(message.price, writer.uint32(42).fork()).ldelim();
    }
    if (message.offerId !== 0) {
      writer.uint32(48).int64(message.offerId);
    }
    if (message.kind !== 0) {
      writer.uint32(56).int32(message.kind);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): XLMOfferRequest {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseXLMOfferRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.details = XLMTransactionDetails.decode(reader, reader.uint32());
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.sellAsset = XLMAsset.decode(reader, reader.uint32());
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.buyAsset = XLMAsset.decode(reader, reader.uint32());
          continue;
        case 4:
          if (tag !== 32) {
            break;
          }

          message.amount = longToNumber(reader.uint64() as Long);
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.price = XLMPrice.decode(reader, reader.uint32());
          continue;
        case 6:
          if (tag !== 48) {
            break;
          }

          message.offerId = longToNumber(reader.int64() as Long);
          continue;
        case 7:
          if (tag !== 56) {
            break;
          }

          message.kind = reader.int32() as any;
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): XLMOfferRequest {
    return {
      details: isSet(object.details) ? XLMTransactionDetails.fromJSON(object.details) : undefined,
      sellAsset: isSet(object.sellAsset) ? XLMAsset.fromJSON(object.sellAsset) : undefined,
      buyAsset: isSet(object.buyAsset) ? XLMAsset.fromJSON(object.buyAsset) : undefined,
      amount: isSet(object.amount) ? globalThis.Number(object.amount) : 0,
      price: isSet(object.price) ? XLMPrice.fromJSON(object.price) : undefined,
      offerId: isSet(object.offerId) ? globalThis.Number(object.offerId) : 0,
      kind: isSet(object.kind) ? xLMOfferRequest_OfferKindFromJSON(object.kind) : 0,
    };
  },

  toJSON(message: XLMOfferRequest): unknown {
    const obj: any = {};
    if (message.details !== undefined) {
      obj.details = XLMTransactionDetails.toJSON(message.details);
    }
    if (message.sellAsset !== undefined) {
      obj.sellAsset = XLMAsset.toJSON(message.sellAsset);
    }
    if (message.buyAsset !== undefined) {
      obj.buyAsset = XLMAsset.toJSON(message.buyAsset);
    }
    if (message.amount !== 0) {
      obj.amount = Math.round(message.amount);
    }
    if (message.price !== undefined) {
      obj.price = XLMPrice.toJSON(message.price);
    }
    if (message.offerId !== 0) {
      obj.offerId = Math.round(message.offerId);
    }
    if (message.kind !== 0) {
      obj.kind = xLMOfferRequest_OfferKindToJSON(message.kind);
    }
    return obj;
  },

  create(base?: DeepPartial<XLMOfferRequest>): XLMOfferRequest {
    return XLMOfferRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<XLMOfferRequest>): XLMOfferRequest {
    const message = createBaseXLMOfferRequest();
    message.details = (object.details !== undefined && object.details !== null)
      ? XLMTransactionDetails.fromPartial(object.details)
      : undefined;
    message.sellAsset = (object.sellAsset !== undefined && object.sellAsset !== null)
      ? XLMAsset.fromPartial(object.sellAsset)
      : undefined;
    message.buyAsset = (object.buyAsset !== undefined && object.buyAsset !== null)
      ? XLMAsset.fromPartial(object.buyAsset)
      : undefined;
    message.amount = object.amount ?? 0;
    message.price = (object.price !== undefined && object.price !== null)
      ? XLMPrice.fromPartial(object.price)
      : undefined;
    message.offerId = object.offerId ?? 0;
    message.kind = object.kind ?? 0;
    return message;
  },
};

function createBaseXRPPaymentsRequest(): XRPPaymentsRequest {
  return { payments: [] };
}

export const XRPPaymentsRequest = {
  encode(message: XRPPaymentsRequest, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    for (const v of message.payments) {
      XRPPayment.encode(v!, writer.uint32(10).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): XRPPaymentsRequest {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseXRPPaymentsRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.payments.push(XRPPayment.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): XRPPaymentsRequest {
    return {
      payments: globalThis.Array.isArray(object?.payments)
        ? object.payments.map((e: any) => XRPPayment.fromJSON(e))
        : [],
    };
  },

  toJSON(message: XRPPaymentsRequest): unknown {
    const obj: any = {};
    if (message.payments?.length) {
      obj.payments = message.payments.map((e) => XRPPayment.toJSON(e));
    }
    return obj;
  },

  create(base?: DeepPartial<XRPPaymentsRequest>): XRPPaymentsRequest {
    return XRPPaymentsRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<XRPPaymentsRequest>): XRPPaymentsRequest {
    const message = createBaseXRPPaymentsRequest();
    message.payments = object.payments?.map((e) => XRPPayment.fromPartial(e)) || [];
    return message;
  },
};

function createBaseXRPPayment(): XRPPayment {
  return {
    from: "",
    sequence: 0,
    destinationTag: new Uint8Array(0),
    lastLedgerSequence: new Uint8Array(0),
    to: "",
    fee: 0,
    amount: 0,
    id: "",
    isSequenceSet: false,
  };
}

export const XRPPayment = {
  encode(message: XRPPayment, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.from !== "") {
      writer.uint32(10).string(message.from);
    }
    if (message.sequence !== 0) {
      writer.uint32(16).uint32(message.sequence);
    }
    if (message.destinationTag.length !== 0) {
      writer.uint32(26).bytes(message.destinationTag);
    }
    if (message.lastLedgerSequence.length !== 0) {
      writer.uint32(34).bytes(message.lastLedgerSequence);
    }
    if (message.to !== "") {
      writer.uint32(42).string(message.to);
    }
    if (message.fee !== 0) {
      writer.uint32(48).uint64(message.fee);
    }
    if (message.amount !== 0) {
      writer.uint32(56).uint64(message.amount);
    }
    if (message.id !== "") {
      writer.uint32(66).string(message.id);
    }
    if (message.isSequenceSet !== false) {
      writer.uint32(72).bool(message.isSequenceSet);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): XRPPayment {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseXRPPayment();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.from = reader.string();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.sequence = reader.uint32();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.destinationTag = reader.bytes();
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.lastLedgerSequence = reader.bytes();
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.to = reader.string();
          continue;
        case 6:
          if (tag !== 48) {
            break;
          }

          message.fee = longToNumber(reader.uint64() as Long);
          continue;
        case 7:
          if (tag !== 56) {
            break;
          }

          message.amount = longToNumber(reader.uint64() as Long);
          continue;
        case 8:
          if (tag !== 66) {
            break;
          }

          message.id = reader.string();
          continue;
        case 9:
          if (tag !== 72) {
            break;
          }

          message.isSequenceSet = reader.bool();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): XRPPayment {
    return {
      from: isSet(object.from) ? globalThis.String(object.from) : "",
      sequence: isSet(object.sequence) ? globalThis.Number(object.sequence) : 0,
      destinationTag: isSet(object.destinationTag) ? bytesFromBase64(object.destinationTag) : new Uint8Array(0),
      lastLedgerSequence: isSet(object.lastLedgerSequence)
        ? bytesFromBase64(object.lastLedgerSequence)
        : new Uint8Array(0),
      to: isSet(object.to) ? globalThis.String(object.to) : "",
      fee: isSet(object.fee) ? globalThis.Number(object.fee) : 0,
      amount: isSet(object.amount) ? globalThis.Number(object.amount) : 0,
      id: isSet(object.id) ? globalThis.String(object.id) : "",
      isSequenceSet: isSet(object.isSequenceSet) ? globalThis.Boolean(object.isSequenceSet) : false,
    };
  },

  toJSON(message: XRPPayment): unknown {
    const obj: any = {};
    if (message.from !== "") {
      obj.from = message.from;
    }
    if (message.sequence !== 0) {
      obj.sequence = Math.round(message.sequence);
    }
    if (message.destinationTag.length !== 0) {
      obj.destinationTag = base64FromBytes(message.destinationTag);
    }
    if (message.lastLedgerSequence.length !== 0) {
      obj.lastLedgerSequence = base64FromBytes(message.lastLedgerSequence);
    }
    if (message.to !== "") {
      obj.to = message.to;
    }
    if (message.fee !== 0) {
      obj.fee = Math.round(message.fee);
    }
    if (message.amount !== 0) {
      obj.amount = Math.round(message.amount);
    }
    if (message.id !== "") {
      obj.id = message.id;
    }
    if (message.isSequenceSet !== false) {
      obj.isSequenceSet = message.isSequenceSet;
    }
    return obj;
  },

  create(base?: DeepPartial<XRPPayment>): XRPPayment {
    return XRPPayment.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<XRPPayment>): XRPPayment {
    const message = createBaseXRPPayment();
    message.from = object.from ?? "";
    message.sequence = object.sequence ?? 0;
    message.destinationTag = object.destinationTag ?? new Uint8Array(0);
    message.lastLedgerSequence = object.lastLedgerSequence ?? new Uint8Array(0);
    message.to = object.to ?? "";
    message.fee = object.fee ?? 0;
    message.amount = object.amount ?? 0;
    message.id = object.id ?? "";
    message.isSequenceSet = object.isSequenceSet ?? false;
    return message;
  },
};

function createBaseXRPAddressRequest(): XRPAddressRequest {
  return { path: "" };
}

export const XRPAddressRequest = {
  encode(message: XRPAddressRequest, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.path !== "") {
      writer.uint32(10).string(message.path);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): XRPAddressRequest {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseXRPAddressRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.path = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): XRPAddressRequest {
    return { path: isSet(object.path) ? globalThis.String(object.path) : "" };
  },

  toJSON(message: XRPAddressRequest): unknown {
    const obj: any = {};
    if (message.path !== "") {
      obj.path = message.path;
    }
    return obj;
  },

  create(base?: DeepPartial<XRPAddressRequest>): XRPAddressRequest {
    return XRPAddressRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<XRPAddressRequest>): XRPAddressRequest {
    const message = createBaseXRPAddressRequest();
    message.path = object.path ?? "";
    return message;
  },
};

function createBaseXRPProofOfReserveRequest(): XRPProofOfReserveRequest {
  return { path: "", challenge: "" };
}

export const XRPProofOfReserveRequest = {
  encode(message: XRPProofOfReserveRequest, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.path !== "") {
      writer.uint32(10).string(message.path);
    }
    if (message.challenge !== "") {
      writer.uint32(18).string(message.challenge);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): XRPProofOfReserveRequest {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseXRPProofOfReserveRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.path = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.challenge = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): XRPProofOfReserveRequest {
    return {
      path: isSet(object.path) ? globalThis.String(object.path) : "",
      challenge: isSet(object.challenge) ? globalThis.String(object.challenge) : "",
    };
  },

  toJSON(message: XRPProofOfReserveRequest): unknown {
    const obj: any = {};
    if (message.path !== "") {
      obj.path = message.path;
    }
    if (message.challenge !== "") {
      obj.challenge = message.challenge;
    }
    return obj;
  },

  create(base?: DeepPartial<XRPProofOfReserveRequest>): XRPProofOfReserveRequest {
    return XRPProofOfReserveRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<XRPProofOfReserveRequest>): XRPProofOfReserveRequest {
    const message = createBaseXRPProofOfReserveRequest();
    message.path = object.path ?? "";
    message.challenge = object.challenge ?? "";
    return message;
  },
};

function createBaseXTZRevealRequest(): XTZRevealRequest {
  return { id: "", branch: "", from: "", fee: 0, counter: new Uint8Array(0), gasLimit: new Uint8Array(0) };
}

export const XTZRevealRequest = {
  encode(message: XTZRevealRequest, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.id !== "") {
      writer.uint32(10).string(message.id);
    }
    if (message.branch !== "") {
      writer.uint32(18).string(message.branch);
    }
    if (message.from !== "") {
      writer.uint32(26).string(message.from);
    }
    if (message.fee !== 0) {
      writer.uint32(32).uint64(message.fee);
    }
    if (message.counter.length !== 0) {
      writer.uint32(42).bytes(message.counter);
    }
    if (message.gasLimit.length !== 0) {
      writer.uint32(50).bytes(message.gasLimit);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): XTZRevealRequest {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseXTZRevealRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.id = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.branch = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.from = reader.string();
          continue;
        case 4:
          if (tag !== 32) {
            break;
          }

          message.fee = longToNumber(reader.uint64() as Long);
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.counter = reader.bytes();
          continue;
        case 6:
          if (tag !== 50) {
            break;
          }

          message.gasLimit = reader.bytes();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): XTZRevealRequest {
    return {
      id: isSet(object.id) ? globalThis.String(object.id) : "",
      branch: isSet(object.branch) ? globalThis.String(object.branch) : "",
      from: isSet(object.from) ? globalThis.String(object.from) : "",
      fee: isSet(object.fee) ? globalThis.Number(object.fee) : 0,
      counter: isSet(object.counter) ? bytesFromBase64(object.counter) : new Uint8Array(0),
      gasLimit: isSet(object.gasLimit) ? bytesFromBase64(object.gasLimit) : new Uint8Array(0),
    };
  },

  toJSON(message: XTZRevealRequest): unknown {
    const obj: any = {};
    if (message.id !== "") {
      obj.id = message.id;
    }
    if (message.branch !== "") {
      obj.branch = message.branch;
    }
    if (message.from !== "") {
      obj.from = message.from;
    }
    if (message.fee !== 0) {
      obj.fee = Math.round(message.fee);
    }
    if (message.counter.length !== 0) {
      obj.counter = base64FromBytes(message.counter);
    }
    if (message.gasLimit.length !== 0) {
      obj.gasLimit = base64FromBytes(message.gasLimit);
    }
    return obj;
  },

  create(base?: DeepPartial<XTZRevealRequest>): XTZRevealRequest {
    return XTZRevealRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<XTZRevealRequest>): XTZRevealRequest {
    const message = createBaseXTZRevealRequest();
    message.id = object.id ?? "";
    message.branch = object.branch ?? "";
    message.from = object.from ?? "";
    message.fee = object.fee ?? 0;
    message.counter = object.counter ?? new Uint8Array(0);
    message.gasLimit = object.gasLimit ?? new Uint8Array(0);
    return message;
  },
};

function createBaseXTZDelegationsRequest(): XTZDelegationsRequest {
  return { delegations: [] };
}

export const XTZDelegationsRequest = {
  encode(message: XTZDelegationsRequest, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    for (const v of message.delegations) {
      XTZDelegation.encode(v!, writer.uint32(10).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): XTZDelegationsRequest {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseXTZDelegationsRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.delegations.push(XTZDelegation.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): XTZDelegationsRequest {
    return {
      delegations: globalThis.Array.isArray(object?.delegations)
        ? object.delegations.map((e: any) => XTZDelegation.fromJSON(e))
        : [],
    };
  },

  toJSON(message: XTZDelegationsRequest): unknown {
    const obj: any = {};
    if (message.delegations?.length) {
      obj.delegations = message.delegations.map((e) => XTZDelegation.toJSON(e));
    }
    return obj;
  },

  create(base?: DeepPartial<XTZDelegationsRequest>): XTZDelegationsRequest {
    return XTZDelegationsRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<XTZDelegationsRequest>): XTZDelegationsRequest {
    const message = createBaseXTZDelegationsRequest();
    message.delegations = object.delegations?.map((e) => XTZDelegation.fromPartial(e)) || [];
    return message;
  },
};

function createBaseXTZDelegation(): XTZDelegation {
  return {
    id: "",
    branch: "",
    from: "",
    fee: 0,
    counter: new Uint8Array(0),
    gasLimit: new Uint8Array(0),
    delegate: "",
    isNonceSet: false,
  };
}

export const XTZDelegation = {
  encode(message: XTZDelegation, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.id !== "") {
      writer.uint32(10).string(message.id);
    }
    if (message.branch !== "") {
      writer.uint32(18).string(message.branch);
    }
    if (message.from !== "") {
      writer.uint32(26).string(message.from);
    }
    if (message.fee !== 0) {
      writer.uint32(32).uint64(message.fee);
    }
    if (message.counter.length !== 0) {
      writer.uint32(42).bytes(message.counter);
    }
    if (message.gasLimit.length !== 0) {
      writer.uint32(50).bytes(message.gasLimit);
    }
    if (message.delegate !== "") {
      writer.uint32(58).string(message.delegate);
    }
    if (message.isNonceSet !== false) {
      writer.uint32(64).bool(message.isNonceSet);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): XTZDelegation {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseXTZDelegation();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.id = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.branch = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.from = reader.string();
          continue;
        case 4:
          if (tag !== 32) {
            break;
          }

          message.fee = longToNumber(reader.uint64() as Long);
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.counter = reader.bytes();
          continue;
        case 6:
          if (tag !== 50) {
            break;
          }

          message.gasLimit = reader.bytes();
          continue;
        case 7:
          if (tag !== 58) {
            break;
          }

          message.delegate = reader.string();
          continue;
        case 8:
          if (tag !== 64) {
            break;
          }

          message.isNonceSet = reader.bool();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): XTZDelegation {
    return {
      id: isSet(object.id) ? globalThis.String(object.id) : "",
      branch: isSet(object.branch) ? globalThis.String(object.branch) : "",
      from: isSet(object.from) ? globalThis.String(object.from) : "",
      fee: isSet(object.fee) ? globalThis.Number(object.fee) : 0,
      counter: isSet(object.counter) ? bytesFromBase64(object.counter) : new Uint8Array(0),
      gasLimit: isSet(object.gasLimit) ? bytesFromBase64(object.gasLimit) : new Uint8Array(0),
      delegate: isSet(object.delegate) ? globalThis.String(object.delegate) : "",
      isNonceSet: isSet(object.isNonceSet) ? globalThis.Boolean(object.isNonceSet) : false,
    };
  },

  toJSON(message: XTZDelegation): unknown {
    const obj: any = {};
    if (message.id !== "") {
      obj.id = message.id;
    }
    if (message.branch !== "") {
      obj.branch = message.branch;
    }
    if (message.from !== "") {
      obj.from = message.from;
    }
    if (message.fee !== 0) {
      obj.fee = Math.round(message.fee);
    }
    if (message.counter.length !== 0) {
      obj.counter = base64FromBytes(message.counter);
    }
    if (message.gasLimit.length !== 0) {
      obj.gasLimit = base64FromBytes(message.gasLimit);
    }
    if (message.delegate !== "") {
      obj.delegate = message.delegate;
    }
    if (message.isNonceSet !== false) {
      obj.isNonceSet = message.isNonceSet;
    }
    return obj;
  },

  create(base?: DeepPartial<XTZDelegation>): XTZDelegation {
    return XTZDelegation.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<XTZDelegation>): XTZDelegation {
    const message = createBaseXTZDelegation();
    message.id = object.id ?? "";
    message.branch = object.branch ?? "";
    message.from = object.from ?? "";
    message.fee = object.fee ?? 0;
    message.counter = object.counter ?? new Uint8Array(0);
    message.gasLimit = object.gasLimit ?? new Uint8Array(0);
    message.delegate = object.delegate ?? "";
    message.isNonceSet = object.isNonceSet ?? false;
    return message;
  },
};

function createBaseXTZTransactionsRequest(): XTZTransactionsRequest {
  return { transactions: [] };
}

export const XTZTransactionsRequest = {
  encode(message: XTZTransactionsRequest, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    for (const v of message.transactions) {
      XTZTransaction.encode(v!, writer.uint32(10).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): XTZTransactionsRequest {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseXTZTransactionsRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.transactions.push(XTZTransaction.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): XTZTransactionsRequest {
    return {
      transactions: globalThis.Array.isArray(object?.transactions)
        ? object.transactions.map((e: any) => XTZTransaction.fromJSON(e))
        : [],
    };
  },

  toJSON(message: XTZTransactionsRequest): unknown {
    const obj: any = {};
    if (message.transactions?.length) {
      obj.transactions = message.transactions.map((e) => XTZTransaction.toJSON(e));
    }
    return obj;
  },

  create(base?: DeepPartial<XTZTransactionsRequest>): XTZTransactionsRequest {
    return XTZTransactionsRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<XTZTransactionsRequest>): XTZTransactionsRequest {
    const message = createBaseXTZTransactionsRequest();
    message.transactions = object.transactions?.map((e) => XTZTransaction.fromPartial(e)) || [];
    return message;
  },
};

function createBaseXTZTransaction(): XTZTransaction {
  return {
    id: "",
    branch: "",
    from: "",
    fee: 0,
    counter: new Uint8Array(0),
    gasLimit: new Uint8Array(0),
    storageLimit: new Uint8Array(0),
    amount: 0,
    to: "",
    parameters: new Uint8Array(0),
    isNonceSet: false,
  };
}

export const XTZTransaction = {
  encode(message: XTZTransaction, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.id !== "") {
      writer.uint32(10).string(message.id);
    }
    if (message.branch !== "") {
      writer.uint32(18).string(message.branch);
    }
    if (message.from !== "") {
      writer.uint32(26).string(message.from);
    }
    if (message.fee !== 0) {
      writer.uint32(32).uint64(message.fee);
    }
    if (message.counter.length !== 0) {
      writer.uint32(42).bytes(message.counter);
    }
    if (message.gasLimit.length !== 0) {
      writer.uint32(50).bytes(message.gasLimit);
    }
    if (message.storageLimit.length !== 0) {
      writer.uint32(58).bytes(message.storageLimit);
    }
    if (message.amount !== 0) {
      writer.uint32(64).uint64(message.amount);
    }
    if (message.to !== "") {
      writer.uint32(74).string(message.to);
    }
    if (message.parameters.length !== 0) {
      writer.uint32(82).bytes(message.parameters);
    }
    if (message.isNonceSet !== false) {
      writer.uint32(88).bool(message.isNonceSet);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): XTZTransaction {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseXTZTransaction();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.id = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.branch = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.from = reader.string();
          continue;
        case 4:
          if (tag !== 32) {
            break;
          }

          message.fee = longToNumber(reader.uint64() as Long);
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.counter = reader.bytes();
          continue;
        case 6:
          if (tag !== 50) {
            break;
          }

          message.gasLimit = reader.bytes();
          continue;
        case 7:
          if (tag !== 58) {
            break;
          }

          message.storageLimit = reader.bytes();
          continue;
        case 8:
          if (tag !== 64) {
            break;
          }

          message.amount = longToNumber(reader.uint64() as Long);
          continue;
        case 9:
          if (tag !== 74) {
            break;
          }

          message.to = reader.string();
          continue;
        case 10:
          if (tag !== 82) {
            break;
          }

          message.parameters = reader.bytes();
          continue;
        case 11:
          if (tag !== 88) {
            break;
          }

          message.isNonceSet = reader.bool();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): XTZTransaction {
    return {
      id: isSet(object.id) ? globalThis.String(object.id) : "",
      branch: isSet(object.branch) ? globalThis.String(object.branch) : "",
      from: isSet(object.from) ? globalThis.String(object.from) : "",
      fee: isSet(object.fee) ? globalThis.Number(object.fee) : 0,
      counter: isSet(object.counter) ? bytesFromBase64(object.counter) : new Uint8Array(0),
      gasLimit: isSet(object.gasLimit) ? bytesFromBase64(object.gasLimit) : new Uint8Array(0),
      storageLimit: isSet(object.storageLimit) ? bytesFromBase64(object.storageLimit) : new Uint8Array(0),
      amount: isSet(object.amount) ? globalThis.Number(object.amount) : 0,
      to: isSet(object.to) ? globalThis.String(object.to) : "",
      parameters: isSet(object.parameters) ? bytesFromBase64(object.parameters) : new Uint8Array(0),
      isNonceSet: isSet(object.isNonceSet) ? globalThis.Boolean(object.isNonceSet) : false,
    };
  },

  toJSON(message: XTZTransaction): unknown {
    const obj: any = {};
    if (message.id !== "") {
      obj.id = message.id;
    }
    if (message.branch !== "") {
      obj.branch = message.branch;
    }
    if (message.from !== "") {
      obj.from = message.from;
    }
    if (message.fee !== 0) {
      obj.fee = Math.round(message.fee);
    }
    if (message.counter.length !== 0) {
      obj.counter = base64FromBytes(message.counter);
    }
    if (message.gasLimit.length !== 0) {
      obj.gasLimit = base64FromBytes(message.gasLimit);
    }
    if (message.storageLimit.length !== 0) {
      obj.storageLimit = base64FromBytes(message.storageLimit);
    }
    if (message.amount !== 0) {
      obj.amount = Math.round(message.amount);
    }
    if (message.to !== "") {
      obj.to = message.to;
    }
    if (message.parameters.length !== 0) {
      obj.parameters = base64FromBytes(message.parameters);
    }
    if (message.isNonceSet !== false) {
      obj.isNonceSet = message.isNonceSet;
    }
    return obj;
  },

  create(base?: DeepPartial<XTZTransaction>): XTZTransaction {
    return XTZTransaction.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<XTZTransaction>): XTZTransaction {
    const message = createBaseXTZTransaction();
    message.id = object.id ?? "";
    message.branch = object.branch ?? "";
    message.from = object.from ?? "";
    message.fee = object.fee ?? 0;
    message.counter = object.counter ?? new Uint8Array(0);
    message.gasLimit = object.gasLimit ?? new Uint8Array(0);
    message.storageLimit = object.storageLimit ?? new Uint8Array(0);
    message.amount = object.amount ?? 0;
    message.to = object.to ?? "";
    message.parameters = object.parameters ?? new Uint8Array(0);
    message.isNonceSet = object.isNonceSet ?? false;
    return message;
  },
};

function createBaseXTZFA12TransfersRequest(): XTZFA12TransfersRequest {
  return { transfers: [] };
}

export const XTZFA12TransfersRequest = {
  encode(message: XTZFA12TransfersRequest, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    for (const v of message.transfers) {
      XTZFA12Transfer.encode(v!, writer.uint32(10).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): XTZFA12TransfersRequest {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseXTZFA12TransfersRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.transfers.push(XTZFA12Transfer.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): XTZFA12TransfersRequest {
    return {
      transfers: globalThis.Array.isArray(object?.transfers)
        ? object.transfers.map((e: any) => XTZFA12Transfer.fromJSON(e))
        : [],
    };
  },

  toJSON(message: XTZFA12TransfersRequest): unknown {
    const obj: any = {};
    if (message.transfers?.length) {
      obj.transfers = message.transfers.map((e) => XTZFA12Transfer.toJSON(e));
    }
    return obj;
  },

  create(base?: DeepPartial<XTZFA12TransfersRequest>): XTZFA12TransfersRequest {
    return XTZFA12TransfersRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<XTZFA12TransfersRequest>): XTZFA12TransfersRequest {
    const message = createBaseXTZFA12TransfersRequest();
    message.transfers = object.transfers?.map((e) => XTZFA12Transfer.fromPartial(e)) || [];
    return message;
  },
};

function createBaseXTZFA12Transfer(): XTZFA12Transfer {
  return {
    id: "",
    branch: "",
    from: "",
    fee: 0,
    counter: new Uint8Array(0),
    gasLimit: new Uint8Array(0),
    storageLimit: new Uint8Array(0),
    amount: 0,
    to: "",
    contract: "",
    isNonceSet: false,
  };
}

export const XTZFA12Transfer = {
  encode(message: XTZFA12Transfer, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.id !== "") {
      writer.uint32(10).string(message.id);
    }
    if (message.branch !== "") {
      writer.uint32(18).string(message.branch);
    }
    if (message.from !== "") {
      writer.uint32(26).string(message.from);
    }
    if (message.fee !== 0) {
      writer.uint32(32).uint64(message.fee);
    }
    if (message.counter.length !== 0) {
      writer.uint32(42).bytes(message.counter);
    }
    if (message.gasLimit.length !== 0) {
      writer.uint32(50).bytes(message.gasLimit);
    }
    if (message.storageLimit.length !== 0) {
      writer.uint32(58).bytes(message.storageLimit);
    }
    if (message.amount !== 0) {
      writer.uint32(64).uint64(message.amount);
    }
    if (message.to !== "") {
      writer.uint32(74).string(message.to);
    }
    if (message.contract !== "") {
      writer.uint32(82).string(message.contract);
    }
    if (message.isNonceSet !== false) {
      writer.uint32(88).bool(message.isNonceSet);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): XTZFA12Transfer {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseXTZFA12Transfer();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.id = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.branch = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.from = reader.string();
          continue;
        case 4:
          if (tag !== 32) {
            break;
          }

          message.fee = longToNumber(reader.uint64() as Long);
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.counter = reader.bytes();
          continue;
        case 6:
          if (tag !== 50) {
            break;
          }

          message.gasLimit = reader.bytes();
          continue;
        case 7:
          if (tag !== 58) {
            break;
          }

          message.storageLimit = reader.bytes();
          continue;
        case 8:
          if (tag !== 64) {
            break;
          }

          message.amount = longToNumber(reader.uint64() as Long);
          continue;
        case 9:
          if (tag !== 74) {
            break;
          }

          message.to = reader.string();
          continue;
        case 10:
          if (tag !== 82) {
            break;
          }

          message.contract = reader.string();
          continue;
        case 11:
          if (tag !== 88) {
            break;
          }

          message.isNonceSet = reader.bool();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): XTZFA12Transfer {
    return {
      id: isSet(object.id) ? globalThis.String(object.id) : "",
      branch: isSet(object.branch) ? globalThis.String(object.branch) : "",
      from: isSet(object.from) ? globalThis.String(object.from) : "",
      fee: isSet(object.fee) ? globalThis.Number(object.fee) : 0,
      counter: isSet(object.counter) ? bytesFromBase64(object.counter) : new Uint8Array(0),
      gasLimit: isSet(object.gasLimit) ? bytesFromBase64(object.gasLimit) : new Uint8Array(0),
      storageLimit: isSet(object.storageLimit) ? bytesFromBase64(object.storageLimit) : new Uint8Array(0),
      amount: isSet(object.amount) ? globalThis.Number(object.amount) : 0,
      to: isSet(object.to) ? globalThis.String(object.to) : "",
      contract: isSet(object.contract) ? globalThis.String(object.contract) : "",
      isNonceSet: isSet(object.isNonceSet) ? globalThis.Boolean(object.isNonceSet) : false,
    };
  },

  toJSON(message: XTZFA12Transfer): unknown {
    const obj: any = {};
    if (message.id !== "") {
      obj.id = message.id;
    }
    if (message.branch !== "") {
      obj.branch = message.branch;
    }
    if (message.from !== "") {
      obj.from = message.from;
    }
    if (message.fee !== 0) {
      obj.fee = Math.round(message.fee);
    }
    if (message.counter.length !== 0) {
      obj.counter = base64FromBytes(message.counter);
    }
    if (message.gasLimit.length !== 0) {
      obj.gasLimit = base64FromBytes(message.gasLimit);
    }
    if (message.storageLimit.length !== 0) {
      obj.storageLimit = base64FromBytes(message.storageLimit);
    }
    if (message.amount !== 0) {
      obj.amount = Math.round(message.amount);
    }
    if (message.to !== "") {
      obj.to = message.to;
    }
    if (message.contract !== "") {
      obj.contract = message.contract;
    }
    if (message.isNonceSet !== false) {
      obj.isNonceSet = message.isNonceSet;
    }
    return obj;
  },

  create(base?: DeepPartial<XTZFA12Transfer>): XTZFA12Transfer {
    return XTZFA12Transfer.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<XTZFA12Transfer>): XTZFA12Transfer {
    const message = createBaseXTZFA12Transfer();
    message.id = object.id ?? "";
    message.branch = object.branch ?? "";
    message.from = object.from ?? "";
    message.fee = object.fee ?? 0;
    message.counter = object.counter ?? new Uint8Array(0);
    message.gasLimit = object.gasLimit ?? new Uint8Array(0);
    message.storageLimit = object.storageLimit ?? new Uint8Array(0);
    message.amount = object.amount ?? 0;
    message.to = object.to ?? "";
    message.contract = object.contract ?? "";
    message.isNonceSet = object.isNonceSet ?? false;
    return message;
  },
};

function createBaseXTZFA2TransfersRequest(): XTZFA2TransfersRequest {
  return { transfers: [] };
}

export const XTZFA2TransfersRequest = {
  encode(message: XTZFA2TransfersRequest, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    for (const v of message.transfers) {
      XTZFA2Transfer.encode(v!, writer.uint32(10).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): XTZFA2TransfersRequest {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseXTZFA2TransfersRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.transfers.push(XTZFA2Transfer.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): XTZFA2TransfersRequest {
    return {
      transfers: globalThis.Array.isArray(object?.transfers)
        ? object.transfers.map((e: any) => XTZFA2Transfer.fromJSON(e))
        : [],
    };
  },

  toJSON(message: XTZFA2TransfersRequest): unknown {
    const obj: any = {};
    if (message.transfers?.length) {
      obj.transfers = message.transfers.map((e) => XTZFA2Transfer.toJSON(e));
    }
    return obj;
  },

  create(base?: DeepPartial<XTZFA2TransfersRequest>): XTZFA2TransfersRequest {
    return XTZFA2TransfersRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<XTZFA2TransfersRequest>): XTZFA2TransfersRequest {
    const message = createBaseXTZFA2TransfersRequest();
    message.transfers = object.transfers?.map((e) => XTZFA2Transfer.fromPartial(e)) || [];
    return message;
  },
};

function createBaseXTZFA2Transfer(): XTZFA2Transfer {
  return {
    id: "",
    branch: "",
    from: "",
    fee: 0,
    counter: new Uint8Array(0),
    gasLimit: new Uint8Array(0),
    storageLimit: new Uint8Array(0),
    amount: 0,
    to: "",
    contract: "",
    tokenId: new Uint8Array(0),
    isNonceSet: false,
  };
}

export const XTZFA2Transfer = {
  encode(message: XTZFA2Transfer, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.id !== "") {
      writer.uint32(10).string(message.id);
    }
    if (message.branch !== "") {
      writer.uint32(18).string(message.branch);
    }
    if (message.from !== "") {
      writer.uint32(26).string(message.from);
    }
    if (message.fee !== 0) {
      writer.uint32(32).uint64(message.fee);
    }
    if (message.counter.length !== 0) {
      writer.uint32(42).bytes(message.counter);
    }
    if (message.gasLimit.length !== 0) {
      writer.uint32(50).bytes(message.gasLimit);
    }
    if (message.storageLimit.length !== 0) {
      writer.uint32(58).bytes(message.storageLimit);
    }
    if (message.amount !== 0) {
      writer.uint32(64).uint64(message.amount);
    }
    if (message.to !== "") {
      writer.uint32(74).string(message.to);
    }
    if (message.contract !== "") {
      writer.uint32(82).string(message.contract);
    }
    if (message.tokenId.length !== 0) {
      writer.uint32(90).bytes(message.tokenId);
    }
    if (message.isNonceSet !== false) {
      writer.uint32(96).bool(message.isNonceSet);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): XTZFA2Transfer {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseXTZFA2Transfer();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.id = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.branch = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.from = reader.string();
          continue;
        case 4:
          if (tag !== 32) {
            break;
          }

          message.fee = longToNumber(reader.uint64() as Long);
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.counter = reader.bytes();
          continue;
        case 6:
          if (tag !== 50) {
            break;
          }

          message.gasLimit = reader.bytes();
          continue;
        case 7:
          if (tag !== 58) {
            break;
          }

          message.storageLimit = reader.bytes();
          continue;
        case 8:
          if (tag !== 64) {
            break;
          }

          message.amount = longToNumber(reader.uint64() as Long);
          continue;
        case 9:
          if (tag !== 74) {
            break;
          }

          message.to = reader.string();
          continue;
        case 10:
          if (tag !== 82) {
            break;
          }

          message.contract = reader.string();
          continue;
        case 11:
          if (tag !== 90) {
            break;
          }

          message.tokenId = reader.bytes();
          continue;
        case 12:
          if (tag !== 96) {
            break;
          }

          message.isNonceSet = reader.bool();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): XTZFA2Transfer {
    return {
      id: isSet(object.id) ? globalThis.String(object.id) : "",
      branch: isSet(object.branch) ? globalThis.String(object.branch) : "",
      from: isSet(object.from) ? globalThis.String(object.from) : "",
      fee: isSet(object.fee) ? globalThis.Number(object.fee) : 0,
      counter: isSet(object.counter) ? bytesFromBase64(object.counter) : new Uint8Array(0),
      gasLimit: isSet(object.gasLimit) ? bytesFromBase64(object.gasLimit) : new Uint8Array(0),
      storageLimit: isSet(object.storageLimit) ? bytesFromBase64(object.storageLimit) : new Uint8Array(0),
      amount: isSet(object.amount) ? globalThis.Number(object.amount) : 0,
      to: isSet(object.to) ? globalThis.String(object.to) : "",
      contract: isSet(object.contract) ? globalThis.String(object.contract) : "",
      tokenId: isSet(object.tokenId) ? bytesFromBase64(object.tokenId) : new Uint8Array(0),
      isNonceSet: isSet(object.isNonceSet) ? globalThis.Boolean(object.isNonceSet) : false,
    };
  },

  toJSON(message: XTZFA2Transfer): unknown {
    const obj: any = {};
    if (message.id !== "") {
      obj.id = message.id;
    }
    if (message.branch !== "") {
      obj.branch = message.branch;
    }
    if (message.from !== "") {
      obj.from = message.from;
    }
    if (message.fee !== 0) {
      obj.fee = Math.round(message.fee);
    }
    if (message.counter.length !== 0) {
      obj.counter = base64FromBytes(message.counter);
    }
    if (message.gasLimit.length !== 0) {
      obj.gasLimit = base64FromBytes(message.gasLimit);
    }
    if (message.storageLimit.length !== 0) {
      obj.storageLimit = base64FromBytes(message.storageLimit);
    }
    if (message.amount !== 0) {
      obj.amount = Math.round(message.amount);
    }
    if (message.to !== "") {
      obj.to = message.to;
    }
    if (message.contract !== "") {
      obj.contract = message.contract;
    }
    if (message.tokenId.length !== 0) {
      obj.tokenId = base64FromBytes(message.tokenId);
    }
    if (message.isNonceSet !== false) {
      obj.isNonceSet = message.isNonceSet;
    }
    return obj;
  },

  create(base?: DeepPartial<XTZFA2Transfer>): XTZFA2Transfer {
    return XTZFA2Transfer.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<XTZFA2Transfer>): XTZFA2Transfer {
    const message = createBaseXTZFA2Transfer();
    message.id = object.id ?? "";
    message.branch = object.branch ?? "";
    message.from = object.from ?? "";
    message.fee = object.fee ?? 0;
    message.counter = object.counter ?? new Uint8Array(0);
    message.gasLimit = object.gasLimit ?? new Uint8Array(0);
    message.storageLimit = object.storageLimit ?? new Uint8Array(0);
    message.amount = object.amount ?? 0;
    message.to = object.to ?? "";
    message.contract = object.contract ?? "";
    message.tokenId = object.tokenId ?? new Uint8Array(0);
    message.isNonceSet = object.isNonceSet ?? false;
    return message;
  },
};

function createBaseXTZCreateContractRequest(): XTZCreateContractRequest {
  return {
    id: "",
    branch: "",
    from: "",
    fee: 0,
    counter: new Uint8Array(0),
    gasLimit: new Uint8Array(0),
    storageLimit: new Uint8Array(0),
    amount: 0,
    delegate: "",
    code: new Uint8Array(0),
    storage: new Uint8Array(0),
    isNonceSet: false,
  };
}

export const XTZCreateContractRequest = {
  encode(message: XTZCreateContractRequest, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.id !== "") {
      writer.uint32(10).string(message.id);
    }
    if (message.branch !== "") {
      writer.uint32(18).string(message.branch);
    }
    if (message.from !== "") {
      writer.uint32(26).string(message.from);
    }
    if (message.fee !== 0) {
      writer.uint32(32).uint64(message.fee);
    }
    if (message.counter.length !== 0) {
      writer.uint32(42).bytes(message.counter);
    }
    if (message.gasLimit.length !== 0) {
      writer.uint32(50).bytes(message.gasLimit);
    }
    if (message.storageLimit.length !== 0) {
      writer.uint32(58).bytes(message.storageLimit);
    }
    if (message.amount !== 0) {
      writer.uint32(64).uint64(message.amount);
    }
    if (message.delegate !== "") {
      writer.uint32(74).string(message.delegate);
    }
    if (message.code.length !== 0) {
      writer.uint32(82).bytes(message.code);
    }
    if (message.storage.length !== 0) {
      writer.uint32(90).bytes(message.storage);
    }
    if (message.isNonceSet !== false) {
      writer.uint32(96).bool(message.isNonceSet);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): XTZCreateContractRequest {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseXTZCreateContractRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.id = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.branch = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.from = reader.string();
          continue;
        case 4:
          if (tag !== 32) {
            break;
          }

          message.fee = longToNumber(reader.uint64() as Long);
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.counter = reader.bytes();
          continue;
        case 6:
          if (tag !== 50) {
            break;
          }

          message.gasLimit = reader.bytes();
          continue;
        case 7:
          if (tag !== 58) {
            break;
          }

          message.storageLimit = reader.bytes();
          continue;
        case 8:
          if (tag !== 64) {
            break;
          }

          message.amount = longToNumber(reader.uint64() as Long);
          continue;
        case 9:
          if (tag !== 74) {
            break;
          }

          message.delegate = reader.string();
          continue;
        case 10:
          if (tag !== 82) {
            break;
          }

          message.code = reader.bytes();
          continue;
        case 11:
          if (tag !== 90) {
            break;
          }

          message.storage = reader.bytes();
          continue;
        case 12:
          if (tag !== 96) {
            break;
          }

          message.isNonceSet = reader.bool();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): XTZCreateContractRequest {
    return {
      id: isSet(object.id) ? globalThis.String(object.id) : "",
      branch: isSet(object.branch) ? globalThis.String(object.branch) : "",
      from: isSet(object.from) ? globalThis.String(object.from) : "",
      fee: isSet(object.fee) ? globalThis.Number(object.fee) : 0,
      counter: isSet(object.counter) ? bytesFromBase64(object.counter) : new Uint8Array(0),
      gasLimit: isSet(object.gasLimit) ? bytesFromBase64(object.gasLimit) : new Uint8Array(0),
      storageLimit: isSet(object.storageLimit) ? bytesFromBase64(object.storageLimit) : new Uint8Array(0),
      amount: isSet(object.amount) ? globalThis.Number(object.amount) : 0,
      delegate: isSet(object.delegate) ? globalThis.String(object.delegate) : "",
      code: isSet(object.code) ? bytesFromBase64(object.code) : new Uint8Array(0),
      storage: isSet(object.storage) ? bytesFromBase64(object.storage) : new Uint8Array(0),
      isNonceSet: isSet(object.isNonceSet) ? globalThis.Boolean(object.isNonceSet) : false,
    };
  },

  toJSON(message: XTZCreateContractRequest): unknown {
    const obj: any = {};
    if (message.id !== "") {
      obj.id = message.id;
    }
    if (message.branch !== "") {
      obj.branch = message.branch;
    }
    if (message.from !== "") {
      obj.from = message.from;
    }
    if (message.fee !== 0) {
      obj.fee = Math.round(message.fee);
    }
    if (message.counter.length !== 0) {
      obj.counter = base64FromBytes(message.counter);
    }
    if (message.gasLimit.length !== 0) {
      obj.gasLimit = base64FromBytes(message.gasLimit);
    }
    if (message.storageLimit.length !== 0) {
      obj.storageLimit = base64FromBytes(message.storageLimit);
    }
    if (message.amount !== 0) {
      obj.amount = Math.round(message.amount);
    }
    if (message.delegate !== "") {
      obj.delegate = message.delegate;
    }
    if (message.code.length !== 0) {
      obj.code = base64FromBytes(message.code);
    }
    if (message.storage.length !== 0) {
      obj.storage = base64FromBytes(message.storage);
    }
    if (message.isNonceSet !== false) {
      obj.isNonceSet = message.isNonceSet;
    }
    return obj;
  },

  create(base?: DeepPartial<XTZCreateContractRequest>): XTZCreateContractRequest {
    return XTZCreateContractRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<XTZCreateContractRequest>): XTZCreateContractRequest {
    const message = createBaseXTZCreateContractRequest();
    message.id = object.id ?? "";
    message.branch = object.branch ?? "";
    message.from = object.from ?? "";
    message.fee = object.fee ?? 0;
    message.counter = object.counter ?? new Uint8Array(0);
    message.gasLimit = object.gasLimit ?? new Uint8Array(0);
    message.storageLimit = object.storageLimit ?? new Uint8Array(0);
    message.amount = object.amount ?? 0;
    message.delegate = object.delegate ?? "";
    message.code = object.code ?? new Uint8Array(0);
    message.storage = object.storage ?? new Uint8Array(0);
    message.isNonceSet = object.isNonceSet ?? false;
    return message;
  },
};

function createBaseXTZStakeRequest(): XTZStakeRequest {
  return {
    id: "",
    branch: "",
    from: "",
    fee: 0,
    counter: new Uint8Array(0),
    gasLimit: new Uint8Array(0),
    amount: 0,
    isNonceSet: false,
  };
}

export const XTZStakeRequest = {
  encode(message: XTZStakeRequest, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.id !== "") {
      writer.uint32(10).string(message.id);
    }
    if (message.branch !== "") {
      writer.uint32(18).string(message.branch);
    }
    if (message.from !== "") {
      writer.uint32(26).string(message.from);
    }
    if (message.fee !== 0) {
      writer.uint32(32).uint64(message.fee);
    }
    if (message.counter.length !== 0) {
      writer.uint32(42).bytes(message.counter);
    }
    if (message.gasLimit.length !== 0) {
      writer.uint32(50).bytes(message.gasLimit);
    }
    if (message.amount !== 0) {
      writer.uint32(56).uint64(message.amount);
    }
    if (message.isNonceSet !== false) {
      writer.uint32(64).bool(message.isNonceSet);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): XTZStakeRequest {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseXTZStakeRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.id = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.branch = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.from = reader.string();
          continue;
        case 4:
          if (tag !== 32) {
            break;
          }

          message.fee = longToNumber(reader.uint64() as Long);
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.counter = reader.bytes();
          continue;
        case 6:
          if (tag !== 50) {
            break;
          }

          message.gasLimit = reader.bytes();
          continue;
        case 7:
          if (tag !== 56) {
            break;
          }

          message.amount = longToNumber(reader.uint64() as Long);
          continue;
        case 8:
          if (tag !== 64) {
            break;
          }

          message.isNonceSet = reader.bool();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): XTZStakeRequest {
    return {
      id: isSet(object.id) ? globalThis.String(object.id) : "",
      branch: isSet(object.branch) ? globalThis.String(object.branch) : "",
      from: isSet(object.from) ? globalThis.String(object.from) : "",
      fee: isSet(object.fee) ? globalThis.Number(object.fee) : 0,
      counter: isSet(object.counter) ? bytesFromBase64(object.counter) : new Uint8Array(0),
      gasLimit: isSet(object.gasLimit) ? bytesFromBase64(object.gasLimit) : new Uint8Array(0),
      amount: isSet(object.amount) ? globalThis.Number(object.amount) : 0,
      isNonceSet: isSet(object.isNonceSet) ? globalThis.Boolean(object.isNonceSet) : false,
    };
  },

  toJSON(message: XTZStakeRequest): unknown {
    const obj: any = {};
    if (message.id !== "") {
      obj.id = message.id;
    }
    if (message.branch !== "") {
      obj.branch = message.branch;
    }
    if (message.from !== "") {
      obj.from = message.from;
    }
    if (message.fee !== 0) {
      obj.fee = Math.round(message.fee);
    }
    if (message.counter.length !== 0) {
      obj.counter = base64FromBytes(message.counter);
    }
    if (message.gasLimit.length !== 0) {
      obj.gasLimit = base64FromBytes(message.gasLimit);
    }
    if (message.amount !== 0) {
      obj.amount = Math.round(message.amount);
    }
    if (message.isNonceSet !== false) {
      obj.isNonceSet = message.isNonceSet;
    }
    return obj;
  },

  create(base?: DeepPartial<XTZStakeRequest>): XTZStakeRequest {
    return XTZStakeRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<XTZStakeRequest>): XTZStakeRequest {
    const message = createBaseXTZStakeRequest();
    message.id = object.id ?? "";
    message.branch = object.branch ?? "";
    message.from = object.from ?? "";
    message.fee = object.fee ?? 0;
    message.counter = object.counter ?? new Uint8Array(0);
    message.gasLimit = object.gasLimit ?? new Uint8Array(0);
    message.amount = object.amount ?? 0;
    message.isNonceSet = object.isNonceSet ?? false;
    return message;
  },
};

function createBaseXTZUnstakeRequest(): XTZUnstakeRequest {
  return {
    id: "",
    branch: "",
    from: "",
    fee: 0,
    counter: new Uint8Array(0),
    gasLimit: new Uint8Array(0),
    amount: 0,
    isNonceSet: false,
  };
}

export const XTZUnstakeRequest = {
  encode(message: XTZUnstakeRequest, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.id !== "") {
      writer.uint32(10).string(message.id);
    }
    if (message.branch !== "") {
      writer.uint32(18).string(message.branch);
    }
    if (message.from !== "") {
      writer.uint32(26).string(message.from);
    }
    if (message.fee !== 0) {
      writer.uint32(32).uint64(message.fee);
    }
    if (message.counter.length !== 0) {
      writer.uint32(42).bytes(message.counter);
    }
    if (message.gasLimit.length !== 0) {
      writer.uint32(50).bytes(message.gasLimit);
    }
    if (message.amount !== 0) {
      writer.uint32(56).uint64(message.amount);
    }
    if (message.isNonceSet !== false) {
      writer.uint32(64).bool(message.isNonceSet);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): XTZUnstakeRequest {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseXTZUnstakeRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.id = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.branch = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.from = reader.string();
          continue;
        case 4:
          if (tag !== 32) {
            break;
          }

          message.fee = longToNumber(reader.uint64() as Long);
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.counter = reader.bytes();
          continue;
        case 6:
          if (tag !== 50) {
            break;
          }

          message.gasLimit = reader.bytes();
          continue;
        case 7:
          if (tag !== 56) {
            break;
          }

          message.amount = longToNumber(reader.uint64() as Long);
          continue;
        case 8:
          if (tag !== 64) {
            break;
          }

          message.isNonceSet = reader.bool();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): XTZUnstakeRequest {
    return {
      id: isSet(object.id) ? globalThis.String(object.id) : "",
      branch: isSet(object.branch) ? globalThis.String(object.branch) : "",
      from: isSet(object.from) ? globalThis.String(object.from) : "",
      fee: isSet(object.fee) ? globalThis.Number(object.fee) : 0,
      counter: isSet(object.counter) ? bytesFromBase64(object.counter) : new Uint8Array(0),
      gasLimit: isSet(object.gasLimit) ? bytesFromBase64(object.gasLimit) : new Uint8Array(0),
      amount: isSet(object.amount) ? globalThis.Number(object.amount) : 0,
      isNonceSet: isSet(object.isNonceSet) ? globalThis.Boolean(object.isNonceSet) : false,
    };
  },

  toJSON(message: XTZUnstakeRequest): unknown {
    const obj: any = {};
    if (message.id !== "") {
      obj.id = message.id;
    }
    if (message.branch !== "") {
      obj.branch = message.branch;
    }
    if (message.from !== "") {
      obj.from = message.from;
    }
    if (message.fee !== 0) {
      obj.fee = Math.round(message.fee);
    }
    if (message.counter.length !== 0) {
      obj.counter = base64FromBytes(message.counter);
    }
    if (message.gasLimit.length !== 0) {
      obj.gasLimit = base64FromBytes(message.gasLimit);
    }
    if (message.amount !== 0) {
      obj.amount = Math.round(message.amount);
    }
    if (message.isNonceSet !== false) {
      obj.isNonceSet = message.isNonceSet;
    }
    return obj;
  },

  create(base?: DeepPartial<XTZUnstakeRequest>): XTZUnstakeRequest {
    return XTZUnstakeRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<XTZUnstakeRequest>): XTZUnstakeRequest {
    const message = createBaseXTZUnstakeRequest();
    message.id = object.id ?? "";
    message.branch = object.branch ?? "";
    message.from = object.from ?? "";
    message.fee = object.fee ?? 0;
    message.counter = object.counter ?? new Uint8Array(0);
    message.gasLimit = object.gasLimit ?? new Uint8Array(0);
    message.amount = object.amount ?? 0;
    message.isNonceSet = object.isNonceSet ?? false;
    return message;
  },
};

function createBaseXTZFinalizeUnstakeRequest(): XTZFinalizeUnstakeRequest {
  return {
    id: "",
    branch: "",
    from: "",
    fee: 0,
    counter: new Uint8Array(0),
    gasLimit: new Uint8Array(0),
    isNonceSet: false,
  };
}

export const XTZFinalizeUnstakeRequest = {
  encode(message: XTZFinalizeUnstakeRequest, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.id !== "") {
      writer.uint32(10).string(message.id);
    }
    if (message.branch !== "") {
      writer.uint32(18).string(message.branch);
    }
    if (message.from !== "") {
      writer.uint32(26).string(message.from);
    }
    if (message.fee !== 0) {
      writer.uint32(32).uint64(message.fee);
    }
    if (message.counter.length !== 0) {
      writer.uint32(42).bytes(message.counter);
    }
    if (message.gasLimit.length !== 0) {
      writer.uint32(50).bytes(message.gasLimit);
    }
    if (message.isNonceSet !== false) {
      writer.uint32(56).bool(message.isNonceSet);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): XTZFinalizeUnstakeRequest {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseXTZFinalizeUnstakeRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.id = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.branch = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.from = reader.string();
          continue;
        case 4:
          if (tag !== 32) {
            break;
          }

          message.fee = longToNumber(reader.uint64() as Long);
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.counter = reader.bytes();
          continue;
        case 6:
          if (tag !== 50) {
            break;
          }

          message.gasLimit = reader.bytes();
          continue;
        case 7:
          if (tag !== 56) {
            break;
          }

          message.isNonceSet = reader.bool();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): XTZFinalizeUnstakeRequest {
    return {
      id: isSet(object.id) ? globalThis.String(object.id) : "",
      branch: isSet(object.branch) ? globalThis.String(object.branch) : "",
      from: isSet(object.from) ? globalThis.String(object.from) : "",
      fee: isSet(object.fee) ? globalThis.Number(object.fee) : 0,
      counter: isSet(object.counter) ? bytesFromBase64(object.counter) : new Uint8Array(0),
      gasLimit: isSet(object.gasLimit) ? bytesFromBase64(object.gasLimit) : new Uint8Array(0),
      isNonceSet: isSet(object.isNonceSet) ? globalThis.Boolean(object.isNonceSet) : false,
    };
  },

  toJSON(message: XTZFinalizeUnstakeRequest): unknown {
    const obj: any = {};
    if (message.id !== "") {
      obj.id = message.id;
    }
    if (message.branch !== "") {
      obj.branch = message.branch;
    }
    if (message.from !== "") {
      obj.from = message.from;
    }
    if (message.fee !== 0) {
      obj.fee = Math.round(message.fee);
    }
    if (message.counter.length !== 0) {
      obj.counter = base64FromBytes(message.counter);
    }
    if (message.gasLimit.length !== 0) {
      obj.gasLimit = base64FromBytes(message.gasLimit);
    }
    if (message.isNonceSet !== false) {
      obj.isNonceSet = message.isNonceSet;
    }
    return obj;
  },

  create(base?: DeepPartial<XTZFinalizeUnstakeRequest>): XTZFinalizeUnstakeRequest {
    return XTZFinalizeUnstakeRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<XTZFinalizeUnstakeRequest>): XTZFinalizeUnstakeRequest {
    const message = createBaseXTZFinalizeUnstakeRequest();
    message.id = object.id ?? "";
    message.branch = object.branch ?? "";
    message.from = object.from ?? "";
    message.fee = object.fee ?? 0;
    message.counter = object.counter ?? new Uint8Array(0);
    message.gasLimit = object.gasLimit ?? new Uint8Array(0);
    message.isNonceSet = object.isNonceSet ?? false;
    return message;
  },
};

function createBaseXTZAddressRequest(): XTZAddressRequest {
  return { path: "" };
}

export const XTZAddressRequest = {
  encode(message: XTZAddressRequest, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.path !== "") {
      writer.uint32(10).string(message.path);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): XTZAddressRequest {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseXTZAddressRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.path = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): XTZAddressRequest {
    return { path: isSet(object.path) ? globalThis.String(object.path) : "" };
  },

  toJSON(message: XTZAddressRequest): unknown {
    const obj: any = {};
    if (message.path !== "") {
      obj.path = message.path;
    }
    return obj;
  },

  create(base?: DeepPartial<XTZAddressRequest>): XTZAddressRequest {
    return XTZAddressRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<XTZAddressRequest>): XTZAddressRequest {
    const message = createBaseXTZAddressRequest();
    message.path = object.path ?? "";
    return message;
  },
};

function createBaseXTZProofOfReserveRequest(): XTZProofOfReserveRequest {
  return { path: "", challenge: "" };
}

export const XTZProofOfReserveRequest = {
  encode(message: XTZProofOfReserveRequest, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.path !== "") {
      writer.uint32(10).string(message.path);
    }
    if (message.challenge !== "") {
      writer.uint32(18).string(message.challenge);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): XTZProofOfReserveRequest {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseXTZProofOfReserveRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.path = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.challenge = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): XTZProofOfReserveRequest {
    return {
      path: isSet(object.path) ? globalThis.String(object.path) : "",
      challenge: isSet(object.challenge) ? globalThis.String(object.challenge) : "",
    };
  },

  toJSON(message: XTZProofOfReserveRequest): unknown {
    const obj: any = {};
    if (message.path !== "") {
      obj.path = message.path;
    }
    if (message.challenge !== "") {
      obj.challenge = message.challenge;
    }
    return obj;
  },

  create(base?: DeepPartial<XTZProofOfReserveRequest>): XTZProofOfReserveRequest {
    return XTZProofOfReserveRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<XTZProofOfReserveRequest>): XTZProofOfReserveRequest {
    const message = createBaseXTZProofOfReserveRequest();
    message.path = object.path ?? "";
    message.challenge = object.challenge ?? "";
    return message;
  },
};

function createBaseXTZBlockHeaderRequest(): XTZBlockHeaderRequest {
  return { id: "", path: "", payload: new Uint8Array(0) };
}

export const XTZBlockHeaderRequest = {
  encode(message: XTZBlockHeaderRequest, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.id !== "") {
      writer.uint32(10).string(message.id);
    }
    if (message.path !== "") {
      writer.uint32(18).string(message.path);
    }
    if (message.payload.length !== 0) {
      writer.uint32(26).bytes(message.payload);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): XTZBlockHeaderRequest {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseXTZBlockHeaderRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.id = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.path = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.payload = reader.bytes();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): XTZBlockHeaderRequest {
    return {
      id: isSet(object.id) ? globalThis.String(object.id) : "",
      path: isSet(object.path) ? globalThis.String(object.path) : "",
      payload: isSet(object.payload) ? bytesFromBase64(object.payload) : new Uint8Array(0),
    };
  },

  toJSON(message: XTZBlockHeaderRequest): unknown {
    const obj: any = {};
    if (message.id !== "") {
      obj.id = message.id;
    }
    if (message.path !== "") {
      obj.path = message.path;
    }
    if (message.payload.length !== 0) {
      obj.payload = base64FromBytes(message.payload);
    }
    return obj;
  },

  create(base?: DeepPartial<XTZBlockHeaderRequest>): XTZBlockHeaderRequest {
    return XTZBlockHeaderRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<XTZBlockHeaderRequest>): XTZBlockHeaderRequest {
    const message = createBaseXTZBlockHeaderRequest();
    message.id = object.id ?? "";
    message.path = object.path ?? "";
    message.payload = object.payload ?? new Uint8Array(0);
    return message;
  },
};

function createBaseETHTransactionsRequest(): ETHTransactionsRequest {
  return { transactions: [] };
}

export const ETHTransactionsRequest = {
  encode(message: ETHTransactionsRequest, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    for (const v of message.transactions) {
      ETHTransaction.encode(v!, writer.uint32(18).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): ETHTransactionsRequest {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseETHTransactionsRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 2:
          if (tag !== 18) {
            break;
          }

          message.transactions.push(ETHTransaction.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ETHTransactionsRequest {
    return {
      transactions: globalThis.Array.isArray(object?.transactions)
        ? object.transactions.map((e: any) => ETHTransaction.fromJSON(e))
        : [],
    };
  },

  toJSON(message: ETHTransactionsRequest): unknown {
    const obj: any = {};
    if (message.transactions?.length) {
      obj.transactions = message.transactions.map((e) => ETHTransaction.toJSON(e));
    }
    return obj;
  },

  create(base?: DeepPartial<ETHTransactionsRequest>): ETHTransactionsRequest {
    return ETHTransactionsRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ETHTransactionsRequest>): ETHTransactionsRequest {
    const message = createBaseETHTransactionsRequest();
    message.transactions = object.transactions?.map((e) => ETHTransaction.fromPartial(e)) || [];
    return message;
  },
};

function createBaseETHTransaction(): ETHTransaction {
  return {
    from: "",
    nonce: 0,
    gasLimit: 0,
    gasPrice: new Uint8Array(0),
    to: "",
    amount: new Uint8Array(0),
    payload: new Uint8Array(0),
    id: "",
    isNonceSet: false,
    chainId: 0,
  };
}

export const ETHTransaction = {
  encode(message: ETHTransaction, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.from !== "") {
      writer.uint32(10).string(message.from);
    }
    if (message.nonce !== 0) {
      writer.uint32(16).uint64(message.nonce);
    }
    if (message.gasLimit !== 0) {
      writer.uint32(24).uint64(message.gasLimit);
    }
    if (message.gasPrice.length !== 0) {
      writer.uint32(34).bytes(message.gasPrice);
    }
    if (message.to !== "") {
      writer.uint32(42).string(message.to);
    }
    if (message.amount.length !== 0) {
      writer.uint32(50).bytes(message.amount);
    }
    if (message.payload.length !== 0) {
      writer.uint32(58).bytes(message.payload);
    }
    if (message.id !== "") {
      writer.uint32(66).string(message.id);
    }
    if (message.isNonceSet !== false) {
      writer.uint32(72).bool(message.isNonceSet);
    }
    if (message.chainId !== 0) {
      writer.uint32(80).uint64(message.chainId);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): ETHTransaction {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseETHTransaction();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.from = reader.string();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.nonce = longToNumber(reader.uint64() as Long);
          continue;
        case 3:
          if (tag !== 24) {
            break;
          }

          message.gasLimit = longToNumber(reader.uint64() as Long);
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.gasPrice = reader.bytes();
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.to = reader.string();
          continue;
        case 6:
          if (tag !== 50) {
            break;
          }

          message.amount = reader.bytes();
          continue;
        case 7:
          if (tag !== 58) {
            break;
          }

          message.payload = reader.bytes();
          continue;
        case 8:
          if (tag !== 66) {
            break;
          }

          message.id = reader.string();
          continue;
        case 9:
          if (tag !== 72) {
            break;
          }

          message.isNonceSet = reader.bool();
          continue;
        case 10:
          if (tag !== 80) {
            break;
          }

          message.chainId = longToNumber(reader.uint64() as Long);
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ETHTransaction {
    return {
      from: isSet(object.from) ? globalThis.String(object.from) : "",
      nonce: isSet(object.nonce) ? globalThis.Number(object.nonce) : 0,
      gasLimit: isSet(object.gasLimit) ? globalThis.Number(object.gasLimit) : 0,
      gasPrice: isSet(object.gasPrice) ? bytesFromBase64(object.gasPrice) : new Uint8Array(0),
      to: isSet(object.to) ? globalThis.String(object.to) : "",
      amount: isSet(object.amount) ? bytesFromBase64(object.amount) : new Uint8Array(0),
      payload: isSet(object.payload) ? bytesFromBase64(object.payload) : new Uint8Array(0),
      id: isSet(object.id) ? globalThis.String(object.id) : "",
      isNonceSet: isSet(object.isNonceSet) ? globalThis.Boolean(object.isNonceSet) : false,
      chainId: isSet(object.chainId) ? globalThis.Number(object.chainId) : 0,
    };
  },

  toJSON(message: ETHTransaction): unknown {
    const obj: any = {};
    if (message.from !== "") {
      obj.from = message.from;
    }
    if (message.nonce !== 0) {
      obj.nonce = Math.round(message.nonce);
    }
    if (message.gasLimit !== 0) {
      obj.gasLimit = Math.round(message.gasLimit);
    }
    if (message.gasPrice.length !== 0) {
      obj.gasPrice = base64FromBytes(message.gasPrice);
    }
    if (message.to !== "") {
      obj.to = message.to;
    }
    if (message.amount.length !== 0) {
      obj.amount = base64FromBytes(message.amount);
    }
    if (message.payload.length !== 0) {
      obj.payload = base64FromBytes(message.payload);
    }
    if (message.id !== "") {
      obj.id = message.id;
    }
    if (message.isNonceSet !== false) {
      obj.isNonceSet = message.isNonceSet;
    }
    if (message.chainId !== 0) {
      obj.chainId = Math.round(message.chainId);
    }
    return obj;
  },

  create(base?: DeepPartial<ETHTransaction>): ETHTransaction {
    return ETHTransaction.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ETHTransaction>): ETHTransaction {
    const message = createBaseETHTransaction();
    message.from = object.from ?? "";
    message.nonce = object.nonce ?? 0;
    message.gasLimit = object.gasLimit ?? 0;
    message.gasPrice = object.gasPrice ?? new Uint8Array(0);
    message.to = object.to ?? "";
    message.amount = object.amount ?? new Uint8Array(0);
    message.payload = object.payload ?? new Uint8Array(0);
    message.id = object.id ?? "";
    message.isNonceSet = object.isNonceSet ?? false;
    message.chainId = object.chainId ?? 0;
    return message;
  },
};

function createBaseETHCreateContractRequest(): ETHCreateContractRequest {
  return {
    from: "",
    nonce: 0,
    gasLimit: 0,
    gasPrice: new Uint8Array(0),
    amount: new Uint8Array(0),
    payload: new Uint8Array(0),
    id: "",
    isNonceSet: false,
    chainId: 0,
  };
}

export const ETHCreateContractRequest = {
  encode(message: ETHCreateContractRequest, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.from !== "") {
      writer.uint32(10).string(message.from);
    }
    if (message.nonce !== 0) {
      writer.uint32(16).uint64(message.nonce);
    }
    if (message.gasLimit !== 0) {
      writer.uint32(24).uint64(message.gasLimit);
    }
    if (message.gasPrice.length !== 0) {
      writer.uint32(34).bytes(message.gasPrice);
    }
    if (message.amount.length !== 0) {
      writer.uint32(42).bytes(message.amount);
    }
    if (message.payload.length !== 0) {
      writer.uint32(50).bytes(message.payload);
    }
    if (message.id !== "") {
      writer.uint32(58).string(message.id);
    }
    if (message.isNonceSet !== false) {
      writer.uint32(64).bool(message.isNonceSet);
    }
    if (message.chainId !== 0) {
      writer.uint32(72).uint64(message.chainId);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): ETHCreateContractRequest {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseETHCreateContractRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.from = reader.string();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.nonce = longToNumber(reader.uint64() as Long);
          continue;
        case 3:
          if (tag !== 24) {
            break;
          }

          message.gasLimit = longToNumber(reader.uint64() as Long);
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.gasPrice = reader.bytes();
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.amount = reader.bytes();
          continue;
        case 6:
          if (tag !== 50) {
            break;
          }

          message.payload = reader.bytes();
          continue;
        case 7:
          if (tag !== 58) {
            break;
          }

          message.id = reader.string();
          continue;
        case 8:
          if (tag !== 64) {
            break;
          }

          message.isNonceSet = reader.bool();
          continue;
        case 9:
          if (tag !== 72) {
            break;
          }

          message.chainId = longToNumber(reader.uint64() as Long);
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ETHCreateContractRequest {
    return {
      from: isSet(object.from) ? globalThis.String(object.from) : "",
      nonce: isSet(object.nonce) ? globalThis.Number(object.nonce) : 0,
      gasLimit: isSet(object.gasLimit) ? globalThis.Number(object.gasLimit) : 0,
      gasPrice: isSet(object.gasPrice) ? bytesFromBase64(object.gasPrice) : new Uint8Array(0),
      amount: isSet(object.amount) ? bytesFromBase64(object.amount) : new Uint8Array(0),
      payload: isSet(object.payload) ? bytesFromBase64(object.payload) : new Uint8Array(0),
      id: isSet(object.id) ? globalThis.String(object.id) : "",
      isNonceSet: isSet(object.isNonceSet) ? globalThis.Boolean(object.isNonceSet) : false,
      chainId: isSet(object.chainId) ? globalThis.Number(object.chainId) : 0,
    };
  },

  toJSON(message: ETHCreateContractRequest): unknown {
    const obj: any = {};
    if (message.from !== "") {
      obj.from = message.from;
    }
    if (message.nonce !== 0) {
      obj.nonce = Math.round(message.nonce);
    }
    if (message.gasLimit !== 0) {
      obj.gasLimit = Math.round(message.gasLimit);
    }
    if (message.gasPrice.length !== 0) {
      obj.gasPrice = base64FromBytes(message.gasPrice);
    }
    if (message.amount.length !== 0) {
      obj.amount = base64FromBytes(message.amount);
    }
    if (message.payload.length !== 0) {
      obj.payload = base64FromBytes(message.payload);
    }
    if (message.id !== "") {
      obj.id = message.id;
    }
    if (message.isNonceSet !== false) {
      obj.isNonceSet = message.isNonceSet;
    }
    if (message.chainId !== 0) {
      obj.chainId = Math.round(message.chainId);
    }
    return obj;
  },

  create(base?: DeepPartial<ETHCreateContractRequest>): ETHCreateContractRequest {
    return ETHCreateContractRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ETHCreateContractRequest>): ETHCreateContractRequest {
    const message = createBaseETHCreateContractRequest();
    message.from = object.from ?? "";
    message.nonce = object.nonce ?? 0;
    message.gasLimit = object.gasLimit ?? 0;
    message.gasPrice = object.gasPrice ?? new Uint8Array(0);
    message.amount = object.amount ?? new Uint8Array(0);
    message.payload = object.payload ?? new Uint8Array(0);
    message.id = object.id ?? "";
    message.isNonceSet = object.isNonceSet ?? false;
    message.chainId = object.chainId ?? 0;
    return message;
  },
};

function createBaseETHAddressRequest(): ETHAddressRequest {
  return { path: "" };
}

export const ETHAddressRequest = {
  encode(message: ETHAddressRequest, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.path !== "") {
      writer.uint32(10).string(message.path);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): ETHAddressRequest {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseETHAddressRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.path = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ETHAddressRequest {
    return { path: isSet(object.path) ? globalThis.String(object.path) : "" };
  },

  toJSON(message: ETHAddressRequest): unknown {
    const obj: any = {};
    if (message.path !== "") {
      obj.path = message.path;
    }
    return obj;
  },

  create(base?: DeepPartial<ETHAddressRequest>): ETHAddressRequest {
    return ETHAddressRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ETHAddressRequest>): ETHAddressRequest {
    const message = createBaseETHAddressRequest();
    message.path = object.path ?? "";
    return message;
  },
};

function createBaseETHProofOfReserveRequest(): ETHProofOfReserveRequest {
  return { path: "", challenge: "" };
}

export const ETHProofOfReserveRequest = {
  encode(message: ETHProofOfReserveRequest, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.path !== "") {
      writer.uint32(10).string(message.path);
    }
    if (message.challenge !== "") {
      writer.uint32(18).string(message.challenge);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): ETHProofOfReserveRequest {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseETHProofOfReserveRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.path = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.challenge = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ETHProofOfReserveRequest {
    return {
      path: isSet(object.path) ? globalThis.String(object.path) : "",
      challenge: isSet(object.challenge) ? globalThis.String(object.challenge) : "",
    };
  },

  toJSON(message: ETHProofOfReserveRequest): unknown {
    const obj: any = {};
    if (message.path !== "") {
      obj.path = message.path;
    }
    if (message.challenge !== "") {
      obj.challenge = message.challenge;
    }
    return obj;
  },

  create(base?: DeepPartial<ETHProofOfReserveRequest>): ETHProofOfReserveRequest {
    return ETHProofOfReserveRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ETHProofOfReserveRequest>): ETHProofOfReserveRequest {
    const message = createBaseETHProofOfReserveRequest();
    message.path = object.path ?? "";
    message.challenge = object.challenge ?? "";
    return message;
  },
};

function createBaseETHTransactionsResponse(): ETHTransactionsResponse {
  return { transactions: [] };
}

export const ETHTransactionsResponse = {
  encode(message: ETHTransactionsResponse, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    for (const v of message.transactions) {
      ETHTransactionsResponse_ETHTransactionResponse.encode(v!, writer.uint32(10).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): ETHTransactionsResponse {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseETHTransactionsResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.transactions.push(ETHTransactionsResponse_ETHTransactionResponse.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ETHTransactionsResponse {
    return {
      transactions: globalThis.Array.isArray(object?.transactions)
        ? object.transactions.map((e: any) => ETHTransactionsResponse_ETHTransactionResponse.fromJSON(e))
        : [],
    };
  },

  toJSON(message: ETHTransactionsResponse): unknown {
    const obj: any = {};
    if (message.transactions?.length) {
      obj.transactions = message.transactions.map((e) => ETHTransactionsResponse_ETHTransactionResponse.toJSON(e));
    }
    return obj;
  },

  create(base?: DeepPartial<ETHTransactionsResponse>): ETHTransactionsResponse {
    return ETHTransactionsResponse.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ETHTransactionsResponse>): ETHTransactionsResponse {
    const message = createBaseETHTransactionsResponse();
    message.transactions =
      object.transactions?.map((e) => ETHTransactionsResponse_ETHTransactionResponse.fromPartial(e)) || [];
    return message;
  },
};

function createBaseETHTransactionsResponse_ETHTransactionResponse(): ETHTransactionsResponse_ETHTransactionResponse {
  return { id: "", transaction: "", publicKey: new Uint8Array(0) };
}

export const ETHTransactionsResponse_ETHTransactionResponse = {
  encode(
    message: ETHTransactionsResponse_ETHTransactionResponse,
    writer: _m0.Writer = _m0.Writer.create(),
  ): _m0.Writer {
    if (message.id !== "") {
      writer.uint32(10).string(message.id);
    }
    if (message.transaction !== "") {
      writer.uint32(18).string(message.transaction);
    }
    if (message.publicKey.length !== 0) {
      writer.uint32(26).bytes(message.publicKey);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): ETHTransactionsResponse_ETHTransactionResponse {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseETHTransactionsResponse_ETHTransactionResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.id = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.transaction = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.publicKey = reader.bytes();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ETHTransactionsResponse_ETHTransactionResponse {
    return {
      id: isSet(object.id) ? globalThis.String(object.id) : "",
      transaction: isSet(object.transaction) ? globalThis.String(object.transaction) : "",
      publicKey: isSet(object.publicKey) ? bytesFromBase64(object.publicKey) : new Uint8Array(0),
    };
  },

  toJSON(message: ETHTransactionsResponse_ETHTransactionResponse): unknown {
    const obj: any = {};
    if (message.id !== "") {
      obj.id = message.id;
    }
    if (message.transaction !== "") {
      obj.transaction = message.transaction;
    }
    if (message.publicKey.length !== 0) {
      obj.publicKey = base64FromBytes(message.publicKey);
    }
    return obj;
  },

  create(
    base?: DeepPartial<ETHTransactionsResponse_ETHTransactionResponse>,
  ): ETHTransactionsResponse_ETHTransactionResponse {
    return ETHTransactionsResponse_ETHTransactionResponse.fromPartial(base ?? {});
  },
  fromPartial(
    object: DeepPartial<ETHTransactionsResponse_ETHTransactionResponse>,
  ): ETHTransactionsResponse_ETHTransactionResponse {
    const message = createBaseETHTransactionsResponse_ETHTransactionResponse();
    message.id = object.id ?? "";
    message.transaction = object.transaction ?? "";
    message.publicKey = object.publicKey ?? new Uint8Array(0);
    return message;
  },
};

function createBaseETHSignTextRequest(): ETHSignTextRequest {
  return { id: "", from: "", message: "" };
}

export const ETHSignTextRequest = {
  encode(message: ETHSignTextRequest, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.id !== "") {
      writer.uint32(10).string(message.id);
    }
    if (message.from !== "") {
      writer.uint32(18).string(message.from);
    }
    if (message.message !== "") {
      writer.uint32(26).string(message.message);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): ETHSignTextRequest {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseETHSignTextRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.id = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.from = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.message = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ETHSignTextRequest {
    return {
      id: isSet(object.id) ? globalThis.String(object.id) : "",
      from: isSet(object.from) ? globalThis.String(object.from) : "",
      message: isSet(object.message) ? globalThis.String(object.message) : "",
    };
  },

  toJSON(message: ETHSignTextRequest): unknown {
    const obj: any = {};
    if (message.id !== "") {
      obj.id = message.id;
    }
    if (message.from !== "") {
      obj.from = message.from;
    }
    if (message.message !== "") {
      obj.message = message.message;
    }
    return obj;
  },

  create(base?: DeepPartial<ETHSignTextRequest>): ETHSignTextRequest {
    return ETHSignTextRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ETHSignTextRequest>): ETHSignTextRequest {
    const message = createBaseETHSignTextRequest();
    message.id = object.id ?? "";
    message.from = object.from ?? "";
    message.message = object.message ?? "";
    return message;
  },
};

function createBaseETHSignTextResponse(): ETHSignTextResponse {
  return { id: "", signature: new Uint8Array(0), publicKey: new Uint8Array(0) };
}

export const ETHSignTextResponse = {
  encode(message: ETHSignTextResponse, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.id !== "") {
      writer.uint32(10).string(message.id);
    }
    if (message.signature.length !== 0) {
      writer.uint32(18).bytes(message.signature);
    }
    if (message.publicKey.length !== 0) {
      writer.uint32(26).bytes(message.publicKey);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): ETHSignTextResponse {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseETHSignTextResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.id = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.signature = reader.bytes();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.publicKey = reader.bytes();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ETHSignTextResponse {
    return {
      id: isSet(object.id) ? globalThis.String(object.id) : "",
      signature: isSet(object.signature) ? bytesFromBase64(object.signature) : new Uint8Array(0),
      publicKey: isSet(object.publicKey) ? bytesFromBase64(object.publicKey) : new Uint8Array(0),
    };
  },

  toJSON(message: ETHSignTextResponse): unknown {
    const obj: any = {};
    if (message.id !== "") {
      obj.id = message.id;
    }
    if (message.signature.length !== 0) {
      obj.signature = base64FromBytes(message.signature);
    }
    if (message.publicKey.length !== 0) {
      obj.publicKey = base64FromBytes(message.publicKey);
    }
    return obj;
  },

  create(base?: DeepPartial<ETHSignTextResponse>): ETHSignTextResponse {
    return ETHSignTextResponse.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ETHSignTextResponse>): ETHSignTextResponse {
    const message = createBaseETHSignTextResponse();
    message.id = object.id ?? "";
    message.signature = object.signature ?? new Uint8Array(0);
    message.publicKey = object.publicKey ?? new Uint8Array(0);
    return message;
  },
};

function createBaseETHWrappedTransactionsRequest(): ETHWrappedTransactionsRequest {
  return { transactions: [] };
}

export const ETHWrappedTransactionsRequest = {
  encode(message: ETHWrappedTransactionsRequest, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    for (const v of message.transactions) {
      ETHWrappedTransaction.encode(v!, writer.uint32(10).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): ETHWrappedTransactionsRequest {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseETHWrappedTransactionsRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.transactions.push(ETHWrappedTransaction.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ETHWrappedTransactionsRequest {
    return {
      transactions: globalThis.Array.isArray(object?.transactions)
        ? object.transactions.map((e: any) => ETHWrappedTransaction.fromJSON(e))
        : [],
    };
  },

  toJSON(message: ETHWrappedTransactionsRequest): unknown {
    const obj: any = {};
    if (message.transactions?.length) {
      obj.transactions = message.transactions.map((e) => ETHWrappedTransaction.toJSON(e));
    }
    return obj;
  },

  create(base?: DeepPartial<ETHWrappedTransactionsRequest>): ETHWrappedTransactionsRequest {
    return ETHWrappedTransactionsRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ETHWrappedTransactionsRequest>): ETHWrappedTransactionsRequest {
    const message = createBaseETHWrappedTransactionsRequest();
    message.transactions = object.transactions?.map((e) => ETHWrappedTransaction.fromPartial(e)) || [];
    return message;
  },
};

function createBaseETHWrappedTransaction(): ETHWrappedTransaction {
  return {
    domainSeparator: new Uint8Array(0),
    requestTypeHash: new Uint8Array(0),
    from: "",
    to: "",
    nonce: 0,
    gasLimit: 0,
    payload: new Uint8Array(0),
    id: "",
    isNonceSet: false,
    forwarder: "",
    deadline: 0,
    forwarderKind: 0,
  };
}

export const ETHWrappedTransaction = {
  encode(message: ETHWrappedTransaction, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.domainSeparator.length !== 0) {
      writer.uint32(10).bytes(message.domainSeparator);
    }
    if (message.requestTypeHash.length !== 0) {
      writer.uint32(18).bytes(message.requestTypeHash);
    }
    if (message.from !== "") {
      writer.uint32(26).string(message.from);
    }
    if (message.to !== "") {
      writer.uint32(34).string(message.to);
    }
    if (message.nonce !== 0) {
      writer.uint32(40).uint64(message.nonce);
    }
    if (message.gasLimit !== 0) {
      writer.uint32(48).uint64(message.gasLimit);
    }
    if (message.payload.length !== 0) {
      writer.uint32(58).bytes(message.payload);
    }
    if (message.id !== "") {
      writer.uint32(66).string(message.id);
    }
    if (message.isNonceSet !== false) {
      writer.uint32(72).bool(message.isNonceSet);
    }
    if (message.forwarder !== "") {
      writer.uint32(82).string(message.forwarder);
    }
    if (message.deadline !== 0) {
      writer.uint32(88).uint64(message.deadline);
    }
    if (message.forwarderKind !== 0) {
      writer.uint32(96).int32(message.forwarderKind);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): ETHWrappedTransaction {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseETHWrappedTransaction();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.domainSeparator = reader.bytes();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.requestTypeHash = reader.bytes();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.from = reader.string();
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.to = reader.string();
          continue;
        case 5:
          if (tag !== 40) {
            break;
          }

          message.nonce = longToNumber(reader.uint64() as Long);
          continue;
        case 6:
          if (tag !== 48) {
            break;
          }

          message.gasLimit = longToNumber(reader.uint64() as Long);
          continue;
        case 7:
          if (tag !== 58) {
            break;
          }

          message.payload = reader.bytes();
          continue;
        case 8:
          if (tag !== 66) {
            break;
          }

          message.id = reader.string();
          continue;
        case 9:
          if (tag !== 72) {
            break;
          }

          message.isNonceSet = reader.bool();
          continue;
        case 10:
          if (tag !== 82) {
            break;
          }

          message.forwarder = reader.string();
          continue;
        case 11:
          if (tag !== 88) {
            break;
          }

          message.deadline = longToNumber(reader.uint64() as Long);
          continue;
        case 12:
          if (tag !== 96) {
            break;
          }

          message.forwarderKind = reader.int32() as any;
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ETHWrappedTransaction {
    return {
      domainSeparator: isSet(object.domainSeparator) ? bytesFromBase64(object.domainSeparator) : new Uint8Array(0),
      requestTypeHash: isSet(object.requestTypeHash) ? bytesFromBase64(object.requestTypeHash) : new Uint8Array(0),
      from: isSet(object.from) ? globalThis.String(object.from) : "",
      to: isSet(object.to) ? globalThis.String(object.to) : "",
      nonce: isSet(object.nonce) ? globalThis.Number(object.nonce) : 0,
      gasLimit: isSet(object.gasLimit) ? globalThis.Number(object.gasLimit) : 0,
      payload: isSet(object.payload) ? bytesFromBase64(object.payload) : new Uint8Array(0),
      id: isSet(object.id) ? globalThis.String(object.id) : "",
      isNonceSet: isSet(object.isNonceSet) ? globalThis.Boolean(object.isNonceSet) : false,
      forwarder: isSet(object.forwarder) ? globalThis.String(object.forwarder) : "",
      deadline: isSet(object.deadline) ? globalThis.Number(object.deadline) : 0,
      forwarderKind: isSet(object.forwarderKind)
        ? eTHWrappedTransaction_ForwarderKindFromJSON(object.forwarderKind)
        : 0,
    };
  },

  toJSON(message: ETHWrappedTransaction): unknown {
    const obj: any = {};
    if (message.domainSeparator.length !== 0) {
      obj.domainSeparator = base64FromBytes(message.domainSeparator);
    }
    if (message.requestTypeHash.length !== 0) {
      obj.requestTypeHash = base64FromBytes(message.requestTypeHash);
    }
    if (message.from !== "") {
      obj.from = message.from;
    }
    if (message.to !== "") {
      obj.to = message.to;
    }
    if (message.nonce !== 0) {
      obj.nonce = Math.round(message.nonce);
    }
    if (message.gasLimit !== 0) {
      obj.gasLimit = Math.round(message.gasLimit);
    }
    if (message.payload.length !== 0) {
      obj.payload = base64FromBytes(message.payload);
    }
    if (message.id !== "") {
      obj.id = message.id;
    }
    if (message.isNonceSet !== false) {
      obj.isNonceSet = message.isNonceSet;
    }
    if (message.forwarder !== "") {
      obj.forwarder = message.forwarder;
    }
    if (message.deadline !== 0) {
      obj.deadline = Math.round(message.deadline);
    }
    if (message.forwarderKind !== 0) {
      obj.forwarderKind = eTHWrappedTransaction_ForwarderKindToJSON(message.forwarderKind);
    }
    return obj;
  },

  create(base?: DeepPartial<ETHWrappedTransaction>): ETHWrappedTransaction {
    return ETHWrappedTransaction.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ETHWrappedTransaction>): ETHWrappedTransaction {
    const message = createBaseETHWrappedTransaction();
    message.domainSeparator = object.domainSeparator ?? new Uint8Array(0);
    message.requestTypeHash = object.requestTypeHash ?? new Uint8Array(0);
    message.from = object.from ?? "";
    message.to = object.to ?? "";
    message.nonce = object.nonce ?? 0;
    message.gasLimit = object.gasLimit ?? 0;
    message.payload = object.payload ?? new Uint8Array(0);
    message.id = object.id ?? "";
    message.isNonceSet = object.isNonceSet ?? false;
    message.forwarder = object.forwarder ?? "";
    message.deadline = object.deadline ?? 0;
    message.forwarderKind = object.forwarderKind ?? 0;
    return message;
  },
};

function createBaseETHWrappedCreateContractRequest(): ETHWrappedCreateContractRequest {
  return {
    domainSeparator: new Uint8Array(0),
    requestTypeHash: new Uint8Array(0),
    from: "",
    nonce: 0,
    payload: new Uint8Array(0),
    id: "",
    isNonceSet: false,
    creator: "",
  };
}

export const ETHWrappedCreateContractRequest = {
  encode(message: ETHWrappedCreateContractRequest, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.domainSeparator.length !== 0) {
      writer.uint32(10).bytes(message.domainSeparator);
    }
    if (message.requestTypeHash.length !== 0) {
      writer.uint32(18).bytes(message.requestTypeHash);
    }
    if (message.from !== "") {
      writer.uint32(26).string(message.from);
    }
    if (message.nonce !== 0) {
      writer.uint32(32).uint64(message.nonce);
    }
    if (message.payload.length !== 0) {
      writer.uint32(42).bytes(message.payload);
    }
    if (message.id !== "") {
      writer.uint32(50).string(message.id);
    }
    if (message.isNonceSet !== false) {
      writer.uint32(56).bool(message.isNonceSet);
    }
    if (message.creator !== "") {
      writer.uint32(66).string(message.creator);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): ETHWrappedCreateContractRequest {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseETHWrappedCreateContractRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.domainSeparator = reader.bytes();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.requestTypeHash = reader.bytes();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.from = reader.string();
          continue;
        case 4:
          if (tag !== 32) {
            break;
          }

          message.nonce = longToNumber(reader.uint64() as Long);
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.payload = reader.bytes();
          continue;
        case 6:
          if (tag !== 50) {
            break;
          }

          message.id = reader.string();
          continue;
        case 7:
          if (tag !== 56) {
            break;
          }

          message.isNonceSet = reader.bool();
          continue;
        case 8:
          if (tag !== 66) {
            break;
          }

          message.creator = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ETHWrappedCreateContractRequest {
    return {
      domainSeparator: isSet(object.domainSeparator) ? bytesFromBase64(object.domainSeparator) : new Uint8Array(0),
      requestTypeHash: isSet(object.requestTypeHash) ? bytesFromBase64(object.requestTypeHash) : new Uint8Array(0),
      from: isSet(object.from) ? globalThis.String(object.from) : "",
      nonce: isSet(object.nonce) ? globalThis.Number(object.nonce) : 0,
      payload: isSet(object.payload) ? bytesFromBase64(object.payload) : new Uint8Array(0),
      id: isSet(object.id) ? globalThis.String(object.id) : "",
      isNonceSet: isSet(object.isNonceSet) ? globalThis.Boolean(object.isNonceSet) : false,
      creator: isSet(object.creator) ? globalThis.String(object.creator) : "",
    };
  },

  toJSON(message: ETHWrappedCreateContractRequest): unknown {
    const obj: any = {};
    if (message.domainSeparator.length !== 0) {
      obj.domainSeparator = base64FromBytes(message.domainSeparator);
    }
    if (message.requestTypeHash.length !== 0) {
      obj.requestTypeHash = base64FromBytes(message.requestTypeHash);
    }
    if (message.from !== "") {
      obj.from = message.from;
    }
    if (message.nonce !== 0) {
      obj.nonce = Math.round(message.nonce);
    }
    if (message.payload.length !== 0) {
      obj.payload = base64FromBytes(message.payload);
    }
    if (message.id !== "") {
      obj.id = message.id;
    }
    if (message.isNonceSet !== false) {
      obj.isNonceSet = message.isNonceSet;
    }
    if (message.creator !== "") {
      obj.creator = message.creator;
    }
    return obj;
  },

  create(base?: DeepPartial<ETHWrappedCreateContractRequest>): ETHWrappedCreateContractRequest {
    return ETHWrappedCreateContractRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ETHWrappedCreateContractRequest>): ETHWrappedCreateContractRequest {
    const message = createBaseETHWrappedCreateContractRequest();
    message.domainSeparator = object.domainSeparator ?? new Uint8Array(0);
    message.requestTypeHash = object.requestTypeHash ?? new Uint8Array(0);
    message.from = object.from ?? "";
    message.nonce = object.nonce ?? 0;
    message.payload = object.payload ?? new Uint8Array(0);
    message.id = object.id ?? "";
    message.isNonceSet = object.isNonceSet ?? false;
    message.creator = object.creator ?? "";
    return message;
  },
};

function createBaseETHWrappedTransactionsResponse(): ETHWrappedTransactionsResponse {
  return { transactions: [] };
}

export const ETHWrappedTransactionsResponse = {
  encode(message: ETHWrappedTransactionsResponse, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    for (const v of message.transactions) {
      ETHWrappedTransactionsResponse_ETHWrappedTransactionResponse.encode(v!, writer.uint32(10).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): ETHWrappedTransactionsResponse {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseETHWrappedTransactionsResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.transactions.push(
            ETHWrappedTransactionsResponse_ETHWrappedTransactionResponse.decode(reader, reader.uint32()),
          );
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ETHWrappedTransactionsResponse {
    return {
      transactions: globalThis.Array.isArray(object?.transactions)
        ? object.transactions.map((e: any) => ETHWrappedTransactionsResponse_ETHWrappedTransactionResponse.fromJSON(e))
        : [],
    };
  },

  toJSON(message: ETHWrappedTransactionsResponse): unknown {
    const obj: any = {};
    if (message.transactions?.length) {
      obj.transactions = message.transactions.map((e) =>
        ETHWrappedTransactionsResponse_ETHWrappedTransactionResponse.toJSON(e)
      );
    }
    return obj;
  },

  create(base?: DeepPartial<ETHWrappedTransactionsResponse>): ETHWrappedTransactionsResponse {
    return ETHWrappedTransactionsResponse.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ETHWrappedTransactionsResponse>): ETHWrappedTransactionsResponse {
    const message = createBaseETHWrappedTransactionsResponse();
    message.transactions =
      object.transactions?.map((e) => ETHWrappedTransactionsResponse_ETHWrappedTransactionResponse.fromPartial(e)) ||
      [];
    return message;
  },
};

function createBaseETHWrappedTransactionsResponse_ETHWrappedTransactionResponse(): ETHWrappedTransactionsResponse_ETHWrappedTransactionResponse {
  return { id: "", transaction: "", publicKey: new Uint8Array(0) };
}

export const ETHWrappedTransactionsResponse_ETHWrappedTransactionResponse = {
  encode(
    message: ETHWrappedTransactionsResponse_ETHWrappedTransactionResponse,
    writer: _m0.Writer = _m0.Writer.create(),
  ): _m0.Writer {
    if (message.id !== "") {
      writer.uint32(10).string(message.id);
    }
    if (message.transaction !== "") {
      writer.uint32(18).string(message.transaction);
    }
    if (message.publicKey.length !== 0) {
      writer.uint32(26).bytes(message.publicKey);
    }
    return writer;
  },

  decode(
    input: _m0.Reader | Uint8Array,
    length?: number,
  ): ETHWrappedTransactionsResponse_ETHWrappedTransactionResponse {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseETHWrappedTransactionsResponse_ETHWrappedTransactionResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.id = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.transaction = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.publicKey = reader.bytes();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ETHWrappedTransactionsResponse_ETHWrappedTransactionResponse {
    return {
      id: isSet(object.id) ? globalThis.String(object.id) : "",
      transaction: isSet(object.transaction) ? globalThis.String(object.transaction) : "",
      publicKey: isSet(object.publicKey) ? bytesFromBase64(object.publicKey) : new Uint8Array(0),
    };
  },

  toJSON(message: ETHWrappedTransactionsResponse_ETHWrappedTransactionResponse): unknown {
    const obj: any = {};
    if (message.id !== "") {
      obj.id = message.id;
    }
    if (message.transaction !== "") {
      obj.transaction = message.transaction;
    }
    if (message.publicKey.length !== 0) {
      obj.publicKey = base64FromBytes(message.publicKey);
    }
    return obj;
  },

  create(
    base?: DeepPartial<ETHWrappedTransactionsResponse_ETHWrappedTransactionResponse>,
  ): ETHWrappedTransactionsResponse_ETHWrappedTransactionResponse {
    return ETHWrappedTransactionsResponse_ETHWrappedTransactionResponse.fromPartial(base ?? {});
  },
  fromPartial(
    object: DeepPartial<ETHWrappedTransactionsResponse_ETHWrappedTransactionResponse>,
  ): ETHWrappedTransactionsResponse_ETHWrappedTransactionResponse {
    const message = createBaseETHWrappedTransactionsResponse_ETHWrappedTransactionResponse();
    message.id = object.id ?? "";
    message.transaction = object.transaction ?? "";
    message.publicKey = object.publicKey ?? new Uint8Array(0);
    return message;
  },
};

function createBaseETHWrappedCreateContractResponse(): ETHWrappedCreateContractResponse {
  return { id: "", transaction: "", publicKey: new Uint8Array(0) };
}

export const ETHWrappedCreateContractResponse = {
  encode(message: ETHWrappedCreateContractResponse, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.id !== "") {
      writer.uint32(10).string(message.id);
    }
    if (message.transaction !== "") {
      writer.uint32(18).string(message.transaction);
    }
    if (message.publicKey.length !== 0) {
      writer.uint32(26).bytes(message.publicKey);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): ETHWrappedCreateContractResponse {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseETHWrappedCreateContractResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.id = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.transaction = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.publicKey = reader.bytes();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ETHWrappedCreateContractResponse {
    return {
      id: isSet(object.id) ? globalThis.String(object.id) : "",
      transaction: isSet(object.transaction) ? globalThis.String(object.transaction) : "",
      publicKey: isSet(object.publicKey) ? bytesFromBase64(object.publicKey) : new Uint8Array(0),
    };
  },

  toJSON(message: ETHWrappedCreateContractResponse): unknown {
    const obj: any = {};
    if (message.id !== "") {
      obj.id = message.id;
    }
    if (message.transaction !== "") {
      obj.transaction = message.transaction;
    }
    if (message.publicKey.length !== 0) {
      obj.publicKey = base64FromBytes(message.publicKey);
    }
    return obj;
  },

  create(base?: DeepPartial<ETHWrappedCreateContractResponse>): ETHWrappedCreateContractResponse {
    return ETHWrappedCreateContractResponse.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ETHWrappedCreateContractResponse>): ETHWrappedCreateContractResponse {
    const message = createBaseETHWrappedCreateContractResponse();
    message.id = object.id ?? "";
    message.transaction = object.transaction ?? "";
    message.publicKey = object.publicKey ?? new Uint8Array(0);
    return message;
  },
};

function createBaseBTCInput(): BTCInput {
  return { path: "", addressType: 0, txHash: new Uint8Array(0), outputIndex: 0, value: 0, sequenceNumber: 0 };
}

export const BTCInput = {
  encode(message: BTCInput, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.path !== "") {
      writer.uint32(10).string(message.path);
    }
    if (message.addressType !== 0) {
      writer.uint32(16).int32(message.addressType);
    }
    if (message.txHash.length !== 0) {
      writer.uint32(26).bytes(message.txHash);
    }
    if (message.outputIndex !== 0) {
      writer.uint32(32).uint32(message.outputIndex);
    }
    if (message.value !== 0) {
      writer.uint32(40).uint64(message.value);
    }
    if (message.sequenceNumber !== 0) {
      writer.uint32(48).uint32(message.sequenceNumber);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): BTCInput {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseBTCInput();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.path = reader.string();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.addressType = reader.int32() as any;
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.txHash = reader.bytes();
          continue;
        case 4:
          if (tag !== 32) {
            break;
          }

          message.outputIndex = reader.uint32();
          continue;
        case 5:
          if (tag !== 40) {
            break;
          }

          message.value = longToNumber(reader.uint64() as Long);
          continue;
        case 6:
          if (tag !== 48) {
            break;
          }

          message.sequenceNumber = reader.uint32();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): BTCInput {
    return {
      path: isSet(object.path) ? globalThis.String(object.path) : "",
      addressType: isSet(object.addressType) ? bTCAddressTypeFromJSON(object.addressType) : 0,
      txHash: isSet(object.txHash) ? bytesFromBase64(object.txHash) : new Uint8Array(0),
      outputIndex: isSet(object.outputIndex) ? globalThis.Number(object.outputIndex) : 0,
      value: isSet(object.value) ? globalThis.Number(object.value) : 0,
      sequenceNumber: isSet(object.sequenceNumber) ? globalThis.Number(object.sequenceNumber) : 0,
    };
  },

  toJSON(message: BTCInput): unknown {
    const obj: any = {};
    if (message.path !== "") {
      obj.path = message.path;
    }
    if (message.addressType !== 0) {
      obj.addressType = bTCAddressTypeToJSON(message.addressType);
    }
    if (message.txHash.length !== 0) {
      obj.txHash = base64FromBytes(message.txHash);
    }
    if (message.outputIndex !== 0) {
      obj.outputIndex = Math.round(message.outputIndex);
    }
    if (message.value !== 0) {
      obj.value = Math.round(message.value);
    }
    if (message.sequenceNumber !== 0) {
      obj.sequenceNumber = Math.round(message.sequenceNumber);
    }
    return obj;
  },

  create(base?: DeepPartial<BTCInput>): BTCInput {
    return BTCInput.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<BTCInput>): BTCInput {
    const message = createBaseBTCInput();
    message.path = object.path ?? "";
    message.addressType = object.addressType ?? 0;
    message.txHash = object.txHash ?? new Uint8Array(0);
    message.outputIndex = object.outputIndex ?? 0;
    message.value = object.value ?? 0;
    message.sequenceNumber = object.sequenceNumber ?? 0;
    return message;
  },
};

function createBaseBTCOutput(): BTCOutput {
  return { destination: "", amount: 0 };
}

export const BTCOutput = {
  encode(message: BTCOutput, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.destination !== "") {
      writer.uint32(10).string(message.destination);
    }
    if (message.amount !== 0) {
      writer.uint32(16).uint64(message.amount);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): BTCOutput {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseBTCOutput();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.destination = reader.string();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.amount = longToNumber(reader.uint64() as Long);
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): BTCOutput {
    return {
      destination: isSet(object.destination) ? globalThis.String(object.destination) : "",
      amount: isSet(object.amount) ? globalThis.Number(object.amount) : 0,
    };
  },

  toJSON(message: BTCOutput): unknown {
    const obj: any = {};
    if (message.destination !== "") {
      obj.destination = message.destination;
    }
    if (message.amount !== 0) {
      obj.amount = Math.round(message.amount);
    }
    return obj;
  },

  create(base?: DeepPartial<BTCOutput>): BTCOutput {
    return BTCOutput.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<BTCOutput>): BTCOutput {
    const message = createBaseBTCOutput();
    message.destination = object.destination ?? "";
    message.amount = object.amount ?? 0;
    return message;
  },
};

function createBaseBTCChangeOutput(): BTCChangeOutput {
  return { path: "", addressType: 0, amount: 0 };
}

export const BTCChangeOutput = {
  encode(message: BTCChangeOutput, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.path !== "") {
      writer.uint32(10).string(message.path);
    }
    if (message.addressType !== 0) {
      writer.uint32(16).int32(message.addressType);
    }
    if (message.amount !== 0) {
      writer.uint32(24).uint64(message.amount);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): BTCChangeOutput {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseBTCChangeOutput();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.path = reader.string();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.addressType = reader.int32() as any;
          continue;
        case 3:
          if (tag !== 24) {
            break;
          }

          message.amount = longToNumber(reader.uint64() as Long);
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): BTCChangeOutput {
    return {
      path: isSet(object.path) ? globalThis.String(object.path) : "",
      addressType: isSet(object.addressType) ? bTCAddressTypeFromJSON(object.addressType) : 0,
      amount: isSet(object.amount) ? globalThis.Number(object.amount) : 0,
    };
  },

  toJSON(message: BTCChangeOutput): unknown {
    const obj: any = {};
    if (message.path !== "") {
      obj.path = message.path;
    }
    if (message.addressType !== 0) {
      obj.addressType = bTCAddressTypeToJSON(message.addressType);
    }
    if (message.amount !== 0) {
      obj.amount = Math.round(message.amount);
    }
    return obj;
  },

  create(base?: DeepPartial<BTCChangeOutput>): BTCChangeOutput {
    return BTCChangeOutput.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<BTCChangeOutput>): BTCChangeOutput {
    const message = createBaseBTCChangeOutput();
    message.path = object.path ?? "";
    message.addressType = object.addressType ?? 0;
    message.amount = object.amount ?? 0;
    return message;
  },
};

function createBaseBTCTransactionRequest(): BTCTransactionRequest {
  return { inputs: [], outputs: [], changeOutputs: [], lockTime: 0, hashType: 0, id: "", size: 0 };
}

export const BTCTransactionRequest = {
  encode(message: BTCTransactionRequest, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    for (const v of message.inputs) {
      BTCInput.encode(v!, writer.uint32(10).fork()).ldelim();
    }
    for (const v of message.outputs) {
      BTCOutput.encode(v!, writer.uint32(18).fork()).ldelim();
    }
    for (const v of message.changeOutputs) {
      BTCChangeOutput.encode(v!, writer.uint32(26).fork()).ldelim();
    }
    if (message.lockTime !== 0) {
      writer.uint32(32).uint32(message.lockTime);
    }
    if (message.hashType !== 0) {
      writer.uint32(40).int32(message.hashType);
    }
    if (message.id !== "") {
      writer.uint32(50).string(message.id);
    }
    if (message.size !== 0) {
      writer.uint32(56).uint32(message.size);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): BTCTransactionRequest {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseBTCTransactionRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.inputs.push(BTCInput.decode(reader, reader.uint32()));
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.outputs.push(BTCOutput.decode(reader, reader.uint32()));
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.changeOutputs.push(BTCChangeOutput.decode(reader, reader.uint32()));
          continue;
        case 4:
          if (tag !== 32) {
            break;
          }

          message.lockTime = reader.uint32();
          continue;
        case 5:
          if (tag !== 40) {
            break;
          }

          message.hashType = reader.int32() as any;
          continue;
        case 6:
          if (tag !== 50) {
            break;
          }

          message.id = reader.string();
          continue;
        case 7:
          if (tag !== 56) {
            break;
          }

          message.size = reader.uint32();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): BTCTransactionRequest {
    return {
      inputs: globalThis.Array.isArray(object?.inputs) ? object.inputs.map((e: any) => BTCInput.fromJSON(e)) : [],
      outputs: globalThis.Array.isArray(object?.outputs) ? object.outputs.map((e: any) => BTCOutput.fromJSON(e)) : [],
      changeOutputs: globalThis.Array.isArray(object?.changeOutputs)
        ? object.changeOutputs.map((e: any) => BTCChangeOutput.fromJSON(e))
        : [],
      lockTime: isSet(object.lockTime) ? globalThis.Number(object.lockTime) : 0,
      hashType: isSet(object.hashType) ? bTCSigHashTypeFromJSON(object.hashType) : 0,
      id: isSet(object.id) ? globalThis.String(object.id) : "",
      size: isSet(object.size) ? globalThis.Number(object.size) : 0,
    };
  },

  toJSON(message: BTCTransactionRequest): unknown {
    const obj: any = {};
    if (message.inputs?.length) {
      obj.inputs = message.inputs.map((e) => BTCInput.toJSON(e));
    }
    if (message.outputs?.length) {
      obj.outputs = message.outputs.map((e) => BTCOutput.toJSON(e));
    }
    if (message.changeOutputs?.length) {
      obj.changeOutputs = message.changeOutputs.map((e) => BTCChangeOutput.toJSON(e));
    }
    if (message.lockTime !== 0) {
      obj.lockTime = Math.round(message.lockTime);
    }
    if (message.hashType !== 0) {
      obj.hashType = bTCSigHashTypeToJSON(message.hashType);
    }
    if (message.id !== "") {
      obj.id = message.id;
    }
    if (message.size !== 0) {
      obj.size = Math.round(message.size);
    }
    return obj;
  },

  create(base?: DeepPartial<BTCTransactionRequest>): BTCTransactionRequest {
    return BTCTransactionRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<BTCTransactionRequest>): BTCTransactionRequest {
    const message = createBaseBTCTransactionRequest();
    message.inputs = object.inputs?.map((e) => BTCInput.fromPartial(e)) || [];
    message.outputs = object.outputs?.map((e) => BTCOutput.fromPartial(e)) || [];
    message.changeOutputs = object.changeOutputs?.map((e) => BTCChangeOutput.fromPartial(e)) || [];
    message.lockTime = object.lockTime ?? 0;
    message.hashType = object.hashType ?? 0;
    message.id = object.id ?? "";
    message.size = object.size ?? 0;
    return message;
  },
};

function createBaseBTCAddressRequest(): BTCAddressRequest {
  return { path: "", addressType: 0 };
}

export const BTCAddressRequest = {
  encode(message: BTCAddressRequest, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.path !== "") {
      writer.uint32(10).string(message.path);
    }
    if (message.addressType !== 0) {
      writer.uint32(16).int32(message.addressType);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): BTCAddressRequest {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseBTCAddressRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.path = reader.string();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.addressType = reader.int32() as any;
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): BTCAddressRequest {
    return {
      path: isSet(object.path) ? globalThis.String(object.path) : "",
      addressType: isSet(object.addressType) ? bTCAddressTypeFromJSON(object.addressType) : 0,
    };
  },

  toJSON(message: BTCAddressRequest): unknown {
    const obj: any = {};
    if (message.path !== "") {
      obj.path = message.path;
    }
    if (message.addressType !== 0) {
      obj.addressType = bTCAddressTypeToJSON(message.addressType);
    }
    return obj;
  },

  create(base?: DeepPartial<BTCAddressRequest>): BTCAddressRequest {
    return BTCAddressRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<BTCAddressRequest>): BTCAddressRequest {
    const message = createBaseBTCAddressRequest();
    message.path = object.path ?? "";
    message.addressType = object.addressType ?? 0;
    return message;
  },
};

function createBaseBTCProofOfReserveRequest(): BTCProofOfReserveRequest {
  return { path: "", addressType: 0, challenge: "" };
}

export const BTCProofOfReserveRequest = {
  encode(message: BTCProofOfReserveRequest, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.path !== "") {
      writer.uint32(10).string(message.path);
    }
    if (message.addressType !== 0) {
      writer.uint32(16).int32(message.addressType);
    }
    if (message.challenge !== "") {
      writer.uint32(26).string(message.challenge);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): BTCProofOfReserveRequest {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseBTCProofOfReserveRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.path = reader.string();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.addressType = reader.int32() as any;
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.challenge = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): BTCProofOfReserveRequest {
    return {
      path: isSet(object.path) ? globalThis.String(object.path) : "",
      addressType: isSet(object.addressType) ? bTCAddressTypeFromJSON(object.addressType) : 0,
      challenge: isSet(object.challenge) ? globalThis.String(object.challenge) : "",
    };
  },

  toJSON(message: BTCProofOfReserveRequest): unknown {
    const obj: any = {};
    if (message.path !== "") {
      obj.path = message.path;
    }
    if (message.addressType !== 0) {
      obj.addressType = bTCAddressTypeToJSON(message.addressType);
    }
    if (message.challenge !== "") {
      obj.challenge = message.challenge;
    }
    return obj;
  },

  create(base?: DeepPartial<BTCProofOfReserveRequest>): BTCProofOfReserveRequest {
    return BTCProofOfReserveRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<BTCProofOfReserveRequest>): BTCProofOfReserveRequest {
    const message = createBaseBTCProofOfReserveRequest();
    message.path = object.path ?? "";
    message.addressType = object.addressType ?? 0;
    message.challenge = object.challenge ?? "";
    return message;
  },
};

function createBaseBTCSignTextRequest(): BTCSignTextRequest {
  return { id: "", from: "", message: "" };
}

export const BTCSignTextRequest = {
  encode(message: BTCSignTextRequest, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.id !== "") {
      writer.uint32(10).string(message.id);
    }
    if (message.from !== "") {
      writer.uint32(18).string(message.from);
    }
    if (message.message !== "") {
      writer.uint32(26).string(message.message);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): BTCSignTextRequest {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseBTCSignTextRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.id = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.from = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.message = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): BTCSignTextRequest {
    return {
      id: isSet(object.id) ? globalThis.String(object.id) : "",
      from: isSet(object.from) ? globalThis.String(object.from) : "",
      message: isSet(object.message) ? globalThis.String(object.message) : "",
    };
  },

  toJSON(message: BTCSignTextRequest): unknown {
    const obj: any = {};
    if (message.id !== "") {
      obj.id = message.id;
    }
    if (message.from !== "") {
      obj.from = message.from;
    }
    if (message.message !== "") {
      obj.message = message.message;
    }
    return obj;
  },

  create(base?: DeepPartial<BTCSignTextRequest>): BTCSignTextRequest {
    return BTCSignTextRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<BTCSignTextRequest>): BTCSignTextRequest {
    const message = createBaseBTCSignTextRequest();
    message.id = object.id ?? "";
    message.from = object.from ?? "";
    message.message = object.message ?? "";
    return message;
  },
};

function createBaseBTCSignTextResponse(): BTCSignTextResponse {
  return { id: "", signature: new Uint8Array(0), publicKey: new Uint8Array(0) };
}

export const BTCSignTextResponse = {
  encode(message: BTCSignTextResponse, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.id !== "") {
      writer.uint32(10).string(message.id);
    }
    if (message.signature.length !== 0) {
      writer.uint32(18).bytes(message.signature);
    }
    if (message.publicKey.length !== 0) {
      writer.uint32(26).bytes(message.publicKey);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): BTCSignTextResponse {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseBTCSignTextResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.id = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.signature = reader.bytes();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.publicKey = reader.bytes();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): BTCSignTextResponse {
    return {
      id: isSet(object.id) ? globalThis.String(object.id) : "",
      signature: isSet(object.signature) ? bytesFromBase64(object.signature) : new Uint8Array(0),
      publicKey: isSet(object.publicKey) ? bytesFromBase64(object.publicKey) : new Uint8Array(0),
    };
  },

  toJSON(message: BTCSignTextResponse): unknown {
    const obj: any = {};
    if (message.id !== "") {
      obj.id = message.id;
    }
    if (message.signature.length !== 0) {
      obj.signature = base64FromBytes(message.signature);
    }
    if (message.publicKey.length !== 0) {
      obj.publicKey = base64FromBytes(message.publicKey);
    }
    return obj;
  },

  create(base?: DeepPartial<BTCSignTextResponse>): BTCSignTextResponse {
    return BTCSignTextResponse.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<BTCSignTextResponse>): BTCSignTextResponse {
    const message = createBaseBTCSignTextResponse();
    message.id = object.id ?? "";
    message.signature = object.signature ?? new Uint8Array(0);
    message.publicKey = object.publicKey ?? new Uint8Array(0);
    return message;
  },
};

function createBaseLTCInput(): LTCInput {
  return { path: "", addressType: 0, txHash: new Uint8Array(0), outputIndex: 0, value: 0, sequenceNumber: 0 };
}

export const LTCInput = {
  encode(message: LTCInput, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.path !== "") {
      writer.uint32(10).string(message.path);
    }
    if (message.addressType !== 0) {
      writer.uint32(16).int32(message.addressType);
    }
    if (message.txHash.length !== 0) {
      writer.uint32(26).bytes(message.txHash);
    }
    if (message.outputIndex !== 0) {
      writer.uint32(32).uint32(message.outputIndex);
    }
    if (message.value !== 0) {
      writer.uint32(40).uint64(message.value);
    }
    if (message.sequenceNumber !== 0) {
      writer.uint32(48).uint32(message.sequenceNumber);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): LTCInput {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseLTCInput();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.path = reader.string();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.addressType = reader.int32() as any;
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.txHash = reader.bytes();
          continue;
        case 4:
          if (tag !== 32) {
            break;
          }

          message.outputIndex = reader.uint32();
          continue;
        case 5:
          if (tag !== 40) {
            break;
          }

          message.value = longToNumber(reader.uint64() as Long);
          continue;
        case 6:
          if (tag !== 48) {
            break;
          }

          message.sequenceNumber = reader.uint32();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): LTCInput {
    return {
      path: isSet(object.path) ? globalThis.String(object.path) : "",
      addressType: isSet(object.addressType) ? lTCAddressTypeFromJSON(object.addressType) : 0,
      txHash: isSet(object.txHash) ? bytesFromBase64(object.txHash) : new Uint8Array(0),
      outputIndex: isSet(object.outputIndex) ? globalThis.Number(object.outputIndex) : 0,
      value: isSet(object.value) ? globalThis.Number(object.value) : 0,
      sequenceNumber: isSet(object.sequenceNumber) ? globalThis.Number(object.sequenceNumber) : 0,
    };
  },

  toJSON(message: LTCInput): unknown {
    const obj: any = {};
    if (message.path !== "") {
      obj.path = message.path;
    }
    if (message.addressType !== 0) {
      obj.addressType = lTCAddressTypeToJSON(message.addressType);
    }
    if (message.txHash.length !== 0) {
      obj.txHash = base64FromBytes(message.txHash);
    }
    if (message.outputIndex !== 0) {
      obj.outputIndex = Math.round(message.outputIndex);
    }
    if (message.value !== 0) {
      obj.value = Math.round(message.value);
    }
    if (message.sequenceNumber !== 0) {
      obj.sequenceNumber = Math.round(message.sequenceNumber);
    }
    return obj;
  },

  create(base?: DeepPartial<LTCInput>): LTCInput {
    return LTCInput.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<LTCInput>): LTCInput {
    const message = createBaseLTCInput();
    message.path = object.path ?? "";
    message.addressType = object.addressType ?? 0;
    message.txHash = object.txHash ?? new Uint8Array(0);
    message.outputIndex = object.outputIndex ?? 0;
    message.value = object.value ?? 0;
    message.sequenceNumber = object.sequenceNumber ?? 0;
    return message;
  },
};

function createBaseLTCOutput(): LTCOutput {
  return { destination: "", amount: 0 };
}

export const LTCOutput = {
  encode(message: LTCOutput, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.destination !== "") {
      writer.uint32(10).string(message.destination);
    }
    if (message.amount !== 0) {
      writer.uint32(16).uint64(message.amount);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): LTCOutput {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseLTCOutput();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.destination = reader.string();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.amount = longToNumber(reader.uint64() as Long);
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): LTCOutput {
    return {
      destination: isSet(object.destination) ? globalThis.String(object.destination) : "",
      amount: isSet(object.amount) ? globalThis.Number(object.amount) : 0,
    };
  },

  toJSON(message: LTCOutput): unknown {
    const obj: any = {};
    if (message.destination !== "") {
      obj.destination = message.destination;
    }
    if (message.amount !== 0) {
      obj.amount = Math.round(message.amount);
    }
    return obj;
  },

  create(base?: DeepPartial<LTCOutput>): LTCOutput {
    return LTCOutput.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<LTCOutput>): LTCOutput {
    const message = createBaseLTCOutput();
    message.destination = object.destination ?? "";
    message.amount = object.amount ?? 0;
    return message;
  },
};

function createBaseLTCChangeOutput(): LTCChangeOutput {
  return { path: "", addressType: 0, amount: 0 };
}

export const LTCChangeOutput = {
  encode(message: LTCChangeOutput, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.path !== "") {
      writer.uint32(10).string(message.path);
    }
    if (message.addressType !== 0) {
      writer.uint32(16).int32(message.addressType);
    }
    if (message.amount !== 0) {
      writer.uint32(24).uint64(message.amount);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): LTCChangeOutput {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseLTCChangeOutput();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.path = reader.string();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.addressType = reader.int32() as any;
          continue;
        case 3:
          if (tag !== 24) {
            break;
          }

          message.amount = longToNumber(reader.uint64() as Long);
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): LTCChangeOutput {
    return {
      path: isSet(object.path) ? globalThis.String(object.path) : "",
      addressType: isSet(object.addressType) ? lTCAddressTypeFromJSON(object.addressType) : 0,
      amount: isSet(object.amount) ? globalThis.Number(object.amount) : 0,
    };
  },

  toJSON(message: LTCChangeOutput): unknown {
    const obj: any = {};
    if (message.path !== "") {
      obj.path = message.path;
    }
    if (message.addressType !== 0) {
      obj.addressType = lTCAddressTypeToJSON(message.addressType);
    }
    if (message.amount !== 0) {
      obj.amount = Math.round(message.amount);
    }
    return obj;
  },

  create(base?: DeepPartial<LTCChangeOutput>): LTCChangeOutput {
    return LTCChangeOutput.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<LTCChangeOutput>): LTCChangeOutput {
    const message = createBaseLTCChangeOutput();
    message.path = object.path ?? "";
    message.addressType = object.addressType ?? 0;
    message.amount = object.amount ?? 0;
    return message;
  },
};

function createBaseLTCTransactionRequest(): LTCTransactionRequest {
  return { inputs: [], outputs: [], changeOutputs: [], lockTime: 0, hashType: 0, id: "" };
}

export const LTCTransactionRequest = {
  encode(message: LTCTransactionRequest, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    for (const v of message.inputs) {
      LTCInput.encode(v!, writer.uint32(10).fork()).ldelim();
    }
    for (const v of message.outputs) {
      LTCOutput.encode(v!, writer.uint32(18).fork()).ldelim();
    }
    for (const v of message.changeOutputs) {
      LTCChangeOutput.encode(v!, writer.uint32(26).fork()).ldelim();
    }
    if (message.lockTime !== 0) {
      writer.uint32(32).uint32(message.lockTime);
    }
    if (message.hashType !== 0) {
      writer.uint32(40).int32(message.hashType);
    }
    if (message.id !== "") {
      writer.uint32(50).string(message.id);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): LTCTransactionRequest {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseLTCTransactionRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.inputs.push(LTCInput.decode(reader, reader.uint32()));
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.outputs.push(LTCOutput.decode(reader, reader.uint32()));
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.changeOutputs.push(LTCChangeOutput.decode(reader, reader.uint32()));
          continue;
        case 4:
          if (tag !== 32) {
            break;
          }

          message.lockTime = reader.uint32();
          continue;
        case 5:
          if (tag !== 40) {
            break;
          }

          message.hashType = reader.int32() as any;
          continue;
        case 6:
          if (tag !== 50) {
            break;
          }

          message.id = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): LTCTransactionRequest {
    return {
      inputs: globalThis.Array.isArray(object?.inputs) ? object.inputs.map((e: any) => LTCInput.fromJSON(e)) : [],
      outputs: globalThis.Array.isArray(object?.outputs) ? object.outputs.map((e: any) => LTCOutput.fromJSON(e)) : [],
      changeOutputs: globalThis.Array.isArray(object?.changeOutputs)
        ? object.changeOutputs.map((e: any) => LTCChangeOutput.fromJSON(e))
        : [],
      lockTime: isSet(object.lockTime) ? globalThis.Number(object.lockTime) : 0,
      hashType: isSet(object.hashType) ? lTCSigHashTypeFromJSON(object.hashType) : 0,
      id: isSet(object.id) ? globalThis.String(object.id) : "",
    };
  },

  toJSON(message: LTCTransactionRequest): unknown {
    const obj: any = {};
    if (message.inputs?.length) {
      obj.inputs = message.inputs.map((e) => LTCInput.toJSON(e));
    }
    if (message.outputs?.length) {
      obj.outputs = message.outputs.map((e) => LTCOutput.toJSON(e));
    }
    if (message.changeOutputs?.length) {
      obj.changeOutputs = message.changeOutputs.map((e) => LTCChangeOutput.toJSON(e));
    }
    if (message.lockTime !== 0) {
      obj.lockTime = Math.round(message.lockTime);
    }
    if (message.hashType !== 0) {
      obj.hashType = lTCSigHashTypeToJSON(message.hashType);
    }
    if (message.id !== "") {
      obj.id = message.id;
    }
    return obj;
  },

  create(base?: DeepPartial<LTCTransactionRequest>): LTCTransactionRequest {
    return LTCTransactionRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<LTCTransactionRequest>): LTCTransactionRequest {
    const message = createBaseLTCTransactionRequest();
    message.inputs = object.inputs?.map((e) => LTCInput.fromPartial(e)) || [];
    message.outputs = object.outputs?.map((e) => LTCOutput.fromPartial(e)) || [];
    message.changeOutputs = object.changeOutputs?.map((e) => LTCChangeOutput.fromPartial(e)) || [];
    message.lockTime = object.lockTime ?? 0;
    message.hashType = object.hashType ?? 0;
    message.id = object.id ?? "";
    return message;
  },
};

function createBaseLTCAddressRequest(): LTCAddressRequest {
  return { path: "", addressType: 0 };
}

export const LTCAddressRequest = {
  encode(message: LTCAddressRequest, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.path !== "") {
      writer.uint32(10).string(message.path);
    }
    if (message.addressType !== 0) {
      writer.uint32(16).int32(message.addressType);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): LTCAddressRequest {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseLTCAddressRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.path = reader.string();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.addressType = reader.int32() as any;
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): LTCAddressRequest {
    return {
      path: isSet(object.path) ? globalThis.String(object.path) : "",
      addressType: isSet(object.addressType) ? lTCAddressTypeFromJSON(object.addressType) : 0,
    };
  },

  toJSON(message: LTCAddressRequest): unknown {
    const obj: any = {};
    if (message.path !== "") {
      obj.path = message.path;
    }
    if (message.addressType !== 0) {
      obj.addressType = lTCAddressTypeToJSON(message.addressType);
    }
    return obj;
  },

  create(base?: DeepPartial<LTCAddressRequest>): LTCAddressRequest {
    return LTCAddressRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<LTCAddressRequest>): LTCAddressRequest {
    const message = createBaseLTCAddressRequest();
    message.path = object.path ?? "";
    message.addressType = object.addressType ?? 0;
    return message;
  },
};

function createBaseLTCProofOfReserveRequest(): LTCProofOfReserveRequest {
  return { path: "", addressType: 0, challenge: "" };
}

export const LTCProofOfReserveRequest = {
  encode(message: LTCProofOfReserveRequest, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.path !== "") {
      writer.uint32(10).string(message.path);
    }
    if (message.addressType !== 0) {
      writer.uint32(16).int32(message.addressType);
    }
    if (message.challenge !== "") {
      writer.uint32(26).string(message.challenge);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): LTCProofOfReserveRequest {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseLTCProofOfReserveRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.path = reader.string();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.addressType = reader.int32() as any;
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.challenge = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): LTCProofOfReserveRequest {
    return {
      path: isSet(object.path) ? globalThis.String(object.path) : "",
      addressType: isSet(object.addressType) ? lTCAddressTypeFromJSON(object.addressType) : 0,
      challenge: isSet(object.challenge) ? globalThis.String(object.challenge) : "",
    };
  },

  toJSON(message: LTCProofOfReserveRequest): unknown {
    const obj: any = {};
    if (message.path !== "") {
      obj.path = message.path;
    }
    if (message.addressType !== 0) {
      obj.addressType = lTCAddressTypeToJSON(message.addressType);
    }
    if (message.challenge !== "") {
      obj.challenge = message.challenge;
    }
    return obj;
  },

  create(base?: DeepPartial<LTCProofOfReserveRequest>): LTCProofOfReserveRequest {
    return LTCProofOfReserveRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<LTCProofOfReserveRequest>): LTCProofOfReserveRequest {
    const message = createBaseLTCProofOfReserveRequest();
    message.path = object.path ?? "";
    message.addressType = object.addressType ?? 0;
    message.challenge = object.challenge ?? "";
    return message;
  },
};

function createBaseBCHInput(): BCHInput {
  return { path: "", addressType: 0, txHash: new Uint8Array(0), outputIndex: 0, value: 0, sequenceNumber: 0 };
}

export const BCHInput = {
  encode(message: BCHInput, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.path !== "") {
      writer.uint32(10).string(message.path);
    }
    if (message.addressType !== 0) {
      writer.uint32(16).int32(message.addressType);
    }
    if (message.txHash.length !== 0) {
      writer.uint32(26).bytes(message.txHash);
    }
    if (message.outputIndex !== 0) {
      writer.uint32(32).uint32(message.outputIndex);
    }
    if (message.value !== 0) {
      writer.uint32(40).uint64(message.value);
    }
    if (message.sequenceNumber !== 0) {
      writer.uint32(48).uint32(message.sequenceNumber);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): BCHInput {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseBCHInput();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.path = reader.string();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.addressType = reader.int32() as any;
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.txHash = reader.bytes();
          continue;
        case 4:
          if (tag !== 32) {
            break;
          }

          message.outputIndex = reader.uint32();
          continue;
        case 5:
          if (tag !== 40) {
            break;
          }

          message.value = longToNumber(reader.uint64() as Long);
          continue;
        case 6:
          if (tag !== 48) {
            break;
          }

          message.sequenceNumber = reader.uint32();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): BCHInput {
    return {
      path: isSet(object.path) ? globalThis.String(object.path) : "",
      addressType: isSet(object.addressType) ? bCHAddressTypeFromJSON(object.addressType) : 0,
      txHash: isSet(object.txHash) ? bytesFromBase64(object.txHash) : new Uint8Array(0),
      outputIndex: isSet(object.outputIndex) ? globalThis.Number(object.outputIndex) : 0,
      value: isSet(object.value) ? globalThis.Number(object.value) : 0,
      sequenceNumber: isSet(object.sequenceNumber) ? globalThis.Number(object.sequenceNumber) : 0,
    };
  },

  toJSON(message: BCHInput): unknown {
    const obj: any = {};
    if (message.path !== "") {
      obj.path = message.path;
    }
    if (message.addressType !== 0) {
      obj.addressType = bCHAddressTypeToJSON(message.addressType);
    }
    if (message.txHash.length !== 0) {
      obj.txHash = base64FromBytes(message.txHash);
    }
    if (message.outputIndex !== 0) {
      obj.outputIndex = Math.round(message.outputIndex);
    }
    if (message.value !== 0) {
      obj.value = Math.round(message.value);
    }
    if (message.sequenceNumber !== 0) {
      obj.sequenceNumber = Math.round(message.sequenceNumber);
    }
    return obj;
  },

  create(base?: DeepPartial<BCHInput>): BCHInput {
    return BCHInput.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<BCHInput>): BCHInput {
    const message = createBaseBCHInput();
    message.path = object.path ?? "";
    message.addressType = object.addressType ?? 0;
    message.txHash = object.txHash ?? new Uint8Array(0);
    message.outputIndex = object.outputIndex ?? 0;
    message.value = object.value ?? 0;
    message.sequenceNumber = object.sequenceNumber ?? 0;
    return message;
  },
};

function createBaseBCHOutput(): BCHOutput {
  return { destination: "", amount: 0 };
}

export const BCHOutput = {
  encode(message: BCHOutput, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.destination !== "") {
      writer.uint32(10).string(message.destination);
    }
    if (message.amount !== 0) {
      writer.uint32(16).uint64(message.amount);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): BCHOutput {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseBCHOutput();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.destination = reader.string();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.amount = longToNumber(reader.uint64() as Long);
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): BCHOutput {
    return {
      destination: isSet(object.destination) ? globalThis.String(object.destination) : "",
      amount: isSet(object.amount) ? globalThis.Number(object.amount) : 0,
    };
  },

  toJSON(message: BCHOutput): unknown {
    const obj: any = {};
    if (message.destination !== "") {
      obj.destination = message.destination;
    }
    if (message.amount !== 0) {
      obj.amount = Math.round(message.amount);
    }
    return obj;
  },

  create(base?: DeepPartial<BCHOutput>): BCHOutput {
    return BCHOutput.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<BCHOutput>): BCHOutput {
    const message = createBaseBCHOutput();
    message.destination = object.destination ?? "";
    message.amount = object.amount ?? 0;
    return message;
  },
};

function createBaseBCHChangeOutput(): BCHChangeOutput {
  return { path: "", addressType: 0, amount: 0 };
}

export const BCHChangeOutput = {
  encode(message: BCHChangeOutput, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.path !== "") {
      writer.uint32(10).string(message.path);
    }
    if (message.addressType !== 0) {
      writer.uint32(16).int32(message.addressType);
    }
    if (message.amount !== 0) {
      writer.uint32(24).uint64(message.amount);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): BCHChangeOutput {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseBCHChangeOutput();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.path = reader.string();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.addressType = reader.int32() as any;
          continue;
        case 3:
          if (tag !== 24) {
            break;
          }

          message.amount = longToNumber(reader.uint64() as Long);
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): BCHChangeOutput {
    return {
      path: isSet(object.path) ? globalThis.String(object.path) : "",
      addressType: isSet(object.addressType) ? bCHAddressTypeFromJSON(object.addressType) : 0,
      amount: isSet(object.amount) ? globalThis.Number(object.amount) : 0,
    };
  },

  toJSON(message: BCHChangeOutput): unknown {
    const obj: any = {};
    if (message.path !== "") {
      obj.path = message.path;
    }
    if (message.addressType !== 0) {
      obj.addressType = bCHAddressTypeToJSON(message.addressType);
    }
    if (message.amount !== 0) {
      obj.amount = Math.round(message.amount);
    }
    return obj;
  },

  create(base?: DeepPartial<BCHChangeOutput>): BCHChangeOutput {
    return BCHChangeOutput.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<BCHChangeOutput>): BCHChangeOutput {
    const message = createBaseBCHChangeOutput();
    message.path = object.path ?? "";
    message.addressType = object.addressType ?? 0;
    message.amount = object.amount ?? 0;
    return message;
  },
};

function createBaseBCHTransactionRequest(): BCHTransactionRequest {
  return { inputs: [], outputs: [], changeOutputs: [], lockTime: 0, hashType: 0, id: "" };
}

export const BCHTransactionRequest = {
  encode(message: BCHTransactionRequest, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    for (const v of message.inputs) {
      BCHInput.encode(v!, writer.uint32(10).fork()).ldelim();
    }
    for (const v of message.outputs) {
      BCHOutput.encode(v!, writer.uint32(18).fork()).ldelim();
    }
    for (const v of message.changeOutputs) {
      BCHChangeOutput.encode(v!, writer.uint32(26).fork()).ldelim();
    }
    if (message.lockTime !== 0) {
      writer.uint32(32).uint32(message.lockTime);
    }
    if (message.hashType !== 0) {
      writer.uint32(40).int32(message.hashType);
    }
    if (message.id !== "") {
      writer.uint32(50).string(message.id);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): BCHTransactionRequest {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseBCHTransactionRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.inputs.push(BCHInput.decode(reader, reader.uint32()));
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.outputs.push(BCHOutput.decode(reader, reader.uint32()));
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.changeOutputs.push(BCHChangeOutput.decode(reader, reader.uint32()));
          continue;
        case 4:
          if (tag !== 32) {
            break;
          }

          message.lockTime = reader.uint32();
          continue;
        case 5:
          if (tag !== 40) {
            break;
          }

          message.hashType = reader.int32() as any;
          continue;
        case 6:
          if (tag !== 50) {
            break;
          }

          message.id = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): BCHTransactionRequest {
    return {
      inputs: globalThis.Array.isArray(object?.inputs) ? object.inputs.map((e: any) => BCHInput.fromJSON(e)) : [],
      outputs: globalThis.Array.isArray(object?.outputs) ? object.outputs.map((e: any) => BCHOutput.fromJSON(e)) : [],
      changeOutputs: globalThis.Array.isArray(object?.changeOutputs)
        ? object.changeOutputs.map((e: any) => BCHChangeOutput.fromJSON(e))
        : [],
      lockTime: isSet(object.lockTime) ? globalThis.Number(object.lockTime) : 0,
      hashType: isSet(object.hashType) ? bCHSigHashTypeFromJSON(object.hashType) : 0,
      id: isSet(object.id) ? globalThis.String(object.id) : "",
    };
  },

  toJSON(message: BCHTransactionRequest): unknown {
    const obj: any = {};
    if (message.inputs?.length) {
      obj.inputs = message.inputs.map((e) => BCHInput.toJSON(e));
    }
    if (message.outputs?.length) {
      obj.outputs = message.outputs.map((e) => BCHOutput.toJSON(e));
    }
    if (message.changeOutputs?.length) {
      obj.changeOutputs = message.changeOutputs.map((e) => BCHChangeOutput.toJSON(e));
    }
    if (message.lockTime !== 0) {
      obj.lockTime = Math.round(message.lockTime);
    }
    if (message.hashType !== 0) {
      obj.hashType = bCHSigHashTypeToJSON(message.hashType);
    }
    if (message.id !== "") {
      obj.id = message.id;
    }
    return obj;
  },

  create(base?: DeepPartial<BCHTransactionRequest>): BCHTransactionRequest {
    return BCHTransactionRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<BCHTransactionRequest>): BCHTransactionRequest {
    const message = createBaseBCHTransactionRequest();
    message.inputs = object.inputs?.map((e) => BCHInput.fromPartial(e)) || [];
    message.outputs = object.outputs?.map((e) => BCHOutput.fromPartial(e)) || [];
    message.changeOutputs = object.changeOutputs?.map((e) => BCHChangeOutput.fromPartial(e)) || [];
    message.lockTime = object.lockTime ?? 0;
    message.hashType = object.hashType ?? 0;
    message.id = object.id ?? "";
    return message;
  },
};

function createBaseBCHAddressRequest(): BCHAddressRequest {
  return { path: "", addressType: 0 };
}

export const BCHAddressRequest = {
  encode(message: BCHAddressRequest, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.path !== "") {
      writer.uint32(10).string(message.path);
    }
    if (message.addressType !== 0) {
      writer.uint32(16).int32(message.addressType);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): BCHAddressRequest {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseBCHAddressRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.path = reader.string();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.addressType = reader.int32() as any;
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): BCHAddressRequest {
    return {
      path: isSet(object.path) ? globalThis.String(object.path) : "",
      addressType: isSet(object.addressType) ? bCHAddressTypeFromJSON(object.addressType) : 0,
    };
  },

  toJSON(message: BCHAddressRequest): unknown {
    const obj: any = {};
    if (message.path !== "") {
      obj.path = message.path;
    }
    if (message.addressType !== 0) {
      obj.addressType = bCHAddressTypeToJSON(message.addressType);
    }
    return obj;
  },

  create(base?: DeepPartial<BCHAddressRequest>): BCHAddressRequest {
    return BCHAddressRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<BCHAddressRequest>): BCHAddressRequest {
    const message = createBaseBCHAddressRequest();
    message.path = object.path ?? "";
    message.addressType = object.addressType ?? 0;
    return message;
  },
};

function createBaseBCHProofOfReserveRequest(): BCHProofOfReserveRequest {
  return { path: "", addressType: 0, challenge: "" };
}

export const BCHProofOfReserveRequest = {
  encode(message: BCHProofOfReserveRequest, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.path !== "") {
      writer.uint32(10).string(message.path);
    }
    if (message.addressType !== 0) {
      writer.uint32(16).int32(message.addressType);
    }
    if (message.challenge !== "") {
      writer.uint32(26).string(message.challenge);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): BCHProofOfReserveRequest {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseBCHProofOfReserveRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.path = reader.string();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.addressType = reader.int32() as any;
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.challenge = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): BCHProofOfReserveRequest {
    return {
      path: isSet(object.path) ? globalThis.String(object.path) : "",
      addressType: isSet(object.addressType) ? bCHAddressTypeFromJSON(object.addressType) : 0,
      challenge: isSet(object.challenge) ? globalThis.String(object.challenge) : "",
    };
  },

  toJSON(message: BCHProofOfReserveRequest): unknown {
    const obj: any = {};
    if (message.path !== "") {
      obj.path = message.path;
    }
    if (message.addressType !== 0) {
      obj.addressType = bCHAddressTypeToJSON(message.addressType);
    }
    if (message.challenge !== "") {
      obj.challenge = message.challenge;
    }
    return obj;
  },

  create(base?: DeepPartial<BCHProofOfReserveRequest>): BCHProofOfReserveRequest {
    return BCHProofOfReserveRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<BCHProofOfReserveRequest>): BCHProofOfReserveRequest {
    const message = createBaseBCHProofOfReserveRequest();
    message.path = object.path ?? "";
    message.addressType = object.addressType ?? 0;
    message.challenge = object.challenge ?? "";
    return message;
  },
};

function createBaseDOTExtrinsic(): DOTExtrinsic {
  return {
    id: "",
    path: "",
    validityPeriod: 0,
    nonce: 0,
    isNonceSet: false,
    tip: new Uint8Array(0),
    specVersion: 0,
    transVersion: 0,
    genesisHash: new Uint8Array(0),
    eraBlockHash: new Uint8Array(0),
    eraBlockNumber: 0,
    fee: new Uint8Array(0),
    network: 0,
  };
}

export const DOTExtrinsic = {
  encode(message: DOTExtrinsic, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.id !== "") {
      writer.uint32(10).string(message.id);
    }
    if (message.path !== "") {
      writer.uint32(18).string(message.path);
    }
    if (message.validityPeriod !== 0) {
      writer.uint32(24).uint32(message.validityPeriod);
    }
    if (message.nonce !== 0) {
      writer.uint32(32).uint64(message.nonce);
    }
    if (message.isNonceSet !== false) {
      writer.uint32(40).bool(message.isNonceSet);
    }
    if (message.tip.length !== 0) {
      writer.uint32(50).bytes(message.tip);
    }
    if (message.specVersion !== 0) {
      writer.uint32(56).uint32(message.specVersion);
    }
    if (message.transVersion !== 0) {
      writer.uint32(64).uint32(message.transVersion);
    }
    if (message.genesisHash.length !== 0) {
      writer.uint32(74).bytes(message.genesisHash);
    }
    if (message.eraBlockHash.length !== 0) {
      writer.uint32(82).bytes(message.eraBlockHash);
    }
    if (message.eraBlockNumber !== 0) {
      writer.uint32(88).uint64(message.eraBlockNumber);
    }
    if (message.fee.length !== 0) {
      writer.uint32(98).bytes(message.fee);
    }
    if (message.network !== 0) {
      writer.uint32(104).int32(message.network);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): DOTExtrinsic {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseDOTExtrinsic();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.id = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.path = reader.string();
          continue;
        case 3:
          if (tag !== 24) {
            break;
          }

          message.validityPeriod = reader.uint32();
          continue;
        case 4:
          if (tag !== 32) {
            break;
          }

          message.nonce = longToNumber(reader.uint64() as Long);
          continue;
        case 5:
          if (tag !== 40) {
            break;
          }

          message.isNonceSet = reader.bool();
          continue;
        case 6:
          if (tag !== 50) {
            break;
          }

          message.tip = reader.bytes();
          continue;
        case 7:
          if (tag !== 56) {
            break;
          }

          message.specVersion = reader.uint32();
          continue;
        case 8:
          if (tag !== 64) {
            break;
          }

          message.transVersion = reader.uint32();
          continue;
        case 9:
          if (tag !== 74) {
            break;
          }

          message.genesisHash = reader.bytes();
          continue;
        case 10:
          if (tag !== 82) {
            break;
          }

          message.eraBlockHash = reader.bytes();
          continue;
        case 11:
          if (tag !== 88) {
            break;
          }

          message.eraBlockNumber = longToNumber(reader.uint64() as Long);
          continue;
        case 12:
          if (tag !== 98) {
            break;
          }

          message.fee = reader.bytes();
          continue;
        case 13:
          if (tag !== 104) {
            break;
          }

          message.network = reader.int32() as any;
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): DOTExtrinsic {
    return {
      id: isSet(object.id) ? globalThis.String(object.id) : "",
      path: isSet(object.path) ? globalThis.String(object.path) : "",
      validityPeriod: isSet(object.validityPeriod) ? globalThis.Number(object.validityPeriod) : 0,
      nonce: isSet(object.nonce) ? globalThis.Number(object.nonce) : 0,
      isNonceSet: isSet(object.isNonceSet) ? globalThis.Boolean(object.isNonceSet) : false,
      tip: isSet(object.tip) ? bytesFromBase64(object.tip) : new Uint8Array(0),
      specVersion: isSet(object.specVersion) ? globalThis.Number(object.specVersion) : 0,
      transVersion: isSet(object.transVersion) ? globalThis.Number(object.transVersion) : 0,
      genesisHash: isSet(object.genesisHash) ? bytesFromBase64(object.genesisHash) : new Uint8Array(0),
      eraBlockHash: isSet(object.eraBlockHash) ? bytesFromBase64(object.eraBlockHash) : new Uint8Array(0),
      eraBlockNumber: isSet(object.eraBlockNumber) ? globalThis.Number(object.eraBlockNumber) : 0,
      fee: isSet(object.fee) ? bytesFromBase64(object.fee) : new Uint8Array(0),
      network: isSet(object.network) ? dOTExtrinsic_NetworkFromJSON(object.network) : 0,
    };
  },

  toJSON(message: DOTExtrinsic): unknown {
    const obj: any = {};
    if (message.id !== "") {
      obj.id = message.id;
    }
    if (message.path !== "") {
      obj.path = message.path;
    }
    if (message.validityPeriod !== 0) {
      obj.validityPeriod = Math.round(message.validityPeriod);
    }
    if (message.nonce !== 0) {
      obj.nonce = Math.round(message.nonce);
    }
    if (message.isNonceSet !== false) {
      obj.isNonceSet = message.isNonceSet;
    }
    if (message.tip.length !== 0) {
      obj.tip = base64FromBytes(message.tip);
    }
    if (message.specVersion !== 0) {
      obj.specVersion = Math.round(message.specVersion);
    }
    if (message.transVersion !== 0) {
      obj.transVersion = Math.round(message.transVersion);
    }
    if (message.genesisHash.length !== 0) {
      obj.genesisHash = base64FromBytes(message.genesisHash);
    }
    if (message.eraBlockHash.length !== 0) {
      obj.eraBlockHash = base64FromBytes(message.eraBlockHash);
    }
    if (message.eraBlockNumber !== 0) {
      obj.eraBlockNumber = Math.round(message.eraBlockNumber);
    }
    if (message.fee.length !== 0) {
      obj.fee = base64FromBytes(message.fee);
    }
    if (message.network !== 0) {
      obj.network = dOTExtrinsic_NetworkToJSON(message.network);
    }
    return obj;
  },

  create(base?: DeepPartial<DOTExtrinsic>): DOTExtrinsic {
    return DOTExtrinsic.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<DOTExtrinsic>): DOTExtrinsic {
    const message = createBaseDOTExtrinsic();
    message.id = object.id ?? "";
    message.path = object.path ?? "";
    message.validityPeriod = object.validityPeriod ?? 0;
    message.nonce = object.nonce ?? 0;
    message.isNonceSet = object.isNonceSet ?? false;
    message.tip = object.tip ?? new Uint8Array(0);
    message.specVersion = object.specVersion ?? 0;
    message.transVersion = object.transVersion ?? 0;
    message.genesisHash = object.genesisHash ?? new Uint8Array(0);
    message.eraBlockHash = object.eraBlockHash ?? new Uint8Array(0);
    message.eraBlockNumber = object.eraBlockNumber ?? 0;
    message.fee = object.fee ?? new Uint8Array(0);
    message.network = object.network ?? 0;
    return message;
  },
};

function createBaseDOTAddressRequest(): DOTAddressRequest {
  return { path: "" };
}

export const DOTAddressRequest = {
  encode(message: DOTAddressRequest, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.path !== "") {
      writer.uint32(10).string(message.path);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): DOTAddressRequest {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseDOTAddressRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.path = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): DOTAddressRequest {
    return { path: isSet(object.path) ? globalThis.String(object.path) : "" };
  },

  toJSON(message: DOTAddressRequest): unknown {
    const obj: any = {};
    if (message.path !== "") {
      obj.path = message.path;
    }
    return obj;
  },

  create(base?: DeepPartial<DOTAddressRequest>): DOTAddressRequest {
    return DOTAddressRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<DOTAddressRequest>): DOTAddressRequest {
    const message = createBaseDOTAddressRequest();
    message.path = object.path ?? "";
    return message;
  },
};

function createBaseDOTTransactionsRequest(): DOTTransactionsRequest {
  return { transactions: [] };
}

export const DOTTransactionsRequest = {
  encode(message: DOTTransactionsRequest, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    for (const v of message.transactions) {
      DOTTransaction.encode(v!, writer.uint32(10).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): DOTTransactionsRequest {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseDOTTransactionsRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.transactions.push(DOTTransaction.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): DOTTransactionsRequest {
    return {
      transactions: globalThis.Array.isArray(object?.transactions)
        ? object.transactions.map((e: any) => DOTTransaction.fromJSON(e))
        : [],
    };
  },

  toJSON(message: DOTTransactionsRequest): unknown {
    const obj: any = {};
    if (message.transactions?.length) {
      obj.transactions = message.transactions.map((e) => DOTTransaction.toJSON(e));
    }
    return obj;
  },

  create(base?: DeepPartial<DOTTransactionsRequest>): DOTTransactionsRequest {
    return DOTTransactionsRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<DOTTransactionsRequest>): DOTTransactionsRequest {
    const message = createBaseDOTTransactionsRequest();
    message.transactions = object.transactions?.map((e) => DOTTransaction.fromPartial(e)) || [];
    return message;
  },
};

function createBaseDOTTransaction(): DOTTransaction {
  return { destination: "", amount: new Uint8Array(0), extrinsic: undefined, unsafe: false };
}

export const DOTTransaction = {
  encode(message: DOTTransaction, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.destination !== "") {
      writer.uint32(10).string(message.destination);
    }
    if (message.amount.length !== 0) {
      writer.uint32(18).bytes(message.amount);
    }
    if (message.extrinsic !== undefined) {
      DOTExtrinsic.encode(message.extrinsic, writer.uint32(26).fork()).ldelim();
    }
    if (message.unsafe !== false) {
      writer.uint32(32).bool(message.unsafe);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): DOTTransaction {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseDOTTransaction();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.destination = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.amount = reader.bytes();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.extrinsic = DOTExtrinsic.decode(reader, reader.uint32());
          continue;
        case 4:
          if (tag !== 32) {
            break;
          }

          message.unsafe = reader.bool();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): DOTTransaction {
    return {
      destination: isSet(object.destination) ? globalThis.String(object.destination) : "",
      amount: isSet(object.amount) ? bytesFromBase64(object.amount) : new Uint8Array(0),
      extrinsic: isSet(object.extrinsic) ? DOTExtrinsic.fromJSON(object.extrinsic) : undefined,
      unsafe: isSet(object.unsafe) ? globalThis.Boolean(object.unsafe) : false,
    };
  },

  toJSON(message: DOTTransaction): unknown {
    const obj: any = {};
    if (message.destination !== "") {
      obj.destination = message.destination;
    }
    if (message.amount.length !== 0) {
      obj.amount = base64FromBytes(message.amount);
    }
    if (message.extrinsic !== undefined) {
      obj.extrinsic = DOTExtrinsic.toJSON(message.extrinsic);
    }
    if (message.unsafe !== false) {
      obj.unsafe = message.unsafe;
    }
    return obj;
  },

  create(base?: DeepPartial<DOTTransaction>): DOTTransaction {
    return DOTTransaction.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<DOTTransaction>): DOTTransaction {
    const message = createBaseDOTTransaction();
    message.destination = object.destination ?? "";
    message.amount = object.amount ?? new Uint8Array(0);
    message.extrinsic = (object.extrinsic !== undefined && object.extrinsic !== null)
      ? DOTExtrinsic.fromPartial(object.extrinsic)
      : undefined;
    message.unsafe = object.unsafe ?? false;
    return message;
  },
};

function createBaseDOTProofOfReserveRequest(): DOTProofOfReserveRequest {
  return { path: "", challenge: "" };
}

export const DOTProofOfReserveRequest = {
  encode(message: DOTProofOfReserveRequest, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.path !== "") {
      writer.uint32(10).string(message.path);
    }
    if (message.challenge !== "") {
      writer.uint32(18).string(message.challenge);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): DOTProofOfReserveRequest {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseDOTProofOfReserveRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.path = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.challenge = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): DOTProofOfReserveRequest {
    return {
      path: isSet(object.path) ? globalThis.String(object.path) : "",
      challenge: isSet(object.challenge) ? globalThis.String(object.challenge) : "",
    };
  },

  toJSON(message: DOTProofOfReserveRequest): unknown {
    const obj: any = {};
    if (message.path !== "") {
      obj.path = message.path;
    }
    if (message.challenge !== "") {
      obj.challenge = message.challenge;
    }
    return obj;
  },

  create(base?: DeepPartial<DOTProofOfReserveRequest>): DOTProofOfReserveRequest {
    return DOTProofOfReserveRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<DOTProofOfReserveRequest>): DOTProofOfReserveRequest {
    const message = createBaseDOTProofOfReserveRequest();
    message.path = object.path ?? "";
    message.challenge = object.challenge ?? "";
    return message;
  },
};

function createBaseDOTPayoutStakersRequest(): DOTPayoutStakersRequest {
  return { validator: "", era: 0, extrinsic: undefined };
}

export const DOTPayoutStakersRequest = {
  encode(message: DOTPayoutStakersRequest, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.validator !== "") {
      writer.uint32(10).string(message.validator);
    }
    if (message.era !== 0) {
      writer.uint32(16).uint32(message.era);
    }
    if (message.extrinsic !== undefined) {
      DOTExtrinsic.encode(message.extrinsic, writer.uint32(26).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): DOTPayoutStakersRequest {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseDOTPayoutStakersRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.validator = reader.string();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.era = reader.uint32();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.extrinsic = DOTExtrinsic.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): DOTPayoutStakersRequest {
    return {
      validator: isSet(object.validator) ? globalThis.String(object.validator) : "",
      era: isSet(object.era) ? globalThis.Number(object.era) : 0,
      extrinsic: isSet(object.extrinsic) ? DOTExtrinsic.fromJSON(object.extrinsic) : undefined,
    };
  },

  toJSON(message: DOTPayoutStakersRequest): unknown {
    const obj: any = {};
    if (message.validator !== "") {
      obj.validator = message.validator;
    }
    if (message.era !== 0) {
      obj.era = Math.round(message.era);
    }
    if (message.extrinsic !== undefined) {
      obj.extrinsic = DOTExtrinsic.toJSON(message.extrinsic);
    }
    return obj;
  },

  create(base?: DeepPartial<DOTPayoutStakersRequest>): DOTPayoutStakersRequest {
    return DOTPayoutStakersRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<DOTPayoutStakersRequest>): DOTPayoutStakersRequest {
    const message = createBaseDOTPayoutStakersRequest();
    message.validator = object.validator ?? "";
    message.era = object.era ?? 0;
    message.extrinsic = (object.extrinsic !== undefined && object.extrinsic !== null)
      ? DOTExtrinsic.fromPartial(object.extrinsic)
      : undefined;
    return message;
  },
};

function createBaseDOTBondRequest(): DOTBondRequest {
  return { amount: new Uint8Array(0), staked: false, extrinsic: undefined };
}

export const DOTBondRequest = {
  encode(message: DOTBondRequest, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.amount.length !== 0) {
      writer.uint32(10).bytes(message.amount);
    }
    if (message.staked !== false) {
      writer.uint32(16).bool(message.staked);
    }
    if (message.extrinsic !== undefined) {
      DOTExtrinsic.encode(message.extrinsic, writer.uint32(26).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): DOTBondRequest {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseDOTBondRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.amount = reader.bytes();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.staked = reader.bool();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.extrinsic = DOTExtrinsic.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): DOTBondRequest {
    return {
      amount: isSet(object.amount) ? bytesFromBase64(object.amount) : new Uint8Array(0),
      staked: isSet(object.staked) ? globalThis.Boolean(object.staked) : false,
      extrinsic: isSet(object.extrinsic) ? DOTExtrinsic.fromJSON(object.extrinsic) : undefined,
    };
  },

  toJSON(message: DOTBondRequest): unknown {
    const obj: any = {};
    if (message.amount.length !== 0) {
      obj.amount = base64FromBytes(message.amount);
    }
    if (message.staked !== false) {
      obj.staked = message.staked;
    }
    if (message.extrinsic !== undefined) {
      obj.extrinsic = DOTExtrinsic.toJSON(message.extrinsic);
    }
    return obj;
  },

  create(base?: DeepPartial<DOTBondRequest>): DOTBondRequest {
    return DOTBondRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<DOTBondRequest>): DOTBondRequest {
    const message = createBaseDOTBondRequest();
    message.amount = object.amount ?? new Uint8Array(0);
    message.staked = object.staked ?? false;
    message.extrinsic = (object.extrinsic !== undefined && object.extrinsic !== null)
      ? DOTExtrinsic.fromPartial(object.extrinsic)
      : undefined;
    return message;
  },
};

function createBaseDOTUnbondRequest(): DOTUnbondRequest {
  return { amount: new Uint8Array(0), extrinsic: undefined };
}

export const DOTUnbondRequest = {
  encode(message: DOTUnbondRequest, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.amount.length !== 0) {
      writer.uint32(10).bytes(message.amount);
    }
    if (message.extrinsic !== undefined) {
      DOTExtrinsic.encode(message.extrinsic, writer.uint32(18).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): DOTUnbondRequest {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseDOTUnbondRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.amount = reader.bytes();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.extrinsic = DOTExtrinsic.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): DOTUnbondRequest {
    return {
      amount: isSet(object.amount) ? bytesFromBase64(object.amount) : new Uint8Array(0),
      extrinsic: isSet(object.extrinsic) ? DOTExtrinsic.fromJSON(object.extrinsic) : undefined,
    };
  },

  toJSON(message: DOTUnbondRequest): unknown {
    const obj: any = {};
    if (message.amount.length !== 0) {
      obj.amount = base64FromBytes(message.amount);
    }
    if (message.extrinsic !== undefined) {
      obj.extrinsic = DOTExtrinsic.toJSON(message.extrinsic);
    }
    return obj;
  },

  create(base?: DeepPartial<DOTUnbondRequest>): DOTUnbondRequest {
    return DOTUnbondRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<DOTUnbondRequest>): DOTUnbondRequest {
    const message = createBaseDOTUnbondRequest();
    message.amount = object.amount ?? new Uint8Array(0);
    message.extrinsic = (object.extrinsic !== undefined && object.extrinsic !== null)
      ? DOTExtrinsic.fromPartial(object.extrinsic)
      : undefined;
    return message;
  },
};

function createBaseDOTBondExtraRequest(): DOTBondExtraRequest {
  return { amount: new Uint8Array(0), extrinsic: undefined };
}

export const DOTBondExtraRequest = {
  encode(message: DOTBondExtraRequest, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.amount.length !== 0) {
      writer.uint32(10).bytes(message.amount);
    }
    if (message.extrinsic !== undefined) {
      DOTExtrinsic.encode(message.extrinsic, writer.uint32(18).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): DOTBondExtraRequest {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseDOTBondExtraRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.amount = reader.bytes();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.extrinsic = DOTExtrinsic.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): DOTBondExtraRequest {
    return {
      amount: isSet(object.amount) ? bytesFromBase64(object.amount) : new Uint8Array(0),
      extrinsic: isSet(object.extrinsic) ? DOTExtrinsic.fromJSON(object.extrinsic) : undefined,
    };
  },

  toJSON(message: DOTBondExtraRequest): unknown {
    const obj: any = {};
    if (message.amount.length !== 0) {
      obj.amount = base64FromBytes(message.amount);
    }
    if (message.extrinsic !== undefined) {
      obj.extrinsic = DOTExtrinsic.toJSON(message.extrinsic);
    }
    return obj;
  },

  create(base?: DeepPartial<DOTBondExtraRequest>): DOTBondExtraRequest {
    return DOTBondExtraRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<DOTBondExtraRequest>): DOTBondExtraRequest {
    const message = createBaseDOTBondExtraRequest();
    message.amount = object.amount ?? new Uint8Array(0);
    message.extrinsic = (object.extrinsic !== undefined && object.extrinsic !== null)
      ? DOTExtrinsic.fromPartial(object.extrinsic)
      : undefined;
    return message;
  },
};

function createBaseDOTChillRequest(): DOTChillRequest {
  return { extrinsic: undefined };
}

export const DOTChillRequest = {
  encode(message: DOTChillRequest, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.extrinsic !== undefined) {
      DOTExtrinsic.encode(message.extrinsic, writer.uint32(10).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): DOTChillRequest {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseDOTChillRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.extrinsic = DOTExtrinsic.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): DOTChillRequest {
    return { extrinsic: isSet(object.extrinsic) ? DOTExtrinsic.fromJSON(object.extrinsic) : undefined };
  },

  toJSON(message: DOTChillRequest): unknown {
    const obj: any = {};
    if (message.extrinsic !== undefined) {
      obj.extrinsic = DOTExtrinsic.toJSON(message.extrinsic);
    }
    return obj;
  },

  create(base?: DeepPartial<DOTChillRequest>): DOTChillRequest {
    return DOTChillRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<DOTChillRequest>): DOTChillRequest {
    const message = createBaseDOTChillRequest();
    message.extrinsic = (object.extrinsic !== undefined && object.extrinsic !== null)
      ? DOTExtrinsic.fromPartial(object.extrinsic)
      : undefined;
    return message;
  },
};

function createBaseDOTNominateRequest(): DOTNominateRequest {
  return { nominees: [], extrinsic: undefined };
}

export const DOTNominateRequest = {
  encode(message: DOTNominateRequest, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    for (const v of message.nominees) {
      writer.uint32(10).string(v!);
    }
    if (message.extrinsic !== undefined) {
      DOTExtrinsic.encode(message.extrinsic, writer.uint32(18).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): DOTNominateRequest {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseDOTNominateRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.nominees.push(reader.string());
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.extrinsic = DOTExtrinsic.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): DOTNominateRequest {
    return {
      nominees: globalThis.Array.isArray(object?.nominees) ? object.nominees.map((e: any) => globalThis.String(e)) : [],
      extrinsic: isSet(object.extrinsic) ? DOTExtrinsic.fromJSON(object.extrinsic) : undefined,
    };
  },

  toJSON(message: DOTNominateRequest): unknown {
    const obj: any = {};
    if (message.nominees?.length) {
      obj.nominees = message.nominees;
    }
    if (message.extrinsic !== undefined) {
      obj.extrinsic = DOTExtrinsic.toJSON(message.extrinsic);
    }
    return obj;
  },

  create(base?: DeepPartial<DOTNominateRequest>): DOTNominateRequest {
    return DOTNominateRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<DOTNominateRequest>): DOTNominateRequest {
    const message = createBaseDOTNominateRequest();
    message.nominees = object.nominees?.map((e) => e) || [];
    message.extrinsic = (object.extrinsic !== undefined && object.extrinsic !== null)
      ? DOTExtrinsic.fromPartial(object.extrinsic)
      : undefined;
    return message;
  },
};

function createBaseDOTWithdrawUnbondedRequest(): DOTWithdrawUnbondedRequest {
  return { s: 0, extrinsic: undefined };
}

export const DOTWithdrawUnbondedRequest = {
  encode(message: DOTWithdrawUnbondedRequest, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.s !== 0) {
      writer.uint32(8).uint32(message.s);
    }
    if (message.extrinsic !== undefined) {
      DOTExtrinsic.encode(message.extrinsic, writer.uint32(18).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): DOTWithdrawUnbondedRequest {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseDOTWithdrawUnbondedRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.s = reader.uint32();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.extrinsic = DOTExtrinsic.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): DOTWithdrawUnbondedRequest {
    return {
      s: isSet(object.s) ? globalThis.Number(object.s) : 0,
      extrinsic: isSet(object.extrinsic) ? DOTExtrinsic.fromJSON(object.extrinsic) : undefined,
    };
  },

  toJSON(message: DOTWithdrawUnbondedRequest): unknown {
    const obj: any = {};
    if (message.s !== 0) {
      obj.s = Math.round(message.s);
    }
    if (message.extrinsic !== undefined) {
      obj.extrinsic = DOTExtrinsic.toJSON(message.extrinsic);
    }
    return obj;
  },

  create(base?: DeepPartial<DOTWithdrawUnbondedRequest>): DOTWithdrawUnbondedRequest {
    return DOTWithdrawUnbondedRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<DOTWithdrawUnbondedRequest>): DOTWithdrawUnbondedRequest {
    const message = createBaseDOTWithdrawUnbondedRequest();
    message.s = object.s ?? 0;
    message.extrinsic = (object.extrinsic !== undefined && object.extrinsic !== null)
      ? DOTExtrinsic.fromPartial(object.extrinsic)
      : undefined;
    return message;
  },
};

function createBaseTAOAddressRequest(): TAOAddressRequest {
  return { path: "" };
}

export const TAOAddressRequest = {
  encode(message: TAOAddressRequest, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.path !== "") {
      writer.uint32(10).string(message.path);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): TAOAddressRequest {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseTAOAddressRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.path = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): TAOAddressRequest {
    return { path: isSet(object.path) ? globalThis.String(object.path) : "" };
  },

  toJSON(message: TAOAddressRequest): unknown {
    const obj: any = {};
    if (message.path !== "") {
      obj.path = message.path;
    }
    return obj;
  },

  create(base?: DeepPartial<TAOAddressRequest>): TAOAddressRequest {
    return TAOAddressRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<TAOAddressRequest>): TAOAddressRequest {
    const message = createBaseTAOAddressRequest();
    message.path = object.path ?? "";
    return message;
  },
};

function createBaseTAOTransactionsRequest(): TAOTransactionsRequest {
  return { transactions: [] };
}

export const TAOTransactionsRequest = {
  encode(message: TAOTransactionsRequest, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    for (const v of message.transactions) {
      TAOTransaction.encode(v!, writer.uint32(10).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): TAOTransactionsRequest {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseTAOTransactionsRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.transactions.push(TAOTransaction.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): TAOTransactionsRequest {
    return {
      transactions: globalThis.Array.isArray(object?.transactions)
        ? object.transactions.map((e: any) => TAOTransaction.fromJSON(e))
        : [],
    };
  },

  toJSON(message: TAOTransactionsRequest): unknown {
    const obj: any = {};
    if (message.transactions?.length) {
      obj.transactions = message.transactions.map((e) => TAOTransaction.toJSON(e));
    }
    return obj;
  },

  create(base?: DeepPartial<TAOTransactionsRequest>): TAOTransactionsRequest {
    return TAOTransactionsRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<TAOTransactionsRequest>): TAOTransactionsRequest {
    const message = createBaseTAOTransactionsRequest();
    message.transactions = object.transactions?.map((e) => TAOTransaction.fromPartial(e)) || [];
    return message;
  },
};

function createBaseTAOTransaction(): TAOTransaction {
  return { destination: "", amount: new Uint8Array(0), extrinsic: undefined, unsafe: false };
}

export const TAOTransaction = {
  encode(message: TAOTransaction, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.destination !== "") {
      writer.uint32(10).string(message.destination);
    }
    if (message.amount.length !== 0) {
      writer.uint32(18).bytes(message.amount);
    }
    if (message.extrinsic !== undefined) {
      DOTExtrinsic.encode(message.extrinsic, writer.uint32(26).fork()).ldelim();
    }
    if (message.unsafe !== false) {
      writer.uint32(32).bool(message.unsafe);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): TAOTransaction {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseTAOTransaction();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.destination = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.amount = reader.bytes();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.extrinsic = DOTExtrinsic.decode(reader, reader.uint32());
          continue;
        case 4:
          if (tag !== 32) {
            break;
          }

          message.unsafe = reader.bool();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): TAOTransaction {
    return {
      destination: isSet(object.destination) ? globalThis.String(object.destination) : "",
      amount: isSet(object.amount) ? bytesFromBase64(object.amount) : new Uint8Array(0),
      extrinsic: isSet(object.extrinsic) ? DOTExtrinsic.fromJSON(object.extrinsic) : undefined,
      unsafe: isSet(object.unsafe) ? globalThis.Boolean(object.unsafe) : false,
    };
  },

  toJSON(message: TAOTransaction): unknown {
    const obj: any = {};
    if (message.destination !== "") {
      obj.destination = message.destination;
    }
    if (message.amount.length !== 0) {
      obj.amount = base64FromBytes(message.amount);
    }
    if (message.extrinsic !== undefined) {
      obj.extrinsic = DOTExtrinsic.toJSON(message.extrinsic);
    }
    if (message.unsafe !== false) {
      obj.unsafe = message.unsafe;
    }
    return obj;
  },

  create(base?: DeepPartial<TAOTransaction>): TAOTransaction {
    return TAOTransaction.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<TAOTransaction>): TAOTransaction {
    const message = createBaseTAOTransaction();
    message.destination = object.destination ?? "";
    message.amount = object.amount ?? new Uint8Array(0);
    message.extrinsic = (object.extrinsic !== undefined && object.extrinsic !== null)
      ? DOTExtrinsic.fromPartial(object.extrinsic)
      : undefined;
    message.unsafe = object.unsafe ?? false;
    return message;
  },
};

function createBaseTAOProofOfReserveRequest(): TAOProofOfReserveRequest {
  return { path: "", challenge: "" };
}

export const TAOProofOfReserveRequest = {
  encode(message: TAOProofOfReserveRequest, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.path !== "") {
      writer.uint32(10).string(message.path);
    }
    if (message.challenge !== "") {
      writer.uint32(18).string(message.challenge);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): TAOProofOfReserveRequest {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseTAOProofOfReserveRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.path = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.challenge = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): TAOProofOfReserveRequest {
    return {
      path: isSet(object.path) ? globalThis.String(object.path) : "",
      challenge: isSet(object.challenge) ? globalThis.String(object.challenge) : "",
    };
  },

  toJSON(message: TAOProofOfReserveRequest): unknown {
    const obj: any = {};
    if (message.path !== "") {
      obj.path = message.path;
    }
    if (message.challenge !== "") {
      obj.challenge = message.challenge;
    }
    return obj;
  },

  create(base?: DeepPartial<TAOProofOfReserveRequest>): TAOProofOfReserveRequest {
    return TAOProofOfReserveRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<TAOProofOfReserveRequest>): TAOProofOfReserveRequest {
    const message = createBaseTAOProofOfReserveRequest();
    message.path = object.path ?? "";
    message.challenge = object.challenge ?? "";
    return message;
  },
};

function createBaseTAOAddStakeRequest(): TAOAddStakeRequest {
  return { destination: "", amount: new Uint8Array(0), extrinsic: undefined };
}

export const TAOAddStakeRequest = {
  encode(message: TAOAddStakeRequest, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.destination !== "") {
      writer.uint32(10).string(message.destination);
    }
    if (message.amount.length !== 0) {
      writer.uint32(18).bytes(message.amount);
    }
    if (message.extrinsic !== undefined) {
      DOTExtrinsic.encode(message.extrinsic, writer.uint32(26).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): TAOAddStakeRequest {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseTAOAddStakeRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.destination = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.amount = reader.bytes();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.extrinsic = DOTExtrinsic.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): TAOAddStakeRequest {
    return {
      destination: isSet(object.destination) ? globalThis.String(object.destination) : "",
      amount: isSet(object.amount) ? bytesFromBase64(object.amount) : new Uint8Array(0),
      extrinsic: isSet(object.extrinsic) ? DOTExtrinsic.fromJSON(object.extrinsic) : undefined,
    };
  },

  toJSON(message: TAOAddStakeRequest): unknown {
    const obj: any = {};
    if (message.destination !== "") {
      obj.destination = message.destination;
    }
    if (message.amount.length !== 0) {
      obj.amount = base64FromBytes(message.amount);
    }
    if (message.extrinsic !== undefined) {
      obj.extrinsic = DOTExtrinsic.toJSON(message.extrinsic);
    }
    return obj;
  },

  create(base?: DeepPartial<TAOAddStakeRequest>): TAOAddStakeRequest {
    return TAOAddStakeRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<TAOAddStakeRequest>): TAOAddStakeRequest {
    const message = createBaseTAOAddStakeRequest();
    message.destination = object.destination ?? "";
    message.amount = object.amount ?? new Uint8Array(0);
    message.extrinsic = (object.extrinsic !== undefined && object.extrinsic !== null)
      ? DOTExtrinsic.fromPartial(object.extrinsic)
      : undefined;
    return message;
  },
};

function createBaseTAORemoveStakeRequest(): TAORemoveStakeRequest {
  return { destination: "", amount: new Uint8Array(0), extrinsic: undefined };
}

export const TAORemoveStakeRequest = {
  encode(message: TAORemoveStakeRequest, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.destination !== "") {
      writer.uint32(10).string(message.destination);
    }
    if (message.amount.length !== 0) {
      writer.uint32(18).bytes(message.amount);
    }
    if (message.extrinsic !== undefined) {
      DOTExtrinsic.encode(message.extrinsic, writer.uint32(26).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): TAORemoveStakeRequest {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseTAORemoveStakeRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.destination = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.amount = reader.bytes();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.extrinsic = DOTExtrinsic.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): TAORemoveStakeRequest {
    return {
      destination: isSet(object.destination) ? globalThis.String(object.destination) : "",
      amount: isSet(object.amount) ? bytesFromBase64(object.amount) : new Uint8Array(0),
      extrinsic: isSet(object.extrinsic) ? DOTExtrinsic.fromJSON(object.extrinsic) : undefined,
    };
  },

  toJSON(message: TAORemoveStakeRequest): unknown {
    const obj: any = {};
    if (message.destination !== "") {
      obj.destination = message.destination;
    }
    if (message.amount.length !== 0) {
      obj.amount = base64FromBytes(message.amount);
    }
    if (message.extrinsic !== undefined) {
      obj.extrinsic = DOTExtrinsic.toJSON(message.extrinsic);
    }
    return obj;
  },

  create(base?: DeepPartial<TAORemoveStakeRequest>): TAORemoveStakeRequest {
    return TAORemoveStakeRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<TAORemoveStakeRequest>): TAORemoveStakeRequest {
    const message = createBaseTAORemoveStakeRequest();
    message.destination = object.destination ?? "";
    message.amount = object.amount ?? new Uint8Array(0);
    message.extrinsic = (object.extrinsic !== undefined && object.extrinsic !== null)
      ? DOTExtrinsic.fromPartial(object.extrinsic)
      : undefined;
    return message;
  },
};

function createBaseFTMTransactionsRequest(): FTMTransactionsRequest {
  return { transactions: [] };
}

export const FTMTransactionsRequest = {
  encode(message: FTMTransactionsRequest, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    for (const v of message.transactions) {
      FTMTransaction.encode(v!, writer.uint32(18).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): FTMTransactionsRequest {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseFTMTransactionsRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 2:
          if (tag !== 18) {
            break;
          }

          message.transactions.push(FTMTransaction.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): FTMTransactionsRequest {
    return {
      transactions: globalThis.Array.isArray(object?.transactions)
        ? object.transactions.map((e: any) => FTMTransaction.fromJSON(e))
        : [],
    };
  },

  toJSON(message: FTMTransactionsRequest): unknown {
    const obj: any = {};
    if (message.transactions?.length) {
      obj.transactions = message.transactions.map((e) => FTMTransaction.toJSON(e));
    }
    return obj;
  },

  create(base?: DeepPartial<FTMTransactionsRequest>): FTMTransactionsRequest {
    return FTMTransactionsRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<FTMTransactionsRequest>): FTMTransactionsRequest {
    const message = createBaseFTMTransactionsRequest();
    message.transactions = object.transactions?.map((e) => FTMTransaction.fromPartial(e)) || [];
    return message;
  },
};

function createBaseFTMTransaction(): FTMTransaction {
  return {
    from: "",
    nonce: 0,
    gasLimit: 0,
    gasPrice: new Uint8Array(0),
    to: "",
    amount: new Uint8Array(0),
    id: "",
    isNonceSet: false,
  };
}

export const FTMTransaction = {
  encode(message: FTMTransaction, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.from !== "") {
      writer.uint32(10).string(message.from);
    }
    if (message.nonce !== 0) {
      writer.uint32(16).uint64(message.nonce);
    }
    if (message.gasLimit !== 0) {
      writer.uint32(24).uint64(message.gasLimit);
    }
    if (message.gasPrice.length !== 0) {
      writer.uint32(34).bytes(message.gasPrice);
    }
    if (message.to !== "") {
      writer.uint32(42).string(message.to);
    }
    if (message.amount.length !== 0) {
      writer.uint32(50).bytes(message.amount);
    }
    if (message.id !== "") {
      writer.uint32(66).string(message.id);
    }
    if (message.isNonceSet !== false) {
      writer.uint32(72).bool(message.isNonceSet);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): FTMTransaction {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseFTMTransaction();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.from = reader.string();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.nonce = longToNumber(reader.uint64() as Long);
          continue;
        case 3:
          if (tag !== 24) {
            break;
          }

          message.gasLimit = longToNumber(reader.uint64() as Long);
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.gasPrice = reader.bytes();
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.to = reader.string();
          continue;
        case 6:
          if (tag !== 50) {
            break;
          }

          message.amount = reader.bytes();
          continue;
        case 8:
          if (tag !== 66) {
            break;
          }

          message.id = reader.string();
          continue;
        case 9:
          if (tag !== 72) {
            break;
          }

          message.isNonceSet = reader.bool();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): FTMTransaction {
    return {
      from: isSet(object.from) ? globalThis.String(object.from) : "",
      nonce: isSet(object.nonce) ? globalThis.Number(object.nonce) : 0,
      gasLimit: isSet(object.gasLimit) ? globalThis.Number(object.gasLimit) : 0,
      gasPrice: isSet(object.gasPrice) ? bytesFromBase64(object.gasPrice) : new Uint8Array(0),
      to: isSet(object.to) ? globalThis.String(object.to) : "",
      amount: isSet(object.amount) ? bytesFromBase64(object.amount) : new Uint8Array(0),
      id: isSet(object.id) ? globalThis.String(object.id) : "",
      isNonceSet: isSet(object.isNonceSet) ? globalThis.Boolean(object.isNonceSet) : false,
    };
  },

  toJSON(message: FTMTransaction): unknown {
    const obj: any = {};
    if (message.from !== "") {
      obj.from = message.from;
    }
    if (message.nonce !== 0) {
      obj.nonce = Math.round(message.nonce);
    }
    if (message.gasLimit !== 0) {
      obj.gasLimit = Math.round(message.gasLimit);
    }
    if (message.gasPrice.length !== 0) {
      obj.gasPrice = base64FromBytes(message.gasPrice);
    }
    if (message.to !== "") {
      obj.to = message.to;
    }
    if (message.amount.length !== 0) {
      obj.amount = base64FromBytes(message.amount);
    }
    if (message.id !== "") {
      obj.id = message.id;
    }
    if (message.isNonceSet !== false) {
      obj.isNonceSet = message.isNonceSet;
    }
    return obj;
  },

  create(base?: DeepPartial<FTMTransaction>): FTMTransaction {
    return FTMTransaction.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<FTMTransaction>): FTMTransaction {
    const message = createBaseFTMTransaction();
    message.from = object.from ?? "";
    message.nonce = object.nonce ?? 0;
    message.gasLimit = object.gasLimit ?? 0;
    message.gasPrice = object.gasPrice ?? new Uint8Array(0);
    message.to = object.to ?? "";
    message.amount = object.amount ?? new Uint8Array(0);
    message.id = object.id ?? "";
    message.isNonceSet = object.isNonceSet ?? false;
    return message;
  },
};

function createBaseFTMAddressRequest(): FTMAddressRequest {
  return { path: "" };
}

export const FTMAddressRequest = {
  encode(message: FTMAddressRequest, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.path !== "") {
      writer.uint32(10).string(message.path);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): FTMAddressRequest {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseFTMAddressRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.path = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): FTMAddressRequest {
    return { path: isSet(object.path) ? globalThis.String(object.path) : "" };
  },

  toJSON(message: FTMAddressRequest): unknown {
    const obj: any = {};
    if (message.path !== "") {
      obj.path = message.path;
    }
    return obj;
  },

  create(base?: DeepPartial<FTMAddressRequest>): FTMAddressRequest {
    return FTMAddressRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<FTMAddressRequest>): FTMAddressRequest {
    const message = createBaseFTMAddressRequest();
    message.path = object.path ?? "";
    return message;
  },
};

function createBaseFTMProofOfReserveRequest(): FTMProofOfReserveRequest {
  return { path: "", challenge: "" };
}

export const FTMProofOfReserveRequest = {
  encode(message: FTMProofOfReserveRequest, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.path !== "") {
      writer.uint32(10).string(message.path);
    }
    if (message.challenge !== "") {
      writer.uint32(18).string(message.challenge);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): FTMProofOfReserveRequest {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseFTMProofOfReserveRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.path = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.challenge = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): FTMProofOfReserveRequest {
    return {
      path: isSet(object.path) ? globalThis.String(object.path) : "",
      challenge: isSet(object.challenge) ? globalThis.String(object.challenge) : "",
    };
  },

  toJSON(message: FTMProofOfReserveRequest): unknown {
    const obj: any = {};
    if (message.path !== "") {
      obj.path = message.path;
    }
    if (message.challenge !== "") {
      obj.challenge = message.challenge;
    }
    return obj;
  },

  create(base?: DeepPartial<FTMProofOfReserveRequest>): FTMProofOfReserveRequest {
    return FTMProofOfReserveRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<FTMProofOfReserveRequest>): FTMProofOfReserveRequest {
    const message = createBaseFTMProofOfReserveRequest();
    message.path = object.path ?? "";
    message.challenge = object.challenge ?? "";
    return message;
  },
};

function createBaseFTMStakingDelegateRequest(): FTMStakingDelegateRequest {
  return { tx: undefined, validatorId: 0, operation: 0, withdrawalId: 0, withdrawalAmount: new Uint8Array(0) };
}

export const FTMStakingDelegateRequest = {
  encode(message: FTMStakingDelegateRequest, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.tx !== undefined) {
      FTMTransaction.encode(message.tx, writer.uint32(10).fork()).ldelim();
    }
    if (message.validatorId !== 0) {
      writer.uint32(16).uint64(message.validatorId);
    }
    if (message.operation !== 0) {
      writer.uint32(24).int32(message.operation);
    }
    if (message.withdrawalId !== 0) {
      writer.uint32(32).uint64(message.withdrawalId);
    }
    if (message.withdrawalAmount.length !== 0) {
      writer.uint32(42).bytes(message.withdrawalAmount);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): FTMStakingDelegateRequest {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseFTMStakingDelegateRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.tx = FTMTransaction.decode(reader, reader.uint32());
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.validatorId = longToNumber(reader.uint64() as Long);
          continue;
        case 3:
          if (tag !== 24) {
            break;
          }

          message.operation = reader.int32() as any;
          continue;
        case 4:
          if (tag !== 32) {
            break;
          }

          message.withdrawalId = longToNumber(reader.uint64() as Long);
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.withdrawalAmount = reader.bytes();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): FTMStakingDelegateRequest {
    return {
      tx: isSet(object.tx) ? FTMTransaction.fromJSON(object.tx) : undefined,
      validatorId: isSet(object.validatorId) ? globalThis.Number(object.validatorId) : 0,
      operation: isSet(object.operation) ? fTMStakingDelegateRequest_FTMDelegateOperationFromJSON(object.operation) : 0,
      withdrawalId: isSet(object.withdrawalId) ? globalThis.Number(object.withdrawalId) : 0,
      withdrawalAmount: isSet(object.withdrawalAmount) ? bytesFromBase64(object.withdrawalAmount) : new Uint8Array(0),
    };
  },

  toJSON(message: FTMStakingDelegateRequest): unknown {
    const obj: any = {};
    if (message.tx !== undefined) {
      obj.tx = FTMTransaction.toJSON(message.tx);
    }
    if (message.validatorId !== 0) {
      obj.validatorId = Math.round(message.validatorId);
    }
    if (message.operation !== 0) {
      obj.operation = fTMStakingDelegateRequest_FTMDelegateOperationToJSON(message.operation);
    }
    if (message.withdrawalId !== 0) {
      obj.withdrawalId = Math.round(message.withdrawalId);
    }
    if (message.withdrawalAmount.length !== 0) {
      obj.withdrawalAmount = base64FromBytes(message.withdrawalAmount);
    }
    return obj;
  },

  create(base?: DeepPartial<FTMStakingDelegateRequest>): FTMStakingDelegateRequest {
    return FTMStakingDelegateRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<FTMStakingDelegateRequest>): FTMStakingDelegateRequest {
    const message = createBaseFTMStakingDelegateRequest();
    message.tx = (object.tx !== undefined && object.tx !== null) ? FTMTransaction.fromPartial(object.tx) : undefined;
    message.validatorId = object.validatorId ?? 0;
    message.operation = object.operation ?? 0;
    message.withdrawalId = object.withdrawalId ?? 0;
    message.withdrawalAmount = object.withdrawalAmount ?? new Uint8Array(0);
    return message;
  },
};

function createBaseFTMStakingClaimRewardsRequest(): FTMStakingClaimRewardsRequest {
  return { tx: undefined, validatorId: 0, restake: false };
}

export const FTMStakingClaimRewardsRequest = {
  encode(message: FTMStakingClaimRewardsRequest, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.tx !== undefined) {
      FTMTransaction.encode(message.tx, writer.uint32(10).fork()).ldelim();
    }
    if (message.validatorId !== 0) {
      writer.uint32(16).uint64(message.validatorId);
    }
    if (message.restake !== false) {
      writer.uint32(24).bool(message.restake);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): FTMStakingClaimRewardsRequest {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseFTMStakingClaimRewardsRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.tx = FTMTransaction.decode(reader, reader.uint32());
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.validatorId = longToNumber(reader.uint64() as Long);
          continue;
        case 3:
          if (tag !== 24) {
            break;
          }

          message.restake = reader.bool();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): FTMStakingClaimRewardsRequest {
    return {
      tx: isSet(object.tx) ? FTMTransaction.fromJSON(object.tx) : undefined,
      validatorId: isSet(object.validatorId) ? globalThis.Number(object.validatorId) : 0,
      restake: isSet(object.restake) ? globalThis.Boolean(object.restake) : false,
    };
  },

  toJSON(message: FTMStakingClaimRewardsRequest): unknown {
    const obj: any = {};
    if (message.tx !== undefined) {
      obj.tx = FTMTransaction.toJSON(message.tx);
    }
    if (message.validatorId !== 0) {
      obj.validatorId = Math.round(message.validatorId);
    }
    if (message.restake !== false) {
      obj.restake = message.restake;
    }
    return obj;
  },

  create(base?: DeepPartial<FTMStakingClaimRewardsRequest>): FTMStakingClaimRewardsRequest {
    return FTMStakingClaimRewardsRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<FTMStakingClaimRewardsRequest>): FTMStakingClaimRewardsRequest {
    const message = createBaseFTMStakingClaimRewardsRequest();
    message.tx = (object.tx !== undefined && object.tx !== null) ? FTMTransaction.fromPartial(object.tx) : undefined;
    message.validatorId = object.validatorId ?? 0;
    message.restake = object.restake ?? false;
    return message;
  },
};

function createBaseFTMStakingLockRequest(): FTMStakingLockRequest {
  return { tx: undefined, validatorId: 0, operation: 0, duration: 0, lockAmount: new Uint8Array(0) };
}

export const FTMStakingLockRequest = {
  encode(message: FTMStakingLockRequest, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.tx !== undefined) {
      FTMTransaction.encode(message.tx, writer.uint32(10).fork()).ldelim();
    }
    if (message.validatorId !== 0) {
      writer.uint32(16).uint64(message.validatorId);
    }
    if (message.operation !== 0) {
      writer.uint32(24).int32(message.operation);
    }
    if (message.duration !== 0) {
      writer.uint32(32).uint64(message.duration);
    }
    if (message.lockAmount.length !== 0) {
      writer.uint32(42).bytes(message.lockAmount);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): FTMStakingLockRequest {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseFTMStakingLockRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.tx = FTMTransaction.decode(reader, reader.uint32());
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.validatorId = longToNumber(reader.uint64() as Long);
          continue;
        case 3:
          if (tag !== 24) {
            break;
          }

          message.operation = reader.int32() as any;
          continue;
        case 4:
          if (tag !== 32) {
            break;
          }

          message.duration = longToNumber(reader.uint64() as Long);
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.lockAmount = reader.bytes();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): FTMStakingLockRequest {
    return {
      tx: isSet(object.tx) ? FTMTransaction.fromJSON(object.tx) : undefined,
      validatorId: isSet(object.validatorId) ? globalThis.Number(object.validatorId) : 0,
      operation: isSet(object.operation) ? fTMStakingLockRequest_FTMLockOperationFromJSON(object.operation) : 0,
      duration: isSet(object.duration) ? globalThis.Number(object.duration) : 0,
      lockAmount: isSet(object.lockAmount) ? bytesFromBase64(object.lockAmount) : new Uint8Array(0),
    };
  },

  toJSON(message: FTMStakingLockRequest): unknown {
    const obj: any = {};
    if (message.tx !== undefined) {
      obj.tx = FTMTransaction.toJSON(message.tx);
    }
    if (message.validatorId !== 0) {
      obj.validatorId = Math.round(message.validatorId);
    }
    if (message.operation !== 0) {
      obj.operation = fTMStakingLockRequest_FTMLockOperationToJSON(message.operation);
    }
    if (message.duration !== 0) {
      obj.duration = Math.round(message.duration);
    }
    if (message.lockAmount.length !== 0) {
      obj.lockAmount = base64FromBytes(message.lockAmount);
    }
    return obj;
  },

  create(base?: DeepPartial<FTMStakingLockRequest>): FTMStakingLockRequest {
    return FTMStakingLockRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<FTMStakingLockRequest>): FTMStakingLockRequest {
    const message = createBaseFTMStakingLockRequest();
    message.tx = (object.tx !== undefined && object.tx !== null) ? FTMTransaction.fromPartial(object.tx) : undefined;
    message.validatorId = object.validatorId ?? 0;
    message.operation = object.operation ?? 0;
    message.duration = object.duration ?? 0;
    message.lockAmount = object.lockAmount ?? new Uint8Array(0);
    return message;
  },
};

function createBaseFTMTransactionsResponse(): FTMTransactionsResponse {
  return { transactions: [] };
}

export const FTMTransactionsResponse = {
  encode(message: FTMTransactionsResponse, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    for (const v of message.transactions) {
      FTMTransactionsResponse_FTMTransactionResponse.encode(v!, writer.uint32(10).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): FTMTransactionsResponse {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseFTMTransactionsResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.transactions.push(FTMTransactionsResponse_FTMTransactionResponse.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): FTMTransactionsResponse {
    return {
      transactions: globalThis.Array.isArray(object?.transactions)
        ? object.transactions.map((e: any) => FTMTransactionsResponse_FTMTransactionResponse.fromJSON(e))
        : [],
    };
  },

  toJSON(message: FTMTransactionsResponse): unknown {
    const obj: any = {};
    if (message.transactions?.length) {
      obj.transactions = message.transactions.map((e) => FTMTransactionsResponse_FTMTransactionResponse.toJSON(e));
    }
    return obj;
  },

  create(base?: DeepPartial<FTMTransactionsResponse>): FTMTransactionsResponse {
    return FTMTransactionsResponse.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<FTMTransactionsResponse>): FTMTransactionsResponse {
    const message = createBaseFTMTransactionsResponse();
    message.transactions =
      object.transactions?.map((e) => FTMTransactionsResponse_FTMTransactionResponse.fromPartial(e)) || [];
    return message;
  },
};

function createBaseFTMTransactionsResponse_FTMTransactionResponse(): FTMTransactionsResponse_FTMTransactionResponse {
  return { id: "", transaction: "", publicKey: new Uint8Array(0) };
}

export const FTMTransactionsResponse_FTMTransactionResponse = {
  encode(
    message: FTMTransactionsResponse_FTMTransactionResponse,
    writer: _m0.Writer = _m0.Writer.create(),
  ): _m0.Writer {
    if (message.id !== "") {
      writer.uint32(10).string(message.id);
    }
    if (message.transaction !== "") {
      writer.uint32(18).string(message.transaction);
    }
    if (message.publicKey.length !== 0) {
      writer.uint32(26).bytes(message.publicKey);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): FTMTransactionsResponse_FTMTransactionResponse {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseFTMTransactionsResponse_FTMTransactionResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.id = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.transaction = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.publicKey = reader.bytes();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): FTMTransactionsResponse_FTMTransactionResponse {
    return {
      id: isSet(object.id) ? globalThis.String(object.id) : "",
      transaction: isSet(object.transaction) ? globalThis.String(object.transaction) : "",
      publicKey: isSet(object.publicKey) ? bytesFromBase64(object.publicKey) : new Uint8Array(0),
    };
  },

  toJSON(message: FTMTransactionsResponse_FTMTransactionResponse): unknown {
    const obj: any = {};
    if (message.id !== "") {
      obj.id = message.id;
    }
    if (message.transaction !== "") {
      obj.transaction = message.transaction;
    }
    if (message.publicKey.length !== 0) {
      obj.publicKey = base64FromBytes(message.publicKey);
    }
    return obj;
  },

  create(
    base?: DeepPartial<FTMTransactionsResponse_FTMTransactionResponse>,
  ): FTMTransactionsResponse_FTMTransactionResponse {
    return FTMTransactionsResponse_FTMTransactionResponse.fromPartial(base ?? {});
  },
  fromPartial(
    object: DeepPartial<FTMTransactionsResponse_FTMTransactionResponse>,
  ): FTMTransactionsResponse_FTMTransactionResponse {
    const message = createBaseFTMTransactionsResponse_FTMTransactionResponse();
    message.id = object.id ?? "";
    message.transaction = object.transaction ?? "";
    message.publicKey = object.publicKey ?? new Uint8Array(0);
    return message;
  },
};

function createBaseSonicTransactionsRequest(): SonicTransactionsRequest {
  return { transactions: [] };
}

export const SonicTransactionsRequest = {
  encode(message: SonicTransactionsRequest, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    for (const v of message.transactions) {
      SonicTransaction.encode(v!, writer.uint32(18).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): SonicTransactionsRequest {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSonicTransactionsRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 2:
          if (tag !== 18) {
            break;
          }

          message.transactions.push(SonicTransaction.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): SonicTransactionsRequest {
    return {
      transactions: globalThis.Array.isArray(object?.transactions)
        ? object.transactions.map((e: any) => SonicTransaction.fromJSON(e))
        : [],
    };
  },

  toJSON(message: SonicTransactionsRequest): unknown {
    const obj: any = {};
    if (message.transactions?.length) {
      obj.transactions = message.transactions.map((e) => SonicTransaction.toJSON(e));
    }
    return obj;
  },

  create(base?: DeepPartial<SonicTransactionsRequest>): SonicTransactionsRequest {
    return SonicTransactionsRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<SonicTransactionsRequest>): SonicTransactionsRequest {
    const message = createBaseSonicTransactionsRequest();
    message.transactions = object.transactions?.map((e) => SonicTransaction.fromPartial(e)) || [];
    return message;
  },
};

function createBaseSonicTransaction(): SonicTransaction {
  return {
    from: "",
    nonce: 0,
    gasLimit: 0,
    gasPrice: new Uint8Array(0),
    to: "",
    amount: new Uint8Array(0),
    id: "",
    isNonceSet: false,
  };
}

export const SonicTransaction = {
  encode(message: SonicTransaction, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.from !== "") {
      writer.uint32(10).string(message.from);
    }
    if (message.nonce !== 0) {
      writer.uint32(16).uint64(message.nonce);
    }
    if (message.gasLimit !== 0) {
      writer.uint32(24).uint64(message.gasLimit);
    }
    if (message.gasPrice.length !== 0) {
      writer.uint32(34).bytes(message.gasPrice);
    }
    if (message.to !== "") {
      writer.uint32(42).string(message.to);
    }
    if (message.amount.length !== 0) {
      writer.uint32(50).bytes(message.amount);
    }
    if (message.id !== "") {
      writer.uint32(66).string(message.id);
    }
    if (message.isNonceSet !== false) {
      writer.uint32(72).bool(message.isNonceSet);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): SonicTransaction {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSonicTransaction();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.from = reader.string();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.nonce = longToNumber(reader.uint64() as Long);
          continue;
        case 3:
          if (tag !== 24) {
            break;
          }

          message.gasLimit = longToNumber(reader.uint64() as Long);
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.gasPrice = reader.bytes();
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.to = reader.string();
          continue;
        case 6:
          if (tag !== 50) {
            break;
          }

          message.amount = reader.bytes();
          continue;
        case 8:
          if (tag !== 66) {
            break;
          }

          message.id = reader.string();
          continue;
        case 9:
          if (tag !== 72) {
            break;
          }

          message.isNonceSet = reader.bool();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): SonicTransaction {
    return {
      from: isSet(object.from) ? globalThis.String(object.from) : "",
      nonce: isSet(object.nonce) ? globalThis.Number(object.nonce) : 0,
      gasLimit: isSet(object.gasLimit) ? globalThis.Number(object.gasLimit) : 0,
      gasPrice: isSet(object.gasPrice) ? bytesFromBase64(object.gasPrice) : new Uint8Array(0),
      to: isSet(object.to) ? globalThis.String(object.to) : "",
      amount: isSet(object.amount) ? bytesFromBase64(object.amount) : new Uint8Array(0),
      id: isSet(object.id) ? globalThis.String(object.id) : "",
      isNonceSet: isSet(object.isNonceSet) ? globalThis.Boolean(object.isNonceSet) : false,
    };
  },

  toJSON(message: SonicTransaction): unknown {
    const obj: any = {};
    if (message.from !== "") {
      obj.from = message.from;
    }
    if (message.nonce !== 0) {
      obj.nonce = Math.round(message.nonce);
    }
    if (message.gasLimit !== 0) {
      obj.gasLimit = Math.round(message.gasLimit);
    }
    if (message.gasPrice.length !== 0) {
      obj.gasPrice = base64FromBytes(message.gasPrice);
    }
    if (message.to !== "") {
      obj.to = message.to;
    }
    if (message.amount.length !== 0) {
      obj.amount = base64FromBytes(message.amount);
    }
    if (message.id !== "") {
      obj.id = message.id;
    }
    if (message.isNonceSet !== false) {
      obj.isNonceSet = message.isNonceSet;
    }
    return obj;
  },

  create(base?: DeepPartial<SonicTransaction>): SonicTransaction {
    return SonicTransaction.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<SonicTransaction>): SonicTransaction {
    const message = createBaseSonicTransaction();
    message.from = object.from ?? "";
    message.nonce = object.nonce ?? 0;
    message.gasLimit = object.gasLimit ?? 0;
    message.gasPrice = object.gasPrice ?? new Uint8Array(0);
    message.to = object.to ?? "";
    message.amount = object.amount ?? new Uint8Array(0);
    message.id = object.id ?? "";
    message.isNonceSet = object.isNonceSet ?? false;
    return message;
  },
};

function createBaseSonicAddressRequest(): SonicAddressRequest {
  return { path: "" };
}

export const SonicAddressRequest = {
  encode(message: SonicAddressRequest, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.path !== "") {
      writer.uint32(10).string(message.path);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): SonicAddressRequest {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSonicAddressRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.path = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): SonicAddressRequest {
    return { path: isSet(object.path) ? globalThis.String(object.path) : "" };
  },

  toJSON(message: SonicAddressRequest): unknown {
    const obj: any = {};
    if (message.path !== "") {
      obj.path = message.path;
    }
    return obj;
  },

  create(base?: DeepPartial<SonicAddressRequest>): SonicAddressRequest {
    return SonicAddressRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<SonicAddressRequest>): SonicAddressRequest {
    const message = createBaseSonicAddressRequest();
    message.path = object.path ?? "";
    return message;
  },
};

function createBaseSonicProofOfReserveRequest(): SonicProofOfReserveRequest {
  return { path: "", challenge: "" };
}

export const SonicProofOfReserveRequest = {
  encode(message: SonicProofOfReserveRequest, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.path !== "") {
      writer.uint32(10).string(message.path);
    }
    if (message.challenge !== "") {
      writer.uint32(18).string(message.challenge);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): SonicProofOfReserveRequest {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSonicProofOfReserveRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.path = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.challenge = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): SonicProofOfReserveRequest {
    return {
      path: isSet(object.path) ? globalThis.String(object.path) : "",
      challenge: isSet(object.challenge) ? globalThis.String(object.challenge) : "",
    };
  },

  toJSON(message: SonicProofOfReserveRequest): unknown {
    const obj: any = {};
    if (message.path !== "") {
      obj.path = message.path;
    }
    if (message.challenge !== "") {
      obj.challenge = message.challenge;
    }
    return obj;
  },

  create(base?: DeepPartial<SonicProofOfReserveRequest>): SonicProofOfReserveRequest {
    return SonicProofOfReserveRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<SonicProofOfReserveRequest>): SonicProofOfReserveRequest {
    const message = createBaseSonicProofOfReserveRequest();
    message.path = object.path ?? "";
    message.challenge = object.challenge ?? "";
    return message;
  },
};

function createBaseSonicStakingDelegateRequest(): SonicStakingDelegateRequest {
  return { tx: undefined, validatorId: 0, operation: 0, withdrawalId: 0, withdrawalAmount: new Uint8Array(0) };
}

export const SonicStakingDelegateRequest = {
  encode(message: SonicStakingDelegateRequest, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.tx !== undefined) {
      SonicTransaction.encode(message.tx, writer.uint32(10).fork()).ldelim();
    }
    if (message.validatorId !== 0) {
      writer.uint32(16).uint64(message.validatorId);
    }
    if (message.operation !== 0) {
      writer.uint32(24).int32(message.operation);
    }
    if (message.withdrawalId !== 0) {
      writer.uint32(32).uint64(message.withdrawalId);
    }
    if (message.withdrawalAmount.length !== 0) {
      writer.uint32(42).bytes(message.withdrawalAmount);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): SonicStakingDelegateRequest {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSonicStakingDelegateRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.tx = SonicTransaction.decode(reader, reader.uint32());
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.validatorId = longToNumber(reader.uint64() as Long);
          continue;
        case 3:
          if (tag !== 24) {
            break;
          }

          message.operation = reader.int32() as any;
          continue;
        case 4:
          if (tag !== 32) {
            break;
          }

          message.withdrawalId = longToNumber(reader.uint64() as Long);
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.withdrawalAmount = reader.bytes();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): SonicStakingDelegateRequest {
    return {
      tx: isSet(object.tx) ? SonicTransaction.fromJSON(object.tx) : undefined,
      validatorId: isSet(object.validatorId) ? globalThis.Number(object.validatorId) : 0,
      operation: isSet(object.operation)
        ? sonicStakingDelegateRequest_SonicDelegateOperationFromJSON(object.operation)
        : 0,
      withdrawalId: isSet(object.withdrawalId) ? globalThis.Number(object.withdrawalId) : 0,
      withdrawalAmount: isSet(object.withdrawalAmount) ? bytesFromBase64(object.withdrawalAmount) : new Uint8Array(0),
    };
  },

  toJSON(message: SonicStakingDelegateRequest): unknown {
    const obj: any = {};
    if (message.tx !== undefined) {
      obj.tx = SonicTransaction.toJSON(message.tx);
    }
    if (message.validatorId !== 0) {
      obj.validatorId = Math.round(message.validatorId);
    }
    if (message.operation !== 0) {
      obj.operation = sonicStakingDelegateRequest_SonicDelegateOperationToJSON(message.operation);
    }
    if (message.withdrawalId !== 0) {
      obj.withdrawalId = Math.round(message.withdrawalId);
    }
    if (message.withdrawalAmount.length !== 0) {
      obj.withdrawalAmount = base64FromBytes(message.withdrawalAmount);
    }
    return obj;
  },

  create(base?: DeepPartial<SonicStakingDelegateRequest>): SonicStakingDelegateRequest {
    return SonicStakingDelegateRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<SonicStakingDelegateRequest>): SonicStakingDelegateRequest {
    const message = createBaseSonicStakingDelegateRequest();
    message.tx = (object.tx !== undefined && object.tx !== null) ? SonicTransaction.fromPartial(object.tx) : undefined;
    message.validatorId = object.validatorId ?? 0;
    message.operation = object.operation ?? 0;
    message.withdrawalId = object.withdrawalId ?? 0;
    message.withdrawalAmount = object.withdrawalAmount ?? new Uint8Array(0);
    return message;
  },
};

function createBaseSonicStakingClaimRewardsRequest(): SonicStakingClaimRewardsRequest {
  return { tx: undefined, validatorId: 0, restake: false };
}

export const SonicStakingClaimRewardsRequest = {
  encode(message: SonicStakingClaimRewardsRequest, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.tx !== undefined) {
      SonicTransaction.encode(message.tx, writer.uint32(10).fork()).ldelim();
    }
    if (message.validatorId !== 0) {
      writer.uint32(16).uint64(message.validatorId);
    }
    if (message.restake !== false) {
      writer.uint32(24).bool(message.restake);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): SonicStakingClaimRewardsRequest {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSonicStakingClaimRewardsRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.tx = SonicTransaction.decode(reader, reader.uint32());
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.validatorId = longToNumber(reader.uint64() as Long);
          continue;
        case 3:
          if (tag !== 24) {
            break;
          }

          message.restake = reader.bool();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): SonicStakingClaimRewardsRequest {
    return {
      tx: isSet(object.tx) ? SonicTransaction.fromJSON(object.tx) : undefined,
      validatorId: isSet(object.validatorId) ? globalThis.Number(object.validatorId) : 0,
      restake: isSet(object.restake) ? globalThis.Boolean(object.restake) : false,
    };
  },

  toJSON(message: SonicStakingClaimRewardsRequest): unknown {
    const obj: any = {};
    if (message.tx !== undefined) {
      obj.tx = SonicTransaction.toJSON(message.tx);
    }
    if (message.validatorId !== 0) {
      obj.validatorId = Math.round(message.validatorId);
    }
    if (message.restake !== false) {
      obj.restake = message.restake;
    }
    return obj;
  },

  create(base?: DeepPartial<SonicStakingClaimRewardsRequest>): SonicStakingClaimRewardsRequest {
    return SonicStakingClaimRewardsRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<SonicStakingClaimRewardsRequest>): SonicStakingClaimRewardsRequest {
    const message = createBaseSonicStakingClaimRewardsRequest();
    message.tx = (object.tx !== undefined && object.tx !== null) ? SonicTransaction.fromPartial(object.tx) : undefined;
    message.validatorId = object.validatorId ?? 0;
    message.restake = object.restake ?? false;
    return message;
  },
};

function createBaseSonicTransactionsResponse(): SonicTransactionsResponse {
  return { transactions: [] };
}

export const SonicTransactionsResponse = {
  encode(message: SonicTransactionsResponse, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    for (const v of message.transactions) {
      SonicTransactionsResponse_SonicTransactionResponse.encode(v!, writer.uint32(10).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): SonicTransactionsResponse {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSonicTransactionsResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.transactions.push(SonicTransactionsResponse_SonicTransactionResponse.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): SonicTransactionsResponse {
    return {
      transactions: globalThis.Array.isArray(object?.transactions)
        ? object.transactions.map((e: any) => SonicTransactionsResponse_SonicTransactionResponse.fromJSON(e))
        : [],
    };
  },

  toJSON(message: SonicTransactionsResponse): unknown {
    const obj: any = {};
    if (message.transactions?.length) {
      obj.transactions = message.transactions.map((e) => SonicTransactionsResponse_SonicTransactionResponse.toJSON(e));
    }
    return obj;
  },

  create(base?: DeepPartial<SonicTransactionsResponse>): SonicTransactionsResponse {
    return SonicTransactionsResponse.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<SonicTransactionsResponse>): SonicTransactionsResponse {
    const message = createBaseSonicTransactionsResponse();
    message.transactions =
      object.transactions?.map((e) => SonicTransactionsResponse_SonicTransactionResponse.fromPartial(e)) || [];
    return message;
  },
};

function createBaseSonicTransactionsResponse_SonicTransactionResponse(): SonicTransactionsResponse_SonicTransactionResponse {
  return { id: "", transaction: "", publicKey: new Uint8Array(0) };
}

export const SonicTransactionsResponse_SonicTransactionResponse = {
  encode(
    message: SonicTransactionsResponse_SonicTransactionResponse,
    writer: _m0.Writer = _m0.Writer.create(),
  ): _m0.Writer {
    if (message.id !== "") {
      writer.uint32(10).string(message.id);
    }
    if (message.transaction !== "") {
      writer.uint32(18).string(message.transaction);
    }
    if (message.publicKey.length !== 0) {
      writer.uint32(26).bytes(message.publicKey);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): SonicTransactionsResponse_SonicTransactionResponse {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSonicTransactionsResponse_SonicTransactionResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.id = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.transaction = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.publicKey = reader.bytes();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): SonicTransactionsResponse_SonicTransactionResponse {
    return {
      id: isSet(object.id) ? globalThis.String(object.id) : "",
      transaction: isSet(object.transaction) ? globalThis.String(object.transaction) : "",
      publicKey: isSet(object.publicKey) ? bytesFromBase64(object.publicKey) : new Uint8Array(0),
    };
  },

  toJSON(message: SonicTransactionsResponse_SonicTransactionResponse): unknown {
    const obj: any = {};
    if (message.id !== "") {
      obj.id = message.id;
    }
    if (message.transaction !== "") {
      obj.transaction = message.transaction;
    }
    if (message.publicKey.length !== 0) {
      obj.publicKey = base64FromBytes(message.publicKey);
    }
    return obj;
  },

  create(
    base?: DeepPartial<SonicTransactionsResponse_SonicTransactionResponse>,
  ): SonicTransactionsResponse_SonicTransactionResponse {
    return SonicTransactionsResponse_SonicTransactionResponse.fromPartial(base ?? {});
  },
  fromPartial(
    object: DeepPartial<SonicTransactionsResponse_SonicTransactionResponse>,
  ): SonicTransactionsResponse_SonicTransactionResponse {
    const message = createBaseSonicTransactionsResponse_SonicTransactionResponse();
    message.id = object.id ?? "";
    message.transaction = object.transaction ?? "";
    message.publicKey = object.publicKey ?? new Uint8Array(0);
    return message;
  },
};

function createBaseALGOTransactionsRequest(): ALGOTransactionsRequest {
  return { transactions: [] };
}

export const ALGOTransactionsRequest = {
  encode(message: ALGOTransactionsRequest, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    for (const v of message.transactions) {
      ALGOTransaction.encode(v!, writer.uint32(10).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): ALGOTransactionsRequest {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseALGOTransactionsRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.transactions.push(ALGOTransaction.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ALGOTransactionsRequest {
    return {
      transactions: globalThis.Array.isArray(object?.transactions)
        ? object.transactions.map((e: any) => ALGOTransaction.fromJSON(e))
        : [],
    };
  },

  toJSON(message: ALGOTransactionsRequest): unknown {
    const obj: any = {};
    if (message.transactions?.length) {
      obj.transactions = message.transactions.map((e) => ALGOTransaction.toJSON(e));
    }
    return obj;
  },

  create(base?: DeepPartial<ALGOTransactionsRequest>): ALGOTransactionsRequest {
    return ALGOTransactionsRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ALGOTransactionsRequest>): ALGOTransactionsRequest {
    const message = createBaseALGOTransactionsRequest();
    message.transactions = object.transactions?.map((e) => ALGOTransaction.fromPartial(e)) || [];
    return message;
  },
};

function createBaseALGOTransactionMaterial(): ALGOTransactionMaterial {
  return { fee: 0, fv: 0, lv: 0, lx: new Uint8Array(0), gen: "", gh: new Uint8Array(0), note: new Uint8Array(0) };
}

export const ALGOTransactionMaterial = {
  encode(message: ALGOTransactionMaterial, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.fee !== 0) {
      writer.uint32(8).uint64(message.fee);
    }
    if (message.fv !== 0) {
      writer.uint32(16).uint64(message.fv);
    }
    if (message.lv !== 0) {
      writer.uint32(24).uint64(message.lv);
    }
    if (message.lx.length !== 0) {
      writer.uint32(34).bytes(message.lx);
    }
    if (message.gen !== "") {
      writer.uint32(42).string(message.gen);
    }
    if (message.gh.length !== 0) {
      writer.uint32(50).bytes(message.gh);
    }
    if (message.note.length !== 0) {
      writer.uint32(58).bytes(message.note);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): ALGOTransactionMaterial {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseALGOTransactionMaterial();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.fee = longToNumber(reader.uint64() as Long);
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.fv = longToNumber(reader.uint64() as Long);
          continue;
        case 3:
          if (tag !== 24) {
            break;
          }

          message.lv = longToNumber(reader.uint64() as Long);
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.lx = reader.bytes();
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.gen = reader.string();
          continue;
        case 6:
          if (tag !== 50) {
            break;
          }

          message.gh = reader.bytes();
          continue;
        case 7:
          if (tag !== 58) {
            break;
          }

          message.note = reader.bytes();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ALGOTransactionMaterial {
    return {
      fee: isSet(object.fee) ? globalThis.Number(object.fee) : 0,
      fv: isSet(object.fv) ? globalThis.Number(object.fv) : 0,
      lv: isSet(object.lv) ? globalThis.Number(object.lv) : 0,
      lx: isSet(object.lx) ? bytesFromBase64(object.lx) : new Uint8Array(0),
      gen: isSet(object.gen) ? globalThis.String(object.gen) : "",
      gh: isSet(object.gh) ? bytesFromBase64(object.gh) : new Uint8Array(0),
      note: isSet(object.note) ? bytesFromBase64(object.note) : new Uint8Array(0),
    };
  },

  toJSON(message: ALGOTransactionMaterial): unknown {
    const obj: any = {};
    if (message.fee !== 0) {
      obj.fee = Math.round(message.fee);
    }
    if (message.fv !== 0) {
      obj.fv = Math.round(message.fv);
    }
    if (message.lv !== 0) {
      obj.lv = Math.round(message.lv);
    }
    if (message.lx.length !== 0) {
      obj.lx = base64FromBytes(message.lx);
    }
    if (message.gen !== "") {
      obj.gen = message.gen;
    }
    if (message.gh.length !== 0) {
      obj.gh = base64FromBytes(message.gh);
    }
    if (message.note.length !== 0) {
      obj.note = base64FromBytes(message.note);
    }
    return obj;
  },

  create(base?: DeepPartial<ALGOTransactionMaterial>): ALGOTransactionMaterial {
    return ALGOTransactionMaterial.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ALGOTransactionMaterial>): ALGOTransactionMaterial {
    const message = createBaseALGOTransactionMaterial();
    message.fee = object.fee ?? 0;
    message.fv = object.fv ?? 0;
    message.lv = object.lv ?? 0;
    message.lx = object.lx ?? new Uint8Array(0);
    message.gen = object.gen ?? "";
    message.gh = object.gh ?? new Uint8Array(0);
    message.note = object.note ?? new Uint8Array(0);
    return message;
  },
};

function createBaseALGOTransaction(): ALGOTransaction {
  return { path: "", to: "", amount: 0, material: undefined, id: "" };
}

export const ALGOTransaction = {
  encode(message: ALGOTransaction, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.path !== "") {
      writer.uint32(10).string(message.path);
    }
    if (message.to !== "") {
      writer.uint32(18).string(message.to);
    }
    if (message.amount !== 0) {
      writer.uint32(24).uint64(message.amount);
    }
    if (message.material !== undefined) {
      ALGOTransactionMaterial.encode(message.material, writer.uint32(34).fork()).ldelim();
    }
    if (message.id !== "") {
      writer.uint32(42).string(message.id);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): ALGOTransaction {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseALGOTransaction();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.path = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.to = reader.string();
          continue;
        case 3:
          if (tag !== 24) {
            break;
          }

          message.amount = longToNumber(reader.uint64() as Long);
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.material = ALGOTransactionMaterial.decode(reader, reader.uint32());
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.id = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ALGOTransaction {
    return {
      path: isSet(object.path) ? globalThis.String(object.path) : "",
      to: isSet(object.to) ? globalThis.String(object.to) : "",
      amount: isSet(object.amount) ? globalThis.Number(object.amount) : 0,
      material: isSet(object.material) ? ALGOTransactionMaterial.fromJSON(object.material) : undefined,
      id: isSet(object.id) ? globalThis.String(object.id) : "",
    };
  },

  toJSON(message: ALGOTransaction): unknown {
    const obj: any = {};
    if (message.path !== "") {
      obj.path = message.path;
    }
    if (message.to !== "") {
      obj.to = message.to;
    }
    if (message.amount !== 0) {
      obj.amount = Math.round(message.amount);
    }
    if (message.material !== undefined) {
      obj.material = ALGOTransactionMaterial.toJSON(message.material);
    }
    if (message.id !== "") {
      obj.id = message.id;
    }
    return obj;
  },

  create(base?: DeepPartial<ALGOTransaction>): ALGOTransaction {
    return ALGOTransaction.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ALGOTransaction>): ALGOTransaction {
    const message = createBaseALGOTransaction();
    message.path = object.path ?? "";
    message.to = object.to ?? "";
    message.amount = object.amount ?? 0;
    message.material = (object.material !== undefined && object.material !== null)
      ? ALGOTransactionMaterial.fromPartial(object.material)
      : undefined;
    message.id = object.id ?? "";
    return message;
  },
};

function createBaseALGOAddressRequest(): ALGOAddressRequest {
  return { path: "" };
}

export const ALGOAddressRequest = {
  encode(message: ALGOAddressRequest, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.path !== "") {
      writer.uint32(10).string(message.path);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): ALGOAddressRequest {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseALGOAddressRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.path = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ALGOAddressRequest {
    return { path: isSet(object.path) ? globalThis.String(object.path) : "" };
  },

  toJSON(message: ALGOAddressRequest): unknown {
    const obj: any = {};
    if (message.path !== "") {
      obj.path = message.path;
    }
    return obj;
  },

  create(base?: DeepPartial<ALGOAddressRequest>): ALGOAddressRequest {
    return ALGOAddressRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ALGOAddressRequest>): ALGOAddressRequest {
    const message = createBaseALGOAddressRequest();
    message.path = object.path ?? "";
    return message;
  },
};

function createBaseALGOProofOfReserveRequest(): ALGOProofOfReserveRequest {
  return { path: "", challenge: "" };
}

export const ALGOProofOfReserveRequest = {
  encode(message: ALGOProofOfReserveRequest, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.path !== "") {
      writer.uint32(10).string(message.path);
    }
    if (message.challenge !== "") {
      writer.uint32(18).string(message.challenge);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): ALGOProofOfReserveRequest {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseALGOProofOfReserveRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.path = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.challenge = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ALGOProofOfReserveRequest {
    return {
      path: isSet(object.path) ? globalThis.String(object.path) : "",
      challenge: isSet(object.challenge) ? globalThis.String(object.challenge) : "",
    };
  },

  toJSON(message: ALGOProofOfReserveRequest): unknown {
    const obj: any = {};
    if (message.path !== "") {
      obj.path = message.path;
    }
    if (message.challenge !== "") {
      obj.challenge = message.challenge;
    }
    return obj;
  },

  create(base?: DeepPartial<ALGOProofOfReserveRequest>): ALGOProofOfReserveRequest {
    return ALGOProofOfReserveRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ALGOProofOfReserveRequest>): ALGOProofOfReserveRequest {
    const message = createBaseALGOProofOfReserveRequest();
    message.path = object.path ?? "";
    message.challenge = object.challenge ?? "";
    return message;
  },
};

function createBaseALGOAssetOptinRequest(): ALGOAssetOptinRequest {
  return { path: "", assetID: 0, material: undefined, id: "" };
}

export const ALGOAssetOptinRequest = {
  encode(message: ALGOAssetOptinRequest, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.path !== "") {
      writer.uint32(10).string(message.path);
    }
    if (message.assetID !== 0) {
      writer.uint32(16).uint64(message.assetID);
    }
    if (message.material !== undefined) {
      ALGOTransactionMaterial.encode(message.material, writer.uint32(26).fork()).ldelim();
    }
    if (message.id !== "") {
      writer.uint32(34).string(message.id);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): ALGOAssetOptinRequest {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseALGOAssetOptinRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.path = reader.string();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.assetID = longToNumber(reader.uint64() as Long);
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.material = ALGOTransactionMaterial.decode(reader, reader.uint32());
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.id = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ALGOAssetOptinRequest {
    return {
      path: isSet(object.path) ? globalThis.String(object.path) : "",
      assetID: isSet(object.assetID) ? globalThis.Number(object.assetID) : 0,
      material: isSet(object.material) ? ALGOTransactionMaterial.fromJSON(object.material) : undefined,
      id: isSet(object.id) ? globalThis.String(object.id) : "",
    };
  },

  toJSON(message: ALGOAssetOptinRequest): unknown {
    const obj: any = {};
    if (message.path !== "") {
      obj.path = message.path;
    }
    if (message.assetID !== 0) {
      obj.assetID = Math.round(message.assetID);
    }
    if (message.material !== undefined) {
      obj.material = ALGOTransactionMaterial.toJSON(message.material);
    }
    if (message.id !== "") {
      obj.id = message.id;
    }
    return obj;
  },

  create(base?: DeepPartial<ALGOAssetOptinRequest>): ALGOAssetOptinRequest {
    return ALGOAssetOptinRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ALGOAssetOptinRequest>): ALGOAssetOptinRequest {
    const message = createBaseALGOAssetOptinRequest();
    message.path = object.path ?? "";
    message.assetID = object.assetID ?? 0;
    message.material = (object.material !== undefined && object.material !== null)
      ? ALGOTransactionMaterial.fromPartial(object.material)
      : undefined;
    message.id = object.id ?? "";
    return message;
  },
};

function createBaseALGOAssetTransferRequest(): ALGOAssetTransferRequest {
  return { transfers: [] };
}

export const ALGOAssetTransferRequest = {
  encode(message: ALGOAssetTransferRequest, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    for (const v of message.transfers) {
      ALGOAssetTransfer.encode(v!, writer.uint32(10).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): ALGOAssetTransferRequest {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseALGOAssetTransferRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.transfers.push(ALGOAssetTransfer.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ALGOAssetTransferRequest {
    return {
      transfers: globalThis.Array.isArray(object?.transfers)
        ? object.transfers.map((e: any) => ALGOAssetTransfer.fromJSON(e))
        : [],
    };
  },

  toJSON(message: ALGOAssetTransferRequest): unknown {
    const obj: any = {};
    if (message.transfers?.length) {
      obj.transfers = message.transfers.map((e) => ALGOAssetTransfer.toJSON(e));
    }
    return obj;
  },

  create(base?: DeepPartial<ALGOAssetTransferRequest>): ALGOAssetTransferRequest {
    return ALGOAssetTransferRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ALGOAssetTransferRequest>): ALGOAssetTransferRequest {
    const message = createBaseALGOAssetTransferRequest();
    message.transfers = object.transfers?.map((e) => ALGOAssetTransfer.fromPartial(e)) || [];
    return message;
  },
};

function createBaseALGOAssetTransfer(): ALGOAssetTransfer {
  return { path: "", to: "", assetID: 0, amount: 0, material: undefined, id: "" };
}

export const ALGOAssetTransfer = {
  encode(message: ALGOAssetTransfer, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.path !== "") {
      writer.uint32(10).string(message.path);
    }
    if (message.to !== "") {
      writer.uint32(18).string(message.to);
    }
    if (message.assetID !== 0) {
      writer.uint32(24).uint64(message.assetID);
    }
    if (message.amount !== 0) {
      writer.uint32(32).uint64(message.amount);
    }
    if (message.material !== undefined) {
      ALGOTransactionMaterial.encode(message.material, writer.uint32(42).fork()).ldelim();
    }
    if (message.id !== "") {
      writer.uint32(50).string(message.id);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): ALGOAssetTransfer {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseALGOAssetTransfer();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.path = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.to = reader.string();
          continue;
        case 3:
          if (tag !== 24) {
            break;
          }

          message.assetID = longToNumber(reader.uint64() as Long);
          continue;
        case 4:
          if (tag !== 32) {
            break;
          }

          message.amount = longToNumber(reader.uint64() as Long);
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.material = ALGOTransactionMaterial.decode(reader, reader.uint32());
          continue;
        case 6:
          if (tag !== 50) {
            break;
          }

          message.id = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ALGOAssetTransfer {
    return {
      path: isSet(object.path) ? globalThis.String(object.path) : "",
      to: isSet(object.to) ? globalThis.String(object.to) : "",
      assetID: isSet(object.assetID) ? globalThis.Number(object.assetID) : 0,
      amount: isSet(object.amount) ? globalThis.Number(object.amount) : 0,
      material: isSet(object.material) ? ALGOTransactionMaterial.fromJSON(object.material) : undefined,
      id: isSet(object.id) ? globalThis.String(object.id) : "",
    };
  },

  toJSON(message: ALGOAssetTransfer): unknown {
    const obj: any = {};
    if (message.path !== "") {
      obj.path = message.path;
    }
    if (message.to !== "") {
      obj.to = message.to;
    }
    if (message.assetID !== 0) {
      obj.assetID = Math.round(message.assetID);
    }
    if (message.amount !== 0) {
      obj.amount = Math.round(message.amount);
    }
    if (message.material !== undefined) {
      obj.material = ALGOTransactionMaterial.toJSON(message.material);
    }
    if (message.id !== "") {
      obj.id = message.id;
    }
    return obj;
  },

  create(base?: DeepPartial<ALGOAssetTransfer>): ALGOAssetTransfer {
    return ALGOAssetTransfer.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ALGOAssetTransfer>): ALGOAssetTransfer {
    const message = createBaseALGOAssetTransfer();
    message.path = object.path ?? "";
    message.to = object.to ?? "";
    message.assetID = object.assetID ?? 0;
    message.amount = object.amount ?? 0;
    message.material = (object.material !== undefined && object.material !== null)
      ? ALGOTransactionMaterial.fromPartial(object.material)
      : undefined;
    message.id = object.id ?? "";
    return message;
  },
};

function createBaseHederaAddressRequest(): HederaAddressRequest {
  return { shardNum: 0, realmNum: 0, path: "" };
}

export const HederaAddressRequest = {
  encode(message: HederaAddressRequest, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.shardNum !== 0) {
      writer.uint32(8).uint64(message.shardNum);
    }
    if (message.realmNum !== 0) {
      writer.uint32(16).uint64(message.realmNum);
    }
    if (message.path !== "") {
      writer.uint32(26).string(message.path);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): HederaAddressRequest {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseHederaAddressRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.shardNum = longToNumber(reader.uint64() as Long);
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.realmNum = longToNumber(reader.uint64() as Long);
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.path = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): HederaAddressRequest {
    return {
      shardNum: isSet(object.shardNum) ? globalThis.Number(object.shardNum) : 0,
      realmNum: isSet(object.realmNum) ? globalThis.Number(object.realmNum) : 0,
      path: isSet(object.path) ? globalThis.String(object.path) : "",
    };
  },

  toJSON(message: HederaAddressRequest): unknown {
    const obj: any = {};
    if (message.shardNum !== 0) {
      obj.shardNum = Math.round(message.shardNum);
    }
    if (message.realmNum !== 0) {
      obj.realmNum = Math.round(message.realmNum);
    }
    if (message.path !== "") {
      obj.path = message.path;
    }
    return obj;
  },

  create(base?: DeepPartial<HederaAddressRequest>): HederaAddressRequest {
    return HederaAddressRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<HederaAddressRequest>): HederaAddressRequest {
    const message = createBaseHederaAddressRequest();
    message.shardNum = object.shardNum ?? 0;
    message.realmNum = object.realmNum ?? 0;
    message.path = object.path ?? "";
    return message;
  },
};

function createBaseHederaTransactionsRequest(): HederaTransactionsRequest {
  return { kind: 0, transactions: [] };
}

export const HederaTransactionsRequest = {
  encode(message: HederaTransactionsRequest, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.kind !== 0) {
      writer.uint32(8).int32(message.kind);
    }
    for (const v of message.transactions) {
      HederaTransaction.encode(v!, writer.uint32(18).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): HederaTransactionsRequest {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseHederaTransactionsRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.kind = reader.int32() as any;
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.transactions.push(HederaTransaction.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): HederaTransactionsRequest {
    return {
      kind: isSet(object.kind) ? hederaTransactionsRequest_OperationKindFromJSON(object.kind) : 0,
      transactions: globalThis.Array.isArray(object?.transactions)
        ? object.transactions.map((e: any) => HederaTransaction.fromJSON(e))
        : [],
    };
  },

  toJSON(message: HederaTransactionsRequest): unknown {
    const obj: any = {};
    if (message.kind !== 0) {
      obj.kind = hederaTransactionsRequest_OperationKindToJSON(message.kind);
    }
    if (message.transactions?.length) {
      obj.transactions = message.transactions.map((e) => HederaTransaction.toJSON(e));
    }
    return obj;
  },

  create(base?: DeepPartial<HederaTransactionsRequest>): HederaTransactionsRequest {
    return HederaTransactionsRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<HederaTransactionsRequest>): HederaTransactionsRequest {
    const message = createBaseHederaTransactionsRequest();
    message.kind = object.kind ?? 0;
    message.transactions = object.transactions?.map((e) => HederaTransaction.fromPartial(e)) || [];
    return message;
  },
};

function createBaseHederaAccount(): HederaAccount {
  return { shardNum: 0, realmNum: 0, accountID: 0 };
}

export const HederaAccount = {
  encode(message: HederaAccount, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.shardNum !== 0) {
      writer.uint32(8).uint64(message.shardNum);
    }
    if (message.realmNum !== 0) {
      writer.uint32(16).uint64(message.realmNum);
    }
    if (message.accountID !== 0) {
      writer.uint32(24).uint64(message.accountID);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): HederaAccount {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseHederaAccount();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.shardNum = longToNumber(reader.uint64() as Long);
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.realmNum = longToNumber(reader.uint64() as Long);
          continue;
        case 3:
          if (tag !== 24) {
            break;
          }

          message.accountID = longToNumber(reader.uint64() as Long);
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): HederaAccount {
    return {
      shardNum: isSet(object.shardNum) ? globalThis.Number(object.shardNum) : 0,
      realmNum: isSet(object.realmNum) ? globalThis.Number(object.realmNum) : 0,
      accountID: isSet(object.accountID) ? globalThis.Number(object.accountID) : 0,
    };
  },

  toJSON(message: HederaAccount): unknown {
    const obj: any = {};
    if (message.shardNum !== 0) {
      obj.shardNum = Math.round(message.shardNum);
    }
    if (message.realmNum !== 0) {
      obj.realmNum = Math.round(message.realmNum);
    }
    if (message.accountID !== 0) {
      obj.accountID = Math.round(message.accountID);
    }
    return obj;
  },

  create(base?: DeepPartial<HederaAccount>): HederaAccount {
    return HederaAccount.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<HederaAccount>): HederaAccount {
    const message = createBaseHederaAccount();
    message.shardNum = object.shardNum ?? 0;
    message.realmNum = object.realmNum ?? 0;
    message.accountID = object.accountID ?? 0;
    return message;
  },
};

function createBaseHederaTimestamp(): HederaTimestamp {
  return { seconds: 0, nanos: 0 };
}

export const HederaTimestamp = {
  encode(message: HederaTimestamp, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.seconds !== 0) {
      writer.uint32(8).uint64(message.seconds);
    }
    if (message.nanos !== 0) {
      writer.uint32(16).uint64(message.nanos);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): HederaTimestamp {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseHederaTimestamp();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.seconds = longToNumber(reader.uint64() as Long);
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.nanos = longToNumber(reader.uint64() as Long);
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): HederaTimestamp {
    return {
      seconds: isSet(object.seconds) ? globalThis.Number(object.seconds) : 0,
      nanos: isSet(object.nanos) ? globalThis.Number(object.nanos) : 0,
    };
  },

  toJSON(message: HederaTimestamp): unknown {
    const obj: any = {};
    if (message.seconds !== 0) {
      obj.seconds = Math.round(message.seconds);
    }
    if (message.nanos !== 0) {
      obj.nanos = Math.round(message.nanos);
    }
    return obj;
  },

  create(base?: DeepPartial<HederaTimestamp>): HederaTimestamp {
    return HederaTimestamp.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<HederaTimestamp>): HederaTimestamp {
    const message = createBaseHederaTimestamp();
    message.seconds = object.seconds ?? 0;
    message.nanos = object.nanos ?? 0;
    return message;
  },
};

function createBaseHederaTransaction(): HederaTransaction {
  return {
    id: "",
    timestamp: undefined,
    source: undefined,
    sourcePath: "",
    node: undefined,
    feeLimit: 0,
    ttlSeconds: 0,
    memo: "",
    operation: new Uint8Array(0),
  };
}

export const HederaTransaction = {
  encode(message: HederaTransaction, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.id !== "") {
      writer.uint32(10).string(message.id);
    }
    if (message.timestamp !== undefined) {
      HederaTimestamp.encode(message.timestamp, writer.uint32(18).fork()).ldelim();
    }
    if (message.source !== undefined) {
      HederaAccount.encode(message.source, writer.uint32(26).fork()).ldelim();
    }
    if (message.sourcePath !== "") {
      writer.uint32(34).string(message.sourcePath);
    }
    if (message.node !== undefined) {
      HederaAccount.encode(message.node, writer.uint32(42).fork()).ldelim();
    }
    if (message.feeLimit !== 0) {
      writer.uint32(48).uint64(message.feeLimit);
    }
    if (message.ttlSeconds !== 0) {
      writer.uint32(56).uint64(message.ttlSeconds);
    }
    if (message.memo !== "") {
      writer.uint32(66).string(message.memo);
    }
    if (message.operation.length !== 0) {
      writer.uint32(74).bytes(message.operation);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): HederaTransaction {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseHederaTransaction();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.id = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.timestamp = HederaTimestamp.decode(reader, reader.uint32());
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.source = HederaAccount.decode(reader, reader.uint32());
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.sourcePath = reader.string();
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.node = HederaAccount.decode(reader, reader.uint32());
          continue;
        case 6:
          if (tag !== 48) {
            break;
          }

          message.feeLimit = longToNumber(reader.uint64() as Long);
          continue;
        case 7:
          if (tag !== 56) {
            break;
          }

          message.ttlSeconds = longToNumber(reader.uint64() as Long);
          continue;
        case 8:
          if (tag !== 66) {
            break;
          }

          message.memo = reader.string();
          continue;
        case 9:
          if (tag !== 74) {
            break;
          }

          message.operation = reader.bytes();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): HederaTransaction {
    return {
      id: isSet(object.id) ? globalThis.String(object.id) : "",
      timestamp: isSet(object.timestamp) ? HederaTimestamp.fromJSON(object.timestamp) : undefined,
      source: isSet(object.source) ? HederaAccount.fromJSON(object.source) : undefined,
      sourcePath: isSet(object.sourcePath) ? globalThis.String(object.sourcePath) : "",
      node: isSet(object.node) ? HederaAccount.fromJSON(object.node) : undefined,
      feeLimit: isSet(object.feeLimit) ? globalThis.Number(object.feeLimit) : 0,
      ttlSeconds: isSet(object.ttlSeconds) ? globalThis.Number(object.ttlSeconds) : 0,
      memo: isSet(object.memo) ? globalThis.String(object.memo) : "",
      operation: isSet(object.operation) ? bytesFromBase64(object.operation) : new Uint8Array(0),
    };
  },

  toJSON(message: HederaTransaction): unknown {
    const obj: any = {};
    if (message.id !== "") {
      obj.id = message.id;
    }
    if (message.timestamp !== undefined) {
      obj.timestamp = HederaTimestamp.toJSON(message.timestamp);
    }
    if (message.source !== undefined) {
      obj.source = HederaAccount.toJSON(message.source);
    }
    if (message.sourcePath !== "") {
      obj.sourcePath = message.sourcePath;
    }
    if (message.node !== undefined) {
      obj.node = HederaAccount.toJSON(message.node);
    }
    if (message.feeLimit !== 0) {
      obj.feeLimit = Math.round(message.feeLimit);
    }
    if (message.ttlSeconds !== 0) {
      obj.ttlSeconds = Math.round(message.ttlSeconds);
    }
    if (message.memo !== "") {
      obj.memo = message.memo;
    }
    if (message.operation.length !== 0) {
      obj.operation = base64FromBytes(message.operation);
    }
    return obj;
  },

  create(base?: DeepPartial<HederaTransaction>): HederaTransaction {
    return HederaTransaction.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<HederaTransaction>): HederaTransaction {
    const message = createBaseHederaTransaction();
    message.id = object.id ?? "";
    message.timestamp = (object.timestamp !== undefined && object.timestamp !== null)
      ? HederaTimestamp.fromPartial(object.timestamp)
      : undefined;
    message.source = (object.source !== undefined && object.source !== null)
      ? HederaAccount.fromPartial(object.source)
      : undefined;
    message.sourcePath = object.sourcePath ?? "";
    message.node = (object.node !== undefined && object.node !== null)
      ? HederaAccount.fromPartial(object.node)
      : undefined;
    message.feeLimit = object.feeLimit ?? 0;
    message.ttlSeconds = object.ttlSeconds ?? 0;
    message.memo = object.memo ?? "";
    message.operation = object.operation ?? new Uint8Array(0);
    return message;
  },
};

function createBaseHederaProofOfReserveRequest(): HederaProofOfReserveRequest {
  return { shardNum: 0, realmNum: 0, path: "", challenge: "" };
}

export const HederaProofOfReserveRequest = {
  encode(message: HederaProofOfReserveRequest, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.shardNum !== 0) {
      writer.uint32(8).uint64(message.shardNum);
    }
    if (message.realmNum !== 0) {
      writer.uint32(16).uint64(message.realmNum);
    }
    if (message.path !== "") {
      writer.uint32(26).string(message.path);
    }
    if (message.challenge !== "") {
      writer.uint32(34).string(message.challenge);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): HederaProofOfReserveRequest {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseHederaProofOfReserveRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.shardNum = longToNumber(reader.uint64() as Long);
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.realmNum = longToNumber(reader.uint64() as Long);
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.path = reader.string();
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.challenge = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): HederaProofOfReserveRequest {
    return {
      shardNum: isSet(object.shardNum) ? globalThis.Number(object.shardNum) : 0,
      realmNum: isSet(object.realmNum) ? globalThis.Number(object.realmNum) : 0,
      path: isSet(object.path) ? globalThis.String(object.path) : "",
      challenge: isSet(object.challenge) ? globalThis.String(object.challenge) : "",
    };
  },

  toJSON(message: HederaProofOfReserveRequest): unknown {
    const obj: any = {};
    if (message.shardNum !== 0) {
      obj.shardNum = Math.round(message.shardNum);
    }
    if (message.realmNum !== 0) {
      obj.realmNum = Math.round(message.realmNum);
    }
    if (message.path !== "") {
      obj.path = message.path;
    }
    if (message.challenge !== "") {
      obj.challenge = message.challenge;
    }
    return obj;
  },

  create(base?: DeepPartial<HederaProofOfReserveRequest>): HederaProofOfReserveRequest {
    return HederaProofOfReserveRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<HederaProofOfReserveRequest>): HederaProofOfReserveRequest {
    const message = createBaseHederaProofOfReserveRequest();
    message.shardNum = object.shardNum ?? 0;
    message.realmNum = object.realmNum ?? 0;
    message.path = object.path ?? "";
    message.challenge = object.challenge ?? "";
    return message;
  },
};

function createBaseSOLAddressRequest(): SOLAddressRequest {
  return { path: "" };
}

export const SOLAddressRequest = {
  encode(message: SOLAddressRequest, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.path !== "") {
      writer.uint32(10).string(message.path);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): SOLAddressRequest {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSOLAddressRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.path = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): SOLAddressRequest {
    return { path: isSet(object.path) ? globalThis.String(object.path) : "" };
  },

  toJSON(message: SOLAddressRequest): unknown {
    const obj: any = {};
    if (message.path !== "") {
      obj.path = message.path;
    }
    return obj;
  },

  create(base?: DeepPartial<SOLAddressRequest>): SOLAddressRequest {
    return SOLAddressRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<SOLAddressRequest>): SOLAddressRequest {
    const message = createBaseSOLAddressRequest();
    message.path = object.path ?? "";
    return message;
  },
};

function createBaseSOLProofOfReserveRequest(): SOLProofOfReserveRequest {
  return { path: "", challenge: "" };
}

export const SOLProofOfReserveRequest = {
  encode(message: SOLProofOfReserveRequest, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.path !== "") {
      writer.uint32(10).string(message.path);
    }
    if (message.challenge !== "") {
      writer.uint32(18).string(message.challenge);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): SOLProofOfReserveRequest {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSOLProofOfReserveRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.path = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.challenge = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): SOLProofOfReserveRequest {
    return {
      path: isSet(object.path) ? globalThis.String(object.path) : "",
      challenge: isSet(object.challenge) ? globalThis.String(object.challenge) : "",
    };
  },

  toJSON(message: SOLProofOfReserveRequest): unknown {
    const obj: any = {};
    if (message.path !== "") {
      obj.path = message.path;
    }
    if (message.challenge !== "") {
      obj.challenge = message.challenge;
    }
    return obj;
  },

  create(base?: DeepPartial<SOLProofOfReserveRequest>): SOLProofOfReserveRequest {
    return SOLProofOfReserveRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<SOLProofOfReserveRequest>): SOLProofOfReserveRequest {
    const message = createBaseSOLProofOfReserveRequest();
    message.path = object.path ?? "";
    message.challenge = object.challenge ?? "";
    return message;
  },
};

function createBaseSOLCleanupDerivedAccountRequest(): SOLCleanupDerivedAccountRequest {
  return { blockHash: "", path: "", seed: "", program: "", amount: 0, id: "" };
}

export const SOLCleanupDerivedAccountRequest = {
  encode(message: SOLCleanupDerivedAccountRequest, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.blockHash !== "") {
      writer.uint32(10).string(message.blockHash);
    }
    if (message.path !== "") {
      writer.uint32(18).string(message.path);
    }
    if (message.seed !== "") {
      writer.uint32(26).string(message.seed);
    }
    if (message.program !== "") {
      writer.uint32(34).string(message.program);
    }
    if (message.amount !== 0) {
      writer.uint32(40).uint64(message.amount);
    }
    if (message.id !== "") {
      writer.uint32(50).string(message.id);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): SOLCleanupDerivedAccountRequest {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSOLCleanupDerivedAccountRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.blockHash = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.path = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.seed = reader.string();
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.program = reader.string();
          continue;
        case 5:
          if (tag !== 40) {
            break;
          }

          message.amount = longToNumber(reader.uint64() as Long);
          continue;
        case 6:
          if (tag !== 50) {
            break;
          }

          message.id = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): SOLCleanupDerivedAccountRequest {
    return {
      blockHash: isSet(object.blockHash) ? globalThis.String(object.blockHash) : "",
      path: isSet(object.path) ? globalThis.String(object.path) : "",
      seed: isSet(object.seed) ? globalThis.String(object.seed) : "",
      program: isSet(object.program) ? globalThis.String(object.program) : "",
      amount: isSet(object.amount) ? globalThis.Number(object.amount) : 0,
      id: isSet(object.id) ? globalThis.String(object.id) : "",
    };
  },

  toJSON(message: SOLCleanupDerivedAccountRequest): unknown {
    const obj: any = {};
    if (message.blockHash !== "") {
      obj.blockHash = message.blockHash;
    }
    if (message.path !== "") {
      obj.path = message.path;
    }
    if (message.seed !== "") {
      obj.seed = message.seed;
    }
    if (message.program !== "") {
      obj.program = message.program;
    }
    if (message.amount !== 0) {
      obj.amount = Math.round(message.amount);
    }
    if (message.id !== "") {
      obj.id = message.id;
    }
    return obj;
  },

  create(base?: DeepPartial<SOLCleanupDerivedAccountRequest>): SOLCleanupDerivedAccountRequest {
    return SOLCleanupDerivedAccountRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<SOLCleanupDerivedAccountRequest>): SOLCleanupDerivedAccountRequest {
    const message = createBaseSOLCleanupDerivedAccountRequest();
    message.blockHash = object.blockHash ?? "";
    message.path = object.path ?? "";
    message.seed = object.seed ?? "";
    message.program = object.program ?? "";
    message.amount = object.amount ?? 0;
    message.id = object.id ?? "";
    return message;
  },
};

function createBaseSOLTransfersRequest(): SOLTransfersRequest {
  return { transfers: [] };
}

export const SOLTransfersRequest = {
  encode(message: SOLTransfersRequest, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    for (const v of message.transfers) {
      SOLTransfer.encode(v!, writer.uint32(10).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): SOLTransfersRequest {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSOLTransfersRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.transfers.push(SOLTransfer.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): SOLTransfersRequest {
    return {
      transfers: globalThis.Array.isArray(object?.transfers)
        ? object.transfers.map((e: any) => SOLTransfer.fromJSON(e))
        : [],
    };
  },

  toJSON(message: SOLTransfersRequest): unknown {
    const obj: any = {};
    if (message.transfers?.length) {
      obj.transfers = message.transfers.map((e) => SOLTransfer.toJSON(e));
    }
    return obj;
  },

  create(base?: DeepPartial<SOLTransfersRequest>): SOLTransfersRequest {
    return SOLTransfersRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<SOLTransfersRequest>): SOLTransfersRequest {
    const message = createBaseSOLTransfersRequest();
    message.transfers = object.transfers?.map((e) => SOLTransfer.fromPartial(e)) || [];
    return message;
  },
};

function createBaseSOLTransfer(): SOLTransfer {
  return { blockHash: "", path: "", to: "", amount: 0, fee: 0, id: "", computePrice: 0, computeBudget: 0 };
}

export const SOLTransfer = {
  encode(message: SOLTransfer, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.blockHash !== "") {
      writer.uint32(10).string(message.blockHash);
    }
    if (message.path !== "") {
      writer.uint32(18).string(message.path);
    }
    if (message.to !== "") {
      writer.uint32(26).string(message.to);
    }
    if (message.amount !== 0) {
      writer.uint32(32).uint64(message.amount);
    }
    if (message.fee !== 0) {
      writer.uint32(40).uint64(message.fee);
    }
    if (message.id !== "") {
      writer.uint32(50).string(message.id);
    }
    if (message.computePrice !== 0) {
      writer.uint32(56).uint64(message.computePrice);
    }
    if (message.computeBudget !== 0) {
      writer.uint32(64).uint64(message.computeBudget);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): SOLTransfer {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSOLTransfer();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.blockHash = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.path = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.to = reader.string();
          continue;
        case 4:
          if (tag !== 32) {
            break;
          }

          message.amount = longToNumber(reader.uint64() as Long);
          continue;
        case 5:
          if (tag !== 40) {
            break;
          }

          message.fee = longToNumber(reader.uint64() as Long);
          continue;
        case 6:
          if (tag !== 50) {
            break;
          }

          message.id = reader.string();
          continue;
        case 7:
          if (tag !== 56) {
            break;
          }

          message.computePrice = longToNumber(reader.uint64() as Long);
          continue;
        case 8:
          if (tag !== 64) {
            break;
          }

          message.computeBudget = longToNumber(reader.uint64() as Long);
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): SOLTransfer {
    return {
      blockHash: isSet(object.blockHash) ? globalThis.String(object.blockHash) : "",
      path: isSet(object.path) ? globalThis.String(object.path) : "",
      to: isSet(object.to) ? globalThis.String(object.to) : "",
      amount: isSet(object.amount) ? globalThis.Number(object.amount) : 0,
      fee: isSet(object.fee) ? globalThis.Number(object.fee) : 0,
      id: isSet(object.id) ? globalThis.String(object.id) : "",
      computePrice: isSet(object.computePrice) ? globalThis.Number(object.computePrice) : 0,
      computeBudget: isSet(object.computeBudget) ? globalThis.Number(object.computeBudget) : 0,
    };
  },

  toJSON(message: SOLTransfer): unknown {
    const obj: any = {};
    if (message.blockHash !== "") {
      obj.blockHash = message.blockHash;
    }
    if (message.path !== "") {
      obj.path = message.path;
    }
    if (message.to !== "") {
      obj.to = message.to;
    }
    if (message.amount !== 0) {
      obj.amount = Math.round(message.amount);
    }
    if (message.fee !== 0) {
      obj.fee = Math.round(message.fee);
    }
    if (message.id !== "") {
      obj.id = message.id;
    }
    if (message.computePrice !== 0) {
      obj.computePrice = Math.round(message.computePrice);
    }
    if (message.computeBudget !== 0) {
      obj.computeBudget = Math.round(message.computeBudget);
    }
    return obj;
  },

  create(base?: DeepPartial<SOLTransfer>): SOLTransfer {
    return SOLTransfer.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<SOLTransfer>): SOLTransfer {
    const message = createBaseSOLTransfer();
    message.blockHash = object.blockHash ?? "";
    message.path = object.path ?? "";
    message.to = object.to ?? "";
    message.amount = object.amount ?? 0;
    message.fee = object.fee ?? 0;
    message.id = object.id ?? "";
    message.computePrice = object.computePrice ?? 0;
    message.computeBudget = object.computeBudget ?? 0;
    return message;
  },
};

function createBaseSOLDelegateStakeRequest(): SOLDelegateStakeRequest {
  return {
    blockHash: "",
    path: "",
    createAccount: false,
    space: 0,
    amount: 0,
    voter: "",
    id: "",
    computePrice: 0,
    computeBudget: 0,
    derivationIndex: 0,
  };
}

export const SOLDelegateStakeRequest = {
  encode(message: SOLDelegateStakeRequest, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.blockHash !== "") {
      writer.uint32(10).string(message.blockHash);
    }
    if (message.path !== "") {
      writer.uint32(18).string(message.path);
    }
    if (message.createAccount !== false) {
      writer.uint32(24).bool(message.createAccount);
    }
    if (message.space !== 0) {
      writer.uint32(32).uint64(message.space);
    }
    if (message.amount !== 0) {
      writer.uint32(40).uint64(message.amount);
    }
    if (message.voter !== "") {
      writer.uint32(50).string(message.voter);
    }
    if (message.id !== "") {
      writer.uint32(58).string(message.id);
    }
    if (message.computePrice !== 0) {
      writer.uint32(64).uint64(message.computePrice);
    }
    if (message.computeBudget !== 0) {
      writer.uint32(72).uint64(message.computeBudget);
    }
    if (message.derivationIndex !== 0) {
      writer.uint32(80).uint64(message.derivationIndex);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): SOLDelegateStakeRequest {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSOLDelegateStakeRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.blockHash = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.path = reader.string();
          continue;
        case 3:
          if (tag !== 24) {
            break;
          }

          message.createAccount = reader.bool();
          continue;
        case 4:
          if (tag !== 32) {
            break;
          }

          message.space = longToNumber(reader.uint64() as Long);
          continue;
        case 5:
          if (tag !== 40) {
            break;
          }

          message.amount = longToNumber(reader.uint64() as Long);
          continue;
        case 6:
          if (tag !== 50) {
            break;
          }

          message.voter = reader.string();
          continue;
        case 7:
          if (tag !== 58) {
            break;
          }

          message.id = reader.string();
          continue;
        case 8:
          if (tag !== 64) {
            break;
          }

          message.computePrice = longToNumber(reader.uint64() as Long);
          continue;
        case 9:
          if (tag !== 72) {
            break;
          }

          message.computeBudget = longToNumber(reader.uint64() as Long);
          continue;
        case 10:
          if (tag !== 80) {
            break;
          }

          message.derivationIndex = longToNumber(reader.uint64() as Long);
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): SOLDelegateStakeRequest {
    return {
      blockHash: isSet(object.blockHash) ? globalThis.String(object.blockHash) : "",
      path: isSet(object.path) ? globalThis.String(object.path) : "",
      createAccount: isSet(object.createAccount) ? globalThis.Boolean(object.createAccount) : false,
      space: isSet(object.space) ? globalThis.Number(object.space) : 0,
      amount: isSet(object.amount) ? globalThis.Number(object.amount) : 0,
      voter: isSet(object.voter) ? globalThis.String(object.voter) : "",
      id: isSet(object.id) ? globalThis.String(object.id) : "",
      computePrice: isSet(object.computePrice) ? globalThis.Number(object.computePrice) : 0,
      computeBudget: isSet(object.computeBudget) ? globalThis.Number(object.computeBudget) : 0,
      derivationIndex: isSet(object.derivationIndex) ? globalThis.Number(object.derivationIndex) : 0,
    };
  },

  toJSON(message: SOLDelegateStakeRequest): unknown {
    const obj: any = {};
    if (message.blockHash !== "") {
      obj.blockHash = message.blockHash;
    }
    if (message.path !== "") {
      obj.path = message.path;
    }
    if (message.createAccount !== false) {
      obj.createAccount = message.createAccount;
    }
    if (message.space !== 0) {
      obj.space = Math.round(message.space);
    }
    if (message.amount !== 0) {
      obj.amount = Math.round(message.amount);
    }
    if (message.voter !== "") {
      obj.voter = message.voter;
    }
    if (message.id !== "") {
      obj.id = message.id;
    }
    if (message.computePrice !== 0) {
      obj.computePrice = Math.round(message.computePrice);
    }
    if (message.computeBudget !== 0) {
      obj.computeBudget = Math.round(message.computeBudget);
    }
    if (message.derivationIndex !== 0) {
      obj.derivationIndex = Math.round(message.derivationIndex);
    }
    return obj;
  },

  create(base?: DeepPartial<SOLDelegateStakeRequest>): SOLDelegateStakeRequest {
    return SOLDelegateStakeRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<SOLDelegateStakeRequest>): SOLDelegateStakeRequest {
    const message = createBaseSOLDelegateStakeRequest();
    message.blockHash = object.blockHash ?? "";
    message.path = object.path ?? "";
    message.createAccount = object.createAccount ?? false;
    message.space = object.space ?? 0;
    message.amount = object.amount ?? 0;
    message.voter = object.voter ?? "";
    message.id = object.id ?? "";
    message.computePrice = object.computePrice ?? 0;
    message.computeBudget = object.computeBudget ?? 0;
    message.derivationIndex = object.derivationIndex ?? 0;
    return message;
  },
};

function createBaseSOLDeactivateStakeRequest(): SOLDeactivateStakeRequest {
  return { blockHash: "", path: "", id: "", computePrice: 0, computeBudget: 0, derivationIndex: 0 };
}

export const SOLDeactivateStakeRequest = {
  encode(message: SOLDeactivateStakeRequest, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.blockHash !== "") {
      writer.uint32(10).string(message.blockHash);
    }
    if (message.path !== "") {
      writer.uint32(18).string(message.path);
    }
    if (message.id !== "") {
      writer.uint32(26).string(message.id);
    }
    if (message.computePrice !== 0) {
      writer.uint32(32).uint64(message.computePrice);
    }
    if (message.computeBudget !== 0) {
      writer.uint32(40).uint64(message.computeBudget);
    }
    if (message.derivationIndex !== 0) {
      writer.uint32(48).uint64(message.derivationIndex);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): SOLDeactivateStakeRequest {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSOLDeactivateStakeRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.blockHash = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.path = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.id = reader.string();
          continue;
        case 4:
          if (tag !== 32) {
            break;
          }

          message.computePrice = longToNumber(reader.uint64() as Long);
          continue;
        case 5:
          if (tag !== 40) {
            break;
          }

          message.computeBudget = longToNumber(reader.uint64() as Long);
          continue;
        case 6:
          if (tag !== 48) {
            break;
          }

          message.derivationIndex = longToNumber(reader.uint64() as Long);
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): SOLDeactivateStakeRequest {
    return {
      blockHash: isSet(object.blockHash) ? globalThis.String(object.blockHash) : "",
      path: isSet(object.path) ? globalThis.String(object.path) : "",
      id: isSet(object.id) ? globalThis.String(object.id) : "",
      computePrice: isSet(object.computePrice) ? globalThis.Number(object.computePrice) : 0,
      computeBudget: isSet(object.computeBudget) ? globalThis.Number(object.computeBudget) : 0,
      derivationIndex: isSet(object.derivationIndex) ? globalThis.Number(object.derivationIndex) : 0,
    };
  },

  toJSON(message: SOLDeactivateStakeRequest): unknown {
    const obj: any = {};
    if (message.blockHash !== "") {
      obj.blockHash = message.blockHash;
    }
    if (message.path !== "") {
      obj.path = message.path;
    }
    if (message.id !== "") {
      obj.id = message.id;
    }
    if (message.computePrice !== 0) {
      obj.computePrice = Math.round(message.computePrice);
    }
    if (message.computeBudget !== 0) {
      obj.computeBudget = Math.round(message.computeBudget);
    }
    if (message.derivationIndex !== 0) {
      obj.derivationIndex = Math.round(message.derivationIndex);
    }
    return obj;
  },

  create(base?: DeepPartial<SOLDeactivateStakeRequest>): SOLDeactivateStakeRequest {
    return SOLDeactivateStakeRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<SOLDeactivateStakeRequest>): SOLDeactivateStakeRequest {
    const message = createBaseSOLDeactivateStakeRequest();
    message.blockHash = object.blockHash ?? "";
    message.path = object.path ?? "";
    message.id = object.id ?? "";
    message.computePrice = object.computePrice ?? 0;
    message.computeBudget = object.computeBudget ?? 0;
    message.derivationIndex = object.derivationIndex ?? 0;
    return message;
  },
};

function createBaseSOLPartialDeactivateStakeRequest(): SOLPartialDeactivateStakeRequest {
  return {
    blockHash: "",
    path: "",
    sourceDerivationIndex: 0,
    destinationDerivationIndex: 0,
    space: 0,
    rentExemptBalance: 0,
    amount: 0,
    inactiveAmount: 0,
    id: "",
    computePrice: 0,
    computeBudget: 0,
  };
}

export const SOLPartialDeactivateStakeRequest = {
  encode(message: SOLPartialDeactivateStakeRequest, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.blockHash !== "") {
      writer.uint32(10).string(message.blockHash);
    }
    if (message.path !== "") {
      writer.uint32(18).string(message.path);
    }
    if (message.sourceDerivationIndex !== 0) {
      writer.uint32(24).uint64(message.sourceDerivationIndex);
    }
    if (message.destinationDerivationIndex !== 0) {
      writer.uint32(32).uint64(message.destinationDerivationIndex);
    }
    if (message.space !== 0) {
      writer.uint32(40).uint64(message.space);
    }
    if (message.rentExemptBalance !== 0) {
      writer.uint32(48).uint64(message.rentExemptBalance);
    }
    if (message.amount !== 0) {
      writer.uint32(56).uint64(message.amount);
    }
    if (message.inactiveAmount !== 0) {
      writer.uint32(64).uint64(message.inactiveAmount);
    }
    if (message.id !== "") {
      writer.uint32(74).string(message.id);
    }
    if (message.computePrice !== 0) {
      writer.uint32(80).uint64(message.computePrice);
    }
    if (message.computeBudget !== 0) {
      writer.uint32(88).uint64(message.computeBudget);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): SOLPartialDeactivateStakeRequest {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSOLPartialDeactivateStakeRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.blockHash = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.path = reader.string();
          continue;
        case 3:
          if (tag !== 24) {
            break;
          }

          message.sourceDerivationIndex = longToNumber(reader.uint64() as Long);
          continue;
        case 4:
          if (tag !== 32) {
            break;
          }

          message.destinationDerivationIndex = longToNumber(reader.uint64() as Long);
          continue;
        case 5:
          if (tag !== 40) {
            break;
          }

          message.space = longToNumber(reader.uint64() as Long);
          continue;
        case 6:
          if (tag !== 48) {
            break;
          }

          message.rentExemptBalance = longToNumber(reader.uint64() as Long);
          continue;
        case 7:
          if (tag !== 56) {
            break;
          }

          message.amount = longToNumber(reader.uint64() as Long);
          continue;
        case 8:
          if (tag !== 64) {
            break;
          }

          message.inactiveAmount = longToNumber(reader.uint64() as Long);
          continue;
        case 9:
          if (tag !== 74) {
            break;
          }

          message.id = reader.string();
          continue;
        case 10:
          if (tag !== 80) {
            break;
          }

          message.computePrice = longToNumber(reader.uint64() as Long);
          continue;
        case 11:
          if (tag !== 88) {
            break;
          }

          message.computeBudget = longToNumber(reader.uint64() as Long);
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): SOLPartialDeactivateStakeRequest {
    return {
      blockHash: isSet(object.blockHash) ? globalThis.String(object.blockHash) : "",
      path: isSet(object.path) ? globalThis.String(object.path) : "",
      sourceDerivationIndex: isSet(object.sourceDerivationIndex) ? globalThis.Number(object.sourceDerivationIndex) : 0,
      destinationDerivationIndex: isSet(object.destinationDerivationIndex)
        ? globalThis.Number(object.destinationDerivationIndex)
        : 0,
      space: isSet(object.space) ? globalThis.Number(object.space) : 0,
      rentExemptBalance: isSet(object.rentExemptBalance) ? globalThis.Number(object.rentExemptBalance) : 0,
      amount: isSet(object.amount) ? globalThis.Number(object.amount) : 0,
      inactiveAmount: isSet(object.inactiveAmount) ? globalThis.Number(object.inactiveAmount) : 0,
      id: isSet(object.id) ? globalThis.String(object.id) : "",
      computePrice: isSet(object.computePrice) ? globalThis.Number(object.computePrice) : 0,
      computeBudget: isSet(object.computeBudget) ? globalThis.Number(object.computeBudget) : 0,
    };
  },

  toJSON(message: SOLPartialDeactivateStakeRequest): unknown {
    const obj: any = {};
    if (message.blockHash !== "") {
      obj.blockHash = message.blockHash;
    }
    if (message.path !== "") {
      obj.path = message.path;
    }
    if (message.sourceDerivationIndex !== 0) {
      obj.sourceDerivationIndex = Math.round(message.sourceDerivationIndex);
    }
    if (message.destinationDerivationIndex !== 0) {
      obj.destinationDerivationIndex = Math.round(message.destinationDerivationIndex);
    }
    if (message.space !== 0) {
      obj.space = Math.round(message.space);
    }
    if (message.rentExemptBalance !== 0) {
      obj.rentExemptBalance = Math.round(message.rentExemptBalance);
    }
    if (message.amount !== 0) {
      obj.amount = Math.round(message.amount);
    }
    if (message.inactiveAmount !== 0) {
      obj.inactiveAmount = Math.round(message.inactiveAmount);
    }
    if (message.id !== "") {
      obj.id = message.id;
    }
    if (message.computePrice !== 0) {
      obj.computePrice = Math.round(message.computePrice);
    }
    if (message.computeBudget !== 0) {
      obj.computeBudget = Math.round(message.computeBudget);
    }
    return obj;
  },

  create(base?: DeepPartial<SOLPartialDeactivateStakeRequest>): SOLPartialDeactivateStakeRequest {
    return SOLPartialDeactivateStakeRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<SOLPartialDeactivateStakeRequest>): SOLPartialDeactivateStakeRequest {
    const message = createBaseSOLPartialDeactivateStakeRequest();
    message.blockHash = object.blockHash ?? "";
    message.path = object.path ?? "";
    message.sourceDerivationIndex = object.sourceDerivationIndex ?? 0;
    message.destinationDerivationIndex = object.destinationDerivationIndex ?? 0;
    message.space = object.space ?? 0;
    message.rentExemptBalance = object.rentExemptBalance ?? 0;
    message.amount = object.amount ?? 0;
    message.inactiveAmount = object.inactiveAmount ?? 0;
    message.id = object.id ?? "";
    message.computePrice = object.computePrice ?? 0;
    message.computeBudget = object.computeBudget ?? 0;
    return message;
  },
};

function createBaseSOLWithdrawStakeRequest(): SOLWithdrawStakeRequest {
  return { blockHash: "", path: "", amount: 0, id: "", computePrice: 0, computeBudget: 0, derivationIndex: 0 };
}

export const SOLWithdrawStakeRequest = {
  encode(message: SOLWithdrawStakeRequest, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.blockHash !== "") {
      writer.uint32(10).string(message.blockHash);
    }
    if (message.path !== "") {
      writer.uint32(18).string(message.path);
    }
    if (message.amount !== 0) {
      writer.uint32(24).uint64(message.amount);
    }
    if (message.id !== "") {
      writer.uint32(34).string(message.id);
    }
    if (message.computePrice !== 0) {
      writer.uint32(40).uint64(message.computePrice);
    }
    if (message.computeBudget !== 0) {
      writer.uint32(48).uint64(message.computeBudget);
    }
    if (message.derivationIndex !== 0) {
      writer.uint32(56).uint64(message.derivationIndex);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): SOLWithdrawStakeRequest {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSOLWithdrawStakeRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.blockHash = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.path = reader.string();
          continue;
        case 3:
          if (tag !== 24) {
            break;
          }

          message.amount = longToNumber(reader.uint64() as Long);
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.id = reader.string();
          continue;
        case 5:
          if (tag !== 40) {
            break;
          }

          message.computePrice = longToNumber(reader.uint64() as Long);
          continue;
        case 6:
          if (tag !== 48) {
            break;
          }

          message.computeBudget = longToNumber(reader.uint64() as Long);
          continue;
        case 7:
          if (tag !== 56) {
            break;
          }

          message.derivationIndex = longToNumber(reader.uint64() as Long);
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): SOLWithdrawStakeRequest {
    return {
      blockHash: isSet(object.blockHash) ? globalThis.String(object.blockHash) : "",
      path: isSet(object.path) ? globalThis.String(object.path) : "",
      amount: isSet(object.amount) ? globalThis.Number(object.amount) : 0,
      id: isSet(object.id) ? globalThis.String(object.id) : "",
      computePrice: isSet(object.computePrice) ? globalThis.Number(object.computePrice) : 0,
      computeBudget: isSet(object.computeBudget) ? globalThis.Number(object.computeBudget) : 0,
      derivationIndex: isSet(object.derivationIndex) ? globalThis.Number(object.derivationIndex) : 0,
    };
  },

  toJSON(message: SOLWithdrawStakeRequest): unknown {
    const obj: any = {};
    if (message.blockHash !== "") {
      obj.blockHash = message.blockHash;
    }
    if (message.path !== "") {
      obj.path = message.path;
    }
    if (message.amount !== 0) {
      obj.amount = Math.round(message.amount);
    }
    if (message.id !== "") {
      obj.id = message.id;
    }
    if (message.computePrice !== 0) {
      obj.computePrice = Math.round(message.computePrice);
    }
    if (message.computeBudget !== 0) {
      obj.computeBudget = Math.round(message.computeBudget);
    }
    if (message.derivationIndex !== 0) {
      obj.derivationIndex = Math.round(message.derivationIndex);
    }
    return obj;
  },

  create(base?: DeepPartial<SOLWithdrawStakeRequest>): SOLWithdrawStakeRequest {
    return SOLWithdrawStakeRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<SOLWithdrawStakeRequest>): SOLWithdrawStakeRequest {
    const message = createBaseSOLWithdrawStakeRequest();
    message.blockHash = object.blockHash ?? "";
    message.path = object.path ?? "";
    message.amount = object.amount ?? 0;
    message.id = object.id ?? "";
    message.computePrice = object.computePrice ?? 0;
    message.computeBudget = object.computeBudget ?? 0;
    message.derivationIndex = object.derivationIndex ?? 0;
    return message;
  },
};

function createBaseSOLMergeStakeRequest(): SOLMergeStakeRequest {
  return {
    blockHash: "",
    path: "",
    sourceDerivationIndex: 0,
    destinationDerivationIndex: 0,
    id: "",
    computePrice: 0,
    computeBudget: 0,
  };
}

export const SOLMergeStakeRequest = {
  encode(message: SOLMergeStakeRequest, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.blockHash !== "") {
      writer.uint32(10).string(message.blockHash);
    }
    if (message.path !== "") {
      writer.uint32(18).string(message.path);
    }
    if (message.sourceDerivationIndex !== 0) {
      writer.uint32(24).uint64(message.sourceDerivationIndex);
    }
    if (message.destinationDerivationIndex !== 0) {
      writer.uint32(32).uint64(message.destinationDerivationIndex);
    }
    if (message.id !== "") {
      writer.uint32(42).string(message.id);
    }
    if (message.computePrice !== 0) {
      writer.uint32(48).uint64(message.computePrice);
    }
    if (message.computeBudget !== 0) {
      writer.uint32(56).uint64(message.computeBudget);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): SOLMergeStakeRequest {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSOLMergeStakeRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.blockHash = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.path = reader.string();
          continue;
        case 3:
          if (tag !== 24) {
            break;
          }

          message.sourceDerivationIndex = longToNumber(reader.uint64() as Long);
          continue;
        case 4:
          if (tag !== 32) {
            break;
          }

          message.destinationDerivationIndex = longToNumber(reader.uint64() as Long);
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.id = reader.string();
          continue;
        case 6:
          if (tag !== 48) {
            break;
          }

          message.computePrice = longToNumber(reader.uint64() as Long);
          continue;
        case 7:
          if (tag !== 56) {
            break;
          }

          message.computeBudget = longToNumber(reader.uint64() as Long);
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): SOLMergeStakeRequest {
    return {
      blockHash: isSet(object.blockHash) ? globalThis.String(object.blockHash) : "",
      path: isSet(object.path) ? globalThis.String(object.path) : "",
      sourceDerivationIndex: isSet(object.sourceDerivationIndex) ? globalThis.Number(object.sourceDerivationIndex) : 0,
      destinationDerivationIndex: isSet(object.destinationDerivationIndex)
        ? globalThis.Number(object.destinationDerivationIndex)
        : 0,
      id: isSet(object.id) ? globalThis.String(object.id) : "",
      computePrice: isSet(object.computePrice) ? globalThis.Number(object.computePrice) : 0,
      computeBudget: isSet(object.computeBudget) ? globalThis.Number(object.computeBudget) : 0,
    };
  },

  toJSON(message: SOLMergeStakeRequest): unknown {
    const obj: any = {};
    if (message.blockHash !== "") {
      obj.blockHash = message.blockHash;
    }
    if (message.path !== "") {
      obj.path = message.path;
    }
    if (message.sourceDerivationIndex !== 0) {
      obj.sourceDerivationIndex = Math.round(message.sourceDerivationIndex);
    }
    if (message.destinationDerivationIndex !== 0) {
      obj.destinationDerivationIndex = Math.round(message.destinationDerivationIndex);
    }
    if (message.id !== "") {
      obj.id = message.id;
    }
    if (message.computePrice !== 0) {
      obj.computePrice = Math.round(message.computePrice);
    }
    if (message.computeBudget !== 0) {
      obj.computeBudget = Math.round(message.computeBudget);
    }
    return obj;
  },

  create(base?: DeepPartial<SOLMergeStakeRequest>): SOLMergeStakeRequest {
    return SOLMergeStakeRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<SOLMergeStakeRequest>): SOLMergeStakeRequest {
    const message = createBaseSOLMergeStakeRequest();
    message.blockHash = object.blockHash ?? "";
    message.path = object.path ?? "";
    message.sourceDerivationIndex = object.sourceDerivationIndex ?? 0;
    message.destinationDerivationIndex = object.destinationDerivationIndex ?? 0;
    message.id = object.id ?? "";
    message.computePrice = object.computePrice ?? 0;
    message.computeBudget = object.computeBudget ?? 0;
    return message;
  },
};

function createBaseSOLTokenCreateRequest(): SOLTokenCreateRequest {
  return {
    blockHash: "",
    path: "",
    program: "",
    seed: "",
    decimals: 0,
    rentExemptBalance: 0,
    name: "",
    symbol: "",
    uri: "",
    id: "",
    computePrice: 0,
    computeBudget: 0,
    enableFreeze: false,
  };
}

export const SOLTokenCreateRequest = {
  encode(message: SOLTokenCreateRequest, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.blockHash !== "") {
      writer.uint32(10).string(message.blockHash);
    }
    if (message.path !== "") {
      writer.uint32(18).string(message.path);
    }
    if (message.program !== "") {
      writer.uint32(26).string(message.program);
    }
    if (message.seed !== "") {
      writer.uint32(34).string(message.seed);
    }
    if (message.decimals !== 0) {
      writer.uint32(40).uint64(message.decimals);
    }
    if (message.rentExemptBalance !== 0) {
      writer.uint32(48).uint64(message.rentExemptBalance);
    }
    if (message.name !== "") {
      writer.uint32(58).string(message.name);
    }
    if (message.symbol !== "") {
      writer.uint32(66).string(message.symbol);
    }
    if (message.uri !== "") {
      writer.uint32(74).string(message.uri);
    }
    if (message.id !== "") {
      writer.uint32(82).string(message.id);
    }
    if (message.computePrice !== 0) {
      writer.uint32(88).uint64(message.computePrice);
    }
    if (message.computeBudget !== 0) {
      writer.uint32(96).uint64(message.computeBudget);
    }
    if (message.enableFreeze !== false) {
      writer.uint32(104).bool(message.enableFreeze);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): SOLTokenCreateRequest {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSOLTokenCreateRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.blockHash = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.path = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.program = reader.string();
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.seed = reader.string();
          continue;
        case 5:
          if (tag !== 40) {
            break;
          }

          message.decimals = longToNumber(reader.uint64() as Long);
          continue;
        case 6:
          if (tag !== 48) {
            break;
          }

          message.rentExemptBalance = longToNumber(reader.uint64() as Long);
          continue;
        case 7:
          if (tag !== 58) {
            break;
          }

          message.name = reader.string();
          continue;
        case 8:
          if (tag !== 66) {
            break;
          }

          message.symbol = reader.string();
          continue;
        case 9:
          if (tag !== 74) {
            break;
          }

          message.uri = reader.string();
          continue;
        case 10:
          if (tag !== 82) {
            break;
          }

          message.id = reader.string();
          continue;
        case 11:
          if (tag !== 88) {
            break;
          }

          message.computePrice = longToNumber(reader.uint64() as Long);
          continue;
        case 12:
          if (tag !== 96) {
            break;
          }

          message.computeBudget = longToNumber(reader.uint64() as Long);
          continue;
        case 13:
          if (tag !== 104) {
            break;
          }

          message.enableFreeze = reader.bool();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): SOLTokenCreateRequest {
    return {
      blockHash: isSet(object.blockHash) ? globalThis.String(object.blockHash) : "",
      path: isSet(object.path) ? globalThis.String(object.path) : "",
      program: isSet(object.program) ? globalThis.String(object.program) : "",
      seed: isSet(object.seed) ? globalThis.String(object.seed) : "",
      decimals: isSet(object.decimals) ? globalThis.Number(object.decimals) : 0,
      rentExemptBalance: isSet(object.rentExemptBalance) ? globalThis.Number(object.rentExemptBalance) : 0,
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      symbol: isSet(object.symbol) ? globalThis.String(object.symbol) : "",
      uri: isSet(object.uri) ? globalThis.String(object.uri) : "",
      id: isSet(object.id) ? globalThis.String(object.id) : "",
      computePrice: isSet(object.computePrice) ? globalThis.Number(object.computePrice) : 0,
      computeBudget: isSet(object.computeBudget) ? globalThis.Number(object.computeBudget) : 0,
      enableFreeze: isSet(object.enableFreeze) ? globalThis.Boolean(object.enableFreeze) : false,
    };
  },

  toJSON(message: SOLTokenCreateRequest): unknown {
    const obj: any = {};
    if (message.blockHash !== "") {
      obj.blockHash = message.blockHash;
    }
    if (message.path !== "") {
      obj.path = message.path;
    }
    if (message.program !== "") {
      obj.program = message.program;
    }
    if (message.seed !== "") {
      obj.seed = message.seed;
    }
    if (message.decimals !== 0) {
      obj.decimals = Math.round(message.decimals);
    }
    if (message.rentExemptBalance !== 0) {
      obj.rentExemptBalance = Math.round(message.rentExemptBalance);
    }
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.symbol !== "") {
      obj.symbol = message.symbol;
    }
    if (message.uri !== "") {
      obj.uri = message.uri;
    }
    if (message.id !== "") {
      obj.id = message.id;
    }
    if (message.computePrice !== 0) {
      obj.computePrice = Math.round(message.computePrice);
    }
    if (message.computeBudget !== 0) {
      obj.computeBudget = Math.round(message.computeBudget);
    }
    if (message.enableFreeze !== false) {
      obj.enableFreeze = message.enableFreeze;
    }
    return obj;
  },

  create(base?: DeepPartial<SOLTokenCreateRequest>): SOLTokenCreateRequest {
    return SOLTokenCreateRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<SOLTokenCreateRequest>): SOLTokenCreateRequest {
    const message = createBaseSOLTokenCreateRequest();
    message.blockHash = object.blockHash ?? "";
    message.path = object.path ?? "";
    message.program = object.program ?? "";
    message.seed = object.seed ?? "";
    message.decimals = object.decimals ?? 0;
    message.rentExemptBalance = object.rentExemptBalance ?? 0;
    message.name = object.name ?? "";
    message.symbol = object.symbol ?? "";
    message.uri = object.uri ?? "";
    message.id = object.id ?? "";
    message.computePrice = object.computePrice ?? 0;
    message.computeBudget = object.computeBudget ?? 0;
    message.enableFreeze = object.enableFreeze ?? false;
    return message;
  },
};

function createBaseSOLTokenMintRequest(): SOLTokenMintRequest {
  return {
    blockHash: "",
    path: "",
    program: "",
    mint: "",
    decimals: 0,
    destination: "",
    createAccount: false,
    amount: 0,
    id: "",
    computePrice: 0,
    computeBudget: 0,
  };
}

export const SOLTokenMintRequest = {
  encode(message: SOLTokenMintRequest, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.blockHash !== "") {
      writer.uint32(10).string(message.blockHash);
    }
    if (message.path !== "") {
      writer.uint32(18).string(message.path);
    }
    if (message.program !== "") {
      writer.uint32(26).string(message.program);
    }
    if (message.mint !== "") {
      writer.uint32(34).string(message.mint);
    }
    if (message.decimals !== 0) {
      writer.uint32(48).uint64(message.decimals);
    }
    if (message.destination !== "") {
      writer.uint32(58).string(message.destination);
    }
    if (message.createAccount !== false) {
      writer.uint32(64).bool(message.createAccount);
    }
    if (message.amount !== 0) {
      writer.uint32(72).uint64(message.amount);
    }
    if (message.id !== "") {
      writer.uint32(82).string(message.id);
    }
    if (message.computePrice !== 0) {
      writer.uint32(88).uint64(message.computePrice);
    }
    if (message.computeBudget !== 0) {
      writer.uint32(96).uint64(message.computeBudget);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): SOLTokenMintRequest {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSOLTokenMintRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.blockHash = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.path = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.program = reader.string();
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.mint = reader.string();
          continue;
        case 6:
          if (tag !== 48) {
            break;
          }

          message.decimals = longToNumber(reader.uint64() as Long);
          continue;
        case 7:
          if (tag !== 58) {
            break;
          }

          message.destination = reader.string();
          continue;
        case 8:
          if (tag !== 64) {
            break;
          }

          message.createAccount = reader.bool();
          continue;
        case 9:
          if (tag !== 72) {
            break;
          }

          message.amount = longToNumber(reader.uint64() as Long);
          continue;
        case 10:
          if (tag !== 82) {
            break;
          }

          message.id = reader.string();
          continue;
        case 11:
          if (tag !== 88) {
            break;
          }

          message.computePrice = longToNumber(reader.uint64() as Long);
          continue;
        case 12:
          if (tag !== 96) {
            break;
          }

          message.computeBudget = longToNumber(reader.uint64() as Long);
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): SOLTokenMintRequest {
    return {
      blockHash: isSet(object.blockHash) ? globalThis.String(object.blockHash) : "",
      path: isSet(object.path) ? globalThis.String(object.path) : "",
      program: isSet(object.program) ? globalThis.String(object.program) : "",
      mint: isSet(object.mint) ? globalThis.String(object.mint) : "",
      decimals: isSet(object.decimals) ? globalThis.Number(object.decimals) : 0,
      destination: isSet(object.destination) ? globalThis.String(object.destination) : "",
      createAccount: isSet(object.createAccount) ? globalThis.Boolean(object.createAccount) : false,
      amount: isSet(object.amount) ? globalThis.Number(object.amount) : 0,
      id: isSet(object.id) ? globalThis.String(object.id) : "",
      computePrice: isSet(object.computePrice) ? globalThis.Number(object.computePrice) : 0,
      computeBudget: isSet(object.computeBudget) ? globalThis.Number(object.computeBudget) : 0,
    };
  },

  toJSON(message: SOLTokenMintRequest): unknown {
    const obj: any = {};
    if (message.blockHash !== "") {
      obj.blockHash = message.blockHash;
    }
    if (message.path !== "") {
      obj.path = message.path;
    }
    if (message.program !== "") {
      obj.program = message.program;
    }
    if (message.mint !== "") {
      obj.mint = message.mint;
    }
    if (message.decimals !== 0) {
      obj.decimals = Math.round(message.decimals);
    }
    if (message.destination !== "") {
      obj.destination = message.destination;
    }
    if (message.createAccount !== false) {
      obj.createAccount = message.createAccount;
    }
    if (message.amount !== 0) {
      obj.amount = Math.round(message.amount);
    }
    if (message.id !== "") {
      obj.id = message.id;
    }
    if (message.computePrice !== 0) {
      obj.computePrice = Math.round(message.computePrice);
    }
    if (message.computeBudget !== 0) {
      obj.computeBudget = Math.round(message.computeBudget);
    }
    return obj;
  },

  create(base?: DeepPartial<SOLTokenMintRequest>): SOLTokenMintRequest {
    return SOLTokenMintRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<SOLTokenMintRequest>): SOLTokenMintRequest {
    const message = createBaseSOLTokenMintRequest();
    message.blockHash = object.blockHash ?? "";
    message.path = object.path ?? "";
    message.program = object.program ?? "";
    message.mint = object.mint ?? "";
    message.decimals = object.decimals ?? 0;
    message.destination = object.destination ?? "";
    message.createAccount = object.createAccount ?? false;
    message.amount = object.amount ?? 0;
    message.id = object.id ?? "";
    message.computePrice = object.computePrice ?? 0;
    message.computeBudget = object.computeBudget ?? 0;
    return message;
  },
};

function createBaseSOLTokenBurnRequest(): SOLTokenBurnRequest {
  return {
    blockHash: "",
    path: "",
    program: "",
    mint: "",
    decimals: 0,
    amount: 0,
    id: "",
    computePrice: 0,
    computeBudget: 0,
  };
}

export const SOLTokenBurnRequest = {
  encode(message: SOLTokenBurnRequest, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.blockHash !== "") {
      writer.uint32(10).string(message.blockHash);
    }
    if (message.path !== "") {
      writer.uint32(18).string(message.path);
    }
    if (message.program !== "") {
      writer.uint32(26).string(message.program);
    }
    if (message.mint !== "") {
      writer.uint32(34).string(message.mint);
    }
    if (message.decimals !== 0) {
      writer.uint32(48).uint64(message.decimals);
    }
    if (message.amount !== 0) {
      writer.uint32(56).uint64(message.amount);
    }
    if (message.id !== "") {
      writer.uint32(66).string(message.id);
    }
    if (message.computePrice !== 0) {
      writer.uint32(72).uint64(message.computePrice);
    }
    if (message.computeBudget !== 0) {
      writer.uint32(80).uint64(message.computeBudget);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): SOLTokenBurnRequest {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSOLTokenBurnRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.blockHash = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.path = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.program = reader.string();
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.mint = reader.string();
          continue;
        case 6:
          if (tag !== 48) {
            break;
          }

          message.decimals = longToNumber(reader.uint64() as Long);
          continue;
        case 7:
          if (tag !== 56) {
            break;
          }

          message.amount = longToNumber(reader.uint64() as Long);
          continue;
        case 8:
          if (tag !== 66) {
            break;
          }

          message.id = reader.string();
          continue;
        case 9:
          if (tag !== 72) {
            break;
          }

          message.computePrice = longToNumber(reader.uint64() as Long);
          continue;
        case 10:
          if (tag !== 80) {
            break;
          }

          message.computeBudget = longToNumber(reader.uint64() as Long);
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): SOLTokenBurnRequest {
    return {
      blockHash: isSet(object.blockHash) ? globalThis.String(object.blockHash) : "",
      path: isSet(object.path) ? globalThis.String(object.path) : "",
      program: isSet(object.program) ? globalThis.String(object.program) : "",
      mint: isSet(object.mint) ? globalThis.String(object.mint) : "",
      decimals: isSet(object.decimals) ? globalThis.Number(object.decimals) : 0,
      amount: isSet(object.amount) ? globalThis.Number(object.amount) : 0,
      id: isSet(object.id) ? globalThis.String(object.id) : "",
      computePrice: isSet(object.computePrice) ? globalThis.Number(object.computePrice) : 0,
      computeBudget: isSet(object.computeBudget) ? globalThis.Number(object.computeBudget) : 0,
    };
  },

  toJSON(message: SOLTokenBurnRequest): unknown {
    const obj: any = {};
    if (message.blockHash !== "") {
      obj.blockHash = message.blockHash;
    }
    if (message.path !== "") {
      obj.path = message.path;
    }
    if (message.program !== "") {
      obj.program = message.program;
    }
    if (message.mint !== "") {
      obj.mint = message.mint;
    }
    if (message.decimals !== 0) {
      obj.decimals = Math.round(message.decimals);
    }
    if (message.amount !== 0) {
      obj.amount = Math.round(message.amount);
    }
    if (message.id !== "") {
      obj.id = message.id;
    }
    if (message.computePrice !== 0) {
      obj.computePrice = Math.round(message.computePrice);
    }
    if (message.computeBudget !== 0) {
      obj.computeBudget = Math.round(message.computeBudget);
    }
    return obj;
  },

  create(base?: DeepPartial<SOLTokenBurnRequest>): SOLTokenBurnRequest {
    return SOLTokenBurnRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<SOLTokenBurnRequest>): SOLTokenBurnRequest {
    const message = createBaseSOLTokenBurnRequest();
    message.blockHash = object.blockHash ?? "";
    message.path = object.path ?? "";
    message.program = object.program ?? "";
    message.mint = object.mint ?? "";
    message.decimals = object.decimals ?? 0;
    message.amount = object.amount ?? 0;
    message.id = object.id ?? "";
    message.computePrice = object.computePrice ?? 0;
    message.computeBudget = object.computeBudget ?? 0;
    return message;
  },
};

function createBaseSOLTokenFreezeAccountRequest(): SOLTokenFreezeAccountRequest {
  return {
    blockHash: "",
    path: "",
    destination: "",
    createAccount: false,
    program: "",
    mint: "",
    operation: 0,
    id: "",
    computePrice: 0,
    computeBudget: 0,
  };
}

export const SOLTokenFreezeAccountRequest = {
  encode(message: SOLTokenFreezeAccountRequest, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.blockHash !== "") {
      writer.uint32(10).string(message.blockHash);
    }
    if (message.path !== "") {
      writer.uint32(18).string(message.path);
    }
    if (message.destination !== "") {
      writer.uint32(26).string(message.destination);
    }
    if (message.createAccount !== false) {
      writer.uint32(32).bool(message.createAccount);
    }
    if (message.program !== "") {
      writer.uint32(42).string(message.program);
    }
    if (message.mint !== "") {
      writer.uint32(50).string(message.mint);
    }
    if (message.operation !== 0) {
      writer.uint32(56).int32(message.operation);
    }
    if (message.id !== "") {
      writer.uint32(66).string(message.id);
    }
    if (message.computePrice !== 0) {
      writer.uint32(72).uint64(message.computePrice);
    }
    if (message.computeBudget !== 0) {
      writer.uint32(80).uint64(message.computeBudget);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): SOLTokenFreezeAccountRequest {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSOLTokenFreezeAccountRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.blockHash = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.path = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.destination = reader.string();
          continue;
        case 4:
          if (tag !== 32) {
            break;
          }

          message.createAccount = reader.bool();
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.program = reader.string();
          continue;
        case 6:
          if (tag !== 50) {
            break;
          }

          message.mint = reader.string();
          continue;
        case 7:
          if (tag !== 56) {
            break;
          }

          message.operation = reader.int32() as any;
          continue;
        case 8:
          if (tag !== 66) {
            break;
          }

          message.id = reader.string();
          continue;
        case 9:
          if (tag !== 72) {
            break;
          }

          message.computePrice = longToNumber(reader.uint64() as Long);
          continue;
        case 10:
          if (tag !== 80) {
            break;
          }

          message.computeBudget = longToNumber(reader.uint64() as Long);
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): SOLTokenFreezeAccountRequest {
    return {
      blockHash: isSet(object.blockHash) ? globalThis.String(object.blockHash) : "",
      path: isSet(object.path) ? globalThis.String(object.path) : "",
      destination: isSet(object.destination) ? globalThis.String(object.destination) : "",
      createAccount: isSet(object.createAccount) ? globalThis.Boolean(object.createAccount) : false,
      program: isSet(object.program) ? globalThis.String(object.program) : "",
      mint: isSet(object.mint) ? globalThis.String(object.mint) : "",
      operation: isSet(object.operation) ? sOLTokenFreezeAccountRequest_OperationKindFromJSON(object.operation) : 0,
      id: isSet(object.id) ? globalThis.String(object.id) : "",
      computePrice: isSet(object.computePrice) ? globalThis.Number(object.computePrice) : 0,
      computeBudget: isSet(object.computeBudget) ? globalThis.Number(object.computeBudget) : 0,
    };
  },

  toJSON(message: SOLTokenFreezeAccountRequest): unknown {
    const obj: any = {};
    if (message.blockHash !== "") {
      obj.blockHash = message.blockHash;
    }
    if (message.path !== "") {
      obj.path = message.path;
    }
    if (message.destination !== "") {
      obj.destination = message.destination;
    }
    if (message.createAccount !== false) {
      obj.createAccount = message.createAccount;
    }
    if (message.program !== "") {
      obj.program = message.program;
    }
    if (message.mint !== "") {
      obj.mint = message.mint;
    }
    if (message.operation !== 0) {
      obj.operation = sOLTokenFreezeAccountRequest_OperationKindToJSON(message.operation);
    }
    if (message.id !== "") {
      obj.id = message.id;
    }
    if (message.computePrice !== 0) {
      obj.computePrice = Math.round(message.computePrice);
    }
    if (message.computeBudget !== 0) {
      obj.computeBudget = Math.round(message.computeBudget);
    }
    return obj;
  },

  create(base?: DeepPartial<SOLTokenFreezeAccountRequest>): SOLTokenFreezeAccountRequest {
    return SOLTokenFreezeAccountRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<SOLTokenFreezeAccountRequest>): SOLTokenFreezeAccountRequest {
    const message = createBaseSOLTokenFreezeAccountRequest();
    message.blockHash = object.blockHash ?? "";
    message.path = object.path ?? "";
    message.destination = object.destination ?? "";
    message.createAccount = object.createAccount ?? false;
    message.program = object.program ?? "";
    message.mint = object.mint ?? "";
    message.operation = object.operation ?? 0;
    message.id = object.id ?? "";
    message.computePrice = object.computePrice ?? 0;
    message.computeBudget = object.computeBudget ?? 0;
    return message;
  },
};

function createBaseSOLTokenTransfersRequest(): SOLTokenTransfersRequest {
  return { transfers: [] };
}

export const SOLTokenTransfersRequest = {
  encode(message: SOLTokenTransfersRequest, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    for (const v of message.transfers) {
      SOLTokenTransfer.encode(v!, writer.uint32(10).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): SOLTokenTransfersRequest {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSOLTokenTransfersRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.transfers.push(SOLTokenTransfer.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): SOLTokenTransfersRequest {
    return {
      transfers: globalThis.Array.isArray(object?.transfers)
        ? object.transfers.map((e: any) => SOLTokenTransfer.fromJSON(e))
        : [],
    };
  },

  toJSON(message: SOLTokenTransfersRequest): unknown {
    const obj: any = {};
    if (message.transfers?.length) {
      obj.transfers = message.transfers.map((e) => SOLTokenTransfer.toJSON(e));
    }
    return obj;
  },

  create(base?: DeepPartial<SOLTokenTransfersRequest>): SOLTokenTransfersRequest {
    return SOLTokenTransfersRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<SOLTokenTransfersRequest>): SOLTokenTransfersRequest {
    const message = createBaseSOLTokenTransfersRequest();
    message.transfers = object.transfers?.map((e) => SOLTokenTransfer.fromPartial(e)) || [];
    return message;
  },
};

function createBaseSOLTokenTransfer(): SOLTokenTransfer {
  return {
    blockHash: "",
    path: "",
    to: "",
    amount: 0,
    createDestination: false,
    mint: "",
    decimals: 0,
    program: "",
    id: "",
    computePrice: 0,
    computeBudget: 0,
    feepayer: "",
  };
}

export const SOLTokenTransfer = {
  encode(message: SOLTokenTransfer, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.blockHash !== "") {
      writer.uint32(10).string(message.blockHash);
    }
    if (message.path !== "") {
      writer.uint32(18).string(message.path);
    }
    if (message.to !== "") {
      writer.uint32(26).string(message.to);
    }
    if (message.amount !== 0) {
      writer.uint32(32).uint64(message.amount);
    }
    if (message.createDestination !== false) {
      writer.uint32(48).bool(message.createDestination);
    }
    if (message.mint !== "") {
      writer.uint32(58).string(message.mint);
    }
    if (message.decimals !== 0) {
      writer.uint32(64).uint64(message.decimals);
    }
    if (message.program !== "") {
      writer.uint32(74).string(message.program);
    }
    if (message.id !== "") {
      writer.uint32(82).string(message.id);
    }
    if (message.computePrice !== 0) {
      writer.uint32(88).uint64(message.computePrice);
    }
    if (message.computeBudget !== 0) {
      writer.uint32(96).uint64(message.computeBudget);
    }
    if (message.feepayer !== "") {
      writer.uint32(106).string(message.feepayer);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): SOLTokenTransfer {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSOLTokenTransfer();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.blockHash = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.path = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.to = reader.string();
          continue;
        case 4:
          if (tag !== 32) {
            break;
          }

          message.amount = longToNumber(reader.uint64() as Long);
          continue;
        case 6:
          if (tag !== 48) {
            break;
          }

          message.createDestination = reader.bool();
          continue;
        case 7:
          if (tag !== 58) {
            break;
          }

          message.mint = reader.string();
          continue;
        case 8:
          if (tag !== 64) {
            break;
          }

          message.decimals = longToNumber(reader.uint64() as Long);
          continue;
        case 9:
          if (tag !== 74) {
            break;
          }

          message.program = reader.string();
          continue;
        case 10:
          if (tag !== 82) {
            break;
          }

          message.id = reader.string();
          continue;
        case 11:
          if (tag !== 88) {
            break;
          }

          message.computePrice = longToNumber(reader.uint64() as Long);
          continue;
        case 12:
          if (tag !== 96) {
            break;
          }

          message.computeBudget = longToNumber(reader.uint64() as Long);
          continue;
        case 13:
          if (tag !== 106) {
            break;
          }

          message.feepayer = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): SOLTokenTransfer {
    return {
      blockHash: isSet(object.blockHash) ? globalThis.String(object.blockHash) : "",
      path: isSet(object.path) ? globalThis.String(object.path) : "",
      to: isSet(object.to) ? globalThis.String(object.to) : "",
      amount: isSet(object.amount) ? globalThis.Number(object.amount) : 0,
      createDestination: isSet(object.createDestination) ? globalThis.Boolean(object.createDestination) : false,
      mint: isSet(object.mint) ? globalThis.String(object.mint) : "",
      decimals: isSet(object.decimals) ? globalThis.Number(object.decimals) : 0,
      program: isSet(object.program) ? globalThis.String(object.program) : "",
      id: isSet(object.id) ? globalThis.String(object.id) : "",
      computePrice: isSet(object.computePrice) ? globalThis.Number(object.computePrice) : 0,
      computeBudget: isSet(object.computeBudget) ? globalThis.Number(object.computeBudget) : 0,
      feepayer: isSet(object.feepayer) ? globalThis.String(object.feepayer) : "",
    };
  },

  toJSON(message: SOLTokenTransfer): unknown {
    const obj: any = {};
    if (message.blockHash !== "") {
      obj.blockHash = message.blockHash;
    }
    if (message.path !== "") {
      obj.path = message.path;
    }
    if (message.to !== "") {
      obj.to = message.to;
    }
    if (message.amount !== 0) {
      obj.amount = Math.round(message.amount);
    }
    if (message.createDestination !== false) {
      obj.createDestination = message.createDestination;
    }
    if (message.mint !== "") {
      obj.mint = message.mint;
    }
    if (message.decimals !== 0) {
      obj.decimals = Math.round(message.decimals);
    }
    if (message.program !== "") {
      obj.program = message.program;
    }
    if (message.id !== "") {
      obj.id = message.id;
    }
    if (message.computePrice !== 0) {
      obj.computePrice = Math.round(message.computePrice);
    }
    if (message.computeBudget !== 0) {
      obj.computeBudget = Math.round(message.computeBudget);
    }
    if (message.feepayer !== "") {
      obj.feepayer = message.feepayer;
    }
    return obj;
  },

  create(base?: DeepPartial<SOLTokenTransfer>): SOLTokenTransfer {
    return SOLTokenTransfer.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<SOLTokenTransfer>): SOLTokenTransfer {
    const message = createBaseSOLTokenTransfer();
    message.blockHash = object.blockHash ?? "";
    message.path = object.path ?? "";
    message.to = object.to ?? "";
    message.amount = object.amount ?? 0;
    message.createDestination = object.createDestination ?? false;
    message.mint = object.mint ?? "";
    message.decimals = object.decimals ?? 0;
    message.program = object.program ?? "";
    message.id = object.id ?? "";
    message.computePrice = object.computePrice ?? 0;
    message.computeBudget = object.computeBudget ?? 0;
    message.feepayer = object.feepayer ?? "";
    return message;
  },
};

function createBaseCosmosAddressRequest(): CosmosAddressRequest {
  return { path: "", prefix: "" };
}

export const CosmosAddressRequest = {
  encode(message: CosmosAddressRequest, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.path !== "") {
      writer.uint32(10).string(message.path);
    }
    if (message.prefix !== "") {
      writer.uint32(18).string(message.prefix);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CosmosAddressRequest {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCosmosAddressRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.path = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.prefix = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CosmosAddressRequest {
    return {
      path: isSet(object.path) ? globalThis.String(object.path) : "",
      prefix: isSet(object.prefix) ? globalThis.String(object.prefix) : "",
    };
  },

  toJSON(message: CosmosAddressRequest): unknown {
    const obj: any = {};
    if (message.path !== "") {
      obj.path = message.path;
    }
    if (message.prefix !== "") {
      obj.prefix = message.prefix;
    }
    return obj;
  },

  create(base?: DeepPartial<CosmosAddressRequest>): CosmosAddressRequest {
    return CosmosAddressRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CosmosAddressRequest>): CosmosAddressRequest {
    const message = createBaseCosmosAddressRequest();
    message.path = object.path ?? "";
    message.prefix = object.prefix ?? "";
    return message;
  },
};

function createBaseCosmosProofOfReserveRequest(): CosmosProofOfReserveRequest {
  return { path: "", prefix: "", challenge: "" };
}

export const CosmosProofOfReserveRequest = {
  encode(message: CosmosProofOfReserveRequest, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.path !== "") {
      writer.uint32(10).string(message.path);
    }
    if (message.prefix !== "") {
      writer.uint32(18).string(message.prefix);
    }
    if (message.challenge !== "") {
      writer.uint32(26).string(message.challenge);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CosmosProofOfReserveRequest {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCosmosProofOfReserveRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.path = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.prefix = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.challenge = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CosmosProofOfReserveRequest {
    return {
      path: isSet(object.path) ? globalThis.String(object.path) : "",
      prefix: isSet(object.prefix) ? globalThis.String(object.prefix) : "",
      challenge: isSet(object.challenge) ? globalThis.String(object.challenge) : "",
    };
  },

  toJSON(message: CosmosProofOfReserveRequest): unknown {
    const obj: any = {};
    if (message.path !== "") {
      obj.path = message.path;
    }
    if (message.prefix !== "") {
      obj.prefix = message.prefix;
    }
    if (message.challenge !== "") {
      obj.challenge = message.challenge;
    }
    return obj;
  },

  create(base?: DeepPartial<CosmosProofOfReserveRequest>): CosmosProofOfReserveRequest {
    return CosmosProofOfReserveRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CosmosProofOfReserveRequest>): CosmosProofOfReserveRequest {
    const message = createBaseCosmosProofOfReserveRequest();
    message.path = object.path ?? "";
    message.prefix = object.prefix ?? "";
    message.challenge = object.challenge ?? "";
    return message;
  },
};

function createBaseCosmosRequestDetails(): CosmosRequestDetails {
  return {
    chainId: "",
    signers: [],
    gasLimit: 0,
    feeDenom: "",
    feeAmount: new Uint8Array(0),
    feePayer: "",
    memo: "",
    timeoutHeight: 0,
    id: "",
    isNonceSet: false,
    isRawRequest: false,
    isTransferRequest: false,
  };
}

export const CosmosRequestDetails = {
  encode(message: CosmosRequestDetails, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.chainId !== "") {
      writer.uint32(10).string(message.chainId);
    }
    for (const v of message.signers) {
      CosmosSigner.encode(v!, writer.uint32(18).fork()).ldelim();
    }
    if (message.gasLimit !== 0) {
      writer.uint32(24).uint64(message.gasLimit);
    }
    if (message.feeDenom !== "") {
      writer.uint32(34).string(message.feeDenom);
    }
    if (message.feeAmount.length !== 0) {
      writer.uint32(42).bytes(message.feeAmount);
    }
    if (message.feePayer !== "") {
      writer.uint32(50).string(message.feePayer);
    }
    if (message.memo !== "") {
      writer.uint32(58).string(message.memo);
    }
    if (message.timeoutHeight !== 0) {
      writer.uint32(64).uint64(message.timeoutHeight);
    }
    if (message.id !== "") {
      writer.uint32(74).string(message.id);
    }
    if (message.isNonceSet !== false) {
      writer.uint32(80).bool(message.isNonceSet);
    }
    if (message.isRawRequest !== false) {
      writer.uint32(88).bool(message.isRawRequest);
    }
    if (message.isTransferRequest !== false) {
      writer.uint32(96).bool(message.isTransferRequest);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CosmosRequestDetails {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCosmosRequestDetails();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.chainId = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.signers.push(CosmosSigner.decode(reader, reader.uint32()));
          continue;
        case 3:
          if (tag !== 24) {
            break;
          }

          message.gasLimit = longToNumber(reader.uint64() as Long);
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.feeDenom = reader.string();
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.feeAmount = reader.bytes();
          continue;
        case 6:
          if (tag !== 50) {
            break;
          }

          message.feePayer = reader.string();
          continue;
        case 7:
          if (tag !== 58) {
            break;
          }

          message.memo = reader.string();
          continue;
        case 8:
          if (tag !== 64) {
            break;
          }

          message.timeoutHeight = longToNumber(reader.uint64() as Long);
          continue;
        case 9:
          if (tag !== 74) {
            break;
          }

          message.id = reader.string();
          continue;
        case 10:
          if (tag !== 80) {
            break;
          }

          message.isNonceSet = reader.bool();
          continue;
        case 11:
          if (tag !== 88) {
            break;
          }

          message.isRawRequest = reader.bool();
          continue;
        case 12:
          if (tag !== 96) {
            break;
          }

          message.isTransferRequest = reader.bool();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CosmosRequestDetails {
    return {
      chainId: isSet(object.chainId) ? globalThis.String(object.chainId) : "",
      signers: globalThis.Array.isArray(object?.signers)
        ? object.signers.map((e: any) => CosmosSigner.fromJSON(e))
        : [],
      gasLimit: isSet(object.gasLimit) ? globalThis.Number(object.gasLimit) : 0,
      feeDenom: isSet(object.feeDenom) ? globalThis.String(object.feeDenom) : "",
      feeAmount: isSet(object.feeAmount) ? bytesFromBase64(object.feeAmount) : new Uint8Array(0),
      feePayer: isSet(object.feePayer) ? globalThis.String(object.feePayer) : "",
      memo: isSet(object.memo) ? globalThis.String(object.memo) : "",
      timeoutHeight: isSet(object.timeoutHeight) ? globalThis.Number(object.timeoutHeight) : 0,
      id: isSet(object.id) ? globalThis.String(object.id) : "",
      isNonceSet: isSet(object.isNonceSet) ? globalThis.Boolean(object.isNonceSet) : false,
      isRawRequest: isSet(object.isRawRequest) ? globalThis.Boolean(object.isRawRequest) : false,
      isTransferRequest: isSet(object.isTransferRequest) ? globalThis.Boolean(object.isTransferRequest) : false,
    };
  },

  toJSON(message: CosmosRequestDetails): unknown {
    const obj: any = {};
    if (message.chainId !== "") {
      obj.chainId = message.chainId;
    }
    if (message.signers?.length) {
      obj.signers = message.signers.map((e) => CosmosSigner.toJSON(e));
    }
    if (message.gasLimit !== 0) {
      obj.gasLimit = Math.round(message.gasLimit);
    }
    if (message.feeDenom !== "") {
      obj.feeDenom = message.feeDenom;
    }
    if (message.feeAmount.length !== 0) {
      obj.feeAmount = base64FromBytes(message.feeAmount);
    }
    if (message.feePayer !== "") {
      obj.feePayer = message.feePayer;
    }
    if (message.memo !== "") {
      obj.memo = message.memo;
    }
    if (message.timeoutHeight !== 0) {
      obj.timeoutHeight = Math.round(message.timeoutHeight);
    }
    if (message.id !== "") {
      obj.id = message.id;
    }
    if (message.isNonceSet !== false) {
      obj.isNonceSet = message.isNonceSet;
    }
    if (message.isRawRequest !== false) {
      obj.isRawRequest = message.isRawRequest;
    }
    if (message.isTransferRequest !== false) {
      obj.isTransferRequest = message.isTransferRequest;
    }
    return obj;
  },

  create(base?: DeepPartial<CosmosRequestDetails>): CosmosRequestDetails {
    return CosmosRequestDetails.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CosmosRequestDetails>): CosmosRequestDetails {
    const message = createBaseCosmosRequestDetails();
    message.chainId = object.chainId ?? "";
    message.signers = object.signers?.map((e) => CosmosSigner.fromPartial(e)) || [];
    message.gasLimit = object.gasLimit ?? 0;
    message.feeDenom = object.feeDenom ?? "";
    message.feeAmount = object.feeAmount ?? new Uint8Array(0);
    message.feePayer = object.feePayer ?? "";
    message.memo = object.memo ?? "";
    message.timeoutHeight = object.timeoutHeight ?? 0;
    message.id = object.id ?? "";
    message.isNonceSet = object.isNonceSet ?? false;
    message.isRawRequest = object.isRawRequest ?? false;
    message.isTransferRequest = object.isTransferRequest ?? false;
    return message;
  },
};

function createBaseCosmosSigner(): CosmosSigner {
  return { path: "", sequence: 0, accountNumber: 0 };
}

export const CosmosSigner = {
  encode(message: CosmosSigner, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.path !== "") {
      writer.uint32(10).string(message.path);
    }
    if (message.sequence !== 0) {
      writer.uint32(16).uint64(message.sequence);
    }
    if (message.accountNumber !== 0) {
      writer.uint32(24).uint64(message.accountNumber);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CosmosSigner {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCosmosSigner();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.path = reader.string();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.sequence = longToNumber(reader.uint64() as Long);
          continue;
        case 3:
          if (tag !== 24) {
            break;
          }

          message.accountNumber = longToNumber(reader.uint64() as Long);
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CosmosSigner {
    return {
      path: isSet(object.path) ? globalThis.String(object.path) : "",
      sequence: isSet(object.sequence) ? globalThis.Number(object.sequence) : 0,
      accountNumber: isSet(object.accountNumber) ? globalThis.Number(object.accountNumber) : 0,
    };
  },

  toJSON(message: CosmosSigner): unknown {
    const obj: any = {};
    if (message.path !== "") {
      obj.path = message.path;
    }
    if (message.sequence !== 0) {
      obj.sequence = Math.round(message.sequence);
    }
    if (message.accountNumber !== 0) {
      obj.accountNumber = Math.round(message.accountNumber);
    }
    return obj;
  },

  create(base?: DeepPartial<CosmosSigner>): CosmosSigner {
    return CosmosSigner.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CosmosSigner>): CosmosSigner {
    const message = createBaseCosmosSigner();
    message.path = object.path ?? "";
    message.sequence = object.sequence ?? 0;
    message.accountNumber = object.accountNumber ?? 0;
    return message;
  },
};

function createBaseCosmosMessage(): CosmosMessage {
  return { url: "", payload: new Uint8Array(0) };
}

export const CosmosMessage = {
  encode(message: CosmosMessage, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.url !== "") {
      writer.uint32(10).string(message.url);
    }
    if (message.payload.length !== 0) {
      writer.uint32(18).bytes(message.payload);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CosmosMessage {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCosmosMessage();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.url = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.payload = reader.bytes();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CosmosMessage {
    return {
      url: isSet(object.url) ? globalThis.String(object.url) : "",
      payload: isSet(object.payload) ? bytesFromBase64(object.payload) : new Uint8Array(0),
    };
  },

  toJSON(message: CosmosMessage): unknown {
    const obj: any = {};
    if (message.url !== "") {
      obj.url = message.url;
    }
    if (message.payload.length !== 0) {
      obj.payload = base64FromBytes(message.payload);
    }
    return obj;
  },

  create(base?: DeepPartial<CosmosMessage>): CosmosMessage {
    return CosmosMessage.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CosmosMessage>): CosmosMessage {
    const message = createBaseCosmosMessage();
    message.url = object.url ?? "";
    message.payload = object.payload ?? new Uint8Array(0);
    return message;
  },
};

function createBaseCosmosGenericCallRequest(): CosmosGenericCallRequest {
  return { details: undefined, messages: [] };
}

export const CosmosGenericCallRequest = {
  encode(message: CosmosGenericCallRequest, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.details !== undefined) {
      CosmosRequestDetails.encode(message.details, writer.uint32(10).fork()).ldelim();
    }
    for (const v of message.messages) {
      CosmosMessage.encode(v!, writer.uint32(18).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CosmosGenericCallRequest {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCosmosGenericCallRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.details = CosmosRequestDetails.decode(reader, reader.uint32());
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.messages.push(CosmosMessage.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CosmosGenericCallRequest {
    return {
      details: isSet(object.details) ? CosmosRequestDetails.fromJSON(object.details) : undefined,
      messages: globalThis.Array.isArray(object?.messages)
        ? object.messages.map((e: any) => CosmosMessage.fromJSON(e))
        : [],
    };
  },

  toJSON(message: CosmosGenericCallRequest): unknown {
    const obj: any = {};
    if (message.details !== undefined) {
      obj.details = CosmosRequestDetails.toJSON(message.details);
    }
    if (message.messages?.length) {
      obj.messages = message.messages.map((e) => CosmosMessage.toJSON(e));
    }
    return obj;
  },

  create(base?: DeepPartial<CosmosGenericCallRequest>): CosmosGenericCallRequest {
    return CosmosGenericCallRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CosmosGenericCallRequest>): CosmosGenericCallRequest {
    const message = createBaseCosmosGenericCallRequest();
    message.details = (object.details !== undefined && object.details !== null)
      ? CosmosRequestDetails.fromPartial(object.details)
      : undefined;
    message.messages = object.messages?.map((e) => CosmosMessage.fromPartial(e)) || [];
    return message;
  },
};

function createBaseCosmosCancelRequest(): CosmosCancelRequest {
  return { details: undefined, addressPrefix: "" };
}

export const CosmosCancelRequest = {
  encode(message: CosmosCancelRequest, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.details !== undefined) {
      CosmosRequestDetails.encode(message.details, writer.uint32(10).fork()).ldelim();
    }
    if (message.addressPrefix !== "") {
      writer.uint32(18).string(message.addressPrefix);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CosmosCancelRequest {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCosmosCancelRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.details = CosmosRequestDetails.decode(reader, reader.uint32());
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.addressPrefix = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CosmosCancelRequest {
    return {
      details: isSet(object.details) ? CosmosRequestDetails.fromJSON(object.details) : undefined,
      addressPrefix: isSet(object.addressPrefix) ? globalThis.String(object.addressPrefix) : "",
    };
  },

  toJSON(message: CosmosCancelRequest): unknown {
    const obj: any = {};
    if (message.details !== undefined) {
      obj.details = CosmosRequestDetails.toJSON(message.details);
    }
    if (message.addressPrefix !== "") {
      obj.addressPrefix = message.addressPrefix;
    }
    return obj;
  },

  create(base?: DeepPartial<CosmosCancelRequest>): CosmosCancelRequest {
    return CosmosCancelRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CosmosCancelRequest>): CosmosCancelRequest {
    const message = createBaseCosmosCancelRequest();
    message.details = (object.details !== undefined && object.details !== null)
      ? CosmosRequestDetails.fromPartial(object.details)
      : undefined;
    message.addressPrefix = object.addressPrefix ?? "";
    return message;
  },
};

function createBasePolygonTransactionsRequest(): PolygonTransactionsRequest {
  return { transactions: [] };
}

export const PolygonTransactionsRequest = {
  encode(message: PolygonTransactionsRequest, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    for (const v of message.transactions) {
      PolygonTransaction.encode(v!, writer.uint32(18).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): PolygonTransactionsRequest {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBasePolygonTransactionsRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 2:
          if (tag !== 18) {
            break;
          }

          message.transactions.push(PolygonTransaction.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): PolygonTransactionsRequest {
    return {
      transactions: globalThis.Array.isArray(object?.transactions)
        ? object.transactions.map((e: any) => PolygonTransaction.fromJSON(e))
        : [],
    };
  },

  toJSON(message: PolygonTransactionsRequest): unknown {
    const obj: any = {};
    if (message.transactions?.length) {
      obj.transactions = message.transactions.map((e) => PolygonTransaction.toJSON(e));
    }
    return obj;
  },

  create(base?: DeepPartial<PolygonTransactionsRequest>): PolygonTransactionsRequest {
    return PolygonTransactionsRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<PolygonTransactionsRequest>): PolygonTransactionsRequest {
    const message = createBasePolygonTransactionsRequest();
    message.transactions = object.transactions?.map((e) => PolygonTransaction.fromPartial(e)) || [];
    return message;
  },
};

function createBasePolygonTransaction(): PolygonTransaction {
  return {
    from: "",
    nonce: 0,
    gasLimit: 0,
    gasPrice: new Uint8Array(0),
    to: "",
    amount: new Uint8Array(0),
    payload: new Uint8Array(0),
    id: "",
    isNonceSet: false,
    chainId: 0,
  };
}

export const PolygonTransaction = {
  encode(message: PolygonTransaction, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.from !== "") {
      writer.uint32(10).string(message.from);
    }
    if (message.nonce !== 0) {
      writer.uint32(16).uint64(message.nonce);
    }
    if (message.gasLimit !== 0) {
      writer.uint32(24).uint64(message.gasLimit);
    }
    if (message.gasPrice.length !== 0) {
      writer.uint32(34).bytes(message.gasPrice);
    }
    if (message.to !== "") {
      writer.uint32(42).string(message.to);
    }
    if (message.amount.length !== 0) {
      writer.uint32(50).bytes(message.amount);
    }
    if (message.payload.length !== 0) {
      writer.uint32(58).bytes(message.payload);
    }
    if (message.id !== "") {
      writer.uint32(66).string(message.id);
    }
    if (message.isNonceSet !== false) {
      writer.uint32(72).bool(message.isNonceSet);
    }
    if (message.chainId !== 0) {
      writer.uint32(80).uint64(message.chainId);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): PolygonTransaction {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBasePolygonTransaction();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.from = reader.string();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.nonce = longToNumber(reader.uint64() as Long);
          continue;
        case 3:
          if (tag !== 24) {
            break;
          }

          message.gasLimit = longToNumber(reader.uint64() as Long);
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.gasPrice = reader.bytes();
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.to = reader.string();
          continue;
        case 6:
          if (tag !== 50) {
            break;
          }

          message.amount = reader.bytes();
          continue;
        case 7:
          if (tag !== 58) {
            break;
          }

          message.payload = reader.bytes();
          continue;
        case 8:
          if (tag !== 66) {
            break;
          }

          message.id = reader.string();
          continue;
        case 9:
          if (tag !== 72) {
            break;
          }

          message.isNonceSet = reader.bool();
          continue;
        case 10:
          if (tag !== 80) {
            break;
          }

          message.chainId = longToNumber(reader.uint64() as Long);
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): PolygonTransaction {
    return {
      from: isSet(object.from) ? globalThis.String(object.from) : "",
      nonce: isSet(object.nonce) ? globalThis.Number(object.nonce) : 0,
      gasLimit: isSet(object.gasLimit) ? globalThis.Number(object.gasLimit) : 0,
      gasPrice: isSet(object.gasPrice) ? bytesFromBase64(object.gasPrice) : new Uint8Array(0),
      to: isSet(object.to) ? globalThis.String(object.to) : "",
      amount: isSet(object.amount) ? bytesFromBase64(object.amount) : new Uint8Array(0),
      payload: isSet(object.payload) ? bytesFromBase64(object.payload) : new Uint8Array(0),
      id: isSet(object.id) ? globalThis.String(object.id) : "",
      isNonceSet: isSet(object.isNonceSet) ? globalThis.Boolean(object.isNonceSet) : false,
      chainId: isSet(object.chainId) ? globalThis.Number(object.chainId) : 0,
    };
  },

  toJSON(message: PolygonTransaction): unknown {
    const obj: any = {};
    if (message.from !== "") {
      obj.from = message.from;
    }
    if (message.nonce !== 0) {
      obj.nonce = Math.round(message.nonce);
    }
    if (message.gasLimit !== 0) {
      obj.gasLimit = Math.round(message.gasLimit);
    }
    if (message.gasPrice.length !== 0) {
      obj.gasPrice = base64FromBytes(message.gasPrice);
    }
    if (message.to !== "") {
      obj.to = message.to;
    }
    if (message.amount.length !== 0) {
      obj.amount = base64FromBytes(message.amount);
    }
    if (message.payload.length !== 0) {
      obj.payload = base64FromBytes(message.payload);
    }
    if (message.id !== "") {
      obj.id = message.id;
    }
    if (message.isNonceSet !== false) {
      obj.isNonceSet = message.isNonceSet;
    }
    if (message.chainId !== 0) {
      obj.chainId = Math.round(message.chainId);
    }
    return obj;
  },

  create(base?: DeepPartial<PolygonTransaction>): PolygonTransaction {
    return PolygonTransaction.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<PolygonTransaction>): PolygonTransaction {
    const message = createBasePolygonTransaction();
    message.from = object.from ?? "";
    message.nonce = object.nonce ?? 0;
    message.gasLimit = object.gasLimit ?? 0;
    message.gasPrice = object.gasPrice ?? new Uint8Array(0);
    message.to = object.to ?? "";
    message.amount = object.amount ?? new Uint8Array(0);
    message.payload = object.payload ?? new Uint8Array(0);
    message.id = object.id ?? "";
    message.isNonceSet = object.isNonceSet ?? false;
    message.chainId = object.chainId ?? 0;
    return message;
  },
};

function createBasePolygonCreateContractRequest(): PolygonCreateContractRequest {
  return {
    from: "",
    nonce: 0,
    gasLimit: 0,
    gasPrice: new Uint8Array(0),
    amount: new Uint8Array(0),
    payload: new Uint8Array(0),
    id: "",
    isNonceSet: false,
    chainId: 0,
  };
}

export const PolygonCreateContractRequest = {
  encode(message: PolygonCreateContractRequest, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.from !== "") {
      writer.uint32(10).string(message.from);
    }
    if (message.nonce !== 0) {
      writer.uint32(16).uint64(message.nonce);
    }
    if (message.gasLimit !== 0) {
      writer.uint32(24).uint64(message.gasLimit);
    }
    if (message.gasPrice.length !== 0) {
      writer.uint32(34).bytes(message.gasPrice);
    }
    if (message.amount.length !== 0) {
      writer.uint32(42).bytes(message.amount);
    }
    if (message.payload.length !== 0) {
      writer.uint32(50).bytes(message.payload);
    }
    if (message.id !== "") {
      writer.uint32(58).string(message.id);
    }
    if (message.isNonceSet !== false) {
      writer.uint32(64).bool(message.isNonceSet);
    }
    if (message.chainId !== 0) {
      writer.uint32(72).uint64(message.chainId);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): PolygonCreateContractRequest {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBasePolygonCreateContractRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.from = reader.string();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.nonce = longToNumber(reader.uint64() as Long);
          continue;
        case 3:
          if (tag !== 24) {
            break;
          }

          message.gasLimit = longToNumber(reader.uint64() as Long);
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.gasPrice = reader.bytes();
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.amount = reader.bytes();
          continue;
        case 6:
          if (tag !== 50) {
            break;
          }

          message.payload = reader.bytes();
          continue;
        case 7:
          if (tag !== 58) {
            break;
          }

          message.id = reader.string();
          continue;
        case 8:
          if (tag !== 64) {
            break;
          }

          message.isNonceSet = reader.bool();
          continue;
        case 9:
          if (tag !== 72) {
            break;
          }

          message.chainId = longToNumber(reader.uint64() as Long);
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): PolygonCreateContractRequest {
    return {
      from: isSet(object.from) ? globalThis.String(object.from) : "",
      nonce: isSet(object.nonce) ? globalThis.Number(object.nonce) : 0,
      gasLimit: isSet(object.gasLimit) ? globalThis.Number(object.gasLimit) : 0,
      gasPrice: isSet(object.gasPrice) ? bytesFromBase64(object.gasPrice) : new Uint8Array(0),
      amount: isSet(object.amount) ? bytesFromBase64(object.amount) : new Uint8Array(0),
      payload: isSet(object.payload) ? bytesFromBase64(object.payload) : new Uint8Array(0),
      id: isSet(object.id) ? globalThis.String(object.id) : "",
      isNonceSet: isSet(object.isNonceSet) ? globalThis.Boolean(object.isNonceSet) : false,
      chainId: isSet(object.chainId) ? globalThis.Number(object.chainId) : 0,
    };
  },

  toJSON(message: PolygonCreateContractRequest): unknown {
    const obj: any = {};
    if (message.from !== "") {
      obj.from = message.from;
    }
    if (message.nonce !== 0) {
      obj.nonce = Math.round(message.nonce);
    }
    if (message.gasLimit !== 0) {
      obj.gasLimit = Math.round(message.gasLimit);
    }
    if (message.gasPrice.length !== 0) {
      obj.gasPrice = base64FromBytes(message.gasPrice);
    }
    if (message.amount.length !== 0) {
      obj.amount = base64FromBytes(message.amount);
    }
    if (message.payload.length !== 0) {
      obj.payload = base64FromBytes(message.payload);
    }
    if (message.id !== "") {
      obj.id = message.id;
    }
    if (message.isNonceSet !== false) {
      obj.isNonceSet = message.isNonceSet;
    }
    if (message.chainId !== 0) {
      obj.chainId = Math.round(message.chainId);
    }
    return obj;
  },

  create(base?: DeepPartial<PolygonCreateContractRequest>): PolygonCreateContractRequest {
    return PolygonCreateContractRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<PolygonCreateContractRequest>): PolygonCreateContractRequest {
    const message = createBasePolygonCreateContractRequest();
    message.from = object.from ?? "";
    message.nonce = object.nonce ?? 0;
    message.gasLimit = object.gasLimit ?? 0;
    message.gasPrice = object.gasPrice ?? new Uint8Array(0);
    message.amount = object.amount ?? new Uint8Array(0);
    message.payload = object.payload ?? new Uint8Array(0);
    message.id = object.id ?? "";
    message.isNonceSet = object.isNonceSet ?? false;
    message.chainId = object.chainId ?? 0;
    return message;
  },
};

function createBasePolygonAddressRequest(): PolygonAddressRequest {
  return { path: "" };
}

export const PolygonAddressRequest = {
  encode(message: PolygonAddressRequest, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.path !== "") {
      writer.uint32(10).string(message.path);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): PolygonAddressRequest {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBasePolygonAddressRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.path = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): PolygonAddressRequest {
    return { path: isSet(object.path) ? globalThis.String(object.path) : "" };
  },

  toJSON(message: PolygonAddressRequest): unknown {
    const obj: any = {};
    if (message.path !== "") {
      obj.path = message.path;
    }
    return obj;
  },

  create(base?: DeepPartial<PolygonAddressRequest>): PolygonAddressRequest {
    return PolygonAddressRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<PolygonAddressRequest>): PolygonAddressRequest {
    const message = createBasePolygonAddressRequest();
    message.path = object.path ?? "";
    return message;
  },
};

function createBasePolygonProofOfReserveRequest(): PolygonProofOfReserveRequest {
  return { path: "", challenge: "" };
}

export const PolygonProofOfReserveRequest = {
  encode(message: PolygonProofOfReserveRequest, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.path !== "") {
      writer.uint32(10).string(message.path);
    }
    if (message.challenge !== "") {
      writer.uint32(18).string(message.challenge);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): PolygonProofOfReserveRequest {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBasePolygonProofOfReserveRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.path = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.challenge = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): PolygonProofOfReserveRequest {
    return {
      path: isSet(object.path) ? globalThis.String(object.path) : "",
      challenge: isSet(object.challenge) ? globalThis.String(object.challenge) : "",
    };
  },

  toJSON(message: PolygonProofOfReserveRequest): unknown {
    const obj: any = {};
    if (message.path !== "") {
      obj.path = message.path;
    }
    if (message.challenge !== "") {
      obj.challenge = message.challenge;
    }
    return obj;
  },

  create(base?: DeepPartial<PolygonProofOfReserveRequest>): PolygonProofOfReserveRequest {
    return PolygonProofOfReserveRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<PolygonProofOfReserveRequest>): PolygonProofOfReserveRequest {
    const message = createBasePolygonProofOfReserveRequest();
    message.path = object.path ?? "";
    message.challenge = object.challenge ?? "";
    return message;
  },
};

function createBasePolygonTransactionsResponse(): PolygonTransactionsResponse {
  return { transactions: [] };
}

export const PolygonTransactionsResponse = {
  encode(message: PolygonTransactionsResponse, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    for (const v of message.transactions) {
      PolygonTransactionsResponse_PolygonTransactionResponse.encode(v!, writer.uint32(10).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): PolygonTransactionsResponse {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBasePolygonTransactionsResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.transactions.push(
            PolygonTransactionsResponse_PolygonTransactionResponse.decode(reader, reader.uint32()),
          );
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): PolygonTransactionsResponse {
    return {
      transactions: globalThis.Array.isArray(object?.transactions)
        ? object.transactions.map((e: any) => PolygonTransactionsResponse_PolygonTransactionResponse.fromJSON(e))
        : [],
    };
  },

  toJSON(message: PolygonTransactionsResponse): unknown {
    const obj: any = {};
    if (message.transactions?.length) {
      obj.transactions = message.transactions.map((e) =>
        PolygonTransactionsResponse_PolygonTransactionResponse.toJSON(e)
      );
    }
    return obj;
  },

  create(base?: DeepPartial<PolygonTransactionsResponse>): PolygonTransactionsResponse {
    return PolygonTransactionsResponse.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<PolygonTransactionsResponse>): PolygonTransactionsResponse {
    const message = createBasePolygonTransactionsResponse();
    message.transactions =
      object.transactions?.map((e) => PolygonTransactionsResponse_PolygonTransactionResponse.fromPartial(e)) || [];
    return message;
  },
};

function createBasePolygonTransactionsResponse_PolygonTransactionResponse(): PolygonTransactionsResponse_PolygonTransactionResponse {
  return { id: "", transaction: "", publicKey: new Uint8Array(0) };
}

export const PolygonTransactionsResponse_PolygonTransactionResponse = {
  encode(
    message: PolygonTransactionsResponse_PolygonTransactionResponse,
    writer: _m0.Writer = _m0.Writer.create(),
  ): _m0.Writer {
    if (message.id !== "") {
      writer.uint32(10).string(message.id);
    }
    if (message.transaction !== "") {
      writer.uint32(18).string(message.transaction);
    }
    if (message.publicKey.length !== 0) {
      writer.uint32(26).bytes(message.publicKey);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): PolygonTransactionsResponse_PolygonTransactionResponse {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBasePolygonTransactionsResponse_PolygonTransactionResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.id = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.transaction = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.publicKey = reader.bytes();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): PolygonTransactionsResponse_PolygonTransactionResponse {
    return {
      id: isSet(object.id) ? globalThis.String(object.id) : "",
      transaction: isSet(object.transaction) ? globalThis.String(object.transaction) : "",
      publicKey: isSet(object.publicKey) ? bytesFromBase64(object.publicKey) : new Uint8Array(0),
    };
  },

  toJSON(message: PolygonTransactionsResponse_PolygonTransactionResponse): unknown {
    const obj: any = {};
    if (message.id !== "") {
      obj.id = message.id;
    }
    if (message.transaction !== "") {
      obj.transaction = message.transaction;
    }
    if (message.publicKey.length !== 0) {
      obj.publicKey = base64FromBytes(message.publicKey);
    }
    return obj;
  },

  create(
    base?: DeepPartial<PolygonTransactionsResponse_PolygonTransactionResponse>,
  ): PolygonTransactionsResponse_PolygonTransactionResponse {
    return PolygonTransactionsResponse_PolygonTransactionResponse.fromPartial(base ?? {});
  },
  fromPartial(
    object: DeepPartial<PolygonTransactionsResponse_PolygonTransactionResponse>,
  ): PolygonTransactionsResponse_PolygonTransactionResponse {
    const message = createBasePolygonTransactionsResponse_PolygonTransactionResponse();
    message.id = object.id ?? "";
    message.transaction = object.transaction ?? "";
    message.publicKey = object.publicKey ?? new Uint8Array(0);
    return message;
  },
};

function createBasePolygonSignTextRequest(): PolygonSignTextRequest {
  return { id: "", from: "", message: "" };
}

export const PolygonSignTextRequest = {
  encode(message: PolygonSignTextRequest, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.id !== "") {
      writer.uint32(10).string(message.id);
    }
    if (message.from !== "") {
      writer.uint32(18).string(message.from);
    }
    if (message.message !== "") {
      writer.uint32(26).string(message.message);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): PolygonSignTextRequest {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBasePolygonSignTextRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.id = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.from = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.message = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): PolygonSignTextRequest {
    return {
      id: isSet(object.id) ? globalThis.String(object.id) : "",
      from: isSet(object.from) ? globalThis.String(object.from) : "",
      message: isSet(object.message) ? globalThis.String(object.message) : "",
    };
  },

  toJSON(message: PolygonSignTextRequest): unknown {
    const obj: any = {};
    if (message.id !== "") {
      obj.id = message.id;
    }
    if (message.from !== "") {
      obj.from = message.from;
    }
    if (message.message !== "") {
      obj.message = message.message;
    }
    return obj;
  },

  create(base?: DeepPartial<PolygonSignTextRequest>): PolygonSignTextRequest {
    return PolygonSignTextRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<PolygonSignTextRequest>): PolygonSignTextRequest {
    const message = createBasePolygonSignTextRequest();
    message.id = object.id ?? "";
    message.from = object.from ?? "";
    message.message = object.message ?? "";
    return message;
  },
};

function createBasePolygonSignTextResponse(): PolygonSignTextResponse {
  return { id: "", signature: new Uint8Array(0), publicKey: new Uint8Array(0) };
}

export const PolygonSignTextResponse = {
  encode(message: PolygonSignTextResponse, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.id !== "") {
      writer.uint32(10).string(message.id);
    }
    if (message.signature.length !== 0) {
      writer.uint32(18).bytes(message.signature);
    }
    if (message.publicKey.length !== 0) {
      writer.uint32(26).bytes(message.publicKey);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): PolygonSignTextResponse {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBasePolygonSignTextResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.id = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.signature = reader.bytes();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.publicKey = reader.bytes();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): PolygonSignTextResponse {
    return {
      id: isSet(object.id) ? globalThis.String(object.id) : "",
      signature: isSet(object.signature) ? bytesFromBase64(object.signature) : new Uint8Array(0),
      publicKey: isSet(object.publicKey) ? bytesFromBase64(object.publicKey) : new Uint8Array(0),
    };
  },

  toJSON(message: PolygonSignTextResponse): unknown {
    const obj: any = {};
    if (message.id !== "") {
      obj.id = message.id;
    }
    if (message.signature.length !== 0) {
      obj.signature = base64FromBytes(message.signature);
    }
    if (message.publicKey.length !== 0) {
      obj.publicKey = base64FromBytes(message.publicKey);
    }
    return obj;
  },

  create(base?: DeepPartial<PolygonSignTextResponse>): PolygonSignTextResponse {
    return PolygonSignTextResponse.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<PolygonSignTextResponse>): PolygonSignTextResponse {
    const message = createBasePolygonSignTextResponse();
    message.id = object.id ?? "";
    message.signature = object.signature ?? new Uint8Array(0);
    message.publicKey = object.publicKey ?? new Uint8Array(0);
    return message;
  },
};

function createBasePolygonWrappedTransactionsRequest(): PolygonWrappedTransactionsRequest {
  return { transactions: [] };
}

export const PolygonWrappedTransactionsRequest = {
  encode(message: PolygonWrappedTransactionsRequest, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    for (const v of message.transactions) {
      PolygonWrappedTransaction.encode(v!, writer.uint32(10).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): PolygonWrappedTransactionsRequest {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBasePolygonWrappedTransactionsRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.transactions.push(PolygonWrappedTransaction.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): PolygonWrappedTransactionsRequest {
    return {
      transactions: globalThis.Array.isArray(object?.transactions)
        ? object.transactions.map((e: any) => PolygonWrappedTransaction.fromJSON(e))
        : [],
    };
  },

  toJSON(message: PolygonWrappedTransactionsRequest): unknown {
    const obj: any = {};
    if (message.transactions?.length) {
      obj.transactions = message.transactions.map((e) => PolygonWrappedTransaction.toJSON(e));
    }
    return obj;
  },

  create(base?: DeepPartial<PolygonWrappedTransactionsRequest>): PolygonWrappedTransactionsRequest {
    return PolygonWrappedTransactionsRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<PolygonWrappedTransactionsRequest>): PolygonWrappedTransactionsRequest {
    const message = createBasePolygonWrappedTransactionsRequest();
    message.transactions = object.transactions?.map((e) => PolygonWrappedTransaction.fromPartial(e)) || [];
    return message;
  },
};

function createBasePolygonWrappedTransaction(): PolygonWrappedTransaction {
  return {
    domainSeparator: new Uint8Array(0),
    requestTypeHash: new Uint8Array(0),
    from: "",
    to: "",
    nonce: 0,
    gasLimit: 0,
    payload: new Uint8Array(0),
    id: "",
    isNonceSet: false,
    forwarder: "",
  };
}

export const PolygonWrappedTransaction = {
  encode(message: PolygonWrappedTransaction, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.domainSeparator.length !== 0) {
      writer.uint32(10).bytes(message.domainSeparator);
    }
    if (message.requestTypeHash.length !== 0) {
      writer.uint32(18).bytes(message.requestTypeHash);
    }
    if (message.from !== "") {
      writer.uint32(26).string(message.from);
    }
    if (message.to !== "") {
      writer.uint32(34).string(message.to);
    }
    if (message.nonce !== 0) {
      writer.uint32(40).uint64(message.nonce);
    }
    if (message.gasLimit !== 0) {
      writer.uint32(48).uint64(message.gasLimit);
    }
    if (message.payload.length !== 0) {
      writer.uint32(58).bytes(message.payload);
    }
    if (message.id !== "") {
      writer.uint32(66).string(message.id);
    }
    if (message.isNonceSet !== false) {
      writer.uint32(72).bool(message.isNonceSet);
    }
    if (message.forwarder !== "") {
      writer.uint32(82).string(message.forwarder);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): PolygonWrappedTransaction {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBasePolygonWrappedTransaction();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.domainSeparator = reader.bytes();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.requestTypeHash = reader.bytes();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.from = reader.string();
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.to = reader.string();
          continue;
        case 5:
          if (tag !== 40) {
            break;
          }

          message.nonce = longToNumber(reader.uint64() as Long);
          continue;
        case 6:
          if (tag !== 48) {
            break;
          }

          message.gasLimit = longToNumber(reader.uint64() as Long);
          continue;
        case 7:
          if (tag !== 58) {
            break;
          }

          message.payload = reader.bytes();
          continue;
        case 8:
          if (tag !== 66) {
            break;
          }

          message.id = reader.string();
          continue;
        case 9:
          if (tag !== 72) {
            break;
          }

          message.isNonceSet = reader.bool();
          continue;
        case 10:
          if (tag !== 82) {
            break;
          }

          message.forwarder = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): PolygonWrappedTransaction {
    return {
      domainSeparator: isSet(object.domainSeparator) ? bytesFromBase64(object.domainSeparator) : new Uint8Array(0),
      requestTypeHash: isSet(object.requestTypeHash) ? bytesFromBase64(object.requestTypeHash) : new Uint8Array(0),
      from: isSet(object.from) ? globalThis.String(object.from) : "",
      to: isSet(object.to) ? globalThis.String(object.to) : "",
      nonce: isSet(object.nonce) ? globalThis.Number(object.nonce) : 0,
      gasLimit: isSet(object.gasLimit) ? globalThis.Number(object.gasLimit) : 0,
      payload: isSet(object.payload) ? bytesFromBase64(object.payload) : new Uint8Array(0),
      id: isSet(object.id) ? globalThis.String(object.id) : "",
      isNonceSet: isSet(object.isNonceSet) ? globalThis.Boolean(object.isNonceSet) : false,
      forwarder: isSet(object.forwarder) ? globalThis.String(object.forwarder) : "",
    };
  },

  toJSON(message: PolygonWrappedTransaction): unknown {
    const obj: any = {};
    if (message.domainSeparator.length !== 0) {
      obj.domainSeparator = base64FromBytes(message.domainSeparator);
    }
    if (message.requestTypeHash.length !== 0) {
      obj.requestTypeHash = base64FromBytes(message.requestTypeHash);
    }
    if (message.from !== "") {
      obj.from = message.from;
    }
    if (message.to !== "") {
      obj.to = message.to;
    }
    if (message.nonce !== 0) {
      obj.nonce = Math.round(message.nonce);
    }
    if (message.gasLimit !== 0) {
      obj.gasLimit = Math.round(message.gasLimit);
    }
    if (message.payload.length !== 0) {
      obj.payload = base64FromBytes(message.payload);
    }
    if (message.id !== "") {
      obj.id = message.id;
    }
    if (message.isNonceSet !== false) {
      obj.isNonceSet = message.isNonceSet;
    }
    if (message.forwarder !== "") {
      obj.forwarder = message.forwarder;
    }
    return obj;
  },

  create(base?: DeepPartial<PolygonWrappedTransaction>): PolygonWrappedTransaction {
    return PolygonWrappedTransaction.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<PolygonWrappedTransaction>): PolygonWrappedTransaction {
    const message = createBasePolygonWrappedTransaction();
    message.domainSeparator = object.domainSeparator ?? new Uint8Array(0);
    message.requestTypeHash = object.requestTypeHash ?? new Uint8Array(0);
    message.from = object.from ?? "";
    message.to = object.to ?? "";
    message.nonce = object.nonce ?? 0;
    message.gasLimit = object.gasLimit ?? 0;
    message.payload = object.payload ?? new Uint8Array(0);
    message.id = object.id ?? "";
    message.isNonceSet = object.isNonceSet ?? false;
    message.forwarder = object.forwarder ?? "";
    return message;
  },
};

function createBasePolygonWrappedCreateContractRequest(): PolygonWrappedCreateContractRequest {
  return {
    domainSeparator: new Uint8Array(0),
    requestTypeHash: new Uint8Array(0),
    from: "",
    nonce: 0,
    payload: new Uint8Array(0),
    id: "",
    isNonceSet: false,
    creator: "",
  };
}

export const PolygonWrappedCreateContractRequest = {
  encode(message: PolygonWrappedCreateContractRequest, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.domainSeparator.length !== 0) {
      writer.uint32(10).bytes(message.domainSeparator);
    }
    if (message.requestTypeHash.length !== 0) {
      writer.uint32(18).bytes(message.requestTypeHash);
    }
    if (message.from !== "") {
      writer.uint32(26).string(message.from);
    }
    if (message.nonce !== 0) {
      writer.uint32(32).uint64(message.nonce);
    }
    if (message.payload.length !== 0) {
      writer.uint32(42).bytes(message.payload);
    }
    if (message.id !== "") {
      writer.uint32(50).string(message.id);
    }
    if (message.isNonceSet !== false) {
      writer.uint32(56).bool(message.isNonceSet);
    }
    if (message.creator !== "") {
      writer.uint32(66).string(message.creator);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): PolygonWrappedCreateContractRequest {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBasePolygonWrappedCreateContractRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.domainSeparator = reader.bytes();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.requestTypeHash = reader.bytes();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.from = reader.string();
          continue;
        case 4:
          if (tag !== 32) {
            break;
          }

          message.nonce = longToNumber(reader.uint64() as Long);
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.payload = reader.bytes();
          continue;
        case 6:
          if (tag !== 50) {
            break;
          }

          message.id = reader.string();
          continue;
        case 7:
          if (tag !== 56) {
            break;
          }

          message.isNonceSet = reader.bool();
          continue;
        case 8:
          if (tag !== 66) {
            break;
          }

          message.creator = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): PolygonWrappedCreateContractRequest {
    return {
      domainSeparator: isSet(object.domainSeparator) ? bytesFromBase64(object.domainSeparator) : new Uint8Array(0),
      requestTypeHash: isSet(object.requestTypeHash) ? bytesFromBase64(object.requestTypeHash) : new Uint8Array(0),
      from: isSet(object.from) ? globalThis.String(object.from) : "",
      nonce: isSet(object.nonce) ? globalThis.Number(object.nonce) : 0,
      payload: isSet(object.payload) ? bytesFromBase64(object.payload) : new Uint8Array(0),
      id: isSet(object.id) ? globalThis.String(object.id) : "",
      isNonceSet: isSet(object.isNonceSet) ? globalThis.Boolean(object.isNonceSet) : false,
      creator: isSet(object.creator) ? globalThis.String(object.creator) : "",
    };
  },

  toJSON(message: PolygonWrappedCreateContractRequest): unknown {
    const obj: any = {};
    if (message.domainSeparator.length !== 0) {
      obj.domainSeparator = base64FromBytes(message.domainSeparator);
    }
    if (message.requestTypeHash.length !== 0) {
      obj.requestTypeHash = base64FromBytes(message.requestTypeHash);
    }
    if (message.from !== "") {
      obj.from = message.from;
    }
    if (message.nonce !== 0) {
      obj.nonce = Math.round(message.nonce);
    }
    if (message.payload.length !== 0) {
      obj.payload = base64FromBytes(message.payload);
    }
    if (message.id !== "") {
      obj.id = message.id;
    }
    if (message.isNonceSet !== false) {
      obj.isNonceSet = message.isNonceSet;
    }
    if (message.creator !== "") {
      obj.creator = message.creator;
    }
    return obj;
  },

  create(base?: DeepPartial<PolygonWrappedCreateContractRequest>): PolygonWrappedCreateContractRequest {
    return PolygonWrappedCreateContractRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<PolygonWrappedCreateContractRequest>): PolygonWrappedCreateContractRequest {
    const message = createBasePolygonWrappedCreateContractRequest();
    message.domainSeparator = object.domainSeparator ?? new Uint8Array(0);
    message.requestTypeHash = object.requestTypeHash ?? new Uint8Array(0);
    message.from = object.from ?? "";
    message.nonce = object.nonce ?? 0;
    message.payload = object.payload ?? new Uint8Array(0);
    message.id = object.id ?? "";
    message.isNonceSet = object.isNonceSet ?? false;
    message.creator = object.creator ?? "";
    return message;
  },
};

function createBasePolygonWrappedTransactionsResponse(): PolygonWrappedTransactionsResponse {
  return { transactions: [] };
}

export const PolygonWrappedTransactionsResponse = {
  encode(message: PolygonWrappedTransactionsResponse, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    for (const v of message.transactions) {
      PolygonWrappedTransactionsResponse_PolygonWrappedTransactionResponse.encode(v!, writer.uint32(10).fork())
        .ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): PolygonWrappedTransactionsResponse {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBasePolygonWrappedTransactionsResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.transactions.push(
            PolygonWrappedTransactionsResponse_PolygonWrappedTransactionResponse.decode(reader, reader.uint32()),
          );
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): PolygonWrappedTransactionsResponse {
    return {
      transactions: globalThis.Array.isArray(object?.transactions)
        ? object.transactions.map((e: any) =>
          PolygonWrappedTransactionsResponse_PolygonWrappedTransactionResponse.fromJSON(e)
        )
        : [],
    };
  },

  toJSON(message: PolygonWrappedTransactionsResponse): unknown {
    const obj: any = {};
    if (message.transactions?.length) {
      obj.transactions = message.transactions.map((e) =>
        PolygonWrappedTransactionsResponse_PolygonWrappedTransactionResponse.toJSON(e)
      );
    }
    return obj;
  },

  create(base?: DeepPartial<PolygonWrappedTransactionsResponse>): PolygonWrappedTransactionsResponse {
    return PolygonWrappedTransactionsResponse.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<PolygonWrappedTransactionsResponse>): PolygonWrappedTransactionsResponse {
    const message = createBasePolygonWrappedTransactionsResponse();
    message.transactions =
      object.transactions?.map((e) =>
        PolygonWrappedTransactionsResponse_PolygonWrappedTransactionResponse.fromPartial(e)
      ) || [];
    return message;
  },
};

function createBasePolygonWrappedTransactionsResponse_PolygonWrappedTransactionResponse(): PolygonWrappedTransactionsResponse_PolygonWrappedTransactionResponse {
  return { id: "", transaction: "", publicKey: new Uint8Array(0) };
}

export const PolygonWrappedTransactionsResponse_PolygonWrappedTransactionResponse = {
  encode(
    message: PolygonWrappedTransactionsResponse_PolygonWrappedTransactionResponse,
    writer: _m0.Writer = _m0.Writer.create(),
  ): _m0.Writer {
    if (message.id !== "") {
      writer.uint32(10).string(message.id);
    }
    if (message.transaction !== "") {
      writer.uint32(18).string(message.transaction);
    }
    if (message.publicKey.length !== 0) {
      writer.uint32(26).bytes(message.publicKey);
    }
    return writer;
  },

  decode(
    input: _m0.Reader | Uint8Array,
    length?: number,
  ): PolygonWrappedTransactionsResponse_PolygonWrappedTransactionResponse {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBasePolygonWrappedTransactionsResponse_PolygonWrappedTransactionResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.id = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.transaction = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.publicKey = reader.bytes();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): PolygonWrappedTransactionsResponse_PolygonWrappedTransactionResponse {
    return {
      id: isSet(object.id) ? globalThis.String(object.id) : "",
      transaction: isSet(object.transaction) ? globalThis.String(object.transaction) : "",
      publicKey: isSet(object.publicKey) ? bytesFromBase64(object.publicKey) : new Uint8Array(0),
    };
  },

  toJSON(message: PolygonWrappedTransactionsResponse_PolygonWrappedTransactionResponse): unknown {
    const obj: any = {};
    if (message.id !== "") {
      obj.id = message.id;
    }
    if (message.transaction !== "") {
      obj.transaction = message.transaction;
    }
    if (message.publicKey.length !== 0) {
      obj.publicKey = base64FromBytes(message.publicKey);
    }
    return obj;
  },

  create(
    base?: DeepPartial<PolygonWrappedTransactionsResponse_PolygonWrappedTransactionResponse>,
  ): PolygonWrappedTransactionsResponse_PolygonWrappedTransactionResponse {
    return PolygonWrappedTransactionsResponse_PolygonWrappedTransactionResponse.fromPartial(base ?? {});
  },
  fromPartial(
    object: DeepPartial<PolygonWrappedTransactionsResponse_PolygonWrappedTransactionResponse>,
  ): PolygonWrappedTransactionsResponse_PolygonWrappedTransactionResponse {
    const message = createBasePolygonWrappedTransactionsResponse_PolygonWrappedTransactionResponse();
    message.id = object.id ?? "";
    message.transaction = object.transaction ?? "";
    message.publicKey = object.publicKey ?? new Uint8Array(0);
    return message;
  },
};

function createBasePolygonWrappedCreateContractResponse(): PolygonWrappedCreateContractResponse {
  return { id: "", transaction: "", publicKey: new Uint8Array(0) };
}

export const PolygonWrappedCreateContractResponse = {
  encode(message: PolygonWrappedCreateContractResponse, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.id !== "") {
      writer.uint32(10).string(message.id);
    }
    if (message.transaction !== "") {
      writer.uint32(18).string(message.transaction);
    }
    if (message.publicKey.length !== 0) {
      writer.uint32(26).bytes(message.publicKey);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): PolygonWrappedCreateContractResponse {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBasePolygonWrappedCreateContractResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.id = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.transaction = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.publicKey = reader.bytes();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): PolygonWrappedCreateContractResponse {
    return {
      id: isSet(object.id) ? globalThis.String(object.id) : "",
      transaction: isSet(object.transaction) ? globalThis.String(object.transaction) : "",
      publicKey: isSet(object.publicKey) ? bytesFromBase64(object.publicKey) : new Uint8Array(0),
    };
  },

  toJSON(message: PolygonWrappedCreateContractResponse): unknown {
    const obj: any = {};
    if (message.id !== "") {
      obj.id = message.id;
    }
    if (message.transaction !== "") {
      obj.transaction = message.transaction;
    }
    if (message.publicKey.length !== 0) {
      obj.publicKey = base64FromBytes(message.publicKey);
    }
    return obj;
  },

  create(base?: DeepPartial<PolygonWrappedCreateContractResponse>): PolygonWrappedCreateContractResponse {
    return PolygonWrappedCreateContractResponse.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<PolygonWrappedCreateContractResponse>): PolygonWrappedCreateContractResponse {
    const message = createBasePolygonWrappedCreateContractResponse();
    message.id = object.id ?? "";
    message.transaction = object.transaction ?? "";
    message.publicKey = object.publicKey ?? new Uint8Array(0);
    return message;
  },
};

function createBaseAvaxCChainTransactionsRequest(): AvaxCChainTransactionsRequest {
  return { transactions: [] };
}

export const AvaxCChainTransactionsRequest = {
  encode(message: AvaxCChainTransactionsRequest, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    for (const v of message.transactions) {
      AvaxCChainTransaction.encode(v!, writer.uint32(18).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): AvaxCChainTransactionsRequest {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseAvaxCChainTransactionsRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 2:
          if (tag !== 18) {
            break;
          }

          message.transactions.push(AvaxCChainTransaction.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): AvaxCChainTransactionsRequest {
    return {
      transactions: globalThis.Array.isArray(object?.transactions)
        ? object.transactions.map((e: any) => AvaxCChainTransaction.fromJSON(e))
        : [],
    };
  },

  toJSON(message: AvaxCChainTransactionsRequest): unknown {
    const obj: any = {};
    if (message.transactions?.length) {
      obj.transactions = message.transactions.map((e) => AvaxCChainTransaction.toJSON(e));
    }
    return obj;
  },

  create(base?: DeepPartial<AvaxCChainTransactionsRequest>): AvaxCChainTransactionsRequest {
    return AvaxCChainTransactionsRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<AvaxCChainTransactionsRequest>): AvaxCChainTransactionsRequest {
    const message = createBaseAvaxCChainTransactionsRequest();
    message.transactions = object.transactions?.map((e) => AvaxCChainTransaction.fromPartial(e)) || [];
    return message;
  },
};

function createBaseAvaxCChainTransaction(): AvaxCChainTransaction {
  return {
    from: "",
    nonce: 0,
    gasLimit: 0,
    gasPrice: new Uint8Array(0),
    to: "",
    amount: new Uint8Array(0),
    payload: new Uint8Array(0),
    id: "",
    isNonceSet: false,
    chainId: 0,
  };
}

export const AvaxCChainTransaction = {
  encode(message: AvaxCChainTransaction, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.from !== "") {
      writer.uint32(10).string(message.from);
    }
    if (message.nonce !== 0) {
      writer.uint32(16).uint64(message.nonce);
    }
    if (message.gasLimit !== 0) {
      writer.uint32(24).uint64(message.gasLimit);
    }
    if (message.gasPrice.length !== 0) {
      writer.uint32(34).bytes(message.gasPrice);
    }
    if (message.to !== "") {
      writer.uint32(42).string(message.to);
    }
    if (message.amount.length !== 0) {
      writer.uint32(50).bytes(message.amount);
    }
    if (message.payload.length !== 0) {
      writer.uint32(58).bytes(message.payload);
    }
    if (message.id !== "") {
      writer.uint32(66).string(message.id);
    }
    if (message.isNonceSet !== false) {
      writer.uint32(72).bool(message.isNonceSet);
    }
    if (message.chainId !== 0) {
      writer.uint32(80).uint64(message.chainId);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): AvaxCChainTransaction {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseAvaxCChainTransaction();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.from = reader.string();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.nonce = longToNumber(reader.uint64() as Long);
          continue;
        case 3:
          if (tag !== 24) {
            break;
          }

          message.gasLimit = longToNumber(reader.uint64() as Long);
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.gasPrice = reader.bytes();
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.to = reader.string();
          continue;
        case 6:
          if (tag !== 50) {
            break;
          }

          message.amount = reader.bytes();
          continue;
        case 7:
          if (tag !== 58) {
            break;
          }

          message.payload = reader.bytes();
          continue;
        case 8:
          if (tag !== 66) {
            break;
          }

          message.id = reader.string();
          continue;
        case 9:
          if (tag !== 72) {
            break;
          }

          message.isNonceSet = reader.bool();
          continue;
        case 10:
          if (tag !== 80) {
            break;
          }

          message.chainId = longToNumber(reader.uint64() as Long);
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): AvaxCChainTransaction {
    return {
      from: isSet(object.from) ? globalThis.String(object.from) : "",
      nonce: isSet(object.nonce) ? globalThis.Number(object.nonce) : 0,
      gasLimit: isSet(object.gasLimit) ? globalThis.Number(object.gasLimit) : 0,
      gasPrice: isSet(object.gasPrice) ? bytesFromBase64(object.gasPrice) : new Uint8Array(0),
      to: isSet(object.to) ? globalThis.String(object.to) : "",
      amount: isSet(object.amount) ? bytesFromBase64(object.amount) : new Uint8Array(0),
      payload: isSet(object.payload) ? bytesFromBase64(object.payload) : new Uint8Array(0),
      id: isSet(object.id) ? globalThis.String(object.id) : "",
      isNonceSet: isSet(object.isNonceSet) ? globalThis.Boolean(object.isNonceSet) : false,
      chainId: isSet(object.chainId) ? globalThis.Number(object.chainId) : 0,
    };
  },

  toJSON(message: AvaxCChainTransaction): unknown {
    const obj: any = {};
    if (message.from !== "") {
      obj.from = message.from;
    }
    if (message.nonce !== 0) {
      obj.nonce = Math.round(message.nonce);
    }
    if (message.gasLimit !== 0) {
      obj.gasLimit = Math.round(message.gasLimit);
    }
    if (message.gasPrice.length !== 0) {
      obj.gasPrice = base64FromBytes(message.gasPrice);
    }
    if (message.to !== "") {
      obj.to = message.to;
    }
    if (message.amount.length !== 0) {
      obj.amount = base64FromBytes(message.amount);
    }
    if (message.payload.length !== 0) {
      obj.payload = base64FromBytes(message.payload);
    }
    if (message.id !== "") {
      obj.id = message.id;
    }
    if (message.isNonceSet !== false) {
      obj.isNonceSet = message.isNonceSet;
    }
    if (message.chainId !== 0) {
      obj.chainId = Math.round(message.chainId);
    }
    return obj;
  },

  create(base?: DeepPartial<AvaxCChainTransaction>): AvaxCChainTransaction {
    return AvaxCChainTransaction.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<AvaxCChainTransaction>): AvaxCChainTransaction {
    const message = createBaseAvaxCChainTransaction();
    message.from = object.from ?? "";
    message.nonce = object.nonce ?? 0;
    message.gasLimit = object.gasLimit ?? 0;
    message.gasPrice = object.gasPrice ?? new Uint8Array(0);
    message.to = object.to ?? "";
    message.amount = object.amount ?? new Uint8Array(0);
    message.payload = object.payload ?? new Uint8Array(0);
    message.id = object.id ?? "";
    message.isNonceSet = object.isNonceSet ?? false;
    message.chainId = object.chainId ?? 0;
    return message;
  },
};

function createBaseAvaxCChainCreateContractRequest(): AvaxCChainCreateContractRequest {
  return {
    from: "",
    nonce: 0,
    gasLimit: 0,
    gasPrice: new Uint8Array(0),
    amount: new Uint8Array(0),
    payload: new Uint8Array(0),
    id: "",
    isNonceSet: false,
    chainId: 0,
  };
}

export const AvaxCChainCreateContractRequest = {
  encode(message: AvaxCChainCreateContractRequest, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.from !== "") {
      writer.uint32(10).string(message.from);
    }
    if (message.nonce !== 0) {
      writer.uint32(16).uint64(message.nonce);
    }
    if (message.gasLimit !== 0) {
      writer.uint32(24).uint64(message.gasLimit);
    }
    if (message.gasPrice.length !== 0) {
      writer.uint32(34).bytes(message.gasPrice);
    }
    if (message.amount.length !== 0) {
      writer.uint32(42).bytes(message.amount);
    }
    if (message.payload.length !== 0) {
      writer.uint32(50).bytes(message.payload);
    }
    if (message.id !== "") {
      writer.uint32(58).string(message.id);
    }
    if (message.isNonceSet !== false) {
      writer.uint32(64).bool(message.isNonceSet);
    }
    if (message.chainId !== 0) {
      writer.uint32(72).uint64(message.chainId);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): AvaxCChainCreateContractRequest {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseAvaxCChainCreateContractRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.from = reader.string();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.nonce = longToNumber(reader.uint64() as Long);
          continue;
        case 3:
          if (tag !== 24) {
            break;
          }

          message.gasLimit = longToNumber(reader.uint64() as Long);
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.gasPrice = reader.bytes();
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.amount = reader.bytes();
          continue;
        case 6:
          if (tag !== 50) {
            break;
          }

          message.payload = reader.bytes();
          continue;
        case 7:
          if (tag !== 58) {
            break;
          }

          message.id = reader.string();
          continue;
        case 8:
          if (tag !== 64) {
            break;
          }

          message.isNonceSet = reader.bool();
          continue;
        case 9:
          if (tag !== 72) {
            break;
          }

          message.chainId = longToNumber(reader.uint64() as Long);
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): AvaxCChainCreateContractRequest {
    return {
      from: isSet(object.from) ? globalThis.String(object.from) : "",
      nonce: isSet(object.nonce) ? globalThis.Number(object.nonce) : 0,
      gasLimit: isSet(object.gasLimit) ? globalThis.Number(object.gasLimit) : 0,
      gasPrice: isSet(object.gasPrice) ? bytesFromBase64(object.gasPrice) : new Uint8Array(0),
      amount: isSet(object.amount) ? bytesFromBase64(object.amount) : new Uint8Array(0),
      payload: isSet(object.payload) ? bytesFromBase64(object.payload) : new Uint8Array(0),
      id: isSet(object.id) ? globalThis.String(object.id) : "",
      isNonceSet: isSet(object.isNonceSet) ? globalThis.Boolean(object.isNonceSet) : false,
      chainId: isSet(object.chainId) ? globalThis.Number(object.chainId) : 0,
    };
  },

  toJSON(message: AvaxCChainCreateContractRequest): unknown {
    const obj: any = {};
    if (message.from !== "") {
      obj.from = message.from;
    }
    if (message.nonce !== 0) {
      obj.nonce = Math.round(message.nonce);
    }
    if (message.gasLimit !== 0) {
      obj.gasLimit = Math.round(message.gasLimit);
    }
    if (message.gasPrice.length !== 0) {
      obj.gasPrice = base64FromBytes(message.gasPrice);
    }
    if (message.amount.length !== 0) {
      obj.amount = base64FromBytes(message.amount);
    }
    if (message.payload.length !== 0) {
      obj.payload = base64FromBytes(message.payload);
    }
    if (message.id !== "") {
      obj.id = message.id;
    }
    if (message.isNonceSet !== false) {
      obj.isNonceSet = message.isNonceSet;
    }
    if (message.chainId !== 0) {
      obj.chainId = Math.round(message.chainId);
    }
    return obj;
  },

  create(base?: DeepPartial<AvaxCChainCreateContractRequest>): AvaxCChainCreateContractRequest {
    return AvaxCChainCreateContractRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<AvaxCChainCreateContractRequest>): AvaxCChainCreateContractRequest {
    const message = createBaseAvaxCChainCreateContractRequest();
    message.from = object.from ?? "";
    message.nonce = object.nonce ?? 0;
    message.gasLimit = object.gasLimit ?? 0;
    message.gasPrice = object.gasPrice ?? new Uint8Array(0);
    message.amount = object.amount ?? new Uint8Array(0);
    message.payload = object.payload ?? new Uint8Array(0);
    message.id = object.id ?? "";
    message.isNonceSet = object.isNonceSet ?? false;
    message.chainId = object.chainId ?? 0;
    return message;
  },
};

function createBaseAvaxCChainAddressRequest(): AvaxCChainAddressRequest {
  return { path: "" };
}

export const AvaxCChainAddressRequest = {
  encode(message: AvaxCChainAddressRequest, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.path !== "") {
      writer.uint32(10).string(message.path);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): AvaxCChainAddressRequest {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseAvaxCChainAddressRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.path = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): AvaxCChainAddressRequest {
    return { path: isSet(object.path) ? globalThis.String(object.path) : "" };
  },

  toJSON(message: AvaxCChainAddressRequest): unknown {
    const obj: any = {};
    if (message.path !== "") {
      obj.path = message.path;
    }
    return obj;
  },

  create(base?: DeepPartial<AvaxCChainAddressRequest>): AvaxCChainAddressRequest {
    return AvaxCChainAddressRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<AvaxCChainAddressRequest>): AvaxCChainAddressRequest {
    const message = createBaseAvaxCChainAddressRequest();
    message.path = object.path ?? "";
    return message;
  },
};

function createBaseAvaxCChainProofOfReserveRequest(): AvaxCChainProofOfReserveRequest {
  return { path: "", challenge: "" };
}

export const AvaxCChainProofOfReserveRequest = {
  encode(message: AvaxCChainProofOfReserveRequest, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.path !== "") {
      writer.uint32(10).string(message.path);
    }
    if (message.challenge !== "") {
      writer.uint32(18).string(message.challenge);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): AvaxCChainProofOfReserveRequest {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseAvaxCChainProofOfReserveRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.path = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.challenge = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): AvaxCChainProofOfReserveRequest {
    return {
      path: isSet(object.path) ? globalThis.String(object.path) : "",
      challenge: isSet(object.challenge) ? globalThis.String(object.challenge) : "",
    };
  },

  toJSON(message: AvaxCChainProofOfReserveRequest): unknown {
    const obj: any = {};
    if (message.path !== "") {
      obj.path = message.path;
    }
    if (message.challenge !== "") {
      obj.challenge = message.challenge;
    }
    return obj;
  },

  create(base?: DeepPartial<AvaxCChainProofOfReserveRequest>): AvaxCChainProofOfReserveRequest {
    return AvaxCChainProofOfReserveRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<AvaxCChainProofOfReserveRequest>): AvaxCChainProofOfReserveRequest {
    const message = createBaseAvaxCChainProofOfReserveRequest();
    message.path = object.path ?? "";
    message.challenge = object.challenge ?? "";
    return message;
  },
};

function createBaseAvaxCChainTransactionsResponse(): AvaxCChainTransactionsResponse {
  return { transactions: [] };
}

export const AvaxCChainTransactionsResponse = {
  encode(message: AvaxCChainTransactionsResponse, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    for (const v of message.transactions) {
      AvaxCChainTransactionsResponse_AvaxCChainTransactionResponse.encode(v!, writer.uint32(10).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): AvaxCChainTransactionsResponse {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseAvaxCChainTransactionsResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.transactions.push(
            AvaxCChainTransactionsResponse_AvaxCChainTransactionResponse.decode(reader, reader.uint32()),
          );
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): AvaxCChainTransactionsResponse {
    return {
      transactions: globalThis.Array.isArray(object?.transactions)
        ? object.transactions.map((e: any) => AvaxCChainTransactionsResponse_AvaxCChainTransactionResponse.fromJSON(e))
        : [],
    };
  },

  toJSON(message: AvaxCChainTransactionsResponse): unknown {
    const obj: any = {};
    if (message.transactions?.length) {
      obj.transactions = message.transactions.map((e) =>
        AvaxCChainTransactionsResponse_AvaxCChainTransactionResponse.toJSON(e)
      );
    }
    return obj;
  },

  create(base?: DeepPartial<AvaxCChainTransactionsResponse>): AvaxCChainTransactionsResponse {
    return AvaxCChainTransactionsResponse.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<AvaxCChainTransactionsResponse>): AvaxCChainTransactionsResponse {
    const message = createBaseAvaxCChainTransactionsResponse();
    message.transactions =
      object.transactions?.map((e) => AvaxCChainTransactionsResponse_AvaxCChainTransactionResponse.fromPartial(e)) ||
      [];
    return message;
  },
};

function createBaseAvaxCChainTransactionsResponse_AvaxCChainTransactionResponse(): AvaxCChainTransactionsResponse_AvaxCChainTransactionResponse {
  return { id: "", transaction: "", publicKey: new Uint8Array(0) };
}

export const AvaxCChainTransactionsResponse_AvaxCChainTransactionResponse = {
  encode(
    message: AvaxCChainTransactionsResponse_AvaxCChainTransactionResponse,
    writer: _m0.Writer = _m0.Writer.create(),
  ): _m0.Writer {
    if (message.id !== "") {
      writer.uint32(10).string(message.id);
    }
    if (message.transaction !== "") {
      writer.uint32(18).string(message.transaction);
    }
    if (message.publicKey.length !== 0) {
      writer.uint32(26).bytes(message.publicKey);
    }
    return writer;
  },

  decode(
    input: _m0.Reader | Uint8Array,
    length?: number,
  ): AvaxCChainTransactionsResponse_AvaxCChainTransactionResponse {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseAvaxCChainTransactionsResponse_AvaxCChainTransactionResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.id = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.transaction = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.publicKey = reader.bytes();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): AvaxCChainTransactionsResponse_AvaxCChainTransactionResponse {
    return {
      id: isSet(object.id) ? globalThis.String(object.id) : "",
      transaction: isSet(object.transaction) ? globalThis.String(object.transaction) : "",
      publicKey: isSet(object.publicKey) ? bytesFromBase64(object.publicKey) : new Uint8Array(0),
    };
  },

  toJSON(message: AvaxCChainTransactionsResponse_AvaxCChainTransactionResponse): unknown {
    const obj: any = {};
    if (message.id !== "") {
      obj.id = message.id;
    }
    if (message.transaction !== "") {
      obj.transaction = message.transaction;
    }
    if (message.publicKey.length !== 0) {
      obj.publicKey = base64FromBytes(message.publicKey);
    }
    return obj;
  },

  create(
    base?: DeepPartial<AvaxCChainTransactionsResponse_AvaxCChainTransactionResponse>,
  ): AvaxCChainTransactionsResponse_AvaxCChainTransactionResponse {
    return AvaxCChainTransactionsResponse_AvaxCChainTransactionResponse.fromPartial(base ?? {});
  },
  fromPartial(
    object: DeepPartial<AvaxCChainTransactionsResponse_AvaxCChainTransactionResponse>,
  ): AvaxCChainTransactionsResponse_AvaxCChainTransactionResponse {
    const message = createBaseAvaxCChainTransactionsResponse_AvaxCChainTransactionResponse();
    message.id = object.id ?? "";
    message.transaction = object.transaction ?? "";
    message.publicKey = object.publicKey ?? new Uint8Array(0);
    return message;
  },
};

function createBaseAvaxCChainSignTextRequest(): AvaxCChainSignTextRequest {
  return { id: "", from: "", message: "" };
}

export const AvaxCChainSignTextRequest = {
  encode(message: AvaxCChainSignTextRequest, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.id !== "") {
      writer.uint32(10).string(message.id);
    }
    if (message.from !== "") {
      writer.uint32(18).string(message.from);
    }
    if (message.message !== "") {
      writer.uint32(26).string(message.message);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): AvaxCChainSignTextRequest {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseAvaxCChainSignTextRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.id = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.from = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.message = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): AvaxCChainSignTextRequest {
    return {
      id: isSet(object.id) ? globalThis.String(object.id) : "",
      from: isSet(object.from) ? globalThis.String(object.from) : "",
      message: isSet(object.message) ? globalThis.String(object.message) : "",
    };
  },

  toJSON(message: AvaxCChainSignTextRequest): unknown {
    const obj: any = {};
    if (message.id !== "") {
      obj.id = message.id;
    }
    if (message.from !== "") {
      obj.from = message.from;
    }
    if (message.message !== "") {
      obj.message = message.message;
    }
    return obj;
  },

  create(base?: DeepPartial<AvaxCChainSignTextRequest>): AvaxCChainSignTextRequest {
    return AvaxCChainSignTextRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<AvaxCChainSignTextRequest>): AvaxCChainSignTextRequest {
    const message = createBaseAvaxCChainSignTextRequest();
    message.id = object.id ?? "";
    message.from = object.from ?? "";
    message.message = object.message ?? "";
    return message;
  },
};

function createBaseAvaxCChainSignTextResponse(): AvaxCChainSignTextResponse {
  return { id: "", signature: new Uint8Array(0), publicKey: new Uint8Array(0) };
}

export const AvaxCChainSignTextResponse = {
  encode(message: AvaxCChainSignTextResponse, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.id !== "") {
      writer.uint32(10).string(message.id);
    }
    if (message.signature.length !== 0) {
      writer.uint32(18).bytes(message.signature);
    }
    if (message.publicKey.length !== 0) {
      writer.uint32(26).bytes(message.publicKey);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): AvaxCChainSignTextResponse {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseAvaxCChainSignTextResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.id = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.signature = reader.bytes();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.publicKey = reader.bytes();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): AvaxCChainSignTextResponse {
    return {
      id: isSet(object.id) ? globalThis.String(object.id) : "",
      signature: isSet(object.signature) ? bytesFromBase64(object.signature) : new Uint8Array(0),
      publicKey: isSet(object.publicKey) ? bytesFromBase64(object.publicKey) : new Uint8Array(0),
    };
  },

  toJSON(message: AvaxCChainSignTextResponse): unknown {
    const obj: any = {};
    if (message.id !== "") {
      obj.id = message.id;
    }
    if (message.signature.length !== 0) {
      obj.signature = base64FromBytes(message.signature);
    }
    if (message.publicKey.length !== 0) {
      obj.publicKey = base64FromBytes(message.publicKey);
    }
    return obj;
  },

  create(base?: DeepPartial<AvaxCChainSignTextResponse>): AvaxCChainSignTextResponse {
    return AvaxCChainSignTextResponse.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<AvaxCChainSignTextResponse>): AvaxCChainSignTextResponse {
    const message = createBaseAvaxCChainSignTextResponse();
    message.id = object.id ?? "";
    message.signature = object.signature ?? new Uint8Array(0);
    message.publicKey = object.publicKey ?? new Uint8Array(0);
    return message;
  },
};

function createBaseAvaxCChainWrappedTransactionsRequest(): AvaxCChainWrappedTransactionsRequest {
  return { transactions: [] };
}

export const AvaxCChainWrappedTransactionsRequest = {
  encode(message: AvaxCChainWrappedTransactionsRequest, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    for (const v of message.transactions) {
      AvaxCChainWrappedTransaction.encode(v!, writer.uint32(10).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): AvaxCChainWrappedTransactionsRequest {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseAvaxCChainWrappedTransactionsRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.transactions.push(AvaxCChainWrappedTransaction.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): AvaxCChainWrappedTransactionsRequest {
    return {
      transactions: globalThis.Array.isArray(object?.transactions)
        ? object.transactions.map((e: any) => AvaxCChainWrappedTransaction.fromJSON(e))
        : [],
    };
  },

  toJSON(message: AvaxCChainWrappedTransactionsRequest): unknown {
    const obj: any = {};
    if (message.transactions?.length) {
      obj.transactions = message.transactions.map((e) => AvaxCChainWrappedTransaction.toJSON(e));
    }
    return obj;
  },

  create(base?: DeepPartial<AvaxCChainWrappedTransactionsRequest>): AvaxCChainWrappedTransactionsRequest {
    return AvaxCChainWrappedTransactionsRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<AvaxCChainWrappedTransactionsRequest>): AvaxCChainWrappedTransactionsRequest {
    const message = createBaseAvaxCChainWrappedTransactionsRequest();
    message.transactions = object.transactions?.map((e) => AvaxCChainWrappedTransaction.fromPartial(e)) || [];
    return message;
  },
};

function createBaseAvaxCChainWrappedTransaction(): AvaxCChainWrappedTransaction {
  return {
    domainSeparator: new Uint8Array(0),
    requestTypeHash: new Uint8Array(0),
    from: "",
    to: "",
    nonce: 0,
    gasLimit: 0,
    payload: new Uint8Array(0),
    id: "",
    isNonceSet: false,
    forwarder: "",
  };
}

export const AvaxCChainWrappedTransaction = {
  encode(message: AvaxCChainWrappedTransaction, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.domainSeparator.length !== 0) {
      writer.uint32(10).bytes(message.domainSeparator);
    }
    if (message.requestTypeHash.length !== 0) {
      writer.uint32(18).bytes(message.requestTypeHash);
    }
    if (message.from !== "") {
      writer.uint32(26).string(message.from);
    }
    if (message.to !== "") {
      writer.uint32(34).string(message.to);
    }
    if (message.nonce !== 0) {
      writer.uint32(40).uint64(message.nonce);
    }
    if (message.gasLimit !== 0) {
      writer.uint32(48).uint64(message.gasLimit);
    }
    if (message.payload.length !== 0) {
      writer.uint32(58).bytes(message.payload);
    }
    if (message.id !== "") {
      writer.uint32(66).string(message.id);
    }
    if (message.isNonceSet !== false) {
      writer.uint32(72).bool(message.isNonceSet);
    }
    if (message.forwarder !== "") {
      writer.uint32(82).string(message.forwarder);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): AvaxCChainWrappedTransaction {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseAvaxCChainWrappedTransaction();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.domainSeparator = reader.bytes();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.requestTypeHash = reader.bytes();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.from = reader.string();
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.to = reader.string();
          continue;
        case 5:
          if (tag !== 40) {
            break;
          }

          message.nonce = longToNumber(reader.uint64() as Long);
          continue;
        case 6:
          if (tag !== 48) {
            break;
          }

          message.gasLimit = longToNumber(reader.uint64() as Long);
          continue;
        case 7:
          if (tag !== 58) {
            break;
          }

          message.payload = reader.bytes();
          continue;
        case 8:
          if (tag !== 66) {
            break;
          }

          message.id = reader.string();
          continue;
        case 9:
          if (tag !== 72) {
            break;
          }

          message.isNonceSet = reader.bool();
          continue;
        case 10:
          if (tag !== 82) {
            break;
          }

          message.forwarder = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): AvaxCChainWrappedTransaction {
    return {
      domainSeparator: isSet(object.domainSeparator) ? bytesFromBase64(object.domainSeparator) : new Uint8Array(0),
      requestTypeHash: isSet(object.requestTypeHash) ? bytesFromBase64(object.requestTypeHash) : new Uint8Array(0),
      from: isSet(object.from) ? globalThis.String(object.from) : "",
      to: isSet(object.to) ? globalThis.String(object.to) : "",
      nonce: isSet(object.nonce) ? globalThis.Number(object.nonce) : 0,
      gasLimit: isSet(object.gasLimit) ? globalThis.Number(object.gasLimit) : 0,
      payload: isSet(object.payload) ? bytesFromBase64(object.payload) : new Uint8Array(0),
      id: isSet(object.id) ? globalThis.String(object.id) : "",
      isNonceSet: isSet(object.isNonceSet) ? globalThis.Boolean(object.isNonceSet) : false,
      forwarder: isSet(object.forwarder) ? globalThis.String(object.forwarder) : "",
    };
  },

  toJSON(message: AvaxCChainWrappedTransaction): unknown {
    const obj: any = {};
    if (message.domainSeparator.length !== 0) {
      obj.domainSeparator = base64FromBytes(message.domainSeparator);
    }
    if (message.requestTypeHash.length !== 0) {
      obj.requestTypeHash = base64FromBytes(message.requestTypeHash);
    }
    if (message.from !== "") {
      obj.from = message.from;
    }
    if (message.to !== "") {
      obj.to = message.to;
    }
    if (message.nonce !== 0) {
      obj.nonce = Math.round(message.nonce);
    }
    if (message.gasLimit !== 0) {
      obj.gasLimit = Math.round(message.gasLimit);
    }
    if (message.payload.length !== 0) {
      obj.payload = base64FromBytes(message.payload);
    }
    if (message.id !== "") {
      obj.id = message.id;
    }
    if (message.isNonceSet !== false) {
      obj.isNonceSet = message.isNonceSet;
    }
    if (message.forwarder !== "") {
      obj.forwarder = message.forwarder;
    }
    return obj;
  },

  create(base?: DeepPartial<AvaxCChainWrappedTransaction>): AvaxCChainWrappedTransaction {
    return AvaxCChainWrappedTransaction.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<AvaxCChainWrappedTransaction>): AvaxCChainWrappedTransaction {
    const message = createBaseAvaxCChainWrappedTransaction();
    message.domainSeparator = object.domainSeparator ?? new Uint8Array(0);
    message.requestTypeHash = object.requestTypeHash ?? new Uint8Array(0);
    message.from = object.from ?? "";
    message.to = object.to ?? "";
    message.nonce = object.nonce ?? 0;
    message.gasLimit = object.gasLimit ?? 0;
    message.payload = object.payload ?? new Uint8Array(0);
    message.id = object.id ?? "";
    message.isNonceSet = object.isNonceSet ?? false;
    message.forwarder = object.forwarder ?? "";
    return message;
  },
};

function createBaseAvaxCChainWrappedCreateContractRequest(): AvaxCChainWrappedCreateContractRequest {
  return {
    domainSeparator: new Uint8Array(0),
    requestTypeHash: new Uint8Array(0),
    from: "",
    nonce: 0,
    payload: new Uint8Array(0),
    id: "",
    isNonceSet: false,
    creator: "",
  };
}

export const AvaxCChainWrappedCreateContractRequest = {
  encode(message: AvaxCChainWrappedCreateContractRequest, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.domainSeparator.length !== 0) {
      writer.uint32(10).bytes(message.domainSeparator);
    }
    if (message.requestTypeHash.length !== 0) {
      writer.uint32(18).bytes(message.requestTypeHash);
    }
    if (message.from !== "") {
      writer.uint32(26).string(message.from);
    }
    if (message.nonce !== 0) {
      writer.uint32(32).uint64(message.nonce);
    }
    if (message.payload.length !== 0) {
      writer.uint32(42).bytes(message.payload);
    }
    if (message.id !== "") {
      writer.uint32(50).string(message.id);
    }
    if (message.isNonceSet !== false) {
      writer.uint32(56).bool(message.isNonceSet);
    }
    if (message.creator !== "") {
      writer.uint32(66).string(message.creator);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): AvaxCChainWrappedCreateContractRequest {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseAvaxCChainWrappedCreateContractRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.domainSeparator = reader.bytes();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.requestTypeHash = reader.bytes();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.from = reader.string();
          continue;
        case 4:
          if (tag !== 32) {
            break;
          }

          message.nonce = longToNumber(reader.uint64() as Long);
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.payload = reader.bytes();
          continue;
        case 6:
          if (tag !== 50) {
            break;
          }

          message.id = reader.string();
          continue;
        case 7:
          if (tag !== 56) {
            break;
          }

          message.isNonceSet = reader.bool();
          continue;
        case 8:
          if (tag !== 66) {
            break;
          }

          message.creator = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): AvaxCChainWrappedCreateContractRequest {
    return {
      domainSeparator: isSet(object.domainSeparator) ? bytesFromBase64(object.domainSeparator) : new Uint8Array(0),
      requestTypeHash: isSet(object.requestTypeHash) ? bytesFromBase64(object.requestTypeHash) : new Uint8Array(0),
      from: isSet(object.from) ? globalThis.String(object.from) : "",
      nonce: isSet(object.nonce) ? globalThis.Number(object.nonce) : 0,
      payload: isSet(object.payload) ? bytesFromBase64(object.payload) : new Uint8Array(0),
      id: isSet(object.id) ? globalThis.String(object.id) : "",
      isNonceSet: isSet(object.isNonceSet) ? globalThis.Boolean(object.isNonceSet) : false,
      creator: isSet(object.creator) ? globalThis.String(object.creator) : "",
    };
  },

  toJSON(message: AvaxCChainWrappedCreateContractRequest): unknown {
    const obj: any = {};
    if (message.domainSeparator.length !== 0) {
      obj.domainSeparator = base64FromBytes(message.domainSeparator);
    }
    if (message.requestTypeHash.length !== 0) {
      obj.requestTypeHash = base64FromBytes(message.requestTypeHash);
    }
    if (message.from !== "") {
      obj.from = message.from;
    }
    if (message.nonce !== 0) {
      obj.nonce = Math.round(message.nonce);
    }
    if (message.payload.length !== 0) {
      obj.payload = base64FromBytes(message.payload);
    }
    if (message.id !== "") {
      obj.id = message.id;
    }
    if (message.isNonceSet !== false) {
      obj.isNonceSet = message.isNonceSet;
    }
    if (message.creator !== "") {
      obj.creator = message.creator;
    }
    return obj;
  },

  create(base?: DeepPartial<AvaxCChainWrappedCreateContractRequest>): AvaxCChainWrappedCreateContractRequest {
    return AvaxCChainWrappedCreateContractRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<AvaxCChainWrappedCreateContractRequest>): AvaxCChainWrappedCreateContractRequest {
    const message = createBaseAvaxCChainWrappedCreateContractRequest();
    message.domainSeparator = object.domainSeparator ?? new Uint8Array(0);
    message.requestTypeHash = object.requestTypeHash ?? new Uint8Array(0);
    message.from = object.from ?? "";
    message.nonce = object.nonce ?? 0;
    message.payload = object.payload ?? new Uint8Array(0);
    message.id = object.id ?? "";
    message.isNonceSet = object.isNonceSet ?? false;
    message.creator = object.creator ?? "";
    return message;
  },
};

function createBaseAvaxCChainWrappedTransactionsResponse(): AvaxCChainWrappedTransactionsResponse {
  return { transactions: [] };
}

export const AvaxCChainWrappedTransactionsResponse = {
  encode(message: AvaxCChainWrappedTransactionsResponse, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    for (const v of message.transactions) {
      AvaxCChainWrappedTransactionsResponse_AvaxCChainWrappedTransactionResponse.encode(v!, writer.uint32(10).fork())
        .ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): AvaxCChainWrappedTransactionsResponse {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseAvaxCChainWrappedTransactionsResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.transactions.push(
            AvaxCChainWrappedTransactionsResponse_AvaxCChainWrappedTransactionResponse.decode(reader, reader.uint32()),
          );
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): AvaxCChainWrappedTransactionsResponse {
    return {
      transactions: globalThis.Array.isArray(object?.transactions)
        ? object.transactions.map((e: any) =>
          AvaxCChainWrappedTransactionsResponse_AvaxCChainWrappedTransactionResponse.fromJSON(e)
        )
        : [],
    };
  },

  toJSON(message: AvaxCChainWrappedTransactionsResponse): unknown {
    const obj: any = {};
    if (message.transactions?.length) {
      obj.transactions = message.transactions.map((e) =>
        AvaxCChainWrappedTransactionsResponse_AvaxCChainWrappedTransactionResponse.toJSON(e)
      );
    }
    return obj;
  },

  create(base?: DeepPartial<AvaxCChainWrappedTransactionsResponse>): AvaxCChainWrappedTransactionsResponse {
    return AvaxCChainWrappedTransactionsResponse.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<AvaxCChainWrappedTransactionsResponse>): AvaxCChainWrappedTransactionsResponse {
    const message = createBaseAvaxCChainWrappedTransactionsResponse();
    message.transactions =
      object.transactions?.map((e) =>
        AvaxCChainWrappedTransactionsResponse_AvaxCChainWrappedTransactionResponse.fromPartial(e)
      ) || [];
    return message;
  },
};

function createBaseAvaxCChainWrappedTransactionsResponse_AvaxCChainWrappedTransactionResponse(): AvaxCChainWrappedTransactionsResponse_AvaxCChainWrappedTransactionResponse {
  return { id: "", transaction: "", publicKey: new Uint8Array(0) };
}

export const AvaxCChainWrappedTransactionsResponse_AvaxCChainWrappedTransactionResponse = {
  encode(
    message: AvaxCChainWrappedTransactionsResponse_AvaxCChainWrappedTransactionResponse,
    writer: _m0.Writer = _m0.Writer.create(),
  ): _m0.Writer {
    if (message.id !== "") {
      writer.uint32(10).string(message.id);
    }
    if (message.transaction !== "") {
      writer.uint32(18).string(message.transaction);
    }
    if (message.publicKey.length !== 0) {
      writer.uint32(26).bytes(message.publicKey);
    }
    return writer;
  },

  decode(
    input: _m0.Reader | Uint8Array,
    length?: number,
  ): AvaxCChainWrappedTransactionsResponse_AvaxCChainWrappedTransactionResponse {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseAvaxCChainWrappedTransactionsResponse_AvaxCChainWrappedTransactionResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.id = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.transaction = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.publicKey = reader.bytes();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): AvaxCChainWrappedTransactionsResponse_AvaxCChainWrappedTransactionResponse {
    return {
      id: isSet(object.id) ? globalThis.String(object.id) : "",
      transaction: isSet(object.transaction) ? globalThis.String(object.transaction) : "",
      publicKey: isSet(object.publicKey) ? bytesFromBase64(object.publicKey) : new Uint8Array(0),
    };
  },

  toJSON(message: AvaxCChainWrappedTransactionsResponse_AvaxCChainWrappedTransactionResponse): unknown {
    const obj: any = {};
    if (message.id !== "") {
      obj.id = message.id;
    }
    if (message.transaction !== "") {
      obj.transaction = message.transaction;
    }
    if (message.publicKey.length !== 0) {
      obj.publicKey = base64FromBytes(message.publicKey);
    }
    return obj;
  },

  create(
    base?: DeepPartial<AvaxCChainWrappedTransactionsResponse_AvaxCChainWrappedTransactionResponse>,
  ): AvaxCChainWrappedTransactionsResponse_AvaxCChainWrappedTransactionResponse {
    return AvaxCChainWrappedTransactionsResponse_AvaxCChainWrappedTransactionResponse.fromPartial(base ?? {});
  },
  fromPartial(
    object: DeepPartial<AvaxCChainWrappedTransactionsResponse_AvaxCChainWrappedTransactionResponse>,
  ): AvaxCChainWrappedTransactionsResponse_AvaxCChainWrappedTransactionResponse {
    const message = createBaseAvaxCChainWrappedTransactionsResponse_AvaxCChainWrappedTransactionResponse();
    message.id = object.id ?? "";
    message.transaction = object.transaction ?? "";
    message.publicKey = object.publicKey ?? new Uint8Array(0);
    return message;
  },
};

function createBaseAvaxCChainWrappedCreateContractResponse(): AvaxCChainWrappedCreateContractResponse {
  return { id: "", transaction: "", publicKey: new Uint8Array(0) };
}

export const AvaxCChainWrappedCreateContractResponse = {
  encode(message: AvaxCChainWrappedCreateContractResponse, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.id !== "") {
      writer.uint32(10).string(message.id);
    }
    if (message.transaction !== "") {
      writer.uint32(18).string(message.transaction);
    }
    if (message.publicKey.length !== 0) {
      writer.uint32(26).bytes(message.publicKey);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): AvaxCChainWrappedCreateContractResponse {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseAvaxCChainWrappedCreateContractResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.id = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.transaction = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.publicKey = reader.bytes();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): AvaxCChainWrappedCreateContractResponse {
    return {
      id: isSet(object.id) ? globalThis.String(object.id) : "",
      transaction: isSet(object.transaction) ? globalThis.String(object.transaction) : "",
      publicKey: isSet(object.publicKey) ? bytesFromBase64(object.publicKey) : new Uint8Array(0),
    };
  },

  toJSON(message: AvaxCChainWrappedCreateContractResponse): unknown {
    const obj: any = {};
    if (message.id !== "") {
      obj.id = message.id;
    }
    if (message.transaction !== "") {
      obj.transaction = message.transaction;
    }
    if (message.publicKey.length !== 0) {
      obj.publicKey = base64FromBytes(message.publicKey);
    }
    return obj;
  },

  create(base?: DeepPartial<AvaxCChainWrappedCreateContractResponse>): AvaxCChainWrappedCreateContractResponse {
    return AvaxCChainWrappedCreateContractResponse.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<AvaxCChainWrappedCreateContractResponse>): AvaxCChainWrappedCreateContractResponse {
    const message = createBaseAvaxCChainWrappedCreateContractResponse();
    message.id = object.id ?? "";
    message.transaction = object.transaction ?? "";
    message.publicKey = object.publicKey ?? new Uint8Array(0);
    return message;
  },
};

function createBaseDOGEInput(): DOGEInput {
  return { path: "", addressType: 0, txHash: new Uint8Array(0), outputIndex: 0, value: 0, sequenceNumber: 0 };
}

export const DOGEInput = {
  encode(message: DOGEInput, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.path !== "") {
      writer.uint32(10).string(message.path);
    }
    if (message.addressType !== 0) {
      writer.uint32(16).int32(message.addressType);
    }
    if (message.txHash.length !== 0) {
      writer.uint32(26).bytes(message.txHash);
    }
    if (message.outputIndex !== 0) {
      writer.uint32(32).uint32(message.outputIndex);
    }
    if (message.value !== 0) {
      writer.uint32(40).uint64(message.value);
    }
    if (message.sequenceNumber !== 0) {
      writer.uint32(48).uint32(message.sequenceNumber);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): DOGEInput {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseDOGEInput();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.path = reader.string();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.addressType = reader.int32() as any;
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.txHash = reader.bytes();
          continue;
        case 4:
          if (tag !== 32) {
            break;
          }

          message.outputIndex = reader.uint32();
          continue;
        case 5:
          if (tag !== 40) {
            break;
          }

          message.value = longToNumber(reader.uint64() as Long);
          continue;
        case 6:
          if (tag !== 48) {
            break;
          }

          message.sequenceNumber = reader.uint32();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): DOGEInput {
    return {
      path: isSet(object.path) ? globalThis.String(object.path) : "",
      addressType: isSet(object.addressType) ? dOGEAddressTypeFromJSON(object.addressType) : 0,
      txHash: isSet(object.txHash) ? bytesFromBase64(object.txHash) : new Uint8Array(0),
      outputIndex: isSet(object.outputIndex) ? globalThis.Number(object.outputIndex) : 0,
      value: isSet(object.value) ? globalThis.Number(object.value) : 0,
      sequenceNumber: isSet(object.sequenceNumber) ? globalThis.Number(object.sequenceNumber) : 0,
    };
  },

  toJSON(message: DOGEInput): unknown {
    const obj: any = {};
    if (message.path !== "") {
      obj.path = message.path;
    }
    if (message.addressType !== 0) {
      obj.addressType = dOGEAddressTypeToJSON(message.addressType);
    }
    if (message.txHash.length !== 0) {
      obj.txHash = base64FromBytes(message.txHash);
    }
    if (message.outputIndex !== 0) {
      obj.outputIndex = Math.round(message.outputIndex);
    }
    if (message.value !== 0) {
      obj.value = Math.round(message.value);
    }
    if (message.sequenceNumber !== 0) {
      obj.sequenceNumber = Math.round(message.sequenceNumber);
    }
    return obj;
  },

  create(base?: DeepPartial<DOGEInput>): DOGEInput {
    return DOGEInput.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<DOGEInput>): DOGEInput {
    const message = createBaseDOGEInput();
    message.path = object.path ?? "";
    message.addressType = object.addressType ?? 0;
    message.txHash = object.txHash ?? new Uint8Array(0);
    message.outputIndex = object.outputIndex ?? 0;
    message.value = object.value ?? 0;
    message.sequenceNumber = object.sequenceNumber ?? 0;
    return message;
  },
};

function createBaseDOGEOutput(): DOGEOutput {
  return { destination: "", amount: 0 };
}

export const DOGEOutput = {
  encode(message: DOGEOutput, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.destination !== "") {
      writer.uint32(10).string(message.destination);
    }
    if (message.amount !== 0) {
      writer.uint32(16).uint64(message.amount);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): DOGEOutput {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseDOGEOutput();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.destination = reader.string();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.amount = longToNumber(reader.uint64() as Long);
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): DOGEOutput {
    return {
      destination: isSet(object.destination) ? globalThis.String(object.destination) : "",
      amount: isSet(object.amount) ? globalThis.Number(object.amount) : 0,
    };
  },

  toJSON(message: DOGEOutput): unknown {
    const obj: any = {};
    if (message.destination !== "") {
      obj.destination = message.destination;
    }
    if (message.amount !== 0) {
      obj.amount = Math.round(message.amount);
    }
    return obj;
  },

  create(base?: DeepPartial<DOGEOutput>): DOGEOutput {
    return DOGEOutput.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<DOGEOutput>): DOGEOutput {
    const message = createBaseDOGEOutput();
    message.destination = object.destination ?? "";
    message.amount = object.amount ?? 0;
    return message;
  },
};

function createBaseDOGEChangeOutput(): DOGEChangeOutput {
  return { path: "", addressType: 0, amount: 0 };
}

export const DOGEChangeOutput = {
  encode(message: DOGEChangeOutput, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.path !== "") {
      writer.uint32(10).string(message.path);
    }
    if (message.addressType !== 0) {
      writer.uint32(16).int32(message.addressType);
    }
    if (message.amount !== 0) {
      writer.uint32(24).uint64(message.amount);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): DOGEChangeOutput {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseDOGEChangeOutput();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.path = reader.string();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.addressType = reader.int32() as any;
          continue;
        case 3:
          if (tag !== 24) {
            break;
          }

          message.amount = longToNumber(reader.uint64() as Long);
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): DOGEChangeOutput {
    return {
      path: isSet(object.path) ? globalThis.String(object.path) : "",
      addressType: isSet(object.addressType) ? dOGEAddressTypeFromJSON(object.addressType) : 0,
      amount: isSet(object.amount) ? globalThis.Number(object.amount) : 0,
    };
  },

  toJSON(message: DOGEChangeOutput): unknown {
    const obj: any = {};
    if (message.path !== "") {
      obj.path = message.path;
    }
    if (message.addressType !== 0) {
      obj.addressType = dOGEAddressTypeToJSON(message.addressType);
    }
    if (message.amount !== 0) {
      obj.amount = Math.round(message.amount);
    }
    return obj;
  },

  create(base?: DeepPartial<DOGEChangeOutput>): DOGEChangeOutput {
    return DOGEChangeOutput.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<DOGEChangeOutput>): DOGEChangeOutput {
    const message = createBaseDOGEChangeOutput();
    message.path = object.path ?? "";
    message.addressType = object.addressType ?? 0;
    message.amount = object.amount ?? 0;
    return message;
  },
};

function createBaseDOGETransactionRequest(): DOGETransactionRequest {
  return { inputs: [], outputs: [], changeOutputs: [], lockTime: 0, hashType: 0, id: "" };
}

export const DOGETransactionRequest = {
  encode(message: DOGETransactionRequest, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    for (const v of message.inputs) {
      DOGEInput.encode(v!, writer.uint32(10).fork()).ldelim();
    }
    for (const v of message.outputs) {
      DOGEOutput.encode(v!, writer.uint32(18).fork()).ldelim();
    }
    for (const v of message.changeOutputs) {
      DOGEChangeOutput.encode(v!, writer.uint32(26).fork()).ldelim();
    }
    if (message.lockTime !== 0) {
      writer.uint32(32).uint32(message.lockTime);
    }
    if (message.hashType !== 0) {
      writer.uint32(40).int32(message.hashType);
    }
    if (message.id !== "") {
      writer.uint32(50).string(message.id);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): DOGETransactionRequest {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseDOGETransactionRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.inputs.push(DOGEInput.decode(reader, reader.uint32()));
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.outputs.push(DOGEOutput.decode(reader, reader.uint32()));
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.changeOutputs.push(DOGEChangeOutput.decode(reader, reader.uint32()));
          continue;
        case 4:
          if (tag !== 32) {
            break;
          }

          message.lockTime = reader.uint32();
          continue;
        case 5:
          if (tag !== 40) {
            break;
          }

          message.hashType = reader.int32() as any;
          continue;
        case 6:
          if (tag !== 50) {
            break;
          }

          message.id = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): DOGETransactionRequest {
    return {
      inputs: globalThis.Array.isArray(object?.inputs) ? object.inputs.map((e: any) => DOGEInput.fromJSON(e)) : [],
      outputs: globalThis.Array.isArray(object?.outputs) ? object.outputs.map((e: any) => DOGEOutput.fromJSON(e)) : [],
      changeOutputs: globalThis.Array.isArray(object?.changeOutputs)
        ? object.changeOutputs.map((e: any) => DOGEChangeOutput.fromJSON(e))
        : [],
      lockTime: isSet(object.lockTime) ? globalThis.Number(object.lockTime) : 0,
      hashType: isSet(object.hashType) ? dOGESigHashTypeFromJSON(object.hashType) : 0,
      id: isSet(object.id) ? globalThis.String(object.id) : "",
    };
  },

  toJSON(message: DOGETransactionRequest): unknown {
    const obj: any = {};
    if (message.inputs?.length) {
      obj.inputs = message.inputs.map((e) => DOGEInput.toJSON(e));
    }
    if (message.outputs?.length) {
      obj.outputs = message.outputs.map((e) => DOGEOutput.toJSON(e));
    }
    if (message.changeOutputs?.length) {
      obj.changeOutputs = message.changeOutputs.map((e) => DOGEChangeOutput.toJSON(e));
    }
    if (message.lockTime !== 0) {
      obj.lockTime = Math.round(message.lockTime);
    }
    if (message.hashType !== 0) {
      obj.hashType = dOGESigHashTypeToJSON(message.hashType);
    }
    if (message.id !== "") {
      obj.id = message.id;
    }
    return obj;
  },

  create(base?: DeepPartial<DOGETransactionRequest>): DOGETransactionRequest {
    return DOGETransactionRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<DOGETransactionRequest>): DOGETransactionRequest {
    const message = createBaseDOGETransactionRequest();
    message.inputs = object.inputs?.map((e) => DOGEInput.fromPartial(e)) || [];
    message.outputs = object.outputs?.map((e) => DOGEOutput.fromPartial(e)) || [];
    message.changeOutputs = object.changeOutputs?.map((e) => DOGEChangeOutput.fromPartial(e)) || [];
    message.lockTime = object.lockTime ?? 0;
    message.hashType = object.hashType ?? 0;
    message.id = object.id ?? "";
    return message;
  },
};

function createBaseDOGEAddressRequest(): DOGEAddressRequest {
  return { path: "", addressType: 0 };
}

export const DOGEAddressRequest = {
  encode(message: DOGEAddressRequest, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.path !== "") {
      writer.uint32(10).string(message.path);
    }
    if (message.addressType !== 0) {
      writer.uint32(16).int32(message.addressType);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): DOGEAddressRequest {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseDOGEAddressRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.path = reader.string();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.addressType = reader.int32() as any;
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): DOGEAddressRequest {
    return {
      path: isSet(object.path) ? globalThis.String(object.path) : "",
      addressType: isSet(object.addressType) ? dOGEAddressTypeFromJSON(object.addressType) : 0,
    };
  },

  toJSON(message: DOGEAddressRequest): unknown {
    const obj: any = {};
    if (message.path !== "") {
      obj.path = message.path;
    }
    if (message.addressType !== 0) {
      obj.addressType = dOGEAddressTypeToJSON(message.addressType);
    }
    return obj;
  },

  create(base?: DeepPartial<DOGEAddressRequest>): DOGEAddressRequest {
    return DOGEAddressRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<DOGEAddressRequest>): DOGEAddressRequest {
    const message = createBaseDOGEAddressRequest();
    message.path = object.path ?? "";
    message.addressType = object.addressType ?? 0;
    return message;
  },
};

function createBaseDOGEProofOfReserveRequest(): DOGEProofOfReserveRequest {
  return { path: "", addressType: 0, challenge: "" };
}

export const DOGEProofOfReserveRequest = {
  encode(message: DOGEProofOfReserveRequest, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.path !== "") {
      writer.uint32(10).string(message.path);
    }
    if (message.addressType !== 0) {
      writer.uint32(16).int32(message.addressType);
    }
    if (message.challenge !== "") {
      writer.uint32(26).string(message.challenge);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): DOGEProofOfReserveRequest {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseDOGEProofOfReserveRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.path = reader.string();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.addressType = reader.int32() as any;
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.challenge = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): DOGEProofOfReserveRequest {
    return {
      path: isSet(object.path) ? globalThis.String(object.path) : "",
      addressType: isSet(object.addressType) ? dOGEAddressTypeFromJSON(object.addressType) : 0,
      challenge: isSet(object.challenge) ? globalThis.String(object.challenge) : "",
    };
  },

  toJSON(message: DOGEProofOfReserveRequest): unknown {
    const obj: any = {};
    if (message.path !== "") {
      obj.path = message.path;
    }
    if (message.addressType !== 0) {
      obj.addressType = dOGEAddressTypeToJSON(message.addressType);
    }
    if (message.challenge !== "") {
      obj.challenge = message.challenge;
    }
    return obj;
  },

  create(base?: DeepPartial<DOGEProofOfReserveRequest>): DOGEProofOfReserveRequest {
    return DOGEProofOfReserveRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<DOGEProofOfReserveRequest>): DOGEProofOfReserveRequest {
    const message = createBaseDOGEProofOfReserveRequest();
    message.path = object.path ?? "";
    message.addressType = object.addressType ?? 0;
    message.challenge = object.challenge ?? "";
    return message;
  },
};

function createBaseMinaAddressRequest(): MinaAddressRequest {
  return { path: "" };
}

export const MinaAddressRequest = {
  encode(message: MinaAddressRequest, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.path !== "") {
      writer.uint32(10).string(message.path);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): MinaAddressRequest {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMinaAddressRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.path = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): MinaAddressRequest {
    return { path: isSet(object.path) ? globalThis.String(object.path) : "" };
  },

  toJSON(message: MinaAddressRequest): unknown {
    const obj: any = {};
    if (message.path !== "") {
      obj.path = message.path;
    }
    return obj;
  },

  create(base?: DeepPartial<MinaAddressRequest>): MinaAddressRequest {
    return MinaAddressRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<MinaAddressRequest>): MinaAddressRequest {
    const message = createBaseMinaAddressRequest();
    message.path = object.path ?? "";
    return message;
  },
};

function createBaseMinaTxCommon(): MinaTxCommon {
  return {
    id: "",
    fee: 0,
    nonce: 0,
    validUntil: 0,
    memo: "",
    networkId: 0,
    networkPrefix: new Uint8Array(0),
    source: "",
  };
}

export const MinaTxCommon = {
  encode(message: MinaTxCommon, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.id !== "") {
      writer.uint32(10).string(message.id);
    }
    if (message.fee !== 0) {
      writer.uint32(16).uint64(message.fee);
    }
    if (message.nonce !== 0) {
      writer.uint32(24).uint32(message.nonce);
    }
    if (message.validUntil !== 0) {
      writer.uint32(32).uint32(message.validUntil);
    }
    if (message.memo !== "") {
      writer.uint32(42).string(message.memo);
    }
    if (message.networkId !== 0) {
      writer.uint32(48).uint32(message.networkId);
    }
    if (message.networkPrefix.length !== 0) {
      writer.uint32(58).bytes(message.networkPrefix);
    }
    if (message.source !== "") {
      writer.uint32(66).string(message.source);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): MinaTxCommon {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMinaTxCommon();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.id = reader.string();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.fee = longToNumber(reader.uint64() as Long);
          continue;
        case 3:
          if (tag !== 24) {
            break;
          }

          message.nonce = reader.uint32();
          continue;
        case 4:
          if (tag !== 32) {
            break;
          }

          message.validUntil = reader.uint32();
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.memo = reader.string();
          continue;
        case 6:
          if (tag !== 48) {
            break;
          }

          message.networkId = reader.uint32();
          continue;
        case 7:
          if (tag !== 58) {
            break;
          }

          message.networkPrefix = reader.bytes();
          continue;
        case 8:
          if (tag !== 66) {
            break;
          }

          message.source = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): MinaTxCommon {
    return {
      id: isSet(object.id) ? globalThis.String(object.id) : "",
      fee: isSet(object.fee) ? globalThis.Number(object.fee) : 0,
      nonce: isSet(object.nonce) ? globalThis.Number(object.nonce) : 0,
      validUntil: isSet(object.validUntil) ? globalThis.Number(object.validUntil) : 0,
      memo: isSet(object.memo) ? globalThis.String(object.memo) : "",
      networkId: isSet(object.networkId) ? globalThis.Number(object.networkId) : 0,
      networkPrefix: isSet(object.networkPrefix) ? bytesFromBase64(object.networkPrefix) : new Uint8Array(0),
      source: isSet(object.source) ? globalThis.String(object.source) : "",
    };
  },

  toJSON(message: MinaTxCommon): unknown {
    const obj: any = {};
    if (message.id !== "") {
      obj.id = message.id;
    }
    if (message.fee !== 0) {
      obj.fee = Math.round(message.fee);
    }
    if (message.nonce !== 0) {
      obj.nonce = Math.round(message.nonce);
    }
    if (message.validUntil !== 0) {
      obj.validUntil = Math.round(message.validUntil);
    }
    if (message.memo !== "") {
      obj.memo = message.memo;
    }
    if (message.networkId !== 0) {
      obj.networkId = Math.round(message.networkId);
    }
    if (message.networkPrefix.length !== 0) {
      obj.networkPrefix = base64FromBytes(message.networkPrefix);
    }
    if (message.source !== "") {
      obj.source = message.source;
    }
    return obj;
  },

  create(base?: DeepPartial<MinaTxCommon>): MinaTxCommon {
    return MinaTxCommon.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<MinaTxCommon>): MinaTxCommon {
    const message = createBaseMinaTxCommon();
    message.id = object.id ?? "";
    message.fee = object.fee ?? 0;
    message.nonce = object.nonce ?? 0;
    message.validUntil = object.validUntil ?? 0;
    message.memo = object.memo ?? "";
    message.networkId = object.networkId ?? 0;
    message.networkPrefix = object.networkPrefix ?? new Uint8Array(0);
    message.source = object.source ?? "";
    return message;
  },
};

function createBaseMinaPayment(): MinaPayment {
  return { common: undefined, destination: "", amount: 0 };
}

export const MinaPayment = {
  encode(message: MinaPayment, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.common !== undefined) {
      MinaTxCommon.encode(message.common, writer.uint32(10).fork()).ldelim();
    }
    if (message.destination !== "") {
      writer.uint32(18).string(message.destination);
    }
    if (message.amount !== 0) {
      writer.uint32(24).uint64(message.amount);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): MinaPayment {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMinaPayment();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.common = MinaTxCommon.decode(reader, reader.uint32());
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.destination = reader.string();
          continue;
        case 3:
          if (tag !== 24) {
            break;
          }

          message.amount = longToNumber(reader.uint64() as Long);
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): MinaPayment {
    return {
      common: isSet(object.common) ? MinaTxCommon.fromJSON(object.common) : undefined,
      destination: isSet(object.destination) ? globalThis.String(object.destination) : "",
      amount: isSet(object.amount) ? globalThis.Number(object.amount) : 0,
    };
  },

  toJSON(message: MinaPayment): unknown {
    const obj: any = {};
    if (message.common !== undefined) {
      obj.common = MinaTxCommon.toJSON(message.common);
    }
    if (message.destination !== "") {
      obj.destination = message.destination;
    }
    if (message.amount !== 0) {
      obj.amount = Math.round(message.amount);
    }
    return obj;
  },

  create(base?: DeepPartial<MinaPayment>): MinaPayment {
    return MinaPayment.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<MinaPayment>): MinaPayment {
    const message = createBaseMinaPayment();
    message.common = (object.common !== undefined && object.common !== null)
      ? MinaTxCommon.fromPartial(object.common)
      : undefined;
    message.destination = object.destination ?? "";
    message.amount = object.amount ?? 0;
    return message;
  },
};

function createBaseMinaPaymentsRequest(): MinaPaymentsRequest {
  return { payments: [] };
}

export const MinaPaymentsRequest = {
  encode(message: MinaPaymentsRequest, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    for (const v of message.payments) {
      MinaPayment.encode(v!, writer.uint32(10).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): MinaPaymentsRequest {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMinaPaymentsRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.payments.push(MinaPayment.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): MinaPaymentsRequest {
    return {
      payments: globalThis.Array.isArray(object?.payments)
        ? object.payments.map((e: any) => MinaPayment.fromJSON(e))
        : [],
    };
  },

  toJSON(message: MinaPaymentsRequest): unknown {
    const obj: any = {};
    if (message.payments?.length) {
      obj.payments = message.payments.map((e) => MinaPayment.toJSON(e));
    }
    return obj;
  },

  create(base?: DeepPartial<MinaPaymentsRequest>): MinaPaymentsRequest {
    return MinaPaymentsRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<MinaPaymentsRequest>): MinaPaymentsRequest {
    const message = createBaseMinaPaymentsRequest();
    message.payments = object.payments?.map((e) => MinaPayment.fromPartial(e)) || [];
    return message;
  },
};

function createBaseMinaDelegationRequest(): MinaDelegationRequest {
  return { common: undefined, delegate: "" };
}

export const MinaDelegationRequest = {
  encode(message: MinaDelegationRequest, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.common !== undefined) {
      MinaTxCommon.encode(message.common, writer.uint32(10).fork()).ldelim();
    }
    if (message.delegate !== "") {
      writer.uint32(18).string(message.delegate);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): MinaDelegationRequest {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMinaDelegationRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.common = MinaTxCommon.decode(reader, reader.uint32());
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.delegate = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): MinaDelegationRequest {
    return {
      common: isSet(object.common) ? MinaTxCommon.fromJSON(object.common) : undefined,
      delegate: isSet(object.delegate) ? globalThis.String(object.delegate) : "",
    };
  },

  toJSON(message: MinaDelegationRequest): unknown {
    const obj: any = {};
    if (message.common !== undefined) {
      obj.common = MinaTxCommon.toJSON(message.common);
    }
    if (message.delegate !== "") {
      obj.delegate = message.delegate;
    }
    return obj;
  },

  create(base?: DeepPartial<MinaDelegationRequest>): MinaDelegationRequest {
    return MinaDelegationRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<MinaDelegationRequest>): MinaDelegationRequest {
    const message = createBaseMinaDelegationRequest();
    message.common = (object.common !== undefined && object.common !== null)
      ? MinaTxCommon.fromPartial(object.common)
      : undefined;
    message.delegate = object.delegate ?? "";
    return message;
  },
};

function createBaseMinaProofOfReserveRequest(): MinaProofOfReserveRequest {
  return { path: "", challenge: "" };
}

export const MinaProofOfReserveRequest = {
  encode(message: MinaProofOfReserveRequest, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.path !== "") {
      writer.uint32(10).string(message.path);
    }
    if (message.challenge !== "") {
      writer.uint32(18).string(message.challenge);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): MinaProofOfReserveRequest {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMinaProofOfReserveRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.path = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.challenge = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): MinaProofOfReserveRequest {
    return {
      path: isSet(object.path) ? globalThis.String(object.path) : "",
      challenge: isSet(object.challenge) ? globalThis.String(object.challenge) : "",
    };
  },

  toJSON(message: MinaProofOfReserveRequest): unknown {
    const obj: any = {};
    if (message.path !== "") {
      obj.path = message.path;
    }
    if (message.challenge !== "") {
      obj.challenge = message.challenge;
    }
    return obj;
  },

  create(base?: DeepPartial<MinaProofOfReserveRequest>): MinaProofOfReserveRequest {
    return MinaProofOfReserveRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<MinaProofOfReserveRequest>): MinaProofOfReserveRequest {
    const message = createBaseMinaProofOfReserveRequest();
    message.path = object.path ?? "";
    message.challenge = object.challenge ?? "";
    return message;
  },
};

function createBaseTRONAddressRequest(): TRONAddressRequest {
  return { path: "" };
}

export const TRONAddressRequest = {
  encode(message: TRONAddressRequest, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.path !== "") {
      writer.uint32(10).string(message.path);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): TRONAddressRequest {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseTRONAddressRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.path = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): TRONAddressRequest {
    return { path: isSet(object.path) ? globalThis.String(object.path) : "" };
  },

  toJSON(message: TRONAddressRequest): unknown {
    const obj: any = {};
    if (message.path !== "") {
      obj.path = message.path;
    }
    return obj;
  },

  create(base?: DeepPartial<TRONAddressRequest>): TRONAddressRequest {
    return TRONAddressRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<TRONAddressRequest>): TRONAddressRequest {
    const message = createBaseTRONAddressRequest();
    message.path = object.path ?? "";
    return message;
  },
};

function createBaseTRONProofOfReserveRequest(): TRONProofOfReserveRequest {
  return { path: "", challenge: "" };
}

export const TRONProofOfReserveRequest = {
  encode(message: TRONProofOfReserveRequest, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.path !== "") {
      writer.uint32(10).string(message.path);
    }
    if (message.challenge !== "") {
      writer.uint32(18).string(message.challenge);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): TRONProofOfReserveRequest {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseTRONProofOfReserveRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.path = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.challenge = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): TRONProofOfReserveRequest {
    return {
      path: isSet(object.path) ? globalThis.String(object.path) : "",
      challenge: isSet(object.challenge) ? globalThis.String(object.challenge) : "",
    };
  },

  toJSON(message: TRONProofOfReserveRequest): unknown {
    const obj: any = {};
    if (message.path !== "") {
      obj.path = message.path;
    }
    if (message.challenge !== "") {
      obj.challenge = message.challenge;
    }
    return obj;
  },

  create(base?: DeepPartial<TRONProofOfReserveRequest>): TRONProofOfReserveRequest {
    return TRONProofOfReserveRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<TRONProofOfReserveRequest>): TRONProofOfReserveRequest {
    const message = createBaseTRONProofOfReserveRequest();
    message.path = object.path ?? "";
    message.challenge = object.challenge ?? "";
    return message;
  },
};

function createBaseTRONTransactionsRequest(): TRONTransactionsRequest {
  return { kind: 0, transactions: [] };
}

export const TRONTransactionsRequest = {
  encode(message: TRONTransactionsRequest, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.kind !== 0) {
      writer.uint32(8).int32(message.kind);
    }
    for (const v of message.transactions) {
      TRONTransaction.encode(v!, writer.uint32(18).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): TRONTransactionsRequest {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseTRONTransactionsRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.kind = reader.int32() as any;
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.transactions.push(TRONTransaction.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): TRONTransactionsRequest {
    return {
      kind: isSet(object.kind) ? tRONTransactionsRequest_OperationKindFromJSON(object.kind) : 0,
      transactions: globalThis.Array.isArray(object?.transactions)
        ? object.transactions.map((e: any) => TRONTransaction.fromJSON(e))
        : [],
    };
  },

  toJSON(message: TRONTransactionsRequest): unknown {
    const obj: any = {};
    if (message.kind !== 0) {
      obj.kind = tRONTransactionsRequest_OperationKindToJSON(message.kind);
    }
    if (message.transactions?.length) {
      obj.transactions = message.transactions.map((e) => TRONTransaction.toJSON(e));
    }
    return obj;
  },

  create(base?: DeepPartial<TRONTransactionsRequest>): TRONTransactionsRequest {
    return TRONTransactionsRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<TRONTransactionsRequest>): TRONTransactionsRequest {
    const message = createBaseTRONTransactionsRequest();
    message.kind = object.kind ?? 0;
    message.transactions = object.transactions?.map((e) => TRONTransaction.fromPartial(e)) || [];
    return message;
  },
};

function createBaseTRONTransaction(): TRONTransaction {
  return {
    id: "",
    source: "",
    refBlockBytes: new Uint8Array(0),
    refBlockHash: new Uint8Array(0),
    expiration: 0,
    timestamp: 0,
    feeLimit: 0,
    data: new Uint8Array(0),
    operation: new Uint8Array(0),
  };
}

export const TRONTransaction = {
  encode(message: TRONTransaction, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.id !== "") {
      writer.uint32(10).string(message.id);
    }
    if (message.source !== "") {
      writer.uint32(18).string(message.source);
    }
    if (message.refBlockBytes.length !== 0) {
      writer.uint32(26).bytes(message.refBlockBytes);
    }
    if (message.refBlockHash.length !== 0) {
      writer.uint32(34).bytes(message.refBlockHash);
    }
    if (message.expiration !== 0) {
      writer.uint32(40).int64(message.expiration);
    }
    if (message.timestamp !== 0) {
      writer.uint32(48).int64(message.timestamp);
    }
    if (message.feeLimit !== 0) {
      writer.uint32(56).int64(message.feeLimit);
    }
    if (message.data.length !== 0) {
      writer.uint32(66).bytes(message.data);
    }
    if (message.operation.length !== 0) {
      writer.uint32(74).bytes(message.operation);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): TRONTransaction {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseTRONTransaction();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.id = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.source = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.refBlockBytes = reader.bytes();
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.refBlockHash = reader.bytes();
          continue;
        case 5:
          if (tag !== 40) {
            break;
          }

          message.expiration = longToNumber(reader.int64() as Long);
          continue;
        case 6:
          if (tag !== 48) {
            break;
          }

          message.timestamp = longToNumber(reader.int64() as Long);
          continue;
        case 7:
          if (tag !== 56) {
            break;
          }

          message.feeLimit = longToNumber(reader.int64() as Long);
          continue;
        case 8:
          if (tag !== 66) {
            break;
          }

          message.data = reader.bytes();
          continue;
        case 9:
          if (tag !== 74) {
            break;
          }

          message.operation = reader.bytes();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): TRONTransaction {
    return {
      id: isSet(object.id) ? globalThis.String(object.id) : "",
      source: isSet(object.source) ? globalThis.String(object.source) : "",
      refBlockBytes: isSet(object.refBlockBytes) ? bytesFromBase64(object.refBlockBytes) : new Uint8Array(0),
      refBlockHash: isSet(object.refBlockHash) ? bytesFromBase64(object.refBlockHash) : new Uint8Array(0),
      expiration: isSet(object.expiration) ? globalThis.Number(object.expiration) : 0,
      timestamp: isSet(object.timestamp) ? globalThis.Number(object.timestamp) : 0,
      feeLimit: isSet(object.feeLimit) ? globalThis.Number(object.feeLimit) : 0,
      data: isSet(object.data) ? bytesFromBase64(object.data) : new Uint8Array(0),
      operation: isSet(object.operation) ? bytesFromBase64(object.operation) : new Uint8Array(0),
    };
  },

  toJSON(message: TRONTransaction): unknown {
    const obj: any = {};
    if (message.id !== "") {
      obj.id = message.id;
    }
    if (message.source !== "") {
      obj.source = message.source;
    }
    if (message.refBlockBytes.length !== 0) {
      obj.refBlockBytes = base64FromBytes(message.refBlockBytes);
    }
    if (message.refBlockHash.length !== 0) {
      obj.refBlockHash = base64FromBytes(message.refBlockHash);
    }
    if (message.expiration !== 0) {
      obj.expiration = Math.round(message.expiration);
    }
    if (message.timestamp !== 0) {
      obj.timestamp = Math.round(message.timestamp);
    }
    if (message.feeLimit !== 0) {
      obj.feeLimit = Math.round(message.feeLimit);
    }
    if (message.data.length !== 0) {
      obj.data = base64FromBytes(message.data);
    }
    if (message.operation.length !== 0) {
      obj.operation = base64FromBytes(message.operation);
    }
    return obj;
  },

  create(base?: DeepPartial<TRONTransaction>): TRONTransaction {
    return TRONTransaction.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<TRONTransaction>): TRONTransaction {
    const message = createBaseTRONTransaction();
    message.id = object.id ?? "";
    message.source = object.source ?? "";
    message.refBlockBytes = object.refBlockBytes ?? new Uint8Array(0);
    message.refBlockHash = object.refBlockHash ?? new Uint8Array(0);
    message.expiration = object.expiration ?? 0;
    message.timestamp = object.timestamp ?? 0;
    message.feeLimit = object.feeLimit ?? 0;
    message.data = object.data ?? new Uint8Array(0);
    message.operation = object.operation ?? new Uint8Array(0);
    return message;
  },
};

function createBaseTRONTransactionsResponse(): TRONTransactionsResponse {
  return { transactions: [] };
}

export const TRONTransactionsResponse = {
  encode(message: TRONTransactionsResponse, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    for (const v of message.transactions) {
      TRONTransactionsResponse_TRONTransactionResponse.encode(v!, writer.uint32(10).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): TRONTransactionsResponse {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseTRONTransactionsResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.transactions.push(TRONTransactionsResponse_TRONTransactionResponse.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): TRONTransactionsResponse {
    return {
      transactions: globalThis.Array.isArray(object?.transactions)
        ? object.transactions.map((e: any) => TRONTransactionsResponse_TRONTransactionResponse.fromJSON(e))
        : [],
    };
  },

  toJSON(message: TRONTransactionsResponse): unknown {
    const obj: any = {};
    if (message.transactions?.length) {
      obj.transactions = message.transactions.map((e) => TRONTransactionsResponse_TRONTransactionResponse.toJSON(e));
    }
    return obj;
  },

  create(base?: DeepPartial<TRONTransactionsResponse>): TRONTransactionsResponse {
    return TRONTransactionsResponse.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<TRONTransactionsResponse>): TRONTransactionsResponse {
    const message = createBaseTRONTransactionsResponse();
    message.transactions =
      object.transactions?.map((e) => TRONTransactionsResponse_TRONTransactionResponse.fromPartial(e)) || [];
    return message;
  },
};

function createBaseTRONTransactionsResponse_TRONTransactionResponse(): TRONTransactionsResponse_TRONTransactionResponse {
  return { id: "", transaction: "", publicKey: new Uint8Array(0) };
}

export const TRONTransactionsResponse_TRONTransactionResponse = {
  encode(
    message: TRONTransactionsResponse_TRONTransactionResponse,
    writer: _m0.Writer = _m0.Writer.create(),
  ): _m0.Writer {
    if (message.id !== "") {
      writer.uint32(10).string(message.id);
    }
    if (message.transaction !== "") {
      writer.uint32(18).string(message.transaction);
    }
    if (message.publicKey.length !== 0) {
      writer.uint32(26).bytes(message.publicKey);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): TRONTransactionsResponse_TRONTransactionResponse {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseTRONTransactionsResponse_TRONTransactionResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.id = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.transaction = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.publicKey = reader.bytes();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): TRONTransactionsResponse_TRONTransactionResponse {
    return {
      id: isSet(object.id) ? globalThis.String(object.id) : "",
      transaction: isSet(object.transaction) ? globalThis.String(object.transaction) : "",
      publicKey: isSet(object.publicKey) ? bytesFromBase64(object.publicKey) : new Uint8Array(0),
    };
  },

  toJSON(message: TRONTransactionsResponse_TRONTransactionResponse): unknown {
    const obj: any = {};
    if (message.id !== "") {
      obj.id = message.id;
    }
    if (message.transaction !== "") {
      obj.transaction = message.transaction;
    }
    if (message.publicKey.length !== 0) {
      obj.publicKey = base64FromBytes(message.publicKey);
    }
    return obj;
  },

  create(
    base?: DeepPartial<TRONTransactionsResponse_TRONTransactionResponse>,
  ): TRONTransactionsResponse_TRONTransactionResponse {
    return TRONTransactionsResponse_TRONTransactionResponse.fromPartial(base ?? {});
  },
  fromPartial(
    object: DeepPartial<TRONTransactionsResponse_TRONTransactionResponse>,
  ): TRONTransactionsResponse_TRONTransactionResponse {
    const message = createBaseTRONTransactionsResponse_TRONTransactionResponse();
    message.id = object.id ?? "";
    message.transaction = object.transaction ?? "";
    message.publicKey = object.publicKey ?? new Uint8Array(0);
    return message;
  },
};

function createBaseFilecoinTransactionsRequest(): FilecoinTransactionsRequest {
  return { transactions: [] };
}

export const FilecoinTransactionsRequest = {
  encode(message: FilecoinTransactionsRequest, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    for (const v of message.transactions) {
      FilecoinTransaction.encode(v!, writer.uint32(10).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): FilecoinTransactionsRequest {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseFilecoinTransactionsRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.transactions.push(FilecoinTransaction.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): FilecoinTransactionsRequest {
    return {
      transactions: globalThis.Array.isArray(object?.transactions)
        ? object.transactions.map((e: any) => FilecoinTransaction.fromJSON(e))
        : [],
    };
  },

  toJSON(message: FilecoinTransactionsRequest): unknown {
    const obj: any = {};
    if (message.transactions?.length) {
      obj.transactions = message.transactions.map((e) => FilecoinTransaction.toJSON(e));
    }
    return obj;
  },

  create(base?: DeepPartial<FilecoinTransactionsRequest>): FilecoinTransactionsRequest {
    return FilecoinTransactionsRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<FilecoinTransactionsRequest>): FilecoinTransactionsRequest {
    const message = createBaseFilecoinTransactionsRequest();
    message.transactions = object.transactions?.map((e) => FilecoinTransaction.fromPartial(e)) || [];
    return message;
  },
};

function createBaseFilecoinTransaction(): FilecoinTransaction {
  return {
    id: "",
    from: "",
    addressType: 0,
    to: "",
    nonce: 0,
    amount: new Uint8Array(0),
    gasLimit: 0,
    gasFeeCap: new Uint8Array(0),
    gasPremium: new Uint8Array(0),
    isNonceSet: false,
  };
}

export const FilecoinTransaction = {
  encode(message: FilecoinTransaction, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.id !== "") {
      writer.uint32(10).string(message.id);
    }
    if (message.from !== "") {
      writer.uint32(18).string(message.from);
    }
    if (message.addressType !== 0) {
      writer.uint32(24).int32(message.addressType);
    }
    if (message.to !== "") {
      writer.uint32(34).string(message.to);
    }
    if (message.nonce !== 0) {
      writer.uint32(40).uint64(message.nonce);
    }
    if (message.amount.length !== 0) {
      writer.uint32(50).bytes(message.amount);
    }
    if (message.gasLimit !== 0) {
      writer.uint32(56).uint64(message.gasLimit);
    }
    if (message.gasFeeCap.length !== 0) {
      writer.uint32(66).bytes(message.gasFeeCap);
    }
    if (message.gasPremium.length !== 0) {
      writer.uint32(74).bytes(message.gasPremium);
    }
    if (message.isNonceSet !== false) {
      writer.uint32(80).bool(message.isNonceSet);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): FilecoinTransaction {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseFilecoinTransaction();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.id = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.from = reader.string();
          continue;
        case 3:
          if (tag !== 24) {
            break;
          }

          message.addressType = reader.int32() as any;
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.to = reader.string();
          continue;
        case 5:
          if (tag !== 40) {
            break;
          }

          message.nonce = longToNumber(reader.uint64() as Long);
          continue;
        case 6:
          if (tag !== 50) {
            break;
          }

          message.amount = reader.bytes();
          continue;
        case 7:
          if (tag !== 56) {
            break;
          }

          message.gasLimit = longToNumber(reader.uint64() as Long);
          continue;
        case 8:
          if (tag !== 66) {
            break;
          }

          message.gasFeeCap = reader.bytes();
          continue;
        case 9:
          if (tag !== 74) {
            break;
          }

          message.gasPremium = reader.bytes();
          continue;
        case 10:
          if (tag !== 80) {
            break;
          }

          message.isNonceSet = reader.bool();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): FilecoinTransaction {
    return {
      id: isSet(object.id) ? globalThis.String(object.id) : "",
      from: isSet(object.from) ? globalThis.String(object.from) : "",
      addressType: isSet(object.addressType) ? filecoinAddressTypeFromJSON(object.addressType) : 0,
      to: isSet(object.to) ? globalThis.String(object.to) : "",
      nonce: isSet(object.nonce) ? globalThis.Number(object.nonce) : 0,
      amount: isSet(object.amount) ? bytesFromBase64(object.amount) : new Uint8Array(0),
      gasLimit: isSet(object.gasLimit) ? globalThis.Number(object.gasLimit) : 0,
      gasFeeCap: isSet(object.gasFeeCap) ? bytesFromBase64(object.gasFeeCap) : new Uint8Array(0),
      gasPremium: isSet(object.gasPremium) ? bytesFromBase64(object.gasPremium) : new Uint8Array(0),
      isNonceSet: isSet(object.isNonceSet) ? globalThis.Boolean(object.isNonceSet) : false,
    };
  },

  toJSON(message: FilecoinTransaction): unknown {
    const obj: any = {};
    if (message.id !== "") {
      obj.id = message.id;
    }
    if (message.from !== "") {
      obj.from = message.from;
    }
    if (message.addressType !== 0) {
      obj.addressType = filecoinAddressTypeToJSON(message.addressType);
    }
    if (message.to !== "") {
      obj.to = message.to;
    }
    if (message.nonce !== 0) {
      obj.nonce = Math.round(message.nonce);
    }
    if (message.amount.length !== 0) {
      obj.amount = base64FromBytes(message.amount);
    }
    if (message.gasLimit !== 0) {
      obj.gasLimit = Math.round(message.gasLimit);
    }
    if (message.gasFeeCap.length !== 0) {
      obj.gasFeeCap = base64FromBytes(message.gasFeeCap);
    }
    if (message.gasPremium.length !== 0) {
      obj.gasPremium = base64FromBytes(message.gasPremium);
    }
    if (message.isNonceSet !== false) {
      obj.isNonceSet = message.isNonceSet;
    }
    return obj;
  },

  create(base?: DeepPartial<FilecoinTransaction>): FilecoinTransaction {
    return FilecoinTransaction.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<FilecoinTransaction>): FilecoinTransaction {
    const message = createBaseFilecoinTransaction();
    message.id = object.id ?? "";
    message.from = object.from ?? "";
    message.addressType = object.addressType ?? 0;
    message.to = object.to ?? "";
    message.nonce = object.nonce ?? 0;
    message.amount = object.amount ?? new Uint8Array(0);
    message.gasLimit = object.gasLimit ?? 0;
    message.gasFeeCap = object.gasFeeCap ?? new Uint8Array(0);
    message.gasPremium = object.gasPremium ?? new Uint8Array(0);
    message.isNonceSet = object.isNonceSet ?? false;
    return message;
  },
};

function createBaseFilecoinAddressRequest(): FilecoinAddressRequest {
  return { path: "", addressType: 0 };
}

export const FilecoinAddressRequest = {
  encode(message: FilecoinAddressRequest, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.path !== "") {
      writer.uint32(10).string(message.path);
    }
    if (message.addressType !== 0) {
      writer.uint32(16).int32(message.addressType);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): FilecoinAddressRequest {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseFilecoinAddressRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.path = reader.string();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.addressType = reader.int32() as any;
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): FilecoinAddressRequest {
    return {
      path: isSet(object.path) ? globalThis.String(object.path) : "",
      addressType: isSet(object.addressType) ? filecoinAddressTypeFromJSON(object.addressType) : 0,
    };
  },

  toJSON(message: FilecoinAddressRequest): unknown {
    const obj: any = {};
    if (message.path !== "") {
      obj.path = message.path;
    }
    if (message.addressType !== 0) {
      obj.addressType = filecoinAddressTypeToJSON(message.addressType);
    }
    return obj;
  },

  create(base?: DeepPartial<FilecoinAddressRequest>): FilecoinAddressRequest {
    return FilecoinAddressRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<FilecoinAddressRequest>): FilecoinAddressRequest {
    const message = createBaseFilecoinAddressRequest();
    message.path = object.path ?? "";
    message.addressType = object.addressType ?? 0;
    return message;
  },
};

function createBaseFilecoinProofOfReserveRequest(): FilecoinProofOfReserveRequest {
  return { path: "", addressType: 0, challenge: "" };
}

export const FilecoinProofOfReserveRequest = {
  encode(message: FilecoinProofOfReserveRequest, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.path !== "") {
      writer.uint32(10).string(message.path);
    }
    if (message.addressType !== 0) {
      writer.uint32(16).int32(message.addressType);
    }
    if (message.challenge !== "") {
      writer.uint32(26).string(message.challenge);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): FilecoinProofOfReserveRequest {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseFilecoinProofOfReserveRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.path = reader.string();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.addressType = reader.int32() as any;
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.challenge = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): FilecoinProofOfReserveRequest {
    return {
      path: isSet(object.path) ? globalThis.String(object.path) : "",
      addressType: isSet(object.addressType) ? filecoinAddressTypeFromJSON(object.addressType) : 0,
      challenge: isSet(object.challenge) ? globalThis.String(object.challenge) : "",
    };
  },

  toJSON(message: FilecoinProofOfReserveRequest): unknown {
    const obj: any = {};
    if (message.path !== "") {
      obj.path = message.path;
    }
    if (message.addressType !== 0) {
      obj.addressType = filecoinAddressTypeToJSON(message.addressType);
    }
    if (message.challenge !== "") {
      obj.challenge = message.challenge;
    }
    return obj;
  },

  create(base?: DeepPartial<FilecoinProofOfReserveRequest>): FilecoinProofOfReserveRequest {
    return FilecoinProofOfReserveRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<FilecoinProofOfReserveRequest>): FilecoinProofOfReserveRequest {
    const message = createBaseFilecoinProofOfReserveRequest();
    message.path = object.path ?? "";
    message.addressType = object.addressType ?? 0;
    message.challenge = object.challenge ?? "";
    return message;
  },
};

function createBaseFilecoinTransactionsResponse(): FilecoinTransactionsResponse {
  return { transactions: [] };
}

export const FilecoinTransactionsResponse = {
  encode(message: FilecoinTransactionsResponse, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    for (const v of message.transactions) {
      FilecoinTransactionsResponse_FilecoinTransactionResponse.encode(v!, writer.uint32(10).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): FilecoinTransactionsResponse {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseFilecoinTransactionsResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.transactions.push(
            FilecoinTransactionsResponse_FilecoinTransactionResponse.decode(reader, reader.uint32()),
          );
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): FilecoinTransactionsResponse {
    return {
      transactions: globalThis.Array.isArray(object?.transactions)
        ? object.transactions.map((e: any) => FilecoinTransactionsResponse_FilecoinTransactionResponse.fromJSON(e))
        : [],
    };
  },

  toJSON(message: FilecoinTransactionsResponse): unknown {
    const obj: any = {};
    if (message.transactions?.length) {
      obj.transactions = message.transactions.map((e) =>
        FilecoinTransactionsResponse_FilecoinTransactionResponse.toJSON(e)
      );
    }
    return obj;
  },

  create(base?: DeepPartial<FilecoinTransactionsResponse>): FilecoinTransactionsResponse {
    return FilecoinTransactionsResponse.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<FilecoinTransactionsResponse>): FilecoinTransactionsResponse {
    const message = createBaseFilecoinTransactionsResponse();
    message.transactions =
      object.transactions?.map((e) => FilecoinTransactionsResponse_FilecoinTransactionResponse.fromPartial(e)) || [];
    return message;
  },
};

function createBaseFilecoinTransactionsResponse_FilecoinTransactionResponse(): FilecoinTransactionsResponse_FilecoinTransactionResponse {
  return { id: "", transaction: "", publicKey: new Uint8Array(0) };
}

export const FilecoinTransactionsResponse_FilecoinTransactionResponse = {
  encode(
    message: FilecoinTransactionsResponse_FilecoinTransactionResponse,
    writer: _m0.Writer = _m0.Writer.create(),
  ): _m0.Writer {
    if (message.id !== "") {
      writer.uint32(10).string(message.id);
    }
    if (message.transaction !== "") {
      writer.uint32(18).string(message.transaction);
    }
    if (message.publicKey.length !== 0) {
      writer.uint32(26).bytes(message.publicKey);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): FilecoinTransactionsResponse_FilecoinTransactionResponse {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseFilecoinTransactionsResponse_FilecoinTransactionResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.id = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.transaction = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.publicKey = reader.bytes();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): FilecoinTransactionsResponse_FilecoinTransactionResponse {
    return {
      id: isSet(object.id) ? globalThis.String(object.id) : "",
      transaction: isSet(object.transaction) ? globalThis.String(object.transaction) : "",
      publicKey: isSet(object.publicKey) ? bytesFromBase64(object.publicKey) : new Uint8Array(0),
    };
  },

  toJSON(message: FilecoinTransactionsResponse_FilecoinTransactionResponse): unknown {
    const obj: any = {};
    if (message.id !== "") {
      obj.id = message.id;
    }
    if (message.transaction !== "") {
      obj.transaction = message.transaction;
    }
    if (message.publicKey.length !== 0) {
      obj.publicKey = base64FromBytes(message.publicKey);
    }
    return obj;
  },

  create(
    base?: DeepPartial<FilecoinTransactionsResponse_FilecoinTransactionResponse>,
  ): FilecoinTransactionsResponse_FilecoinTransactionResponse {
    return FilecoinTransactionsResponse_FilecoinTransactionResponse.fromPartial(base ?? {});
  },
  fromPartial(
    object: DeepPartial<FilecoinTransactionsResponse_FilecoinTransactionResponse>,
  ): FilecoinTransactionsResponse_FilecoinTransactionResponse {
    const message = createBaseFilecoinTransactionsResponse_FilecoinTransactionResponse();
    message.id = object.id ?? "";
    message.transaction = object.transaction ?? "";
    message.publicKey = object.publicKey ?? new Uint8Array(0);
    return message;
  },
};

function createBaseUser(): User {
  return { id: "", publicKey: "", roles: [], properties: {} };
}

export const User = {
  encode(message: User, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.id !== "") {
      writer.uint32(10).string(message.id);
    }
    if (message.publicKey !== "") {
      writer.uint32(18).string(message.publicKey);
    }
    writer.uint32(26).fork();
    for (const v of message.roles) {
      writer.int32(v);
    }
    writer.ldelim();
    Object.entries(message.properties).forEach(([key, value]) => {
      User_PropertiesEntry.encode({ key: key as any, value }, writer.uint32(34).fork()).ldelim();
    });
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): User {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseUser();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.id = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.publicKey = reader.string();
          continue;
        case 3:
          if (tag === 24) {
            message.roles.push(reader.int32() as any);

            continue;
          }

          if (tag === 26) {
            const end2 = reader.uint32() + reader.pos;
            while (reader.pos < end2) {
              message.roles.push(reader.int32() as any);
            }

            continue;
          }

          break;
        case 4:
          if (tag !== 34) {
            break;
          }

          const entry4 = User_PropertiesEntry.decode(reader, reader.uint32());
          if (entry4.value !== undefined) {
            message.properties[entry4.key] = entry4.value;
          }
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): User {
    return {
      id: isSet(object.id) ? globalThis.String(object.id) : "",
      publicKey: isSet(object.publicKey) ? globalThis.String(object.publicKey) : "",
      roles: globalThis.Array.isArray(object?.roles) ? object.roles.map((e: any) => roleFromJSON(e)) : [],
      properties: isObject(object.properties)
        ? Object.entries(object.properties).reduce<{ [key: string]: Uint8Array }>((acc, [key, value]) => {
          acc[key] = bytesFromBase64(value as string);
          return acc;
        }, {})
        : {},
    };
  },

  toJSON(message: User): unknown {
    const obj: any = {};
    if (message.id !== "") {
      obj.id = message.id;
    }
    if (message.publicKey !== "") {
      obj.publicKey = message.publicKey;
    }
    if (message.roles?.length) {
      obj.roles = message.roles.map((e) => roleToJSON(e));
    }
    if (message.properties) {
      const entries = Object.entries(message.properties);
      if (entries.length > 0) {
        obj.properties = {};
        entries.forEach(([k, v]) => {
          obj.properties[k] = base64FromBytes(v);
        });
      }
    }
    return obj;
  },

  create(base?: DeepPartial<User>): User {
    return User.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<User>): User {
    const message = createBaseUser();
    message.id = object.id ?? "";
    message.publicKey = object.publicKey ?? "";
    message.roles = object.roles?.map((e) => e) || [];
    message.properties = Object.entries(object.properties ?? {}).reduce<{ [key: string]: Uint8Array }>(
      (acc, [key, value]) => {
        if (value !== undefined) {
          acc[key] = value;
        }
        return acc;
      },
      {},
    );
    return message;
  },
};

function createBaseUser_PropertiesEntry(): User_PropertiesEntry {
  return { key: "", value: new Uint8Array(0) };
}

export const User_PropertiesEntry = {
  encode(message: User_PropertiesEntry, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.key !== "") {
      writer.uint32(10).string(message.key);
    }
    if (message.value.length !== 0) {
      writer.uint32(18).bytes(message.value);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): User_PropertiesEntry {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseUser_PropertiesEntry();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.key = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.value = reader.bytes();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): User_PropertiesEntry {
    return {
      key: isSet(object.key) ? globalThis.String(object.key) : "",
      value: isSet(object.value) ? bytesFromBase64(object.value) : new Uint8Array(0),
    };
  },

  toJSON(message: User_PropertiesEntry): unknown {
    const obj: any = {};
    if (message.key !== "") {
      obj.key = message.key;
    }
    if (message.value.length !== 0) {
      obj.value = base64FromBytes(message.value);
    }
    return obj;
  },

  create(base?: DeepPartial<User_PropertiesEntry>): User_PropertiesEntry {
    return User_PropertiesEntry.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<User_PropertiesEntry>): User_PropertiesEntry {
    const message = createBaseUser_PropertiesEntry();
    message.key = object.key ?? "";
    message.value = object.value ?? new Uint8Array(0);
    return message;
  },
};

function createBaseGroup(): Group {
  return { id: "", userIds: [], properties: {} };
}

export const Group = {
  encode(message: Group, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.id !== "") {
      writer.uint32(10).string(message.id);
    }
    for (const v of message.userIds) {
      writer.uint32(18).string(v!);
    }
    Object.entries(message.properties).forEach(([key, value]) => {
      Group_PropertiesEntry.encode({ key: key as any, value }, writer.uint32(26).fork()).ldelim();
    });
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): Group {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGroup();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.id = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.userIds.push(reader.string());
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          const entry3 = Group_PropertiesEntry.decode(reader, reader.uint32());
          if (entry3.value !== undefined) {
            message.properties[entry3.key] = entry3.value;
          }
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Group {
    return {
      id: isSet(object.id) ? globalThis.String(object.id) : "",
      userIds: globalThis.Array.isArray(object?.userIds) ? object.userIds.map((e: any) => globalThis.String(e)) : [],
      properties: isObject(object.properties)
        ? Object.entries(object.properties).reduce<{ [key: string]: Uint8Array }>((acc, [key, value]) => {
          acc[key] = bytesFromBase64(value as string);
          return acc;
        }, {})
        : {},
    };
  },

  toJSON(message: Group): unknown {
    const obj: any = {};
    if (message.id !== "") {
      obj.id = message.id;
    }
    if (message.userIds?.length) {
      obj.userIds = message.userIds;
    }
    if (message.properties) {
      const entries = Object.entries(message.properties);
      if (entries.length > 0) {
        obj.properties = {};
        entries.forEach(([k, v]) => {
          obj.properties[k] = base64FromBytes(v);
        });
      }
    }
    return obj;
  },

  create(base?: DeepPartial<Group>): Group {
    return Group.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<Group>): Group {
    const message = createBaseGroup();
    message.id = object.id ?? "";
    message.userIds = object.userIds?.map((e) => e) || [];
    message.properties = Object.entries(object.properties ?? {}).reduce<{ [key: string]: Uint8Array }>(
      (acc, [key, value]) => {
        if (value !== undefined) {
          acc[key] = value;
        }
        return acc;
      },
      {},
    );
    return message;
  },
};

function createBaseGroup_PropertiesEntry(): Group_PropertiesEntry {
  return { key: "", value: new Uint8Array(0) };
}

export const Group_PropertiesEntry = {
  encode(message: Group_PropertiesEntry, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.key !== "") {
      writer.uint32(10).string(message.key);
    }
    if (message.value.length !== 0) {
      writer.uint32(18).bytes(message.value);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): Group_PropertiesEntry {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGroup_PropertiesEntry();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.key = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.value = reader.bytes();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Group_PropertiesEntry {
    return {
      key: isSet(object.key) ? globalThis.String(object.key) : "",
      value: isSet(object.value) ? bytesFromBase64(object.value) : new Uint8Array(0),
    };
  },

  toJSON(message: Group_PropertiesEntry): unknown {
    const obj: any = {};
    if (message.key !== "") {
      obj.key = message.key;
    }
    if (message.value.length !== 0) {
      obj.value = base64FromBytes(message.value);
    }
    return obj;
  },

  create(base?: DeepPartial<Group_PropertiesEntry>): Group_PropertiesEntry {
    return Group_PropertiesEntry.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<Group_PropertiesEntry>): Group_PropertiesEntry {
    const message = createBaseGroup_PropertiesEntry();
    message.key = object.key ?? "";
    message.value = object.value ?? new Uint8Array(0);
    return message;
  },
};

function createBaseRuleSourceInternalWallet(): RuleSourceInternalWallet {
  return { path: "" };
}

export const RuleSourceInternalWallet = {
  encode(message: RuleSourceInternalWallet, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.path !== "") {
      writer.uint32(10).string(message.path);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): RuleSourceInternalWallet {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseRuleSourceInternalWallet();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.path = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): RuleSourceInternalWallet {
    return { path: isSet(object.path) ? globalThis.String(object.path) : "" };
  },

  toJSON(message: RuleSourceInternalWallet): unknown {
    const obj: any = {};
    if (message.path !== "") {
      obj.path = message.path;
    }
    return obj;
  },

  create(base?: DeepPartial<RuleSourceInternalWallet>): RuleSourceInternalWallet {
    return RuleSourceInternalWallet.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<RuleSourceInternalWallet>): RuleSourceInternalWallet {
    const message = createBaseRuleSourceInternalWallet();
    message.path = object.path ?? "";
    return message;
  },
};

function createBaseRuleSourceInternalAddress(): RuleSourceInternalAddress {
  return { address: "", path: "" };
}

export const RuleSourceInternalAddress = {
  encode(message: RuleSourceInternalAddress, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.address !== "") {
      writer.uint32(10).string(message.address);
    }
    if (message.path !== "") {
      writer.uint32(18).string(message.path);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): RuleSourceInternalAddress {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseRuleSourceInternalAddress();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.address = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.path = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): RuleSourceInternalAddress {
    return {
      address: isSet(object.address) ? globalThis.String(object.address) : "",
      path: isSet(object.path) ? globalThis.String(object.path) : "",
    };
  },

  toJSON(message: RuleSourceInternalAddress): unknown {
    const obj: any = {};
    if (message.address !== "") {
      obj.address = message.address;
    }
    if (message.path !== "") {
      obj.path = message.path;
    }
    return obj;
  },

  create(base?: DeepPartial<RuleSourceInternalAddress>): RuleSourceInternalAddress {
    return RuleSourceInternalAddress.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<RuleSourceInternalAddress>): RuleSourceInternalAddress {
    const message = createBaseRuleSourceInternalAddress();
    message.address = object.address ?? "";
    message.path = object.path ?? "";
    return message;
  },
};

function createBaseRuleSourceExchange(): RuleSourceExchange {
  return { label: "" };
}

export const RuleSourceExchange = {
  encode(message: RuleSourceExchange, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.label !== "") {
      writer.uint32(10).string(message.label);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): RuleSourceExchange {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseRuleSourceExchange();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.label = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): RuleSourceExchange {
    return { label: isSet(object.label) ? globalThis.String(object.label) : "" };
  },

  toJSON(message: RuleSourceExchange): unknown {
    const obj: any = {};
    if (message.label !== "") {
      obj.label = message.label;
    }
    return obj;
  },

  create(base?: DeepPartial<RuleSourceExchange>): RuleSourceExchange {
    return RuleSourceExchange.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<RuleSourceExchange>): RuleSourceExchange {
    const message = createBaseRuleSourceExchange();
    message.label = object.label ?? "";
    return message;
  },
};

function createBaseRuleSourceExternalAddress(): RuleSourceExternalAddress {
  return { address: "", memo: "" };
}

export const RuleSourceExternalAddress = {
  encode(message: RuleSourceExternalAddress, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.address !== "") {
      writer.uint32(10).string(message.address);
    }
    if (message.memo !== "") {
      writer.uint32(18).string(message.memo);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): RuleSourceExternalAddress {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseRuleSourceExternalAddress();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.address = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.memo = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): RuleSourceExternalAddress {
    return {
      address: isSet(object.address) ? globalThis.String(object.address) : "",
      memo: isSet(object.memo) ? globalThis.String(object.memo) : "",
    };
  },

  toJSON(message: RuleSourceExternalAddress): unknown {
    const obj: any = {};
    if (message.address !== "") {
      obj.address = message.address;
    }
    if (message.memo !== "") {
      obj.memo = message.memo;
    }
    return obj;
  },

  create(base?: DeepPartial<RuleSourceExternalAddress>): RuleSourceExternalAddress {
    return RuleSourceExternalAddress.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<RuleSourceExternalAddress>): RuleSourceExternalAddress {
    const message = createBaseRuleSourceExternalAddress();
    message.address = object.address ?? "";
    message.memo = object.memo ?? "";
    return message;
  },
};

function createBaseRuleSource(): RuleSource {
  return { type: 0, payload: new Uint8Array(0) };
}

export const RuleSource = {
  encode(message: RuleSource, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.type !== 0) {
      writer.uint32(8).int32(message.type);
    }
    if (message.payload.length !== 0) {
      writer.uint32(18).bytes(message.payload);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): RuleSource {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseRuleSource();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.type = reader.int32() as any;
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.payload = reader.bytes();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): RuleSource {
    return {
      type: isSet(object.type) ? ruleSource_RuleSourceTypeFromJSON(object.type) : 0,
      payload: isSet(object.payload) ? bytesFromBase64(object.payload) : new Uint8Array(0),
    };
  },

  toJSON(message: RuleSource): unknown {
    const obj: any = {};
    if (message.type !== 0) {
      obj.type = ruleSource_RuleSourceTypeToJSON(message.type);
    }
    if (message.payload.length !== 0) {
      obj.payload = base64FromBytes(message.payload);
    }
    return obj;
  },

  create(base?: DeepPartial<RuleSource>): RuleSource {
    return RuleSource.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<RuleSource>): RuleSource {
    const message = createBaseRuleSource();
    message.type = object.type ?? 0;
    message.payload = object.payload ?? new Uint8Array(0);
    return message;
  },
};

function createBaseRuleDestinationInternalWallet(): RuleDestinationInternalWallet {
  return { path: "" };
}

export const RuleDestinationInternalWallet = {
  encode(message: RuleDestinationInternalWallet, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.path !== "") {
      writer.uint32(10).string(message.path);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): RuleDestinationInternalWallet {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseRuleDestinationInternalWallet();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.path = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): RuleDestinationInternalWallet {
    return { path: isSet(object.path) ? globalThis.String(object.path) : "" };
  },

  toJSON(message: RuleDestinationInternalWallet): unknown {
    const obj: any = {};
    if (message.path !== "") {
      obj.path = message.path;
    }
    return obj;
  },

  create(base?: DeepPartial<RuleDestinationInternalWallet>): RuleDestinationInternalWallet {
    return RuleDestinationInternalWallet.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<RuleDestinationInternalWallet>): RuleDestinationInternalWallet {
    const message = createBaseRuleDestinationInternalWallet();
    message.path = object.path ?? "";
    return message;
  },
};

function createBaseRuleDestinationInternalAddress(): RuleDestinationInternalAddress {
  return { address: "", path: "" };
}

export const RuleDestinationInternalAddress = {
  encode(message: RuleDestinationInternalAddress, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.address !== "") {
      writer.uint32(10).string(message.address);
    }
    if (message.path !== "") {
      writer.uint32(18).string(message.path);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): RuleDestinationInternalAddress {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseRuleDestinationInternalAddress();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.address = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.path = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): RuleDestinationInternalAddress {
    return {
      address: isSet(object.address) ? globalThis.String(object.address) : "",
      path: isSet(object.path) ? globalThis.String(object.path) : "",
    };
  },

  toJSON(message: RuleDestinationInternalAddress): unknown {
    const obj: any = {};
    if (message.address !== "") {
      obj.address = message.address;
    }
    if (message.path !== "") {
      obj.path = message.path;
    }
    return obj;
  },

  create(base?: DeepPartial<RuleDestinationInternalAddress>): RuleDestinationInternalAddress {
    return RuleDestinationInternalAddress.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<RuleDestinationInternalAddress>): RuleDestinationInternalAddress {
    const message = createBaseRuleDestinationInternalAddress();
    message.address = object.address ?? "";
    message.path = object.path ?? "";
    return message;
  },
};

function createBaseRuleDestinationExternalAddress(): RuleDestinationExternalAddress {
  return { address: "", memo: "" };
}

export const RuleDestinationExternalAddress = {
  encode(message: RuleDestinationExternalAddress, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.address !== "") {
      writer.uint32(10).string(message.address);
    }
    if (message.memo !== "") {
      writer.uint32(18).string(message.memo);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): RuleDestinationExternalAddress {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseRuleDestinationExternalAddress();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.address = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.memo = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): RuleDestinationExternalAddress {
    return {
      address: isSet(object.address) ? globalThis.String(object.address) : "",
      memo: isSet(object.memo) ? globalThis.String(object.memo) : "",
    };
  },

  toJSON(message: RuleDestinationExternalAddress): unknown {
    const obj: any = {};
    if (message.address !== "") {
      obj.address = message.address;
    }
    if (message.memo !== "") {
      obj.memo = message.memo;
    }
    return obj;
  },

  create(base?: DeepPartial<RuleDestinationExternalAddress>): RuleDestinationExternalAddress {
    return RuleDestinationExternalAddress.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<RuleDestinationExternalAddress>): RuleDestinationExternalAddress {
    const message = createBaseRuleDestinationExternalAddress();
    message.address = object.address ?? "";
    message.memo = object.memo ?? "";
    return message;
  },
};

function createBaseRuleDestinationContractAddress(): RuleDestinationContractAddress {
  return { address: "", name: "", symbol: "", blockchain: 0 };
}

export const RuleDestinationContractAddress = {
  encode(message: RuleDestinationContractAddress, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.address !== "") {
      writer.uint32(10).string(message.address);
    }
    if (message.name !== "") {
      writer.uint32(18).string(message.name);
    }
    if (message.symbol !== "") {
      writer.uint32(26).string(message.symbol);
    }
    if (message.blockchain !== 0) {
      writer.uint32(32).int32(message.blockchain);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): RuleDestinationContractAddress {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseRuleDestinationContractAddress();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.address = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.name = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.symbol = reader.string();
          continue;
        case 4:
          if (tag !== 32) {
            break;
          }

          message.blockchain = reader.int32() as any;
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): RuleDestinationContractAddress {
    return {
      address: isSet(object.address) ? globalThis.String(object.address) : "",
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      symbol: isSet(object.symbol) ? globalThis.String(object.symbol) : "",
      blockchain: isSet(object.blockchain) ? blockchainFromJSON(object.blockchain) : 0,
    };
  },

  toJSON(message: RuleDestinationContractAddress): unknown {
    const obj: any = {};
    if (message.address !== "") {
      obj.address = message.address;
    }
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.symbol !== "") {
      obj.symbol = message.symbol;
    }
    if (message.blockchain !== 0) {
      obj.blockchain = blockchainToJSON(message.blockchain);
    }
    return obj;
  },

  create(base?: DeepPartial<RuleDestinationContractAddress>): RuleDestinationContractAddress {
    return RuleDestinationContractAddress.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<RuleDestinationContractAddress>): RuleDestinationContractAddress {
    const message = createBaseRuleDestinationContractAddress();
    message.address = object.address ?? "";
    message.name = object.name ?? "";
    message.symbol = object.symbol ?? "";
    message.blockchain = object.blockchain ?? 0;
    return message;
  },
};

function createBaseRuleDestinationExchange(): RuleDestinationExchange {
  return { label: "", memo: "" };
}

export const RuleDestinationExchange = {
  encode(message: RuleDestinationExchange, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.label !== "") {
      writer.uint32(10).string(message.label);
    }
    if (message.memo !== "") {
      writer.uint32(18).string(message.memo);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): RuleDestinationExchange {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseRuleDestinationExchange();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.label = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.memo = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): RuleDestinationExchange {
    return {
      label: isSet(object.label) ? globalThis.String(object.label) : "",
      memo: isSet(object.memo) ? globalThis.String(object.memo) : "",
    };
  },

  toJSON(message: RuleDestinationExchange): unknown {
    const obj: any = {};
    if (message.label !== "") {
      obj.label = message.label;
    }
    if (message.memo !== "") {
      obj.memo = message.memo;
    }
    return obj;
  },

  create(base?: DeepPartial<RuleDestinationExchange>): RuleDestinationExchange {
    return RuleDestinationExchange.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<RuleDestinationExchange>): RuleDestinationExchange {
    const message = createBaseRuleDestinationExchange();
    message.label = object.label ?? "";
    message.memo = object.memo ?? "";
    return message;
  },
};

function createBaseRuleDestination(): RuleDestination {
  return { type: 0, payload: new Uint8Array(0) };
}

export const RuleDestination = {
  encode(message: RuleDestination, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.type !== 0) {
      writer.uint32(8).int32(message.type);
    }
    if (message.payload.length !== 0) {
      writer.uint32(18).bytes(message.payload);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): RuleDestination {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseRuleDestination();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.type = reader.int32() as any;
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.payload = reader.bytes();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): RuleDestination {
    return {
      type: isSet(object.type) ? ruleDestination_RuleDestinationTypeFromJSON(object.type) : 0,
      payload: isSet(object.payload) ? bytesFromBase64(object.payload) : new Uint8Array(0),
    };
  },

  toJSON(message: RuleDestination): unknown {
    const obj: any = {};
    if (message.type !== 0) {
      obj.type = ruleDestination_RuleDestinationTypeToJSON(message.type);
    }
    if (message.payload.length !== 0) {
      obj.payload = base64FromBytes(message.payload);
    }
    return obj;
  },

  create(base?: DeepPartial<RuleDestination>): RuleDestination {
    return RuleDestination.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<RuleDestination>): RuleDestination {
    const message = createBaseRuleDestination();
    message.type = object.type ?? 0;
    message.payload = object.payload ?? new Uint8Array(0);
    return message;
  },
};

function createBaseRuleWhitelistedContract(): RuleWhitelistedContract {
  return { type: 0, payload: new Uint8Array(0) };
}

export const RuleWhitelistedContract = {
  encode(message: RuleWhitelistedContract, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.type !== 0) {
      writer.uint32(8).int32(message.type);
    }
    if (message.payload.length !== 0) {
      writer.uint32(18).bytes(message.payload);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): RuleWhitelistedContract {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseRuleWhitelistedContract();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.type = reader.int32() as any;
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.payload = reader.bytes();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): RuleWhitelistedContract {
    return {
      type: isSet(object.type) ? ruleWhitelistedContract_RuleWhitelistedContractTypeFromJSON(object.type) : 0,
      payload: isSet(object.payload) ? bytesFromBase64(object.payload) : new Uint8Array(0),
    };
  },

  toJSON(message: RuleWhitelistedContract): unknown {
    const obj: any = {};
    if (message.type !== 0) {
      obj.type = ruleWhitelistedContract_RuleWhitelistedContractTypeToJSON(message.type);
    }
    if (message.payload.length !== 0) {
      obj.payload = base64FromBytes(message.payload);
    }
    return obj;
  },

  create(base?: DeepPartial<RuleWhitelistedContract>): RuleWhitelistedContract {
    return RuleWhitelistedContract.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<RuleWhitelistedContract>): RuleWhitelistedContract {
    const message = createBaseRuleWhitelistedContract();
    message.type = object.type ?? 0;
    message.payload = object.payload ?? new Uint8Array(0);
    return message;
  },
};

function createBaseRuleIntegerGreater(): RuleIntegerGreater {
  return { type: 0, payload: new Uint8Array(0) };
}

export const RuleIntegerGreater = {
  encode(message: RuleIntegerGreater, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.type !== 0) {
      writer.uint32(8).int32(message.type);
    }
    if (message.payload.length !== 0) {
      writer.uint32(18).bytes(message.payload);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): RuleIntegerGreater {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseRuleIntegerGreater();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.type = reader.int32() as any;
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.payload = reader.bytes();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): RuleIntegerGreater {
    return {
      type: isSet(object.type) ? ruleIntegerGreater_RuleIntegerGreaterTypeFromJSON(object.type) : 0,
      payload: isSet(object.payload) ? bytesFromBase64(object.payload) : new Uint8Array(0),
    };
  },

  toJSON(message: RuleIntegerGreater): unknown {
    const obj: any = {};
    if (message.type !== 0) {
      obj.type = ruleIntegerGreater_RuleIntegerGreaterTypeToJSON(message.type);
    }
    if (message.payload.length !== 0) {
      obj.payload = base64FromBytes(message.payload);
    }
    return obj;
  },

  create(base?: DeepPartial<RuleIntegerGreater>): RuleIntegerGreater {
    return RuleIntegerGreater.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<RuleIntegerGreater>): RuleIntegerGreater {
    const message = createBaseRuleIntegerGreater();
    message.type = object.type ?? 0;
    message.payload = object.payload ?? new Uint8Array(0);
    return message;
  },
};

function createBaseRuleUIntegerGreater(): RuleUIntegerGreater {
  return { type: 0, payload: new Uint8Array(0) };
}

export const RuleUIntegerGreater = {
  encode(message: RuleUIntegerGreater, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.type !== 0) {
      writer.uint32(8).int32(message.type);
    }
    if (message.payload.length !== 0) {
      writer.uint32(18).bytes(message.payload);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): RuleUIntegerGreater {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseRuleUIntegerGreater();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.type = reader.int32() as any;
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.payload = reader.bytes();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): RuleUIntegerGreater {
    return {
      type: isSet(object.type) ? ruleUIntegerGreater_RuleUIntegerGreaterTypeFromJSON(object.type) : 0,
      payload: isSet(object.payload) ? bytesFromBase64(object.payload) : new Uint8Array(0),
    };
  },

  toJSON(message: RuleUIntegerGreater): unknown {
    const obj: any = {};
    if (message.type !== 0) {
      obj.type = ruleUIntegerGreater_RuleUIntegerGreaterTypeToJSON(message.type);
    }
    if (message.payload.length !== 0) {
      obj.payload = base64FromBytes(message.payload);
    }
    return obj;
  },

  create(base?: DeepPartial<RuleUIntegerGreater>): RuleUIntegerGreater {
    return RuleUIntegerGreater.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<RuleUIntegerGreater>): RuleUIntegerGreater {
    const message = createBaseRuleUIntegerGreater();
    message.type = object.type ?? 0;
    message.payload = object.payload ?? new Uint8Array(0);
    return message;
  },
};

function createBaseRuleFiatAmountRange(): RuleFiatAmountRange {
  return { minAmount: "", maxAmount: "" };
}

export const RuleFiatAmountRange = {
  encode(message: RuleFiatAmountRange, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.minAmount !== "") {
      writer.uint32(10).string(message.minAmount);
    }
    if (message.maxAmount !== "") {
      writer.uint32(18).string(message.maxAmount);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): RuleFiatAmountRange {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseRuleFiatAmountRange();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.minAmount = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.maxAmount = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): RuleFiatAmountRange {
    return {
      minAmount: isSet(object.minAmount) ? globalThis.String(object.minAmount) : "",
      maxAmount: isSet(object.maxAmount) ? globalThis.String(object.maxAmount) : "",
    };
  },

  toJSON(message: RuleFiatAmountRange): unknown {
    const obj: any = {};
    if (message.minAmount !== "") {
      obj.minAmount = message.minAmount;
    }
    if (message.maxAmount !== "") {
      obj.maxAmount = message.maxAmount;
    }
    return obj;
  },

  create(base?: DeepPartial<RuleFiatAmountRange>): RuleFiatAmountRange {
    return RuleFiatAmountRange.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<RuleFiatAmountRange>): RuleFiatAmountRange {
    const message = createBaseRuleFiatAmountRange();
    message.minAmount = object.minAmount ?? "";
    message.maxAmount = object.maxAmount ?? "";
    return message;
  },
};

function createBaseRuleFiatAmount(): RuleFiatAmount {
  return { type: 0, payload: new Uint8Array(0) };
}

export const RuleFiatAmount = {
  encode(message: RuleFiatAmount, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.type !== 0) {
      writer.uint32(8).int32(message.type);
    }
    if (message.payload.length !== 0) {
      writer.uint32(18).bytes(message.payload);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): RuleFiatAmount {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseRuleFiatAmount();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.type = reader.int32() as any;
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.payload = reader.bytes();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): RuleFiatAmount {
    return {
      type: isSet(object.type) ? ruleFiatAmount_RuleFiatAmountTypeFromJSON(object.type) : 0,
      payload: isSet(object.payload) ? bytesFromBase64(object.payload) : new Uint8Array(0),
    };
  },

  toJSON(message: RuleFiatAmount): unknown {
    const obj: any = {};
    if (message.type !== 0) {
      obj.type = ruleFiatAmount_RuleFiatAmountTypeToJSON(message.type);
    }
    if (message.payload.length !== 0) {
      obj.payload = base64FromBytes(message.payload);
    }
    return obj;
  },

  create(base?: DeepPartial<RuleFiatAmount>): RuleFiatAmount {
    return RuleFiatAmount.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<RuleFiatAmount>): RuleFiatAmount {
    const message = createBaseRuleFiatAmount();
    message.type = object.type ?? 0;
    message.payload = object.payload ?? new Uint8Array(0);
    return message;
  },
};

function createBaseRuleStringEqual(): RuleStringEqual {
  return { type: 0, payload: new Uint8Array(0) };
}

export const RuleStringEqual = {
  encode(message: RuleStringEqual, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.type !== 0) {
      writer.uint32(8).int32(message.type);
    }
    if (message.payload.length !== 0) {
      writer.uint32(18).bytes(message.payload);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): RuleStringEqual {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseRuleStringEqual();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.type = reader.int32() as any;
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.payload = reader.bytes();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): RuleStringEqual {
    return {
      type: isSet(object.type) ? ruleStringEqual_RuleStringEqualTypeFromJSON(object.type) : 0,
      payload: isSet(object.payload) ? bytesFromBase64(object.payload) : new Uint8Array(0),
    };
  },

  toJSON(message: RuleStringEqual): unknown {
    const obj: any = {};
    if (message.type !== 0) {
      obj.type = ruleStringEqual_RuleStringEqualTypeToJSON(message.type);
    }
    if (message.payload.length !== 0) {
      obj.payload = base64FromBytes(message.payload);
    }
    return obj;
  },

  create(base?: DeepPartial<RuleStringEqual>): RuleStringEqual {
    return RuleStringEqual.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<RuleStringEqual>): RuleStringEqual {
    const message = createBaseRuleStringEqual();
    message.type = object.type ?? 0;
    message.payload = object.payload ?? new Uint8Array(0);
    return message;
  },
};

function createBaseRuleStringArrayEqualValue(): RuleStringArrayEqualValue {
  return { values: [] };
}

export const RuleStringArrayEqualValue = {
  encode(message: RuleStringArrayEqualValue, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    for (const v of message.values) {
      writer.uint32(10).string(v!);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): RuleStringArrayEqualValue {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseRuleStringArrayEqualValue();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.values.push(reader.string());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): RuleStringArrayEqualValue {
    return {
      values: globalThis.Array.isArray(object?.values) ? object.values.map((e: any) => globalThis.String(e)) : [],
    };
  },

  toJSON(message: RuleStringArrayEqualValue): unknown {
    const obj: any = {};
    if (message.values?.length) {
      obj.values = message.values;
    }
    return obj;
  },

  create(base?: DeepPartial<RuleStringArrayEqualValue>): RuleStringArrayEqualValue {
    return RuleStringArrayEqualValue.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<RuleStringArrayEqualValue>): RuleStringArrayEqualValue {
    const message = createBaseRuleStringArrayEqualValue();
    message.values = object.values?.map((e) => e) || [];
    return message;
  },
};

function createBaseRuleStringArrayEqual(): RuleStringArrayEqual {
  return { type: 0, payload: new Uint8Array(0) };
}

export const RuleStringArrayEqual = {
  encode(message: RuleStringArrayEqual, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.type !== 0) {
      writer.uint32(8).int32(message.type);
    }
    if (message.payload.length !== 0) {
      writer.uint32(18).bytes(message.payload);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): RuleStringArrayEqual {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseRuleStringArrayEqual();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.type = reader.int32() as any;
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.payload = reader.bytes();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): RuleStringArrayEqual {
    return {
      type: isSet(object.type) ? ruleStringArrayEqual_RuleStringArrayEqualTypeFromJSON(object.type) : 0,
      payload: isSet(object.payload) ? bytesFromBase64(object.payload) : new Uint8Array(0),
    };
  },

  toJSON(message: RuleStringArrayEqual): unknown {
    const obj: any = {};
    if (message.type !== 0) {
      obj.type = ruleStringArrayEqual_RuleStringArrayEqualTypeToJSON(message.type);
    }
    if (message.payload.length !== 0) {
      obj.payload = base64FromBytes(message.payload);
    }
    return obj;
  },

  create(base?: DeepPartial<RuleStringArrayEqual>): RuleStringArrayEqual {
    return RuleStringArrayEqual.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<RuleStringArrayEqual>): RuleStringArrayEqual {
    const message = createBaseRuleStringArrayEqual();
    message.type = object.type ?? 0;
    message.payload = object.payload ?? new Uint8Array(0);
    return message;
  },
};

function createBaseRuleBytesEqual(): RuleBytesEqual {
  return { type: 0, payload: new Uint8Array(0) };
}

export const RuleBytesEqual = {
  encode(message: RuleBytesEqual, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.type !== 0) {
      writer.uint32(8).int32(message.type);
    }
    if (message.payload.length !== 0) {
      writer.uint32(18).bytes(message.payload);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): RuleBytesEqual {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseRuleBytesEqual();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.type = reader.int32() as any;
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.payload = reader.bytes();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): RuleBytesEqual {
    return {
      type: isSet(object.type) ? ruleBytesEqual_RuleBytesEqualTypeFromJSON(object.type) : 0,
      payload: isSet(object.payload) ? bytesFromBase64(object.payload) : new Uint8Array(0),
    };
  },

  toJSON(message: RuleBytesEqual): unknown {
    const obj: any = {};
    if (message.type !== 0) {
      obj.type = ruleBytesEqual_RuleBytesEqualTypeToJSON(message.type);
    }
    if (message.payload.length !== 0) {
      obj.payload = base64FromBytes(message.payload);
    }
    return obj;
  },

  create(base?: DeepPartial<RuleBytesEqual>): RuleBytesEqual {
    return RuleBytesEqual.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<RuleBytesEqual>): RuleBytesEqual {
    const message = createBaseRuleBytesEqual();
    message.type = object.type ?? 0;
    message.payload = object.payload ?? new Uint8Array(0);
    return message;
  },
};

function createBaseGroupThreshold(): GroupThreshold {
  return { groupId: "", minimumSignatures: 0 };
}

export const GroupThreshold = {
  encode(message: GroupThreshold, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.groupId !== "") {
      writer.uint32(10).string(message.groupId);
    }
    if (message.minimumSignatures !== 0) {
      writer.uint32(16).uint32(message.minimumSignatures);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): GroupThreshold {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGroupThreshold();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.groupId = reader.string();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.minimumSignatures = reader.uint32();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GroupThreshold {
    return {
      groupId: isSet(object.groupId) ? globalThis.String(object.groupId) : "",
      minimumSignatures: isSet(object.minimumSignatures) ? globalThis.Number(object.minimumSignatures) : 0,
    };
  },

  toJSON(message: GroupThreshold): unknown {
    const obj: any = {};
    if (message.groupId !== "") {
      obj.groupId = message.groupId;
    }
    if (message.minimumSignatures !== 0) {
      obj.minimumSignatures = Math.round(message.minimumSignatures);
    }
    return obj;
  },

  create(base?: DeepPartial<GroupThreshold>): GroupThreshold {
    return GroupThreshold.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<GroupThreshold>): GroupThreshold {
    const message = createBaseGroupThreshold();
    message.groupId = object.groupId ?? "";
    message.minimumSignatures = object.minimumSignatures ?? 0;
    return message;
  },
};

function createBaseSequentialThresholds(): SequentialThresholds {
  return { thresholds: [] };
}

export const SequentialThresholds = {
  encode(message: SequentialThresholds, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    for (const v of message.thresholds) {
      GroupThreshold.encode(v!, writer.uint32(10).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): SequentialThresholds {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSequentialThresholds();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.thresholds.push(GroupThreshold.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): SequentialThresholds {
    return {
      thresholds: globalThis.Array.isArray(object?.thresholds)
        ? object.thresholds.map((e: any) => GroupThreshold.fromJSON(e))
        : [],
    };
  },

  toJSON(message: SequentialThresholds): unknown {
    const obj: any = {};
    if (message.thresholds?.length) {
      obj.thresholds = message.thresholds.map((e) => GroupThreshold.toJSON(e));
    }
    return obj;
  },

  create(base?: DeepPartial<SequentialThresholds>): SequentialThresholds {
    return SequentialThresholds.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<SequentialThresholds>): SequentialThresholds {
    const message = createBaseSequentialThresholds();
    message.thresholds = object.thresholds?.map((e) => GroupThreshold.fromPartial(e)) || [];
    return message;
  },
};

function createBaseRulesContainer(): RulesContainer {
  return {
    users: [],
    groups: [],
    minimumDistinctUserSignatures: 0,
    minimumDistinctGroupSignatures: 0,
    transactionRules: [],
    addressWhitelistingRules: [],
    contractAddressWhitelistingRules: [],
    enforcedRulesHash: "",
    properties: {},
    timestamp: 0,
    minimumCommitmentSignatures: 0,
    engineIdentities: [],
    hsmSlotId: 0,
  };
}

export const RulesContainer = {
  encode(message: RulesContainer, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    for (const v of message.users) {
      User.encode(v!, writer.uint32(10).fork()).ldelim();
    }
    for (const v of message.groups) {
      Group.encode(v!, writer.uint32(18).fork()).ldelim();
    }
    if (message.minimumDistinctUserSignatures !== 0) {
      writer.uint32(24).uint32(message.minimumDistinctUserSignatures);
    }
    if (message.minimumDistinctGroupSignatures !== 0) {
      writer.uint32(32).uint32(message.minimumDistinctGroupSignatures);
    }
    for (const v of message.transactionRules) {
      RulesContainer_TransactionRules.encode(v!, writer.uint32(42).fork()).ldelim();
    }
    for (const v of message.addressWhitelistingRules) {
      RulesContainer_AddressWhitelistingRules.encode(v!, writer.uint32(50).fork()).ldelim();
    }
    for (const v of message.contractAddressWhitelistingRules) {
      RulesContainer_ContractAddressWhitelistingRules.encode(v!, writer.uint32(58).fork()).ldelim();
    }
    if (message.enforcedRulesHash !== "") {
      writer.uint32(66).string(message.enforcedRulesHash);
    }
    Object.entries(message.properties).forEach(([key, value]) => {
      RulesContainer_PropertiesEntry.encode({ key: key as any, value }, writer.uint32(74).fork()).ldelim();
    });
    if (message.timestamp !== 0) {
      writer.uint32(80).uint64(message.timestamp);
    }
    if (message.minimumCommitmentSignatures !== 0) {
      writer.uint32(88).uint32(message.minimumCommitmentSignatures);
    }
    for (const v of message.engineIdentities) {
      writer.uint32(98).string(v!);
    }
    if (message.hsmSlotId !== 0) {
      writer.uint32(104).uint32(message.hsmSlotId);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): RulesContainer {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseRulesContainer();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.users.push(User.decode(reader, reader.uint32()));
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.groups.push(Group.decode(reader, reader.uint32()));
          continue;
        case 3:
          if (tag !== 24) {
            break;
          }

          message.minimumDistinctUserSignatures = reader.uint32();
          continue;
        case 4:
          if (tag !== 32) {
            break;
          }

          message.minimumDistinctGroupSignatures = reader.uint32();
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.transactionRules.push(RulesContainer_TransactionRules.decode(reader, reader.uint32()));
          continue;
        case 6:
          if (tag !== 50) {
            break;
          }

          message.addressWhitelistingRules.push(
            RulesContainer_AddressWhitelistingRules.decode(reader, reader.uint32()),
          );
          continue;
        case 7:
          if (tag !== 58) {
            break;
          }

          message.contractAddressWhitelistingRules.push(
            RulesContainer_ContractAddressWhitelistingRules.decode(reader, reader.uint32()),
          );
          continue;
        case 8:
          if (tag !== 66) {
            break;
          }

          message.enforcedRulesHash = reader.string();
          continue;
        case 9:
          if (tag !== 74) {
            break;
          }

          const entry9 = RulesContainer_PropertiesEntry.decode(reader, reader.uint32());
          if (entry9.value !== undefined) {
            message.properties[entry9.key] = entry9.value;
          }
          continue;
        case 10:
          if (tag !== 80) {
            break;
          }

          message.timestamp = longToNumber(reader.uint64() as Long);
          continue;
        case 11:
          if (tag !== 88) {
            break;
          }

          message.minimumCommitmentSignatures = reader.uint32();
          continue;
        case 12:
          if (tag !== 98) {
            break;
          }

          message.engineIdentities.push(reader.string());
          continue;
        case 13:
          if (tag !== 104) {
            break;
          }

          message.hsmSlotId = reader.uint32();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): RulesContainer {
    return {
      users: globalThis.Array.isArray(object?.users) ? object.users.map((e: any) => User.fromJSON(e)) : [],
      groups: globalThis.Array.isArray(object?.groups) ? object.groups.map((e: any) => Group.fromJSON(e)) : [],
      minimumDistinctUserSignatures: isSet(object.minimumDistinctUserSignatures)
        ? globalThis.Number(object.minimumDistinctUserSignatures)
        : 0,
      minimumDistinctGroupSignatures: isSet(object.minimumDistinctGroupSignatures)
        ? globalThis.Number(object.minimumDistinctGroupSignatures)
        : 0,
      transactionRules: globalThis.Array.isArray(object?.transactionRules)
        ? object.transactionRules.map((e: any) => RulesContainer_TransactionRules.fromJSON(e))
        : [],
      addressWhitelistingRules: globalThis.Array.isArray(object?.addressWhitelistingRules)
        ? object.addressWhitelistingRules.map((e: any) => RulesContainer_AddressWhitelistingRules.fromJSON(e))
        : [],
      contractAddressWhitelistingRules: globalThis.Array.isArray(object?.contractAddressWhitelistingRules)
        ? object.contractAddressWhitelistingRules.map((e: any) =>
          RulesContainer_ContractAddressWhitelistingRules.fromJSON(e)
        )
        : [],
      enforcedRulesHash: isSet(object.enforcedRulesHash) ? globalThis.String(object.enforcedRulesHash) : "",
      properties: isObject(object.properties)
        ? Object.entries(object.properties).reduce<{ [key: string]: Uint8Array }>((acc, [key, value]) => {
          acc[key] = bytesFromBase64(value as string);
          return acc;
        }, {})
        : {},
      timestamp: isSet(object.timestamp) ? globalThis.Number(object.timestamp) : 0,
      minimumCommitmentSignatures: isSet(object.minimumCommitmentSignatures)
        ? globalThis.Number(object.minimumCommitmentSignatures)
        : 0,
      engineIdentities: globalThis.Array.isArray(object?.engineIdentities)
        ? object.engineIdentities.map((e: any) => globalThis.String(e))
        : [],
      hsmSlotId: isSet(object.hsmSlotId) ? globalThis.Number(object.hsmSlotId) : 0,
    };
  },

  toJSON(message: RulesContainer): unknown {
    const obj: any = {};
    if (message.users?.length) {
      obj.users = message.users.map((e) => User.toJSON(e));
    }
    if (message.groups?.length) {
      obj.groups = message.groups.map((e) => Group.toJSON(e));
    }
    if (message.minimumDistinctUserSignatures !== 0) {
      obj.minimumDistinctUserSignatures = Math.round(message.minimumDistinctUserSignatures);
    }
    if (message.minimumDistinctGroupSignatures !== 0) {
      obj.minimumDistinctGroupSignatures = Math.round(message.minimumDistinctGroupSignatures);
    }
    if (message.transactionRules?.length) {
      obj.transactionRules = message.transactionRules.map((e) => RulesContainer_TransactionRules.toJSON(e));
    }
    if (message.addressWhitelistingRules?.length) {
      obj.addressWhitelistingRules = message.addressWhitelistingRules.map((e) =>
        RulesContainer_AddressWhitelistingRules.toJSON(e)
      );
    }
    if (message.contractAddressWhitelistingRules?.length) {
      obj.contractAddressWhitelistingRules = message.contractAddressWhitelistingRules.map((e) =>
        RulesContainer_ContractAddressWhitelistingRules.toJSON(e)
      );
    }
    if (message.enforcedRulesHash !== "") {
      obj.enforcedRulesHash = message.enforcedRulesHash;
    }
    if (message.properties) {
      const entries = Object.entries(message.properties);
      if (entries.length > 0) {
        obj.properties = {};
        entries.forEach(([k, v]) => {
          obj.properties[k] = base64FromBytes(v);
        });
      }
    }
    if (message.timestamp !== 0) {
      obj.timestamp = Math.round(message.timestamp);
    }
    if (message.minimumCommitmentSignatures !== 0) {
      obj.minimumCommitmentSignatures = Math.round(message.minimumCommitmentSignatures);
    }
    if (message.engineIdentities?.length) {
      obj.engineIdentities = message.engineIdentities;
    }
    if (message.hsmSlotId !== 0) {
      obj.hsmSlotId = Math.round(message.hsmSlotId);
    }
    return obj;
  },

  create(base?: DeepPartial<RulesContainer>): RulesContainer {
    return RulesContainer.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<RulesContainer>): RulesContainer {
    const message = createBaseRulesContainer();
    message.users = object.users?.map((e) => User.fromPartial(e)) || [];
    message.groups = object.groups?.map((e) => Group.fromPartial(e)) || [];
    message.minimumDistinctUserSignatures = object.minimumDistinctUserSignatures ?? 0;
    message.minimumDistinctGroupSignatures = object.minimumDistinctGroupSignatures ?? 0;
    message.transactionRules = object.transactionRules?.map((e) => RulesContainer_TransactionRules.fromPartial(e)) ||
      [];
    message.addressWhitelistingRules =
      object.addressWhitelistingRules?.map((e) => RulesContainer_AddressWhitelistingRules.fromPartial(e)) || [];
    message.contractAddressWhitelistingRules =
      object.contractAddressWhitelistingRules?.map((e) =>
        RulesContainer_ContractAddressWhitelistingRules.fromPartial(e)
      ) || [];
    message.enforcedRulesHash = object.enforcedRulesHash ?? "";
    message.properties = Object.entries(object.properties ?? {}).reduce<{ [key: string]: Uint8Array }>(
      (acc, [key, value]) => {
        if (value !== undefined) {
          acc[key] = value;
        }
        return acc;
      },
      {},
    );
    message.timestamp = object.timestamp ?? 0;
    message.minimumCommitmentSignatures = object.minimumCommitmentSignatures ?? 0;
    message.engineIdentities = object.engineIdentities?.map((e) => e) || [];
    message.hsmSlotId = object.hsmSlotId ?? 0;
    return message;
  },
};

function createBaseRulesContainer_Column(): RulesContainer_Column {
  return { type: 0, name: "", metadataKey: "" };
}

export const RulesContainer_Column = {
  encode(message: RulesContainer_Column, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.type !== 0) {
      writer.uint32(8).int32(message.type);
    }
    if (message.name !== "") {
      writer.uint32(18).string(message.name);
    }
    if (message.metadataKey !== "") {
      writer.uint32(26).string(message.metadataKey);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): RulesContainer_Column {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseRulesContainer_Column();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.type = reader.int32() as any;
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.name = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.metadataKey = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): RulesContainer_Column {
    return {
      type: isSet(object.type) ? rulesContainer_ColumnTypeFromJSON(object.type) : 0,
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      metadataKey: isSet(object.metadataKey) ? globalThis.String(object.metadataKey) : "",
    };
  },

  toJSON(message: RulesContainer_Column): unknown {
    const obj: any = {};
    if (message.type !== 0) {
      obj.type = rulesContainer_ColumnTypeToJSON(message.type);
    }
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.metadataKey !== "") {
      obj.metadataKey = message.metadataKey;
    }
    return obj;
  },

  create(base?: DeepPartial<RulesContainer_Column>): RulesContainer_Column {
    return RulesContainer_Column.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<RulesContainer_Column>): RulesContainer_Column {
    const message = createBaseRulesContainer_Column();
    message.type = object.type ?? 0;
    message.name = object.name ?? "";
    message.metadataKey = object.metadataKey ?? "";
    return message;
  },
};

function createBaseRulesContainer_Line(): RulesContainer_Line {
  return { cells: [], parallelThresholds: [], properties: {}, priority: 0 };
}

export const RulesContainer_Line = {
  encode(message: RulesContainer_Line, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    for (const v of message.cells) {
      writer.uint32(10).bytes(v!);
    }
    for (const v of message.parallelThresholds) {
      SequentialThresholds.encode(v!, writer.uint32(18).fork()).ldelim();
    }
    Object.entries(message.properties).forEach(([key, value]) => {
      RulesContainer_Line_PropertiesEntry.encode({ key: key as any, value }, writer.uint32(26).fork()).ldelim();
    });
    if (message.priority !== 0) {
      writer.uint32(32).uint32(message.priority);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): RulesContainer_Line {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseRulesContainer_Line();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.cells.push(reader.bytes());
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.parallelThresholds.push(SequentialThresholds.decode(reader, reader.uint32()));
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          const entry3 = RulesContainer_Line_PropertiesEntry.decode(reader, reader.uint32());
          if (entry3.value !== undefined) {
            message.properties[entry3.key] = entry3.value;
          }
          continue;
        case 4:
          if (tag !== 32) {
            break;
          }

          message.priority = reader.uint32();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): RulesContainer_Line {
    return {
      cells: globalThis.Array.isArray(object?.cells) ? object.cells.map((e: any) => bytesFromBase64(e)) : [],
      parallelThresholds: globalThis.Array.isArray(object?.parallelThresholds)
        ? object.parallelThresholds.map((e: any) => SequentialThresholds.fromJSON(e))
        : [],
      properties: isObject(object.properties)
        ? Object.entries(object.properties).reduce<{ [key: string]: Uint8Array }>((acc, [key, value]) => {
          acc[key] = bytesFromBase64(value as string);
          return acc;
        }, {})
        : {},
      priority: isSet(object.priority) ? globalThis.Number(object.priority) : 0,
    };
  },

  toJSON(message: RulesContainer_Line): unknown {
    const obj: any = {};
    if (message.cells?.length) {
      obj.cells = message.cells.map((e) => base64FromBytes(e));
    }
    if (message.parallelThresholds?.length) {
      obj.parallelThresholds = message.parallelThresholds.map((e) => SequentialThresholds.toJSON(e));
    }
    if (message.properties) {
      const entries = Object.entries(message.properties);
      if (entries.length > 0) {
        obj.properties = {};
        entries.forEach(([k, v]) => {
          obj.properties[k] = base64FromBytes(v);
        });
      }
    }
    if (message.priority !== 0) {
      obj.priority = Math.round(message.priority);
    }
    return obj;
  },

  create(base?: DeepPartial<RulesContainer_Line>): RulesContainer_Line {
    return RulesContainer_Line.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<RulesContainer_Line>): RulesContainer_Line {
    const message = createBaseRulesContainer_Line();
    message.cells = object.cells?.map((e) => e) || [];
    message.parallelThresholds = object.parallelThresholds?.map((e) => SequentialThresholds.fromPartial(e)) || [];
    message.properties = Object.entries(object.properties ?? {}).reduce<{ [key: string]: Uint8Array }>(
      (acc, [key, value]) => {
        if (value !== undefined) {
          acc[key] = value;
        }
        return acc;
      },
      {},
    );
    message.priority = object.priority ?? 0;
    return message;
  },
};

function createBaseRulesContainer_Line_PropertiesEntry(): RulesContainer_Line_PropertiesEntry {
  return { key: "", value: new Uint8Array(0) };
}

export const RulesContainer_Line_PropertiesEntry = {
  encode(message: RulesContainer_Line_PropertiesEntry, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.key !== "") {
      writer.uint32(10).string(message.key);
    }
    if (message.value.length !== 0) {
      writer.uint32(18).bytes(message.value);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): RulesContainer_Line_PropertiesEntry {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseRulesContainer_Line_PropertiesEntry();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.key = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.value = reader.bytes();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): RulesContainer_Line_PropertiesEntry {
    return {
      key: isSet(object.key) ? globalThis.String(object.key) : "",
      value: isSet(object.value) ? bytesFromBase64(object.value) : new Uint8Array(0),
    };
  },

  toJSON(message: RulesContainer_Line_PropertiesEntry): unknown {
    const obj: any = {};
    if (message.key !== "") {
      obj.key = message.key;
    }
    if (message.value.length !== 0) {
      obj.value = base64FromBytes(message.value);
    }
    return obj;
  },

  create(base?: DeepPartial<RulesContainer_Line_PropertiesEntry>): RulesContainer_Line_PropertiesEntry {
    return RulesContainer_Line_PropertiesEntry.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<RulesContainer_Line_PropertiesEntry>): RulesContainer_Line_PropertiesEntry {
    const message = createBaseRulesContainer_Line_PropertiesEntry();
    message.key = object.key ?? "";
    message.value = object.value ?? new Uint8Array(0);
    return message;
  },
};

function createBaseRulesContainer_TransactionRules(): RulesContainer_TransactionRules {
  return { key: "", columns: [], lines: [], details: undefined };
}

export const RulesContainer_TransactionRules = {
  encode(message: RulesContainer_TransactionRules, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.key !== "") {
      writer.uint32(10).string(message.key);
    }
    for (const v of message.columns) {
      RulesContainer_Column.encode(v!, writer.uint32(18).fork()).ldelim();
    }
    for (const v of message.lines) {
      RulesContainer_Line.encode(v!, writer.uint32(26).fork()).ldelim();
    }
    if (message.details !== undefined) {
      RulesContainer_TransactionRules_TransactionRuleDetails.encode(message.details, writer.uint32(34).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): RulesContainer_TransactionRules {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseRulesContainer_TransactionRules();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.key = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.columns.push(RulesContainer_Column.decode(reader, reader.uint32()));
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.lines.push(RulesContainer_Line.decode(reader, reader.uint32()));
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.details = RulesContainer_TransactionRules_TransactionRuleDetails.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): RulesContainer_TransactionRules {
    return {
      key: isSet(object.key) ? globalThis.String(object.key) : "",
      columns: globalThis.Array.isArray(object?.columns)
        ? object.columns.map((e: any) => RulesContainer_Column.fromJSON(e))
        : [],
      lines: globalThis.Array.isArray(object?.lines)
        ? object.lines.map((e: any) => RulesContainer_Line.fromJSON(e))
        : [],
      details: isSet(object.details)
        ? RulesContainer_TransactionRules_TransactionRuleDetails.fromJSON(object.details)
        : undefined,
    };
  },

  toJSON(message: RulesContainer_TransactionRules): unknown {
    const obj: any = {};
    if (message.key !== "") {
      obj.key = message.key;
    }
    if (message.columns?.length) {
      obj.columns = message.columns.map((e) => RulesContainer_Column.toJSON(e));
    }
    if (message.lines?.length) {
      obj.lines = message.lines.map((e) => RulesContainer_Line.toJSON(e));
    }
    if (message.details !== undefined) {
      obj.details = RulesContainer_TransactionRules_TransactionRuleDetails.toJSON(message.details);
    }
    return obj;
  },

  create(base?: DeepPartial<RulesContainer_TransactionRules>): RulesContainer_TransactionRules {
    return RulesContainer_TransactionRules.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<RulesContainer_TransactionRules>): RulesContainer_TransactionRules {
    const message = createBaseRulesContainer_TransactionRules();
    message.key = object.key ?? "";
    message.columns = object.columns?.map((e) => RulesContainer_Column.fromPartial(e)) || [];
    message.lines = object.lines?.map((e) => RulesContainer_Line.fromPartial(e)) || [];
    message.details = (object.details !== undefined && object.details !== null)
      ? RulesContainer_TransactionRules_TransactionRuleDetails.fromPartial(object.details)
      : undefined;
    return message;
  },
};

function createBaseRulesContainer_TransactionRules_TransactionRuleDetails(): RulesContainer_TransactionRules_TransactionRuleDetails {
  return {
    domain: 0,
    subDomain: 0,
    blockchain: "",
    network: "",
    evmCallContract: undefined,
    xtzCallContract: undefined,
    cashSettlement: undefined,
    cosmosDetails: undefined,
  };
}

export const RulesContainer_TransactionRules_TransactionRuleDetails = {
  encode(
    message: RulesContainer_TransactionRules_TransactionRuleDetails,
    writer: _m0.Writer = _m0.Writer.create(),
  ): _m0.Writer {
    if (message.domain !== 0) {
      writer.uint32(8).int32(message.domain);
    }
    if (message.subDomain !== 0) {
      writer.uint32(16).int32(message.subDomain);
    }
    if (message.blockchain !== "") {
      writer.uint32(26).string(message.blockchain);
    }
    if (message.network !== "") {
      writer.uint32(34).string(message.network);
    }
    if (message.evmCallContract !== undefined) {
      RulesContainer_TransactionRules_TransactionRuleDetails_EvmCallContract.encode(
        message.evmCallContract,
        writer.uint32(42).fork(),
      ).ldelim();
    }
    if (message.xtzCallContract !== undefined) {
      RulesContainer_TransactionRules_TransactionRuleDetails_XtzCallContract.encode(
        message.xtzCallContract,
        writer.uint32(50).fork(),
      ).ldelim();
    }
    if (message.cashSettlement !== undefined) {
      RulesContainer_TransactionRules_TransactionRuleDetails_CashSettlement.encode(
        message.cashSettlement,
        writer.uint32(58).fork(),
      ).ldelim();
    }
    if (message.cosmosDetails !== undefined) {
      RulesContainer_TransactionRules_TransactionRuleDetails_CosmosDetails.encode(
        message.cosmosDetails,
        writer.uint32(66).fork(),
      ).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): RulesContainer_TransactionRules_TransactionRuleDetails {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseRulesContainer_TransactionRules_TransactionRuleDetails();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.domain = reader.int32() as any;
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.subDomain = reader.int32() as any;
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.blockchain = reader.string();
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.network = reader.string();
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.evmCallContract = RulesContainer_TransactionRules_TransactionRuleDetails_EvmCallContract.decode(
            reader,
            reader.uint32(),
          );
          continue;
        case 6:
          if (tag !== 50) {
            break;
          }

          message.xtzCallContract = RulesContainer_TransactionRules_TransactionRuleDetails_XtzCallContract.decode(
            reader,
            reader.uint32(),
          );
          continue;
        case 7:
          if (tag !== 58) {
            break;
          }

          message.cashSettlement = RulesContainer_TransactionRules_TransactionRuleDetails_CashSettlement.decode(
            reader,
            reader.uint32(),
          );
          continue;
        case 8:
          if (tag !== 66) {
            break;
          }

          message.cosmosDetails = RulesContainer_TransactionRules_TransactionRuleDetails_CosmosDetails.decode(
            reader,
            reader.uint32(),
          );
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): RulesContainer_TransactionRules_TransactionRuleDetails {
    return {
      domain: isSet(object.domain)
        ? rulesContainer_TransactionRules_TransactionRuleDetails_RuleDomainFromJSON(object.domain)
        : 0,
      subDomain: isSet(object.subDomain)
        ? rulesContainer_TransactionRules_TransactionRuleDetails_RuleSubDomainFromJSON(object.subDomain)
        : 0,
      blockchain: isSet(object.blockchain) ? globalThis.String(object.blockchain) : "",
      network: isSet(object.network) ? globalThis.String(object.network) : "",
      evmCallContract: isSet(object.evmCallContract)
        ? RulesContainer_TransactionRules_TransactionRuleDetails_EvmCallContract.fromJSON(object.evmCallContract)
        : undefined,
      xtzCallContract: isSet(object.xtzCallContract)
        ? RulesContainer_TransactionRules_TransactionRuleDetails_XtzCallContract.fromJSON(object.xtzCallContract)
        : undefined,
      cashSettlement: isSet(object.cashSettlement)
        ? RulesContainer_TransactionRules_TransactionRuleDetails_CashSettlement.fromJSON(object.cashSettlement)
        : undefined,
      cosmosDetails: isSet(object.cosmosDetails)
        ? RulesContainer_TransactionRules_TransactionRuleDetails_CosmosDetails.fromJSON(object.cosmosDetails)
        : undefined,
    };
  },

  toJSON(message: RulesContainer_TransactionRules_TransactionRuleDetails): unknown {
    const obj: any = {};
    if (message.domain !== 0) {
      obj.domain = rulesContainer_TransactionRules_TransactionRuleDetails_RuleDomainToJSON(message.domain);
    }
    if (message.subDomain !== 0) {
      obj.subDomain = rulesContainer_TransactionRules_TransactionRuleDetails_RuleSubDomainToJSON(message.subDomain);
    }
    if (message.blockchain !== "") {
      obj.blockchain = message.blockchain;
    }
    if (message.network !== "") {
      obj.network = message.network;
    }
    if (message.evmCallContract !== undefined) {
      obj.evmCallContract = RulesContainer_TransactionRules_TransactionRuleDetails_EvmCallContract.toJSON(
        message.evmCallContract,
      );
    }
    if (message.xtzCallContract !== undefined) {
      obj.xtzCallContract = RulesContainer_TransactionRules_TransactionRuleDetails_XtzCallContract.toJSON(
        message.xtzCallContract,
      );
    }
    if (message.cashSettlement !== undefined) {
      obj.cashSettlement = RulesContainer_TransactionRules_TransactionRuleDetails_CashSettlement.toJSON(
        message.cashSettlement,
      );
    }
    if (message.cosmosDetails !== undefined) {
      obj.cosmosDetails = RulesContainer_TransactionRules_TransactionRuleDetails_CosmosDetails.toJSON(
        message.cosmosDetails,
      );
    }
    return obj;
  },

  create(
    base?: DeepPartial<RulesContainer_TransactionRules_TransactionRuleDetails>,
  ): RulesContainer_TransactionRules_TransactionRuleDetails {
    return RulesContainer_TransactionRules_TransactionRuleDetails.fromPartial(base ?? {});
  },
  fromPartial(
    object: DeepPartial<RulesContainer_TransactionRules_TransactionRuleDetails>,
  ): RulesContainer_TransactionRules_TransactionRuleDetails {
    const message = createBaseRulesContainer_TransactionRules_TransactionRuleDetails();
    message.domain = object.domain ?? 0;
    message.subDomain = object.subDomain ?? 0;
    message.blockchain = object.blockchain ?? "";
    message.network = object.network ?? "";
    message.evmCallContract = (object.evmCallContract !== undefined && object.evmCallContract !== null)
      ? RulesContainer_TransactionRules_TransactionRuleDetails_EvmCallContract.fromPartial(object.evmCallContract)
      : undefined;
    message.xtzCallContract = (object.xtzCallContract !== undefined && object.xtzCallContract !== null)
      ? RulesContainer_TransactionRules_TransactionRuleDetails_XtzCallContract.fromPartial(object.xtzCallContract)
      : undefined;
    message.cashSettlement = (object.cashSettlement !== undefined && object.cashSettlement !== null)
      ? RulesContainer_TransactionRules_TransactionRuleDetails_CashSettlement.fromPartial(object.cashSettlement)
      : undefined;
    message.cosmosDetails = (object.cosmosDetails !== undefined && object.cosmosDetails !== null)
      ? RulesContainer_TransactionRules_TransactionRuleDetails_CosmosDetails.fromPartial(object.cosmosDetails)
      : undefined;
    return message;
  },
};

function createBaseRulesContainer_TransactionRules_TransactionRuleDetails_EvmCallContract(): RulesContainer_TransactionRules_TransactionRuleDetails_EvmCallContract {
  return { contractType: "", methodSignature: "" };
}

export const RulesContainer_TransactionRules_TransactionRuleDetails_EvmCallContract = {
  encode(
    message: RulesContainer_TransactionRules_TransactionRuleDetails_EvmCallContract,
    writer: _m0.Writer = _m0.Writer.create(),
  ): _m0.Writer {
    if (message.contractType !== "") {
      writer.uint32(10).string(message.contractType);
    }
    if (message.methodSignature !== "") {
      writer.uint32(18).string(message.methodSignature);
    }
    return writer;
  },

  decode(
    input: _m0.Reader | Uint8Array,
    length?: number,
  ): RulesContainer_TransactionRules_TransactionRuleDetails_EvmCallContract {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseRulesContainer_TransactionRules_TransactionRuleDetails_EvmCallContract();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.contractType = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.methodSignature = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): RulesContainer_TransactionRules_TransactionRuleDetails_EvmCallContract {
    return {
      contractType: isSet(object.contractType) ? globalThis.String(object.contractType) : "",
      methodSignature: isSet(object.methodSignature) ? globalThis.String(object.methodSignature) : "",
    };
  },

  toJSON(message: RulesContainer_TransactionRules_TransactionRuleDetails_EvmCallContract): unknown {
    const obj: any = {};
    if (message.contractType !== "") {
      obj.contractType = message.contractType;
    }
    if (message.methodSignature !== "") {
      obj.methodSignature = message.methodSignature;
    }
    return obj;
  },

  create(
    base?: DeepPartial<RulesContainer_TransactionRules_TransactionRuleDetails_EvmCallContract>,
  ): RulesContainer_TransactionRules_TransactionRuleDetails_EvmCallContract {
    return RulesContainer_TransactionRules_TransactionRuleDetails_EvmCallContract.fromPartial(base ?? {});
  },
  fromPartial(
    object: DeepPartial<RulesContainer_TransactionRules_TransactionRuleDetails_EvmCallContract>,
  ): RulesContainer_TransactionRules_TransactionRuleDetails_EvmCallContract {
    const message = createBaseRulesContainer_TransactionRules_TransactionRuleDetails_EvmCallContract();
    message.contractType = object.contractType ?? "";
    message.methodSignature = object.methodSignature ?? "";
    return message;
  },
};

function createBaseRulesContainer_TransactionRules_TransactionRuleDetails_XtzCallContract(): RulesContainer_TransactionRules_TransactionRuleDetails_XtzCallContract {
  return { contractType: "", methodSignature: "" };
}

export const RulesContainer_TransactionRules_TransactionRuleDetails_XtzCallContract = {
  encode(
    message: RulesContainer_TransactionRules_TransactionRuleDetails_XtzCallContract,
    writer: _m0.Writer = _m0.Writer.create(),
  ): _m0.Writer {
    if (message.contractType !== "") {
      writer.uint32(10).string(message.contractType);
    }
    if (message.methodSignature !== "") {
      writer.uint32(18).string(message.methodSignature);
    }
    return writer;
  },

  decode(
    input: _m0.Reader | Uint8Array,
    length?: number,
  ): RulesContainer_TransactionRules_TransactionRuleDetails_XtzCallContract {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseRulesContainer_TransactionRules_TransactionRuleDetails_XtzCallContract();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.contractType = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.methodSignature = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): RulesContainer_TransactionRules_TransactionRuleDetails_XtzCallContract {
    return {
      contractType: isSet(object.contractType) ? globalThis.String(object.contractType) : "",
      methodSignature: isSet(object.methodSignature) ? globalThis.String(object.methodSignature) : "",
    };
  },

  toJSON(message: RulesContainer_TransactionRules_TransactionRuleDetails_XtzCallContract): unknown {
    const obj: any = {};
    if (message.contractType !== "") {
      obj.contractType = message.contractType;
    }
    if (message.methodSignature !== "") {
      obj.methodSignature = message.methodSignature;
    }
    return obj;
  },

  create(
    base?: DeepPartial<RulesContainer_TransactionRules_TransactionRuleDetails_XtzCallContract>,
  ): RulesContainer_TransactionRules_TransactionRuleDetails_XtzCallContract {
    return RulesContainer_TransactionRules_TransactionRuleDetails_XtzCallContract.fromPartial(base ?? {});
  },
  fromPartial(
    object: DeepPartial<RulesContainer_TransactionRules_TransactionRuleDetails_XtzCallContract>,
  ): RulesContainer_TransactionRules_TransactionRuleDetails_XtzCallContract {
    const message = createBaseRulesContainer_TransactionRules_TransactionRuleDetails_XtzCallContract();
    message.contractType = object.contractType ?? "";
    message.methodSignature = object.methodSignature ?? "";
    return message;
  },
};

function createBaseRulesContainer_TransactionRules_TransactionRuleDetails_CashSettlement(): RulesContainer_TransactionRules_TransactionRuleDetails_CashSettlement {
  return { provider: "", requestType: "" };
}

export const RulesContainer_TransactionRules_TransactionRuleDetails_CashSettlement = {
  encode(
    message: RulesContainer_TransactionRules_TransactionRuleDetails_CashSettlement,
    writer: _m0.Writer = _m0.Writer.create(),
  ): _m0.Writer {
    if (message.provider !== "") {
      writer.uint32(10).string(message.provider);
    }
    if (message.requestType !== "") {
      writer.uint32(18).string(message.requestType);
    }
    return writer;
  },

  decode(
    input: _m0.Reader | Uint8Array,
    length?: number,
  ): RulesContainer_TransactionRules_TransactionRuleDetails_CashSettlement {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseRulesContainer_TransactionRules_TransactionRuleDetails_CashSettlement();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.provider = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.requestType = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): RulesContainer_TransactionRules_TransactionRuleDetails_CashSettlement {
    return {
      provider: isSet(object.provider) ? globalThis.String(object.provider) : "",
      requestType: isSet(object.requestType) ? globalThis.String(object.requestType) : "",
    };
  },

  toJSON(message: RulesContainer_TransactionRules_TransactionRuleDetails_CashSettlement): unknown {
    const obj: any = {};
    if (message.provider !== "") {
      obj.provider = message.provider;
    }
    if (message.requestType !== "") {
      obj.requestType = message.requestType;
    }
    return obj;
  },

  create(
    base?: DeepPartial<RulesContainer_TransactionRules_TransactionRuleDetails_CashSettlement>,
  ): RulesContainer_TransactionRules_TransactionRuleDetails_CashSettlement {
    return RulesContainer_TransactionRules_TransactionRuleDetails_CashSettlement.fromPartial(base ?? {});
  },
  fromPartial(
    object: DeepPartial<RulesContainer_TransactionRules_TransactionRuleDetails_CashSettlement>,
  ): RulesContainer_TransactionRules_TransactionRuleDetails_CashSettlement {
    const message = createBaseRulesContainer_TransactionRules_TransactionRuleDetails_CashSettlement();
    message.provider = object.provider ?? "";
    message.requestType = object.requestType ?? "";
    return message;
  },
};

function createBaseRulesContainer_TransactionRules_TransactionRuleDetails_CosmosDetails(): RulesContainer_TransactionRules_TransactionRuleDetails_CosmosDetails {
  return { methodSignatures: [] };
}

export const RulesContainer_TransactionRules_TransactionRuleDetails_CosmosDetails = {
  encode(
    message: RulesContainer_TransactionRules_TransactionRuleDetails_CosmosDetails,
    writer: _m0.Writer = _m0.Writer.create(),
  ): _m0.Writer {
    for (const v of message.methodSignatures) {
      writer.uint32(10).string(v!);
    }
    return writer;
  },

  decode(
    input: _m0.Reader | Uint8Array,
    length?: number,
  ): RulesContainer_TransactionRules_TransactionRuleDetails_CosmosDetails {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseRulesContainer_TransactionRules_TransactionRuleDetails_CosmosDetails();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.methodSignatures.push(reader.string());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): RulesContainer_TransactionRules_TransactionRuleDetails_CosmosDetails {
    return {
      methodSignatures: globalThis.Array.isArray(object?.methodSignatures)
        ? object.methodSignatures.map((e: any) => globalThis.String(e))
        : [],
    };
  },

  toJSON(message: RulesContainer_TransactionRules_TransactionRuleDetails_CosmosDetails): unknown {
    const obj: any = {};
    if (message.methodSignatures?.length) {
      obj.methodSignatures = message.methodSignatures;
    }
    return obj;
  },

  create(
    base?: DeepPartial<RulesContainer_TransactionRules_TransactionRuleDetails_CosmosDetails>,
  ): RulesContainer_TransactionRules_TransactionRuleDetails_CosmosDetails {
    return RulesContainer_TransactionRules_TransactionRuleDetails_CosmosDetails.fromPartial(base ?? {});
  },
  fromPartial(
    object: DeepPartial<RulesContainer_TransactionRules_TransactionRuleDetails_CosmosDetails>,
  ): RulesContainer_TransactionRules_TransactionRuleDetails_CosmosDetails {
    const message = createBaseRulesContainer_TransactionRules_TransactionRuleDetails_CosmosDetails();
    message.methodSignatures = object.methodSignatures?.map((e) => e) || [];
    return message;
  },
};

function createBaseRulesContainer_AddressWhitelistingRules(): RulesContainer_AddressWhitelistingRules {
  return { currency: "", parallelThresholds: [], properties: {}, network: "", lines: [] };
}

export const RulesContainer_AddressWhitelistingRules = {
  encode(message: RulesContainer_AddressWhitelistingRules, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.currency !== "") {
      writer.uint32(10).string(message.currency);
    }
    for (const v of message.parallelThresholds) {
      SequentialThresholds.encode(v!, writer.uint32(18).fork()).ldelim();
    }
    Object.entries(message.properties).forEach(([key, value]) => {
      RulesContainer_AddressWhitelistingRules_PropertiesEntry.encode(
        { key: key as any, value },
        writer.uint32(26).fork(),
      ).ldelim();
    });
    if (message.network !== "") {
      writer.uint32(34).string(message.network);
    }
    for (const v of message.lines) {
      RulesContainer_AddressWhitelistingRules_Line.encode(v!, writer.uint32(42).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): RulesContainer_AddressWhitelistingRules {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseRulesContainer_AddressWhitelistingRules();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.currency = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.parallelThresholds.push(SequentialThresholds.decode(reader, reader.uint32()));
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          const entry3 = RulesContainer_AddressWhitelistingRules_PropertiesEntry.decode(reader, reader.uint32());
          if (entry3.value !== undefined) {
            message.properties[entry3.key] = entry3.value;
          }
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.network = reader.string();
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.lines.push(RulesContainer_AddressWhitelistingRules_Line.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): RulesContainer_AddressWhitelistingRules {
    return {
      currency: isSet(object.currency) ? globalThis.String(object.currency) : "",
      parallelThresholds: globalThis.Array.isArray(object?.parallelThresholds)
        ? object.parallelThresholds.map((e: any) => SequentialThresholds.fromJSON(e))
        : [],
      properties: isObject(object.properties)
        ? Object.entries(object.properties).reduce<{ [key: string]: Uint8Array }>((acc, [key, value]) => {
          acc[key] = bytesFromBase64(value as string);
          return acc;
        }, {})
        : {},
      network: isSet(object.network) ? globalThis.String(object.network) : "",
      lines: globalThis.Array.isArray(object?.lines)
        ? object.lines.map((e: any) => RulesContainer_AddressWhitelistingRules_Line.fromJSON(e))
        : [],
    };
  },

  toJSON(message: RulesContainer_AddressWhitelistingRules): unknown {
    const obj: any = {};
    if (message.currency !== "") {
      obj.currency = message.currency;
    }
    if (message.parallelThresholds?.length) {
      obj.parallelThresholds = message.parallelThresholds.map((e) => SequentialThresholds.toJSON(e));
    }
    if (message.properties) {
      const entries = Object.entries(message.properties);
      if (entries.length > 0) {
        obj.properties = {};
        entries.forEach(([k, v]) => {
          obj.properties[k] = base64FromBytes(v);
        });
      }
    }
    if (message.network !== "") {
      obj.network = message.network;
    }
    if (message.lines?.length) {
      obj.lines = message.lines.map((e) => RulesContainer_AddressWhitelistingRules_Line.toJSON(e));
    }
    return obj;
  },

  create(base?: DeepPartial<RulesContainer_AddressWhitelistingRules>): RulesContainer_AddressWhitelistingRules {
    return RulesContainer_AddressWhitelistingRules.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<RulesContainer_AddressWhitelistingRules>): RulesContainer_AddressWhitelistingRules {
    const message = createBaseRulesContainer_AddressWhitelistingRules();
    message.currency = object.currency ?? "";
    message.parallelThresholds = object.parallelThresholds?.map((e) => SequentialThresholds.fromPartial(e)) || [];
    message.properties = Object.entries(object.properties ?? {}).reduce<{ [key: string]: Uint8Array }>(
      (acc, [key, value]) => {
        if (value !== undefined) {
          acc[key] = value;
        }
        return acc;
      },
      {},
    );
    message.network = object.network ?? "";
    message.lines = object.lines?.map((e) => RulesContainer_AddressWhitelistingRules_Line.fromPartial(e)) || [];
    return message;
  },
};

function createBaseRulesContainer_AddressWhitelistingRules_Line(): RulesContainer_AddressWhitelistingRules_Line {
  return { cells: [], parallelThresholds: [], properties: {} };
}

export const RulesContainer_AddressWhitelistingRules_Line = {
  encode(message: RulesContainer_AddressWhitelistingRules_Line, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    for (const v of message.cells) {
      writer.uint32(10).bytes(v!);
    }
    for (const v of message.parallelThresholds) {
      SequentialThresholds.encode(v!, writer.uint32(18).fork()).ldelim();
    }
    Object.entries(message.properties).forEach(([key, value]) => {
      RulesContainer_AddressWhitelistingRules_Line_PropertiesEntry.encode(
        { key: key as any, value },
        writer.uint32(26).fork(),
      ).ldelim();
    });
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): RulesContainer_AddressWhitelistingRules_Line {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseRulesContainer_AddressWhitelistingRules_Line();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.cells.push(reader.bytes());
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.parallelThresholds.push(SequentialThresholds.decode(reader, reader.uint32()));
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          const entry3 = RulesContainer_AddressWhitelistingRules_Line_PropertiesEntry.decode(reader, reader.uint32());
          if (entry3.value !== undefined) {
            message.properties[entry3.key] = entry3.value;
          }
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): RulesContainer_AddressWhitelistingRules_Line {
    return {
      cells: globalThis.Array.isArray(object?.cells) ? object.cells.map((e: any) => bytesFromBase64(e)) : [],
      parallelThresholds: globalThis.Array.isArray(object?.parallelThresholds)
        ? object.parallelThresholds.map((e: any) => SequentialThresholds.fromJSON(e))
        : [],
      properties: isObject(object.properties)
        ? Object.entries(object.properties).reduce<{ [key: string]: Uint8Array }>((acc, [key, value]) => {
          acc[key] = bytesFromBase64(value as string);
          return acc;
        }, {})
        : {},
    };
  },

  toJSON(message: RulesContainer_AddressWhitelistingRules_Line): unknown {
    const obj: any = {};
    if (message.cells?.length) {
      obj.cells = message.cells.map((e) => base64FromBytes(e));
    }
    if (message.parallelThresholds?.length) {
      obj.parallelThresholds = message.parallelThresholds.map((e) => SequentialThresholds.toJSON(e));
    }
    if (message.properties) {
      const entries = Object.entries(message.properties);
      if (entries.length > 0) {
        obj.properties = {};
        entries.forEach(([k, v]) => {
          obj.properties[k] = base64FromBytes(v);
        });
      }
    }
    return obj;
  },

  create(
    base?: DeepPartial<RulesContainer_AddressWhitelistingRules_Line>,
  ): RulesContainer_AddressWhitelistingRules_Line {
    return RulesContainer_AddressWhitelistingRules_Line.fromPartial(base ?? {});
  },
  fromPartial(
    object: DeepPartial<RulesContainer_AddressWhitelistingRules_Line>,
  ): RulesContainer_AddressWhitelistingRules_Line {
    const message = createBaseRulesContainer_AddressWhitelistingRules_Line();
    message.cells = object.cells?.map((e) => e) || [];
    message.parallelThresholds = object.parallelThresholds?.map((e) => SequentialThresholds.fromPartial(e)) || [];
    message.properties = Object.entries(object.properties ?? {}).reduce<{ [key: string]: Uint8Array }>(
      (acc, [key, value]) => {
        if (value !== undefined) {
          acc[key] = value;
        }
        return acc;
      },
      {},
    );
    return message;
  },
};

function createBaseRulesContainer_AddressWhitelistingRules_Line_PropertiesEntry(): RulesContainer_AddressWhitelistingRules_Line_PropertiesEntry {
  return { key: "", value: new Uint8Array(0) };
}

export const RulesContainer_AddressWhitelistingRules_Line_PropertiesEntry = {
  encode(
    message: RulesContainer_AddressWhitelistingRules_Line_PropertiesEntry,
    writer: _m0.Writer = _m0.Writer.create(),
  ): _m0.Writer {
    if (message.key !== "") {
      writer.uint32(10).string(message.key);
    }
    if (message.value.length !== 0) {
      writer.uint32(18).bytes(message.value);
    }
    return writer;
  },

  decode(
    input: _m0.Reader | Uint8Array,
    length?: number,
  ): RulesContainer_AddressWhitelistingRules_Line_PropertiesEntry {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseRulesContainer_AddressWhitelistingRules_Line_PropertiesEntry();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.key = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.value = reader.bytes();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): RulesContainer_AddressWhitelistingRules_Line_PropertiesEntry {
    return {
      key: isSet(object.key) ? globalThis.String(object.key) : "",
      value: isSet(object.value) ? bytesFromBase64(object.value) : new Uint8Array(0),
    };
  },

  toJSON(message: RulesContainer_AddressWhitelistingRules_Line_PropertiesEntry): unknown {
    const obj: any = {};
    if (message.key !== "") {
      obj.key = message.key;
    }
    if (message.value.length !== 0) {
      obj.value = base64FromBytes(message.value);
    }
    return obj;
  },

  create(
    base?: DeepPartial<RulesContainer_AddressWhitelistingRules_Line_PropertiesEntry>,
  ): RulesContainer_AddressWhitelistingRules_Line_PropertiesEntry {
    return RulesContainer_AddressWhitelistingRules_Line_PropertiesEntry.fromPartial(base ?? {});
  },
  fromPartial(
    object: DeepPartial<RulesContainer_AddressWhitelistingRules_Line_PropertiesEntry>,
  ): RulesContainer_AddressWhitelistingRules_Line_PropertiesEntry {
    const message = createBaseRulesContainer_AddressWhitelistingRules_Line_PropertiesEntry();
    message.key = object.key ?? "";
    message.value = object.value ?? new Uint8Array(0);
    return message;
  },
};

function createBaseRulesContainer_AddressWhitelistingRules_PropertiesEntry(): RulesContainer_AddressWhitelistingRules_PropertiesEntry {
  return { key: "", value: new Uint8Array(0) };
}

export const RulesContainer_AddressWhitelistingRules_PropertiesEntry = {
  encode(
    message: RulesContainer_AddressWhitelistingRules_PropertiesEntry,
    writer: _m0.Writer = _m0.Writer.create(),
  ): _m0.Writer {
    if (message.key !== "") {
      writer.uint32(10).string(message.key);
    }
    if (message.value.length !== 0) {
      writer.uint32(18).bytes(message.value);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): RulesContainer_AddressWhitelistingRules_PropertiesEntry {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseRulesContainer_AddressWhitelistingRules_PropertiesEntry();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.key = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.value = reader.bytes();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): RulesContainer_AddressWhitelistingRules_PropertiesEntry {
    return {
      key: isSet(object.key) ? globalThis.String(object.key) : "",
      value: isSet(object.value) ? bytesFromBase64(object.value) : new Uint8Array(0),
    };
  },

  toJSON(message: RulesContainer_AddressWhitelistingRules_PropertiesEntry): unknown {
    const obj: any = {};
    if (message.key !== "") {
      obj.key = message.key;
    }
    if (message.value.length !== 0) {
      obj.value = base64FromBytes(message.value);
    }
    return obj;
  },

  create(
    base?: DeepPartial<RulesContainer_AddressWhitelistingRules_PropertiesEntry>,
  ): RulesContainer_AddressWhitelistingRules_PropertiesEntry {
    return RulesContainer_AddressWhitelistingRules_PropertiesEntry.fromPartial(base ?? {});
  },
  fromPartial(
    object: DeepPartial<RulesContainer_AddressWhitelistingRules_PropertiesEntry>,
  ): RulesContainer_AddressWhitelistingRules_PropertiesEntry {
    const message = createBaseRulesContainer_AddressWhitelistingRules_PropertiesEntry();
    message.key = object.key ?? "";
    message.value = object.value ?? new Uint8Array(0);
    return message;
  },
};

function createBaseRulesContainer_ContractAddressWhitelistingRules(): RulesContainer_ContractAddressWhitelistingRules {
  return { blockchain: 0, parallelThresholds: [], properties: {}, network: "" };
}

export const RulesContainer_ContractAddressWhitelistingRules = {
  encode(
    message: RulesContainer_ContractAddressWhitelistingRules,
    writer: _m0.Writer = _m0.Writer.create(),
  ): _m0.Writer {
    if (message.blockchain !== 0) {
      writer.uint32(24).int32(message.blockchain);
    }
    for (const v of message.parallelThresholds) {
      SequentialThresholds.encode(v!, writer.uint32(18).fork()).ldelim();
    }
    Object.entries(message.properties).forEach(([key, value]) => {
      RulesContainer_ContractAddressWhitelistingRules_PropertiesEntry.encode(
        { key: key as any, value },
        writer.uint32(34).fork(),
      ).ldelim();
    });
    if (message.network !== "") {
      writer.uint32(42).string(message.network);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): RulesContainer_ContractAddressWhitelistingRules {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseRulesContainer_ContractAddressWhitelistingRules();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 3:
          if (tag !== 24) {
            break;
          }

          message.blockchain = reader.int32() as any;
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.parallelThresholds.push(SequentialThresholds.decode(reader, reader.uint32()));
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          const entry4 = RulesContainer_ContractAddressWhitelistingRules_PropertiesEntry.decode(
            reader,
            reader.uint32(),
          );
          if (entry4.value !== undefined) {
            message.properties[entry4.key] = entry4.value;
          }
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.network = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): RulesContainer_ContractAddressWhitelistingRules {
    return {
      blockchain: isSet(object.blockchain) ? blockchainFromJSON(object.blockchain) : 0,
      parallelThresholds: globalThis.Array.isArray(object?.parallelThresholds)
        ? object.parallelThresholds.map((e: any) => SequentialThresholds.fromJSON(e))
        : [],
      properties: isObject(object.properties)
        ? Object.entries(object.properties).reduce<{ [key: string]: Uint8Array }>((acc, [key, value]) => {
          acc[key] = bytesFromBase64(value as string);
          return acc;
        }, {})
        : {},
      network: isSet(object.network) ? globalThis.String(object.network) : "",
    };
  },

  toJSON(message: RulesContainer_ContractAddressWhitelistingRules): unknown {
    const obj: any = {};
    if (message.blockchain !== 0) {
      obj.blockchain = blockchainToJSON(message.blockchain);
    }
    if (message.parallelThresholds?.length) {
      obj.parallelThresholds = message.parallelThresholds.map((e) => SequentialThresholds.toJSON(e));
    }
    if (message.properties) {
      const entries = Object.entries(message.properties);
      if (entries.length > 0) {
        obj.properties = {};
        entries.forEach(([k, v]) => {
          obj.properties[k] = base64FromBytes(v);
        });
      }
    }
    if (message.network !== "") {
      obj.network = message.network;
    }
    return obj;
  },

  create(
    base?: DeepPartial<RulesContainer_ContractAddressWhitelistingRules>,
  ): RulesContainer_ContractAddressWhitelistingRules {
    return RulesContainer_ContractAddressWhitelistingRules.fromPartial(base ?? {});
  },
  fromPartial(
    object: DeepPartial<RulesContainer_ContractAddressWhitelistingRules>,
  ): RulesContainer_ContractAddressWhitelistingRules {
    const message = createBaseRulesContainer_ContractAddressWhitelistingRules();
    message.blockchain = object.blockchain ?? 0;
    message.parallelThresholds = object.parallelThresholds?.map((e) => SequentialThresholds.fromPartial(e)) || [];
    message.properties = Object.entries(object.properties ?? {}).reduce<{ [key: string]: Uint8Array }>(
      (acc, [key, value]) => {
        if (value !== undefined) {
          acc[key] = value;
        }
        return acc;
      },
      {},
    );
    message.network = object.network ?? "";
    return message;
  },
};

function createBaseRulesContainer_ContractAddressWhitelistingRules_PropertiesEntry(): RulesContainer_ContractAddressWhitelistingRules_PropertiesEntry {
  return { key: "", value: new Uint8Array(0) };
}

export const RulesContainer_ContractAddressWhitelistingRules_PropertiesEntry = {
  encode(
    message: RulesContainer_ContractAddressWhitelistingRules_PropertiesEntry,
    writer: _m0.Writer = _m0.Writer.create(),
  ): _m0.Writer {
    if (message.key !== "") {
      writer.uint32(10).string(message.key);
    }
    if (message.value.length !== 0) {
      writer.uint32(18).bytes(message.value);
    }
    return writer;
  },

  decode(
    input: _m0.Reader | Uint8Array,
    length?: number,
  ): RulesContainer_ContractAddressWhitelistingRules_PropertiesEntry {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseRulesContainer_ContractAddressWhitelistingRules_PropertiesEntry();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.key = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.value = reader.bytes();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): RulesContainer_ContractAddressWhitelistingRules_PropertiesEntry {
    return {
      key: isSet(object.key) ? globalThis.String(object.key) : "",
      value: isSet(object.value) ? bytesFromBase64(object.value) : new Uint8Array(0),
    };
  },

  toJSON(message: RulesContainer_ContractAddressWhitelistingRules_PropertiesEntry): unknown {
    const obj: any = {};
    if (message.key !== "") {
      obj.key = message.key;
    }
    if (message.value.length !== 0) {
      obj.value = base64FromBytes(message.value);
    }
    return obj;
  },

  create(
    base?: DeepPartial<RulesContainer_ContractAddressWhitelistingRules_PropertiesEntry>,
  ): RulesContainer_ContractAddressWhitelistingRules_PropertiesEntry {
    return RulesContainer_ContractAddressWhitelistingRules_PropertiesEntry.fromPartial(base ?? {});
  },
  fromPartial(
    object: DeepPartial<RulesContainer_ContractAddressWhitelistingRules_PropertiesEntry>,
  ): RulesContainer_ContractAddressWhitelistingRules_PropertiesEntry {
    const message = createBaseRulesContainer_ContractAddressWhitelistingRules_PropertiesEntry();
    message.key = object.key ?? "";
    message.value = object.value ?? new Uint8Array(0);
    return message;
  },
};

function createBaseRulesContainer_Policy(): RulesContainer_Policy {
  return { id: "", label: "", parallelThresholds: [], description: "" };
}

export const RulesContainer_Policy = {
  encode(message: RulesContainer_Policy, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.id !== "") {
      writer.uint32(10).string(message.id);
    }
    if (message.label !== "") {
      writer.uint32(18).string(message.label);
    }
    for (const v of message.parallelThresholds) {
      SequentialThresholds.encode(v!, writer.uint32(26).fork()).ldelim();
    }
    if (message.description !== "") {
      writer.uint32(34).string(message.description);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): RulesContainer_Policy {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseRulesContainer_Policy();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.id = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.label = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.parallelThresholds.push(SequentialThresholds.decode(reader, reader.uint32()));
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.description = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): RulesContainer_Policy {
    return {
      id: isSet(object.id) ? globalThis.String(object.id) : "",
      label: isSet(object.label) ? globalThis.String(object.label) : "",
      parallelThresholds: globalThis.Array.isArray(object?.parallelThresholds)
        ? object.parallelThresholds.map((e: any) => SequentialThresholds.fromJSON(e))
        : [],
      description: isSet(object.description) ? globalThis.String(object.description) : "",
    };
  },

  toJSON(message: RulesContainer_Policy): unknown {
    const obj: any = {};
    if (message.id !== "") {
      obj.id = message.id;
    }
    if (message.label !== "") {
      obj.label = message.label;
    }
    if (message.parallelThresholds?.length) {
      obj.parallelThresholds = message.parallelThresholds.map((e) => SequentialThresholds.toJSON(e));
    }
    if (message.description !== "") {
      obj.description = message.description;
    }
    return obj;
  },

  create(base?: DeepPartial<RulesContainer_Policy>): RulesContainer_Policy {
    return RulesContainer_Policy.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<RulesContainer_Policy>): RulesContainer_Policy {
    const message = createBaseRulesContainer_Policy();
    message.id = object.id ?? "";
    message.label = object.label ?? "";
    message.parallelThresholds = object.parallelThresholds?.map((e) => SequentialThresholds.fromPartial(e)) || [];
    message.description = object.description ?? "";
    return message;
  },
};

function createBaseRulesContainer_Policies(): RulesContainer_Policies {
  return { policies: [] };
}

export const RulesContainer_Policies = {
  encode(message: RulesContainer_Policies, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    for (const v of message.policies) {
      RulesContainer_Policy.encode(v!, writer.uint32(10).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): RulesContainer_Policies {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseRulesContainer_Policies();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.policies.push(RulesContainer_Policy.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): RulesContainer_Policies {
    return {
      policies: globalThis.Array.isArray(object?.policies)
        ? object.policies.map((e: any) => RulesContainer_Policy.fromJSON(e))
        : [],
    };
  },

  toJSON(message: RulesContainer_Policies): unknown {
    const obj: any = {};
    if (message.policies?.length) {
      obj.policies = message.policies.map((e) => RulesContainer_Policy.toJSON(e));
    }
    return obj;
  },

  create(base?: DeepPartial<RulesContainer_Policies>): RulesContainer_Policies {
    return RulesContainer_Policies.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<RulesContainer_Policies>): RulesContainer_Policies {
    const message = createBaseRulesContainer_Policies();
    message.policies = object.policies?.map((e) => RulesContainer_Policy.fromPartial(e)) || [];
    return message;
  },
};

function createBaseRulesContainer_PropertiesEntry(): RulesContainer_PropertiesEntry {
  return { key: "", value: new Uint8Array(0) };
}

export const RulesContainer_PropertiesEntry = {
  encode(message: RulesContainer_PropertiesEntry, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.key !== "") {
      writer.uint32(10).string(message.key);
    }
    if (message.value.length !== 0) {
      writer.uint32(18).bytes(message.value);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): RulesContainer_PropertiesEntry {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseRulesContainer_PropertiesEntry();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.key = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.value = reader.bytes();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): RulesContainer_PropertiesEntry {
    return {
      key: isSet(object.key) ? globalThis.String(object.key) : "",
      value: isSet(object.value) ? bytesFromBase64(object.value) : new Uint8Array(0),
    };
  },

  toJSON(message: RulesContainer_PropertiesEntry): unknown {
    const obj: any = {};
    if (message.key !== "") {
      obj.key = message.key;
    }
    if (message.value.length !== 0) {
      obj.value = base64FromBytes(message.value);
    }
    return obj;
  },

  create(base?: DeepPartial<RulesContainer_PropertiesEntry>): RulesContainer_PropertiesEntry {
    return RulesContainer_PropertiesEntry.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<RulesContainer_PropertiesEntry>): RulesContainer_PropertiesEntry {
    const message = createBaseRulesContainer_PropertiesEntry();
    message.key = object.key ?? "";
    message.value = object.value ?? new Uint8Array(0);
    return message;
  },
};

function bytesFromBase64(b64: string): Uint8Array {
  const bin = globalThis.atob(b64);
  const arr = new Uint8Array(bin.length);
  for (let i = 0; i < bin.length; ++i) {
    arr[i] = bin.charCodeAt(i);
  }
  return arr;
}

function base64FromBytes(arr: Uint8Array): string {
  const bin: string[] = [];
  arr.forEach((byte) => {
    bin.push(globalThis.String.fromCharCode(byte));
  });
  return globalThis.btoa(bin.join(""));
}

type Builtin = Date | Function | Uint8Array | string | number | boolean | undefined;

export type DeepPartial<T> = T extends Builtin ? T
  : T extends globalThis.Array<infer U> ? globalThis.Array<DeepPartial<U>>
  : T extends ReadonlyArray<infer U> ? ReadonlyArray<DeepPartial<U>>
  : T extends {} ? { [K in keyof T]?: DeepPartial<T[K]> }
  : Partial<T>;

function longToNumber(long: Long): number {
  if (long.gt(globalThis.Number.MAX_SAFE_INTEGER)) {
    throw new globalThis.Error("Value is larger than Number.MAX_SAFE_INTEGER");
  }
  if (long.lt(globalThis.Number.MIN_SAFE_INTEGER)) {
    throw new globalThis.Error("Value is smaller than Number.MIN_SAFE_INTEGER");
  }
  return long.toNumber();
}

if (_m0.util.Long !== Long) {
  _m0.util.Long = Long as any;
  _m0.configure();
}

function isObject(value: any): boolean {
  return typeof value === "object" && value !== null;
}

function isSet(value: any): boolean {
  return value !== null && value !== undefined;
}
