# -*- coding: utf-8 -*-
# Generated by the protocol buffer compiler.  DO NOT EDIT!
# NO CHECKED-IN PROTOBUF GENCODE
# source: auth_proxy/api_request_to_validate.proto
# Protobuf Python Version: 6.33.4
"""Generated protocol buffer code."""
from google.protobuf import descriptor as _descriptor
from google.protobuf import descriptor_pool as _descriptor_pool
from google.protobuf import runtime_version as _runtime_version
from google.protobuf import symbol_database as _symbol_database
from google.protobuf.internal import builder as _builder
_runtime_version.ValidateProtobufRuntimeVersion(
    _runtime_version.Domain.PUBLIC,
    6,
    33,
    4,
    '',
    'auth_proxy/api_request_to_validate.proto'
)
# @@protoc_insertion_point(imports)

_sym_db = _symbol_database.Default()


from google.api import annotations_pb2 as google_dot_api_dot_annotations__pb2
from google.protobuf import timestamp_pb2 as google_dot_protobuf_dot_timestamp__pb2
from protoc_gen_openapiv2.options import annotations_pb2 as protoc__gen__openapiv2_dot_options_dot_annotations__pb2


DESCRIPTOR = _descriptor_pool.Default().AddSerializedFile(b'\n(auth_proxy/api_request_to_validate.proto\x12\nauth_proxy\x1a\x1cgoogle/api/annotations.proto\x1a\x1fgoogle/protobuf/timestamp.proto\x1a.protoc-gen-openapiv2/options/annotations.proto\"\x94\x07\n\x14\x41piRequestToValidate\x12\x42\n\x06prefix\x18\x01 \x01(\tB2\x92\x41/2-An identifier of the signing protocol version\x12\x43\n\x06\x61piKey\x18\x02 \x01(\tB3\x92\x41\x30\x32.The API key of the user submitting the request\x12I\n\x05nonce\x18\x03 \x01(\tB:\x92\x41\x37\x32\x35The nonce associated to the API key (to avoid replay)\x12|\n\ttimestamp\x18\x04 \x01(\x0b\x32\x1a.google.protobuf.TimestampBM\x92\x41J2HThe timestamp of the request - used to reject too old or future requests\x12\x33\n\x06method\x18\x05 \x01(\tB#\x92\x41 2\x1eThe HTTP method of the request\x12\x33\n\x04host\x18\x06 \x01(\tB%\x92\x41\"2 The host property of the request\x12\x33\n\x04path\x18\x07 \x01(\tB%\x92\x41\"2 The path property of the request\x12\x35\n\x05query\x18\x08 \x01(\tB&\x92\x41#2!The query property of the request\x12\x41\n\x0b\x63ontentType\x18\t \x01(\tB,\x92\x41)2\'The contentType property of the request\x12k\n\x04\x62ody\x18\n \x01(\x0c\x42]\x92\x41Z2XThe body of the request (through the REST API, the bytes are encoded as a base64 string)\x12\xa3\x01\n\tsignature\x18\x0b \x01(\x0c\x42\x8f\x01\x92\x41\x8b\x01\x32\x88\x01The submitted HMAC signature for the request, which we need to validate (through the REST API, the bytes are encoded as a base64 string)B2\n0com.taurushq.sdk.protect.proto.common.auth_proxyb\x06proto3')

_globals = globals()
_builder.BuildMessageAndEnumDescriptors(DESCRIPTOR, _globals)
_builder.BuildTopDescriptorsAndMessages(DESCRIPTOR, 'auth_proxy.api_request_to_validate_pb2', _globals)
if not _descriptor._USE_C_DESCRIPTORS:
  _globals['DESCRIPTOR']._loaded_options = None
  _globals['DESCRIPTOR']._serialized_options = b'\n0com.taurushq.sdk.protect.proto.common.auth_proxy'
  _globals['_APIREQUESTTOVALIDATE'].fields_by_name['prefix']._loaded_options = None
  _globals['_APIREQUESTTOVALIDATE'].fields_by_name['prefix']._serialized_options = b'\222A/2-An identifier of the signing protocol version'
  _globals['_APIREQUESTTOVALIDATE'].fields_by_name['apiKey']._loaded_options = None
  _globals['_APIREQUESTTOVALIDATE'].fields_by_name['apiKey']._serialized_options = b'\222A02.The API key of the user submitting the request'
  _globals['_APIREQUESTTOVALIDATE'].fields_by_name['nonce']._loaded_options = None
  _globals['_APIREQUESTTOVALIDATE'].fields_by_name['nonce']._serialized_options = b'\222A725The nonce associated to the API key (to avoid replay)'
  _globals['_APIREQUESTTOVALIDATE'].fields_by_name['timestamp']._loaded_options = None
  _globals['_APIREQUESTTOVALIDATE'].fields_by_name['timestamp']._serialized_options = b'\222AJ2HThe timestamp of the request - used to reject too old or future requests'
  _globals['_APIREQUESTTOVALIDATE'].fields_by_name['method']._loaded_options = None
  _globals['_APIREQUESTTOVALIDATE'].fields_by_name['method']._serialized_options = b'\222A 2\036The HTTP method of the request'
  _globals['_APIREQUESTTOVALIDATE'].fields_by_name['host']._loaded_options = None
  _globals['_APIREQUESTTOVALIDATE'].fields_by_name['host']._serialized_options = b'\222A\"2 The host property of the request'
  _globals['_APIREQUESTTOVALIDATE'].fields_by_name['path']._loaded_options = None
  _globals['_APIREQUESTTOVALIDATE'].fields_by_name['path']._serialized_options = b'\222A\"2 The path property of the request'
  _globals['_APIREQUESTTOVALIDATE'].fields_by_name['query']._loaded_options = None
  _globals['_APIREQUESTTOVALIDATE'].fields_by_name['query']._serialized_options = b'\222A#2!The query property of the request'
  _globals['_APIREQUESTTOVALIDATE'].fields_by_name['contentType']._loaded_options = None
  _globals['_APIREQUESTTOVALIDATE'].fields_by_name['contentType']._serialized_options = b'\222A)2\'The contentType property of the request'
  _globals['_APIREQUESTTOVALIDATE'].fields_by_name['body']._loaded_options = None
  _globals['_APIREQUESTTOVALIDATE'].fields_by_name['body']._serialized_options = b'\222AZ2XThe body of the request (through the REST API, the bytes are encoded as a base64 string)'
  _globals['_APIREQUESTTOVALIDATE'].fields_by_name['signature']._loaded_options = None
  _globals['_APIREQUESTTOVALIDATE'].fields_by_name['signature']._serialized_options = b'\222A\213\0012\210\001The submitted HMAC signature for the request, which we need to validate (through the REST API, the bytes are encoded as a base64 string)'
  _globals['_APIREQUESTTOVALIDATE']._serialized_start=168
  _globals['_APIREQUESTTOVALIDATE']._serialized_end=1084
# @@protoc_insertion_point(module_scope)
