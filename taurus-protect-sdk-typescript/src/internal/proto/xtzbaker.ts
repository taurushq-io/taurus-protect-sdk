// Code generated by protoc-gen-ts_proto. DO NOT EDIT.
// versions:
//   protoc-gen-ts_proto  v1.181.2
//   protoc               v6.33.4
// source: xtzbaker.proto

/* eslint-disable */
import _m0 from "protobufjs/minimal";

export const protobufPackage = "tgvalidatord";

export interface XTZBaker {
  address: string;
  stakingBond: string;
  stakingBalance: string;
  stakingCapacity: string;
  availableCapacity: string;
  active: boolean;
  isStakingAllowed: boolean;
  totalStaked: string;
  externalStaked: string;
  overStaked: string;
  externalStakingCapacity: string;
  totalDelegated: string;
  externalDelegated: string;
  delegationCapacity: string;
  availableDelegationCapacity: string;
  edgeOfBakingOverStaking: string;
}

function createBaseXTZBaker(): XTZBaker {
  return {
    address: "",
    stakingBond: "",
    stakingBalance: "",
    stakingCapacity: "",
    availableCapacity: "",
    active: false,
    isStakingAllowed: false,
    totalStaked: "",
    externalStaked: "",
    overStaked: "",
    externalStakingCapacity: "",
    totalDelegated: "",
    externalDelegated: "",
    delegationCapacity: "",
    availableDelegationCapacity: "",
    edgeOfBakingOverStaking: "",
  };
}

export const XTZBaker = {
  encode(message: XTZBaker, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.address !== "") {
      writer.uint32(10).string(message.address);
    }
    if (message.stakingBond !== "") {
      writer.uint32(18).string(message.stakingBond);
    }
    if (message.stakingBalance !== "") {
      writer.uint32(26).string(message.stakingBalance);
    }
    if (message.stakingCapacity !== "") {
      writer.uint32(34).string(message.stakingCapacity);
    }
    if (message.availableCapacity !== "") {
      writer.uint32(42).string(message.availableCapacity);
    }
    if (message.active !== false) {
      writer.uint32(48).bool(message.active);
    }
    if (message.isStakingAllowed !== false) {
      writer.uint32(56).bool(message.isStakingAllowed);
    }
    if (message.totalStaked !== "") {
      writer.uint32(66).string(message.totalStaked);
    }
    if (message.externalStaked !== "") {
      writer.uint32(74).string(message.externalStaked);
    }
    if (message.overStaked !== "") {
      writer.uint32(82).string(message.overStaked);
    }
    if (message.externalStakingCapacity !== "") {
      writer.uint32(90).string(message.externalStakingCapacity);
    }
    if (message.totalDelegated !== "") {
      writer.uint32(98).string(message.totalDelegated);
    }
    if (message.externalDelegated !== "") {
      writer.uint32(106).string(message.externalDelegated);
    }
    if (message.delegationCapacity !== "") {
      writer.uint32(114).string(message.delegationCapacity);
    }
    if (message.availableDelegationCapacity !== "") {
      writer.uint32(122).string(message.availableDelegationCapacity);
    }
    if (message.edgeOfBakingOverStaking !== "") {
      writer.uint32(130).string(message.edgeOfBakingOverStaking);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): XTZBaker {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseXTZBaker();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.address = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.stakingBond = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.stakingBalance = reader.string();
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.stakingCapacity = reader.string();
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.availableCapacity = reader.string();
          continue;
        case 6:
          if (tag !== 48) {
            break;
          }

          message.active = reader.bool();
          continue;
        case 7:
          if (tag !== 56) {
            break;
          }

          message.isStakingAllowed = reader.bool();
          continue;
        case 8:
          if (tag !== 66) {
            break;
          }

          message.totalStaked = reader.string();
          continue;
        case 9:
          if (tag !== 74) {
            break;
          }

          message.externalStaked = reader.string();
          continue;
        case 10:
          if (tag !== 82) {
            break;
          }

          message.overStaked = reader.string();
          continue;
        case 11:
          if (tag !== 90) {
            break;
          }

          message.externalStakingCapacity = reader.string();
          continue;
        case 12:
          if (tag !== 98) {
            break;
          }

          message.totalDelegated = reader.string();
          continue;
        case 13:
          if (tag !== 106) {
            break;
          }

          message.externalDelegated = reader.string();
          continue;
        case 14:
          if (tag !== 114) {
            break;
          }

          message.delegationCapacity = reader.string();
          continue;
        case 15:
          if (tag !== 122) {
            break;
          }

          message.availableDelegationCapacity = reader.string();
          continue;
        case 16:
          if (tag !== 130) {
            break;
          }

          message.edgeOfBakingOverStaking = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): XTZBaker {
    return {
      address: isSet(object.address) ? globalThis.String(object.address) : "",
      stakingBond: isSet(object.stakingBond) ? globalThis.String(object.stakingBond) : "",
      stakingBalance: isSet(object.stakingBalance) ? globalThis.String(object.stakingBalance) : "",
      stakingCapacity: isSet(object.stakingCapacity) ? globalThis.String(object.stakingCapacity) : "",
      availableCapacity: isSet(object.availableCapacity) ? globalThis.String(object.availableCapacity) : "",
      active: isSet(object.active) ? globalThis.Boolean(object.active) : false,
      isStakingAllowed: isSet(object.isStakingAllowed) ? globalThis.Boolean(object.isStakingAllowed) : false,
      totalStaked: isSet(object.totalStaked) ? globalThis.String(object.totalStaked) : "",
      externalStaked: isSet(object.externalStaked) ? globalThis.String(object.externalStaked) : "",
      overStaked: isSet(object.overStaked) ? globalThis.String(object.overStaked) : "",
      externalStakingCapacity: isSet(object.externalStakingCapacity)
        ? globalThis.String(object.externalStakingCapacity)
        : "",
      totalDelegated: isSet(object.totalDelegated) ? globalThis.String(object.totalDelegated) : "",
      externalDelegated: isSet(object.externalDelegated) ? globalThis.String(object.externalDelegated) : "",
      delegationCapacity: isSet(object.delegationCapacity) ? globalThis.String(object.delegationCapacity) : "",
      availableDelegationCapacity: isSet(object.availableDelegationCapacity)
        ? globalThis.String(object.availableDelegationCapacity)
        : "",
      edgeOfBakingOverStaking: isSet(object.edgeOfBakingOverStaking)
        ? globalThis.String(object.edgeOfBakingOverStaking)
        : "",
    };
  },

  toJSON(message: XTZBaker): unknown {
    const obj: any = {};
    if (message.address !== "") {
      obj.address = message.address;
    }
    if (message.stakingBond !== "") {
      obj.stakingBond = message.stakingBond;
    }
    if (message.stakingBalance !== "") {
      obj.stakingBalance = message.stakingBalance;
    }
    if (message.stakingCapacity !== "") {
      obj.stakingCapacity = message.stakingCapacity;
    }
    if (message.availableCapacity !== "") {
      obj.availableCapacity = message.availableCapacity;
    }
    if (message.active !== false) {
      obj.active = message.active;
    }
    if (message.isStakingAllowed !== false) {
      obj.isStakingAllowed = message.isStakingAllowed;
    }
    if (message.totalStaked !== "") {
      obj.totalStaked = message.totalStaked;
    }
    if (message.externalStaked !== "") {
      obj.externalStaked = message.externalStaked;
    }
    if (message.overStaked !== "") {
      obj.overStaked = message.overStaked;
    }
    if (message.externalStakingCapacity !== "") {
      obj.externalStakingCapacity = message.externalStakingCapacity;
    }
    if (message.totalDelegated !== "") {
      obj.totalDelegated = message.totalDelegated;
    }
    if (message.externalDelegated !== "") {
      obj.externalDelegated = message.externalDelegated;
    }
    if (message.delegationCapacity !== "") {
      obj.delegationCapacity = message.delegationCapacity;
    }
    if (message.availableDelegationCapacity !== "") {
      obj.availableDelegationCapacity = message.availableDelegationCapacity;
    }
    if (message.edgeOfBakingOverStaking !== "") {
      obj.edgeOfBakingOverStaking = message.edgeOfBakingOverStaking;
    }
    return obj;
  },

  create(base?: DeepPartial<XTZBaker>): XTZBaker {
    return XTZBaker.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<XTZBaker>): XTZBaker {
    const message = createBaseXTZBaker();
    message.address = object.address ?? "";
    message.stakingBond = object.stakingBond ?? "";
    message.stakingBalance = object.stakingBalance ?? "";
    message.stakingCapacity = object.stakingCapacity ?? "";
    message.availableCapacity = object.availableCapacity ?? "";
    message.active = object.active ?? false;
    message.isStakingAllowed = object.isStakingAllowed ?? false;
    message.totalStaked = object.totalStaked ?? "";
    message.externalStaked = object.externalStaked ?? "";
    message.overStaked = object.overStaked ?? "";
    message.externalStakingCapacity = object.externalStakingCapacity ?? "";
    message.totalDelegated = object.totalDelegated ?? "";
    message.externalDelegated = object.externalDelegated ?? "";
    message.delegationCapacity = object.delegationCapacity ?? "";
    message.availableDelegationCapacity = object.availableDelegationCapacity ?? "";
    message.edgeOfBakingOverStaking = object.edgeOfBakingOverStaking ?? "";
    return message;
  },
};

type Builtin = Date | Function | Uint8Array | string | number | boolean | undefined;

export type DeepPartial<T> = T extends Builtin ? T
  : T extends globalThis.Array<infer U> ? globalThis.Array<DeepPartial<U>>
  : T extends ReadonlyArray<infer U> ? ReadonlyArray<DeepPartial<U>>
  : T extends {} ? { [K in keyof T]?: DeepPartial<T[K]> }
  : Partial<T>;

function isSet(value: any): boolean {
  return value !== null && value !== undefined;
}
