// Code generated by protoc-gen-go. DO NOT EDIT.
// versions:
// 	protoc-gen-go v1.36.11
// 	protoc        v5.29.3
// source: tp_messages/commitments.proto

package proto

import (
	protoreflect "google.golang.org/protobuf/reflect/protoreflect"
	protoimpl "google.golang.org/protobuf/runtime/protoimpl"
	reflect "reflect"
	sync "sync"
	unsafe "unsafe"
)

const (
	// Verify that this generated code is sufficiently up-to-date.
	_ = protoimpl.EnforceVersion(20 - protoimpl.MinVersion)
	// Verify that runtime/protoimpl is sufficiently up-to-date.
	_ = protoimpl.EnforceVersion(protoimpl.MaxVersion - 20)
)

type CommitmentKind int32

const (
	CommitmentKind_UTXO               CommitmentKind = 0
	CommitmentKind_Account            CommitmentKind = 1
	CommitmentKind_Algo               CommitmentKind = 2
	CommitmentKind_ETHwrapped         CommitmentKind = 3
	CommitmentKind_Icp                CommitmentKind = 4
	CommitmentKind_Hash               CommitmentKind = 5
	CommitmentKind_HederaTransactions CommitmentKind = 6
)

// Enum value maps for CommitmentKind.
var (
	CommitmentKind_name = map[int32]string{
		0: "UTXO",
		1: "Account",
		2: "Algo",
		3: "ETHwrapped",
		4: "Icp",
		5: "Hash",
		6: "HederaTransactions",
	}
	CommitmentKind_value = map[string]int32{
		"UTXO":               0,
		"Account":            1,
		"Algo":               2,
		"ETHwrapped":         3,
		"Icp":                4,
		"Hash":               5,
		"HederaTransactions": 6,
	}
)

func (x CommitmentKind) Enum() *CommitmentKind {
	p := new(CommitmentKind)
	*p = x
	return p
}

func (x CommitmentKind) String() string {
	return protoimpl.X.EnumStringOf(x.Descriptor(), protoreflect.EnumNumber(x))
}

func (CommitmentKind) Descriptor() protoreflect.EnumDescriptor {
	return file_tp_messages_commitments_proto_enumTypes[0].Descriptor()
}

func (CommitmentKind) Type() protoreflect.EnumType {
	return &file_tp_messages_commitments_proto_enumTypes[0]
}

func (x CommitmentKind) Number() protoreflect.EnumNumber {
	return protoreflect.EnumNumber(x)
}

// Deprecated: Use CommitmentKind.Descriptor instead.
func (CommitmentKind) EnumDescriptor() ([]byte, []int) {
	return file_tp_messages_commitments_proto_rawDescGZIP(), []int{0}
}

// Is the commitment type for:
// Avax,Cosmos,DOT,ETH,FTM,NEAR,Polygon,XLM,XRP,XTZ
type AccountCommitment struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// Strong binding to the committer
	// Different committers operate on different networks, and will refuse to sign data from another network.
	// This information is cross checked within the metadata
	// In itself, this isn't enough to prevent replays across networks, but combined with the chainId, it's enough.
	Network string `protobuf:"bytes,1,opt,name=network,proto3" json:"network,omitempty"`
	// A generic chain identifier, used to distinguish between chain networks.
	// Avax,ETH,FTM,Polygon: the chain id
	// Cosmos: the chain id
	// DOT: the genesis hash
	// NEAR: a recent block hash
	// XLM: hash of the network passphrase
	// XRP: network ID
	// XTZ: a recent block hash
	ChainId       []byte                              `protobuf:"bytes,2,opt,name=chainId,proto3" json:"chainId,omitempty"`
	Bindings      []*AccountCommitment_AccountBinding `protobuf:"bytes,3,rep,name=bindings,proto3" json:"bindings,omitempty"`
	Blockchain    string                              `protobuf:"bytes,4,opt,name=blockchain,proto3" json:"blockchain,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *AccountCommitment) Reset() {
	*x = AccountCommitment{}
	mi := &file_tp_messages_commitments_proto_msgTypes[0]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *AccountCommitment) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*AccountCommitment) ProtoMessage() {}

func (x *AccountCommitment) ProtoReflect() protoreflect.Message {
	mi := &file_tp_messages_commitments_proto_msgTypes[0]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use AccountCommitment.ProtoReflect.Descriptor instead.
func (*AccountCommitment) Descriptor() ([]byte, []int) {
	return file_tp_messages_commitments_proto_rawDescGZIP(), []int{0}
}

func (x *AccountCommitment) GetNetwork() string {
	if x != nil {
		return x.Network
	}
	return ""
}

func (x *AccountCommitment) GetChainId() []byte {
	if x != nil {
		return x.ChainId
	}
	return nil
}

func (x *AccountCommitment) GetBindings() []*AccountCommitment_AccountBinding {
	if x != nil {
		return x.Bindings
	}
	return nil
}

func (x *AccountCommitment) GetBlockchain() string {
	if x != nil {
		return x.Blockchain
	}
	return ""
}

// Is the commitment type for
// ADA,BCH,BTC,LTC requests
type UTXOCommitment struct {
	state         protoimpl.MessageState         `protogen:"open.v1"`
	Network       string                         `protobuf:"bytes,1,opt,name=network,proto3" json:"network,omitempty"`
	ChainId       []byte                         `protobuf:"bytes,2,opt,name=chainId,proto3" json:"chainId,omitempty"`
	Bindings      []*UTXOCommitment_InputBinding `protobuf:"bytes,3,rep,name=bindings,proto3" json:"bindings,omitempty"`
	Blockchain    string                         `protobuf:"bytes,4,opt,name=blockchain,proto3" json:"blockchain,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *UTXOCommitment) Reset() {
	*x = UTXOCommitment{}
	mi := &file_tp_messages_commitments_proto_msgTypes[1]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *UTXOCommitment) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*UTXOCommitment) ProtoMessage() {}

func (x *UTXOCommitment) ProtoReflect() protoreflect.Message {
	mi := &file_tp_messages_commitments_proto_msgTypes[1]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use UTXOCommitment.ProtoReflect.Descriptor instead.
func (*UTXOCommitment) Descriptor() ([]byte, []int) {
	return file_tp_messages_commitments_proto_rawDescGZIP(), []int{1}
}

func (x *UTXOCommitment) GetNetwork() string {
	if x != nil {
		return x.Network
	}
	return ""
}

func (x *UTXOCommitment) GetChainId() []byte {
	if x != nil {
		return x.ChainId
	}
	return nil
}

func (x *UTXOCommitment) GetBindings() []*UTXOCommitment_InputBinding {
	if x != nil {
		return x.Bindings
	}
	return nil
}

func (x *UTXOCommitment) GetBlockchain() string {
	if x != nil {
		return x.Blockchain
	}
	return ""
}

// Algo commitments
// The unicity constraint enforced on-chain is that two identical transactions cannot be mined,
// and that two transactions cannot have the same (sender,lease) pair within their validity window (max 1000 blocks).
// Algorand commitments bind on the lease and validity window of a transaction:
// * the lease `lx` allows us to identify broadcasted transactions on the blockchain. It is globally unique and fixed in the metadata.
// * the validity window `lv` determines when a commitment expires
type AlgoCommitment struct {
	state         protoimpl.MessageState      `protogen:"open.v1"`
	Blockchain    string                      `protobuf:"bytes,1,opt,name=blockchain,proto3" json:"blockchain,omitempty"`
	Network       string                      `protobuf:"bytes,2,opt,name=network,proto3" json:"network,omitempty"`
	ChainId       string                      `protobuf:"bytes,3,opt,name=chainId,proto3" json:"chainId,omitempty"` // ALGO genesis ID
	Bindings      []*AlgoCommitment_TxBinding `protobuf:"bytes,4,rep,name=bindings,proto3" json:"bindings,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *AlgoCommitment) Reset() {
	*x = AlgoCommitment{}
	mi := &file_tp_messages_commitments_proto_msgTypes[2]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *AlgoCommitment) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*AlgoCommitment) ProtoMessage() {}

func (x *AlgoCommitment) ProtoReflect() protoreflect.Message {
	mi := &file_tp_messages_commitments_proto_msgTypes[2]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use AlgoCommitment.ProtoReflect.Descriptor instead.
func (*AlgoCommitment) Descriptor() ([]byte, []int) {
	return file_tp_messages_commitments_proto_rawDescGZIP(), []int{2}
}

func (x *AlgoCommitment) GetBlockchain() string {
	if x != nil {
		return x.Blockchain
	}
	return ""
}

func (x *AlgoCommitment) GetNetwork() string {
	if x != nil {
		return x.Network
	}
	return ""
}

func (x *AlgoCommitment) GetChainId() string {
	if x != nil {
		return x.ChainId
	}
	return ""
}

func (x *AlgoCommitment) GetBindings() []*AlgoCommitment_TxBinding {
	if x != nil {
		return x.Bindings
	}
	return nil
}

// ICP commitments
// hash == hash(from, to, amount, fee, memo, created_at_time)
//
//	or hash(from, amount, memo, created_at_time) for Burn and to instead of from for Mint.
//
// Only 1 transaction with the same fields can pass
type ICPCommitment struct {
	state         protoimpl.MessageState     `protogen:"open.v1"`
	Network       string                     `protobuf:"bytes,1,opt,name=network,proto3" json:"network,omitempty"`
	Bindings      []*ICPCommitment_TxBinding `protobuf:"bytes,2,rep,name=bindings,proto3" json:"bindings,omitempty"`
	Blockchain    string                     `protobuf:"bytes,3,opt,name=blockchain,proto3" json:"blockchain,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *ICPCommitment) Reset() {
	*x = ICPCommitment{}
	mi := &file_tp_messages_commitments_proto_msgTypes[3]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *ICPCommitment) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*ICPCommitment) ProtoMessage() {}

func (x *ICPCommitment) ProtoReflect() protoreflect.Message {
	mi := &file_tp_messages_commitments_proto_msgTypes[3]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use ICPCommitment.ProtoReflect.Descriptor instead.
func (*ICPCommitment) Descriptor() ([]byte, []int) {
	return file_tp_messages_commitments_proto_rawDescGZIP(), []int{3}
}

func (x *ICPCommitment) GetNetwork() string {
	if x != nil {
		return x.Network
	}
	return ""
}

func (x *ICPCommitment) GetBindings() []*ICPCommitment_TxBinding {
	if x != nil {
		return x.Bindings
	}
	return nil
}

func (x *ICPCommitment) GetBlockchain() string {
	if x != nil {
		return x.Blockchain
	}
	return ""
}

// "Wrapped" EVM commitment, for gasless transactions
// Ignores the amount, binds to address and nonce, adds the forwarder address
type ETHWrappedCommitment struct {
	state         protoimpl.MessageState          `protogen:"open.v1"`
	Network       string                          `protobuf:"bytes,1,opt,name=network,proto3" json:"network,omitempty"`
	Bindings      []*ETHWrappedCommitment_Binding `protobuf:"bytes,4,rep,name=bindings,proto3" json:"bindings,omitempty"`
	Blockchain    string                          `protobuf:"bytes,5,opt,name=blockchain,proto3" json:"blockchain,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *ETHWrappedCommitment) Reset() {
	*x = ETHWrappedCommitment{}
	mi := &file_tp_messages_commitments_proto_msgTypes[4]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *ETHWrappedCommitment) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*ETHWrappedCommitment) ProtoMessage() {}

func (x *ETHWrappedCommitment) ProtoReflect() protoreflect.Message {
	mi := &file_tp_messages_commitments_proto_msgTypes[4]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use ETHWrappedCommitment.ProtoReflect.Descriptor instead.
func (*ETHWrappedCommitment) Descriptor() ([]byte, []int) {
	return file_tp_messages_commitments_proto_rawDescGZIP(), []int{4}
}

func (x *ETHWrappedCommitment) GetNetwork() string {
	if x != nil {
		return x.Network
	}
	return ""
}

func (x *ETHWrappedCommitment) GetBindings() []*ETHWrappedCommitment_Binding {
	if x != nil {
		return x.Bindings
	}
	return nil
}

func (x *ETHWrappedCommitment) GetBlockchain() string {
	if x != nil {
		return x.Blockchain
	}
	return ""
}

// Hash commitments
// Each tx is identified by its (pre-signature) tx hash
type HashCommitment struct {
	state         protoimpl.MessageState      `protogen:"open.v1"`
	Blockchain    string                      `protobuf:"bytes,1,opt,name=blockchain,proto3" json:"blockchain,omitempty"`
	Network       string                      `protobuf:"bytes,2,opt,name=network,proto3" json:"network,omitempty"`
	ChainId       []byte                      `protobuf:"bytes,3,opt,name=chainId,proto3" json:"chainId,omitempty"`
	Bindings      []*HashCommitment_TxBinding `protobuf:"bytes,4,rep,name=bindings,proto3" json:"bindings,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *HashCommitment) Reset() {
	*x = HashCommitment{}
	mi := &file_tp_messages_commitments_proto_msgTypes[5]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *HashCommitment) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*HashCommitment) ProtoMessage() {}

func (x *HashCommitment) ProtoReflect() protoreflect.Message {
	mi := &file_tp_messages_commitments_proto_msgTypes[5]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use HashCommitment.ProtoReflect.Descriptor instead.
func (*HashCommitment) Descriptor() ([]byte, []int) {
	return file_tp_messages_commitments_proto_rawDescGZIP(), []int{5}
}

func (x *HashCommitment) GetBlockchain() string {
	if x != nil {
		return x.Blockchain
	}
	return ""
}

func (x *HashCommitment) GetNetwork() string {
	if x != nil {
		return x.Network
	}
	return ""
}

func (x *HashCommitment) GetChainId() []byte {
	if x != nil {
		return x.ChainId
	}
	return nil
}

func (x *HashCommitment) GetBindings() []*HashCommitment_TxBinding {
	if x != nil {
		return x.Bindings
	}
	return nil
}

// Hedera commitments
// A special kind of account commitment, with no chain_id
// The nonce is replaced by a timestamp
type HederaCommitment struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// The network is still used to strongly tie to a committer
	// but the lack of chain_id means the same commitment
	// can be used to generate transactions valid on multiple networks
	// Due to Hedera's structure,
	Network       string                            `protobuf:"bytes,1,opt,name=network,proto3" json:"network,omitempty"`
	Bindings      []*HederaCommitment_HederaBinding `protobuf:"bytes,3,rep,name=bindings,proto3" json:"bindings,omitempty"`
	Blockchain    string                            `protobuf:"bytes,4,opt,name=blockchain,proto3" json:"blockchain,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *HederaCommitment) Reset() {
	*x = HederaCommitment{}
	mi := &file_tp_messages_commitments_proto_msgTypes[6]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *HederaCommitment) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*HederaCommitment) ProtoMessage() {}

func (x *HederaCommitment) ProtoReflect() protoreflect.Message {
	mi := &file_tp_messages_commitments_proto_msgTypes[6]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use HederaCommitment.ProtoReflect.Descriptor instead.
func (*HederaCommitment) Descriptor() ([]byte, []int) {
	return file_tp_messages_commitments_proto_rawDescGZIP(), []int{6}
}

func (x *HederaCommitment) GetNetwork() string {
	if x != nil {
		return x.Network
	}
	return ""
}

func (x *HederaCommitment) GetBindings() []*HederaCommitment_HederaBinding {
	if x != nil {
		return x.Bindings
	}
	return nil
}

func (x *HederaCommitment) GetBlockchain() string {
	if x != nil {
		return x.Blockchain
	}
	return ""
}

type AccountCommitment_AccountBinding struct {
	state         protoimpl.MessageState `protogen:"open.v1"`
	Address       string                 `protobuf:"bytes,1,opt,name=address,proto3" json:"address,omitempty"`
	Nonce         []byte                 `protobuf:"bytes,2,opt,name=nonce,proto3" json:"nonce,omitempty"`
	Amount        []byte                 `protobuf:"bytes,3,opt,name=amount,proto3" json:"amount,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *AccountCommitment_AccountBinding) Reset() {
	*x = AccountCommitment_AccountBinding{}
	mi := &file_tp_messages_commitments_proto_msgTypes[7]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *AccountCommitment_AccountBinding) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*AccountCommitment_AccountBinding) ProtoMessage() {}

func (x *AccountCommitment_AccountBinding) ProtoReflect() protoreflect.Message {
	mi := &file_tp_messages_commitments_proto_msgTypes[7]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use AccountCommitment_AccountBinding.ProtoReflect.Descriptor instead.
func (*AccountCommitment_AccountBinding) Descriptor() ([]byte, []int) {
	return file_tp_messages_commitments_proto_rawDescGZIP(), []int{0, 0}
}

func (x *AccountCommitment_AccountBinding) GetAddress() string {
	if x != nil {
		return x.Address
	}
	return ""
}

func (x *AccountCommitment_AccountBinding) GetNonce() []byte {
	if x != nil {
		return x.Nonce
	}
	return nil
}

func (x *AccountCommitment_AccountBinding) GetAmount() []byte {
	if x != nil {
		return x.Amount
	}
	return nil
}

// Inputs are very susceptible to being malleable
// transfers from addresses/wallets can use any utxo for the address/wallet and lie about its amount (pay the excess in fees)
// Outputs however, are not malleable in a useful way:
// - changing the target destination results in a metadata mismatch
// - changing the change destination results in either a correct request or a metadata mismatch
// On the other hand, inputs of a transaction are enough to completely distinguish it
// Making them ideal for commitments
type UTXOCommitment_InputBinding struct {
	state         protoimpl.MessageState `protogen:"open.v1"`
	Hash          []byte                 `protobuf:"bytes,1,opt,name=hash,proto3" json:"hash,omitempty"`
	Index         uint64                 `protobuf:"varint,2,opt,name=index,proto3" json:"index,omitempty"`
	Amount        []byte                 `protobuf:"bytes,3,opt,name=amount,proto3" json:"amount,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *UTXOCommitment_InputBinding) Reset() {
	*x = UTXOCommitment_InputBinding{}
	mi := &file_tp_messages_commitments_proto_msgTypes[8]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *UTXOCommitment_InputBinding) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*UTXOCommitment_InputBinding) ProtoMessage() {}

func (x *UTXOCommitment_InputBinding) ProtoReflect() protoreflect.Message {
	mi := &file_tp_messages_commitments_proto_msgTypes[8]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use UTXOCommitment_InputBinding.ProtoReflect.Descriptor instead.
func (*UTXOCommitment_InputBinding) Descriptor() ([]byte, []int) {
	return file_tp_messages_commitments_proto_rawDescGZIP(), []int{1, 0}
}

func (x *UTXOCommitment_InputBinding) GetHash() []byte {
	if x != nil {
		return x.Hash
	}
	return nil
}

func (x *UTXOCommitment_InputBinding) GetIndex() uint64 {
	if x != nil {
		return x.Index
	}
	return 0
}

func (x *UTXOCommitment_InputBinding) GetAmount() []byte {
	if x != nil {
		return x.Amount
	}
	return nil
}

type AlgoCommitment_TxBinding struct {
	state         protoimpl.MessageState `protogen:"open.v1"`
	Address       string                 `protobuf:"bytes,1,opt,name=address,proto3" json:"address,omitempty"`
	Lx            []byte                 `protobuf:"bytes,2,opt,name=lx,proto3" json:"lx,omitempty"`
	Lv            uint64                 `protobuf:"varint,3,opt,name=lv,proto3" json:"lv,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *AlgoCommitment_TxBinding) Reset() {
	*x = AlgoCommitment_TxBinding{}
	mi := &file_tp_messages_commitments_proto_msgTypes[9]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *AlgoCommitment_TxBinding) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*AlgoCommitment_TxBinding) ProtoMessage() {}

func (x *AlgoCommitment_TxBinding) ProtoReflect() protoreflect.Message {
	mi := &file_tp_messages_commitments_proto_msgTypes[9]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use AlgoCommitment_TxBinding.ProtoReflect.Descriptor instead.
func (*AlgoCommitment_TxBinding) Descriptor() ([]byte, []int) {
	return file_tp_messages_commitments_proto_rawDescGZIP(), []int{2, 0}
}

func (x *AlgoCommitment_TxBinding) GetAddress() string {
	if x != nil {
		return x.Address
	}
	return ""
}

func (x *AlgoCommitment_TxBinding) GetLx() []byte {
	if x != nil {
		return x.Lx
	}
	return nil
}

func (x *AlgoCommitment_TxBinding) GetLv() uint64 {
	if x != nil {
		return x.Lv
	}
	return 0
}

type ICPCommitment_TxBinding struct {
	state         protoimpl.MessageState `protogen:"open.v1"`
	Hash          string                 `protobuf:"bytes,1,opt,name=hash,proto3" json:"hash,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *ICPCommitment_TxBinding) Reset() {
	*x = ICPCommitment_TxBinding{}
	mi := &file_tp_messages_commitments_proto_msgTypes[10]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *ICPCommitment_TxBinding) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*ICPCommitment_TxBinding) ProtoMessage() {}

func (x *ICPCommitment_TxBinding) ProtoReflect() protoreflect.Message {
	mi := &file_tp_messages_commitments_proto_msgTypes[10]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use ICPCommitment_TxBinding.ProtoReflect.Descriptor instead.
func (*ICPCommitment_TxBinding) Descriptor() ([]byte, []int) {
	return file_tp_messages_commitments_proto_rawDescGZIP(), []int{3, 0}
}

func (x *ICPCommitment_TxBinding) GetHash() string {
	if x != nil {
		return x.Hash
	}
	return ""
}

type ETHWrappedCommitment_Binding struct {
	state         protoimpl.MessageState `protogen:"open.v1"`
	Address       string                 `protobuf:"bytes,1,opt,name=address,proto3" json:"address,omitempty"`
	Nonce         []byte                 `protobuf:"bytes,2,opt,name=nonce,proto3" json:"nonce,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *ETHWrappedCommitment_Binding) Reset() {
	*x = ETHWrappedCommitment_Binding{}
	mi := &file_tp_messages_commitments_proto_msgTypes[11]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *ETHWrappedCommitment_Binding) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*ETHWrappedCommitment_Binding) ProtoMessage() {}

func (x *ETHWrappedCommitment_Binding) ProtoReflect() protoreflect.Message {
	mi := &file_tp_messages_commitments_proto_msgTypes[11]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use ETHWrappedCommitment_Binding.ProtoReflect.Descriptor instead.
func (*ETHWrappedCommitment_Binding) Descriptor() ([]byte, []int) {
	return file_tp_messages_commitments_proto_rawDescGZIP(), []int{4, 0}
}

func (x *ETHWrappedCommitment_Binding) GetAddress() string {
	if x != nil {
		return x.Address
	}
	return ""
}

func (x *ETHWrappedCommitment_Binding) GetNonce() []byte {
	if x != nil {
		return x.Nonce
	}
	return nil
}

type HashCommitment_TxBinding struct {
	state         protoimpl.MessageState `protogen:"open.v1"`
	Hash          []byte                 `protobuf:"bytes,1,opt,name=hash,proto3" json:"hash,omitempty"`
	Address       string                 `protobuf:"bytes,2,opt,name=address,proto3" json:"address,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *HashCommitment_TxBinding) Reset() {
	*x = HashCommitment_TxBinding{}
	mi := &file_tp_messages_commitments_proto_msgTypes[12]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *HashCommitment_TxBinding) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*HashCommitment_TxBinding) ProtoMessage() {}

func (x *HashCommitment_TxBinding) ProtoReflect() protoreflect.Message {
	mi := &file_tp_messages_commitments_proto_msgTypes[12]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use HashCommitment_TxBinding.ProtoReflect.Descriptor instead.
func (*HashCommitment_TxBinding) Descriptor() ([]byte, []int) {
	return file_tp_messages_commitments_proto_rawDescGZIP(), []int{5, 0}
}

func (x *HashCommitment_TxBinding) GetHash() []byte {
	if x != nil {
		return x.Hash
	}
	return nil
}

func (x *HashCommitment_TxBinding) GetAddress() string {
	if x != nil {
		return x.Address
	}
	return ""
}

// Stutter because of swagger's weird namespacing..?
type HederaCommitment_HederaTimestamp struct {
	state         protoimpl.MessageState `protogen:"open.v1"`
	Seconds       uint64                 `protobuf:"varint,1,opt,name=seconds,proto3" json:"seconds,omitempty"`
	Nanos         uint64                 `protobuf:"varint,2,opt,name=nanos,proto3" json:"nanos,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *HederaCommitment_HederaTimestamp) Reset() {
	*x = HederaCommitment_HederaTimestamp{}
	mi := &file_tp_messages_commitments_proto_msgTypes[13]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *HederaCommitment_HederaTimestamp) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*HederaCommitment_HederaTimestamp) ProtoMessage() {}

func (x *HederaCommitment_HederaTimestamp) ProtoReflect() protoreflect.Message {
	mi := &file_tp_messages_commitments_proto_msgTypes[13]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use HederaCommitment_HederaTimestamp.ProtoReflect.Descriptor instead.
func (*HederaCommitment_HederaTimestamp) Descriptor() ([]byte, []int) {
	return file_tp_messages_commitments_proto_rawDescGZIP(), []int{6, 0}
}

func (x *HederaCommitment_HederaTimestamp) GetSeconds() uint64 {
	if x != nil {
		return x.Seconds
	}
	return 0
}

func (x *HederaCommitment_HederaTimestamp) GetNanos() uint64 {
	if x != nil {
		return x.Nanos
	}
	return 0
}

type HederaCommitment_HederaBinding struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// Hedera addresses are represented as <shardnum>.<realmnum>.<accountid>
	// Where <accountid> has no relation to the key
	// This means given only an address, we cannot tie it to a public key
	// This explains the presence of the publicKey (compressed ECDSA) field in the binding
	Address       string                            `protobuf:"bytes,1,opt,name=address,proto3" json:"address,omitempty"`
	PublicKey     []byte                            `protobuf:"bytes,2,opt,name=publicKey,proto3" json:"publicKey,omitempty"`
	Timestamp     *HederaCommitment_HederaTimestamp `protobuf:"bytes,3,opt,name=timestamp,proto3" json:"timestamp,omitempty"` // Hedera transactions by themselves don't have amounts
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *HederaCommitment_HederaBinding) Reset() {
	*x = HederaCommitment_HederaBinding{}
	mi := &file_tp_messages_commitments_proto_msgTypes[14]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *HederaCommitment_HederaBinding) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*HederaCommitment_HederaBinding) ProtoMessage() {}

func (x *HederaCommitment_HederaBinding) ProtoReflect() protoreflect.Message {
	mi := &file_tp_messages_commitments_proto_msgTypes[14]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use HederaCommitment_HederaBinding.ProtoReflect.Descriptor instead.
func (*HederaCommitment_HederaBinding) Descriptor() ([]byte, []int) {
	return file_tp_messages_commitments_proto_rawDescGZIP(), []int{6, 1}
}

func (x *HederaCommitment_HederaBinding) GetAddress() string {
	if x != nil {
		return x.Address
	}
	return ""
}

func (x *HederaCommitment_HederaBinding) GetPublicKey() []byte {
	if x != nil {
		return x.PublicKey
	}
	return nil
}

func (x *HederaCommitment_HederaBinding) GetTimestamp() *HederaCommitment_HederaTimestamp {
	if x != nil {
		return x.Timestamp
	}
	return nil
}

var File_tp_messages_commitments_proto protoreflect.FileDescriptor

const file_tp_messages_commitments_proto_rawDesc = "" +
	"\n" +
	"\x1dtp_messages/commitments.proto\x12\vtp_messages\"\x8c\x02\n" +
	"\x11AccountCommitment\x12\x18\n" +
	"\anetwork\x18\x01 \x01(\tR\anetwork\x12\x18\n" +
	"\achainId\x18\x02 \x01(\fR\achainId\x12I\n" +
	"\bbindings\x18\x03 \x03(\v2-.tp_messages.AccountCommitment.AccountBindingR\bbindings\x12\x1e\n" +
	"\n" +
	"blockchain\x18\x04 \x01(\tR\n" +
	"blockchain\x1aX\n" +
	"\x0eAccountBinding\x12\x18\n" +
	"\aaddress\x18\x01 \x01(\tR\aaddress\x12\x14\n" +
	"\x05nonce\x18\x02 \x01(\fR\x05nonce\x12\x16\n" +
	"\x06amount\x18\x03 \x01(\fR\x06amount\"\xfc\x01\n" +
	"\x0eUTXOCommitment\x12\x18\n" +
	"\anetwork\x18\x01 \x01(\tR\anetwork\x12\x18\n" +
	"\achainId\x18\x02 \x01(\fR\achainId\x12D\n" +
	"\bbindings\x18\x03 \x03(\v2(.tp_messages.UTXOCommitment.InputBindingR\bbindings\x12\x1e\n" +
	"\n" +
	"blockchain\x18\x04 \x01(\tR\n" +
	"blockchain\x1aP\n" +
	"\fInputBinding\x12\x12\n" +
	"\x04hash\x18\x01 \x01(\fR\x04hash\x12\x14\n" +
	"\x05index\x18\x02 \x01(\x04R\x05index\x12\x16\n" +
	"\x06amount\x18\x03 \x01(\fR\x06amount\"\xee\x01\n" +
	"\x0eAlgoCommitment\x12\x1e\n" +
	"\n" +
	"blockchain\x18\x01 \x01(\tR\n" +
	"blockchain\x12\x18\n" +
	"\anetwork\x18\x02 \x01(\tR\anetwork\x12\x18\n" +
	"\achainId\x18\x03 \x01(\tR\achainId\x12A\n" +
	"\bbindings\x18\x04 \x03(\v2%.tp_messages.AlgoCommitment.TxBindingR\bbindings\x1aE\n" +
	"\tTxBinding\x12\x18\n" +
	"\aaddress\x18\x01 \x01(\tR\aaddress\x12\x0e\n" +
	"\x02lx\x18\x02 \x01(\fR\x02lx\x12\x0e\n" +
	"\x02lv\x18\x03 \x01(\x04R\x02lv\"\xac\x01\n" +
	"\rICPCommitment\x12\x18\n" +
	"\anetwork\x18\x01 \x01(\tR\anetwork\x12@\n" +
	"\bbindings\x18\x02 \x03(\v2$.tp_messages.ICPCommitment.TxBindingR\bbindings\x12\x1e\n" +
	"\n" +
	"blockchain\x18\x03 \x01(\tR\n" +
	"blockchain\x1a\x1f\n" +
	"\tTxBinding\x12\x12\n" +
	"\x04hash\x18\x01 \x01(\tR\x04hash\"\xd2\x01\n" +
	"\x14ETHWrappedCommitment\x12\x18\n" +
	"\anetwork\x18\x01 \x01(\tR\anetwork\x12E\n" +
	"\bbindings\x18\x04 \x03(\v2).tp_messages.ETHWrappedCommitment.BindingR\bbindings\x12\x1e\n" +
	"\n" +
	"blockchain\x18\x05 \x01(\tR\n" +
	"blockchain\x1a9\n" +
	"\aBinding\x12\x18\n" +
	"\aaddress\x18\x01 \x01(\tR\aaddress\x12\x14\n" +
	"\x05nonce\x18\x02 \x01(\fR\x05nonce\"\xe2\x01\n" +
	"\x0eHashCommitment\x12\x1e\n" +
	"\n" +
	"blockchain\x18\x01 \x01(\tR\n" +
	"blockchain\x12\x18\n" +
	"\anetwork\x18\x02 \x01(\tR\anetwork\x12\x18\n" +
	"\achainId\x18\x03 \x01(\fR\achainId\x12A\n" +
	"\bbindings\x18\x04 \x03(\v2%.tp_messages.HashCommitment.TxBindingR\bbindings\x1a9\n" +
	"\tTxBinding\x12\x12\n" +
	"\x04hash\x18\x01 \x01(\fR\x04hash\x12\x18\n" +
	"\aaddress\x18\x02 \x01(\tR\aaddress\"\xef\x02\n" +
	"\x10HederaCommitment\x12\x18\n" +
	"\anetwork\x18\x01 \x01(\tR\anetwork\x12G\n" +
	"\bbindings\x18\x03 \x03(\v2+.tp_messages.HederaCommitment.HederaBindingR\bbindings\x12\x1e\n" +
	"\n" +
	"blockchain\x18\x04 \x01(\tR\n" +
	"blockchain\x1aA\n" +
	"\x0fHederaTimestamp\x12\x18\n" +
	"\aseconds\x18\x01 \x01(\x04R\aseconds\x12\x14\n" +
	"\x05nanos\x18\x02 \x01(\x04R\x05nanos\x1a\x94\x01\n" +
	"\rHederaBinding\x12\x18\n" +
	"\aaddress\x18\x01 \x01(\tR\aaddress\x12\x1c\n" +
	"\tpublicKey\x18\x02 \x01(\fR\tpublicKey\x12K\n" +
	"\ttimestamp\x18\x03 \x01(\v2-.tp_messages.HederaCommitment.HederaTimestampR\ttimestamp*l\n" +
	"\x0eCommitmentKind\x12\b\n" +
	"\x04UTXO\x10\x00\x12\v\n" +
	"\aAccount\x10\x01\x12\b\n" +
	"\x04Algo\x10\x02\x12\x0e\n" +
	"\n" +
	"ETHwrapped\x10\x03\x12\a\n" +
	"\x03Icp\x10\x04\x12\b\n" +
	"\x04Hash\x10\x05\x12\x16\n" +
	"\x12HederaTransactions\x10\x06B3\n" +
	"1com.taurushq.sdk.protect.proto.common.tp_messagesb\x06proto3"

var (
	file_tp_messages_commitments_proto_rawDescOnce sync.Once
	file_tp_messages_commitments_proto_rawDescData []byte
)

func file_tp_messages_commitments_proto_rawDescGZIP() []byte {
	file_tp_messages_commitments_proto_rawDescOnce.Do(func() {
		file_tp_messages_commitments_proto_rawDescData = protoimpl.X.CompressGZIP(unsafe.Slice(unsafe.StringData(file_tp_messages_commitments_proto_rawDesc), len(file_tp_messages_commitments_proto_rawDesc)))
	})
	return file_tp_messages_commitments_proto_rawDescData
}

var file_tp_messages_commitments_proto_enumTypes = make([]protoimpl.EnumInfo, 1)
var file_tp_messages_commitments_proto_msgTypes = make([]protoimpl.MessageInfo, 15)
var file_tp_messages_commitments_proto_goTypes = []any{
	(CommitmentKind)(0),                      // 0: tp_messages.CommitmentKind
	(*AccountCommitment)(nil),                // 1: tp_messages.AccountCommitment
	(*UTXOCommitment)(nil),                   // 2: tp_messages.UTXOCommitment
	(*AlgoCommitment)(nil),                   // 3: tp_messages.AlgoCommitment
	(*ICPCommitment)(nil),                    // 4: tp_messages.ICPCommitment
	(*ETHWrappedCommitment)(nil),             // 5: tp_messages.ETHWrappedCommitment
	(*HashCommitment)(nil),                   // 6: tp_messages.HashCommitment
	(*HederaCommitment)(nil),                 // 7: tp_messages.HederaCommitment
	(*AccountCommitment_AccountBinding)(nil), // 8: tp_messages.AccountCommitment.AccountBinding
	(*UTXOCommitment_InputBinding)(nil),      // 9: tp_messages.UTXOCommitment.InputBinding
	(*AlgoCommitment_TxBinding)(nil),         // 10: tp_messages.AlgoCommitment.TxBinding
	(*ICPCommitment_TxBinding)(nil),          // 11: tp_messages.ICPCommitment.TxBinding
	(*ETHWrappedCommitment_Binding)(nil),     // 12: tp_messages.ETHWrappedCommitment.Binding
	(*HashCommitment_TxBinding)(nil),         // 13: tp_messages.HashCommitment.TxBinding
	(*HederaCommitment_HederaTimestamp)(nil), // 14: tp_messages.HederaCommitment.HederaTimestamp
	(*HederaCommitment_HederaBinding)(nil),   // 15: tp_messages.HederaCommitment.HederaBinding
}
var file_tp_messages_commitments_proto_depIdxs = []int32{
	8,  // 0: tp_messages.AccountCommitment.bindings:type_name -> tp_messages.AccountCommitment.AccountBinding
	9,  // 1: tp_messages.UTXOCommitment.bindings:type_name -> tp_messages.UTXOCommitment.InputBinding
	10, // 2: tp_messages.AlgoCommitment.bindings:type_name -> tp_messages.AlgoCommitment.TxBinding
	11, // 3: tp_messages.ICPCommitment.bindings:type_name -> tp_messages.ICPCommitment.TxBinding
	12, // 4: tp_messages.ETHWrappedCommitment.bindings:type_name -> tp_messages.ETHWrappedCommitment.Binding
	13, // 5: tp_messages.HashCommitment.bindings:type_name -> tp_messages.HashCommitment.TxBinding
	15, // 6: tp_messages.HederaCommitment.bindings:type_name -> tp_messages.HederaCommitment.HederaBinding
	14, // 7: tp_messages.HederaCommitment.HederaBinding.timestamp:type_name -> tp_messages.HederaCommitment.HederaTimestamp
	8,  // [8:8] is the sub-list for method output_type
	8,  // [8:8] is the sub-list for method input_type
	8,  // [8:8] is the sub-list for extension type_name
	8,  // [8:8] is the sub-list for extension extendee
	0,  // [0:8] is the sub-list for field type_name
}

func init() { file_tp_messages_commitments_proto_init() }
func file_tp_messages_commitments_proto_init() {
	if File_tp_messages_commitments_proto != nil {
		return
	}
	type x struct{}
	out := protoimpl.TypeBuilder{
		File: protoimpl.DescBuilder{
			GoPackagePath: reflect.TypeOf(x{}).PkgPath(),
			RawDescriptor: unsafe.Slice(unsafe.StringData(file_tp_messages_commitments_proto_rawDesc), len(file_tp_messages_commitments_proto_rawDesc)),
			NumEnums:      1,
			NumMessages:   15,
			NumExtensions: 0,
			NumServices:   0,
		},
		GoTypes:           file_tp_messages_commitments_proto_goTypes,
		DependencyIndexes: file_tp_messages_commitments_proto_depIdxs,
		EnumInfos:         file_tp_messages_commitments_proto_enumTypes,
		MessageInfos:      file_tp_messages_commitments_proto_msgTypes,
	}.Build()
	File_tp_messages_commitments_proto = out.File
	file_tp_messages_commitments_proto_goTypes = nil
	file_tp_messages_commitments_proto_depIdxs = nil
}
