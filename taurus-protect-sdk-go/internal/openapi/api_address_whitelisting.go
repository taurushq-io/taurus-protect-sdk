/*
Taurus-PROTECT APIs

Taurus-PROTECT APIs description

API version: 1.0
*/

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package openapi

import (
	"bytes"
	"context"
	"io"
	"net/http"
	"net/url"
	"strings"
	"reflect"
	"time"
)


// AddressWhitelistingAPIService AddressWhitelistingAPI service
type AddressWhitelistingAPIService service

type ApiWhitelistServiceApproveWhitelistedAddressRequest struct {
	ctx context.Context
	ApiService *AddressWhitelistingAPIService
	body *TgvalidatordApproveWhitelistedAddressRequest
}

func (r ApiWhitelistServiceApproveWhitelistedAddressRequest) Body(body TgvalidatordApproveWhitelistedAddressRequest) ApiWhitelistServiceApproveWhitelistedAddressRequest {
	r.body = &body
	return r
}

func (r ApiWhitelistServiceApproveWhitelistedAddressRequest) Execute() (*TgvalidatordApproveWhitelistingReply, *http.Response, error) {
	return r.ApiService.WhitelistServiceApproveWhitelistedAddressExecute(r)
}

/*
WhitelistServiceApproveWhitelistedAddress Approve a whitelisted address

This endpoint approves a whitelisted address.
 Required role: **WhitelistedAddressApprover**.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiWhitelistServiceApproveWhitelistedAddressRequest
*/
func (a *AddressWhitelistingAPIService) WhitelistServiceApproveWhitelistedAddress(ctx context.Context) ApiWhitelistServiceApproveWhitelistedAddressRequest {
	return ApiWhitelistServiceApproveWhitelistedAddressRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return TgvalidatordApproveWhitelistingReply
func (a *AddressWhitelistingAPIService) WhitelistServiceApproveWhitelistedAddressExecute(r ApiWhitelistServiceApproveWhitelistedAddressRequest) (*TgvalidatordApproveWhitelistingReply, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *TgvalidatordApproveWhitelistingReply
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AddressWhitelistingAPIService.WhitelistServiceApproveWhitelistedAddress")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/rest/v1/whitelists/addresses/approve"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.body == nil {
		return localVarReturnValue, nil, reportError("body is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["ApiKeyTPV1"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v map[string]interface{}
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v map[string]interface{}
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v map[string]interface{}
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v map[string]interface{}
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v map[string]interface{}
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 503 {
			var v map[string]interface{}
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
			var v GooglerpcStatus
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiWhitelistServiceCreateWhitelistedAddressRequest struct {
	ctx context.Context
	ApiService *AddressWhitelistingAPIService
	body *TgvalidatordCreateWhitelistedAddressRequest
}

func (r ApiWhitelistServiceCreateWhitelistedAddressRequest) Body(body TgvalidatordCreateWhitelistedAddressRequest) ApiWhitelistServiceCreateWhitelistedAddressRequest {
	r.body = &body
	return r
}

func (r ApiWhitelistServiceCreateWhitelistedAddressRequest) Execute() (*TgvalidatordCreateReply, *http.Response, error) {
	return r.ApiService.WhitelistServiceCreateWhitelistedAddressExecute(r)
}

/*
WhitelistServiceCreateWhitelistedAddress Create a whitelisted address

This endpoint creates a new whitelisted address.
 Required role: **WhitelistedAddressCreator**.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiWhitelistServiceCreateWhitelistedAddressRequest
*/
func (a *AddressWhitelistingAPIService) WhitelistServiceCreateWhitelistedAddress(ctx context.Context) ApiWhitelistServiceCreateWhitelistedAddressRequest {
	return ApiWhitelistServiceCreateWhitelistedAddressRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return TgvalidatordCreateReply
func (a *AddressWhitelistingAPIService) WhitelistServiceCreateWhitelistedAddressExecute(r ApiWhitelistServiceCreateWhitelistedAddressRequest) (*TgvalidatordCreateReply, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *TgvalidatordCreateReply
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AddressWhitelistingAPIService.WhitelistServiceCreateWhitelistedAddress")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/rest/v1/whitelists/addresses"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.body == nil {
		return localVarReturnValue, nil, reportError("body is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["ApiKeyTPV1"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v map[string]interface{}
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v map[string]interface{}
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v map[string]interface{}
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v map[string]interface{}
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v map[string]interface{}
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 503 {
			var v map[string]interface{}
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
			var v GooglerpcStatus
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiWhitelistServiceCreateWhitelistedAddressAttributesRequest struct {
	ctx context.Context
	ApiService *AddressWhitelistingAPIService
	whitelistedAddressId string
	body *WhitelistServiceCreateWhitelistedAddressAttributesBody
}

func (r ApiWhitelistServiceCreateWhitelistedAddressAttributesRequest) Body(body WhitelistServiceCreateWhitelistedAddressAttributesBody) ApiWhitelistServiceCreateWhitelistedAddressAttributesRequest {
	r.body = &body
	return r
}

func (r ApiWhitelistServiceCreateWhitelistedAddressAttributesRequest) Execute() (*TgvalidatordCreateWhitelistedAddressAttributesReply, *http.Response, error) {
	return r.ApiService.WhitelistServiceCreateWhitelistedAddressAttributesExecute(r)
}

/*
WhitelistServiceCreateWhitelistedAddressAttributes Create attributes

This endpoint creates attributes of a given whitelisted address.
 Required role: **WhitelistedAddressCreator**.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param whitelistedAddressId uint64; The ID of the whitelisted address for the attribute
 @return ApiWhitelistServiceCreateWhitelistedAddressAttributesRequest
*/
func (a *AddressWhitelistingAPIService) WhitelistServiceCreateWhitelistedAddressAttributes(ctx context.Context, whitelistedAddressId string) ApiWhitelistServiceCreateWhitelistedAddressAttributesRequest {
	return ApiWhitelistServiceCreateWhitelistedAddressAttributesRequest{
		ApiService: a,
		ctx: ctx,
		whitelistedAddressId: whitelistedAddressId,
	}
}

// Execute executes the request
//  @return TgvalidatordCreateWhitelistedAddressAttributesReply
func (a *AddressWhitelistingAPIService) WhitelistServiceCreateWhitelistedAddressAttributesExecute(r ApiWhitelistServiceCreateWhitelistedAddressAttributesRequest) (*TgvalidatordCreateWhitelistedAddressAttributesReply, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *TgvalidatordCreateWhitelistedAddressAttributesReply
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AddressWhitelistingAPIService.WhitelistServiceCreateWhitelistedAddressAttributes")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/rest/v1/whitelists/addresses/{whitelistedAddressId}/attributes"
	localVarPath = strings.Replace(localVarPath, "{"+"whitelistedAddressId"+"}", url.PathEscape(parameterValueToString(r.whitelistedAddressId, "whitelistedAddressId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.body == nil {
		return localVarReturnValue, nil, reportError("body is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["ApiKeyTPV1"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v map[string]interface{}
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v map[string]interface{}
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v map[string]interface{}
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v map[string]interface{}
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v map[string]interface{}
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 503 {
			var v map[string]interface{}
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
			var v GooglerpcStatus
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiWhitelistServiceDeleteWhitelistedAddressRequest struct {
	ctx context.Context
	ApiService *AddressWhitelistingAPIService
	body *TgvalidatordDeleteWhitelistedAddressRequest
}

func (r ApiWhitelistServiceDeleteWhitelistedAddressRequest) Body(body TgvalidatordDeleteWhitelistedAddressRequest) ApiWhitelistServiceDeleteWhitelistedAddressRequest {
	r.body = &body
	return r
}

func (r ApiWhitelistServiceDeleteWhitelistedAddressRequest) Execute() (*TgvalidatordCreateReply, *http.Response, error) {
	return r.ApiService.WhitelistServiceDeleteWhitelistedAddressExecute(r)
}

/*
WhitelistServiceDeleteWhitelistedAddress Delete a whitelisted address

This endpoint deletes a whitelisted address.
 Required role: **WhitelistedAddressCreator**.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiWhitelistServiceDeleteWhitelistedAddressRequest
*/
func (a *AddressWhitelistingAPIService) WhitelistServiceDeleteWhitelistedAddress(ctx context.Context) ApiWhitelistServiceDeleteWhitelistedAddressRequest {
	return ApiWhitelistServiceDeleteWhitelistedAddressRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return TgvalidatordCreateReply
func (a *AddressWhitelistingAPIService) WhitelistServiceDeleteWhitelistedAddressExecute(r ApiWhitelistServiceDeleteWhitelistedAddressRequest) (*TgvalidatordCreateReply, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *TgvalidatordCreateReply
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AddressWhitelistingAPIService.WhitelistServiceDeleteWhitelistedAddress")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/rest/v1/whitelists/addresses/delete"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.body == nil {
		return localVarReturnValue, nil, reportError("body is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["ApiKeyTPV1"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v map[string]interface{}
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v map[string]interface{}
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v map[string]interface{}
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v map[string]interface{}
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v map[string]interface{}
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 503 {
			var v map[string]interface{}
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
			var v GooglerpcStatus
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiWhitelistServiceDeleteWhitelistedAddressAttributeRequest struct {
	ctx context.Context
	ApiService *AddressWhitelistingAPIService
	whitelistedAddressId string
	id string
}

func (r ApiWhitelistServiceDeleteWhitelistedAddressAttributeRequest) Execute() (map[string]interface{}, *http.Response, error) {
	return r.ApiService.WhitelistServiceDeleteWhitelistedAddressAttributeExecute(r)
}

/*
WhitelistServiceDeleteWhitelistedAddressAttribute Delete an attribute

This endpoint deletes an attribute of a given whitelisted address.
 Required role: **WhitelistedAddressCreator**.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param whitelistedAddressId uint64; The whitelisted address ID for the attribute
 @param id uint64; The attribute ID to delete
 @return ApiWhitelistServiceDeleteWhitelistedAddressAttributeRequest
*/
func (a *AddressWhitelistingAPIService) WhitelistServiceDeleteWhitelistedAddressAttribute(ctx context.Context, whitelistedAddressId string, id string) ApiWhitelistServiceDeleteWhitelistedAddressAttributeRequest {
	return ApiWhitelistServiceDeleteWhitelistedAddressAttributeRequest{
		ApiService: a,
		ctx: ctx,
		whitelistedAddressId: whitelistedAddressId,
		id: id,
	}
}

// Execute executes the request
//  @return map[string]interface{}
func (a *AddressWhitelistingAPIService) WhitelistServiceDeleteWhitelistedAddressAttributeExecute(r ApiWhitelistServiceDeleteWhitelistedAddressAttributeRequest) (map[string]interface{}, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  map[string]interface{}
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AddressWhitelistingAPIService.WhitelistServiceDeleteWhitelistedAddressAttribute")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/rest/v1/whitelists/addresses/{whitelistedAddressId}/attributes/{id}"
	localVarPath = strings.Replace(localVarPath, "{"+"whitelistedAddressId"+"}", url.PathEscape(parameterValueToString(r.whitelistedAddressId, "whitelistedAddressId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["ApiKeyTPV1"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v map[string]interface{}
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v map[string]interface{}
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v map[string]interface{}
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v map[string]interface{}
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v map[string]interface{}
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 503 {
			var v map[string]interface{}
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
			var v GooglerpcStatus
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiWhitelistServiceExportWhitelistedAddressesRequest struct {
	ctx context.Context
	ApiService *AddressWhitelistingAPIService
	format *string
	exchangeAccountId *string
	addressType *string
	query *string
	currency *string
	scoreProvider *string
	scoreInBelow *string
	scoreOutBelow *string
	scoreExclusive *bool
	exchangeAccountIds *[]string
	coinfirmScoreGreater *string
	tags *[]string
	chainalysisScoreGreater *string
	blockchain *string
	addresses *[]string
	network *string
	scoreFilterScoreProvider *string
	scoreFilterScorechainFiltersScoreInBelow *string
	scoreFilterScorechainFiltersScoreOutBelow *string
	scoreFilterScorechainFiltersScoreExclusive *bool
	scoreFilterCoinfirmFiltersScoreGreater *string
	scoreFilterChainalysisFiltersScoreGreater *string
	scoreFilterEllipticFiltersScoreGreater *string
	scoreFilterTrmlabsFiltersScoreGreater *string
}

// defaults to &#x60;json&#x60;; can be &#x60;csv&#x60; or &#x60;json&#x60;
func (r ApiWhitelistServiceExportWhitelistedAddressesRequest) Format(format string) ApiWhitelistServiceExportWhitelistedAddressesRequest {
	r.format = &format
	return r
}

// **Deprecated:** Use exchangeAccountIds instead
func (r ApiWhitelistServiceExportWhitelistedAddressesRequest) ExchangeAccountId(exchangeAccountId string) ApiWhitelistServiceExportWhitelistedAddressesRequest {
	r.exchangeAccountId = &exchangeAccountId
	return r
}

// Can be one of the following: &#x60;individual&#x60;, &#x60;exchange&#x60;, &#x60;baker&#x60;, &#x60;stakepool&#x60;, &#x60;contract&#x60;, &#x60;validator&#x60;, node, &#x60;fiatprovider&#x60;
func (r ApiWhitelistServiceExportWhitelistedAddressesRequest) AddressType(addressType string) ApiWhitelistServiceExportWhitelistedAddressesRequest {
	r.addressType = &addressType
	return r
}

// Will find a match in any part of the value. Filter applies to the following fields: &#x60;customerid&#x60;, &#x60;address&#x60;, &#x60;blockchain&#x60;, &#x60;label&#x60;, &#x60;memo&#x60;, &#x60;addresstype&#x60;
func (r ApiWhitelistServiceExportWhitelistedAddressesRequest) Query(query string) ApiWhitelistServiceExportWhitelistedAddressesRequest {
	r.query = &query
	return r
}

// **Deprecated:** Use &#x60;blockchain&#x60; instead
func (r ApiWhitelistServiceExportWhitelistedAddressesRequest) Currency(currency string) ApiWhitelistServiceExportWhitelistedAddressesRequest {
	r.currency = &currency
	return r
}

// **Deprecated:** Use &#x60;scoreFilter&#x60; instead. Can be either of the following: &#x60;scorechain&#x60;, &#x60;coinfirm&#x60;, &#x60;chainalysis&#x60;, &#x60;elliptic&#x60;, &#x60;trmlabs&#x60;
func (r ApiWhitelistServiceExportWhitelistedAddressesRequest) ScoreProvider(scoreProvider string) ApiWhitelistServiceExportWhitelistedAddressesRequest {
	r.scoreProvider = &scoreProvider
	return r
}

// numeric; **Deprecated:** Use &#x60;scoreFilter&#x60; instead
func (r ApiWhitelistServiceExportWhitelistedAddressesRequest) ScoreInBelow(scoreInBelow string) ApiWhitelistServiceExportWhitelistedAddressesRequest {
	r.scoreInBelow = &scoreInBelow
	return r
}

// numeric; **Deprecated:** Use &#x60;scoreFilter&#x60; instead
func (r ApiWhitelistServiceExportWhitelistedAddressesRequest) ScoreOutBelow(scoreOutBelow string) ApiWhitelistServiceExportWhitelistedAddressesRequest {
	r.scoreOutBelow = &scoreOutBelow
	return r
}

// **Deprecated:** Use &#x60;scoreFilter&#x60; instead
func (r ApiWhitelistServiceExportWhitelistedAddressesRequest) ScoreExclusive(scoreExclusive bool) ApiWhitelistServiceExportWhitelistedAddressesRequest {
	r.scoreExclusive = &scoreExclusive
	return r
}

// uint64; Array containing the list of IDs for exchange accounts
func (r ApiWhitelistServiceExportWhitelistedAddressesRequest) ExchangeAccountIds(exchangeAccountIds []string) ApiWhitelistServiceExportWhitelistedAddressesRequest {
	r.exchangeAccountIds = &exchangeAccountIds
	return r
}

// uint64; **Deprecated:** Use &#x60;scoreFilter&#x60; instead
func (r ApiWhitelistServiceExportWhitelistedAddressesRequest) CoinfirmScoreGreater(coinfirmScoreGreater string) ApiWhitelistServiceExportWhitelistedAddressesRequest {
	r.coinfirmScoreGreater = &coinfirmScoreGreater
	return r
}

// List of tags applied returned whitelisted addresses
func (r ApiWhitelistServiceExportWhitelistedAddressesRequest) Tags(tags []string) ApiWhitelistServiceExportWhitelistedAddressesRequest {
	r.tags = &tags
	return r
}

// uint64; **Deprecated:** Use &#x60;scoreFilter&#x60; instead
func (r ApiWhitelistServiceExportWhitelistedAddressesRequest) ChainalysisScoreGreater(chainalysisScoreGreater string) ApiWhitelistServiceExportWhitelistedAddressesRequest {
	r.chainalysisScoreGreater = &chainalysisScoreGreater
	return r
}

// Filter on the blockchain of the WLA.
func (r ApiWhitelistServiceExportWhitelistedAddressesRequest) Blockchain(blockchain string) ApiWhitelistServiceExportWhitelistedAddressesRequest {
	r.blockchain = &blockchain
	return r
}

// Filter on the specific addresses to return. This field is using the blockchain&#39;s native address syntax
func (r ApiWhitelistServiceExportWhitelistedAddressesRequest) Addresses(addresses []string) ApiWhitelistServiceExportWhitelistedAddressesRequest {
	r.addresses = &addresses
	return r
}

// Name of the blockchain network, eg. &#x60;mainnet&#x60;, &#x60;testnet&#x60;, or &#x60;sepolia&#x60;
func (r ApiWhitelistServiceExportWhitelistedAddressesRequest) Network(network string) ApiWhitelistServiceExportWhitelistedAddressesRequest {
	r.network = &network
	return r
}

// Specify the score provider to filter on, or empty.Each provider has associated filter parameters that can be set.Supported values: &#x60;scorechain&#x60;, &#x60;coinfirm&#x60;, &#x60;chainalysis&#x60;, &#x60;elliptic&#x60;, &#x60;trmlabs&#x60;
func (r ApiWhitelistServiceExportWhitelistedAddressesRequest) ScoreFilterScoreProvider(scoreFilterScoreProvider string) ApiWhitelistServiceExportWhitelistedAddressesRequest {
	r.scoreFilterScoreProvider = &scoreFilterScoreProvider
	return r
}

// Filter addresses under a Scorechain incoming score threshold.
func (r ApiWhitelistServiceExportWhitelistedAddressesRequest) ScoreFilterScorechainFiltersScoreInBelow(scoreFilterScorechainFiltersScoreInBelow string) ApiWhitelistServiceExportWhitelistedAddressesRequest {
	r.scoreFilterScorechainFiltersScoreInBelow = &scoreFilterScorechainFiltersScoreInBelow
	return r
}

// Filter addresses under a Scorechain outgoing score threshold.
func (r ApiWhitelistServiceExportWhitelistedAddressesRequest) ScoreFilterScorechainFiltersScoreOutBelow(scoreFilterScorechainFiltersScoreOutBelow string) ApiWhitelistServiceExportWhitelistedAddressesRequest {
	r.scoreFilterScorechainFiltersScoreOutBelow = &scoreFilterScorechainFiltersScoreOutBelow
	return r
}

// By default when both Scorechain scores scoreInBelow and scoreOutBelow are provided, it returns the addresses matching (scoreInBelow AND scoreOutBelow). When scoreExclusive is set to true, it will return the addresses matching (scoreInBelow OR scoreOutBelow).
func (r ApiWhitelistServiceExportWhitelistedAddressesRequest) ScoreFilterScorechainFiltersScoreExclusive(scoreFilterScorechainFiltersScoreExclusive bool) ApiWhitelistServiceExportWhitelistedAddressesRequest {
	r.scoreFilterScorechainFiltersScoreExclusive = &scoreFilterScorechainFiltersScoreExclusive
	return r
}

// Filter addresses with a Coinfirm C-score above threshold.
func (r ApiWhitelistServiceExportWhitelistedAddressesRequest) ScoreFilterCoinfirmFiltersScoreGreater(scoreFilterCoinfirmFiltersScoreGreater string) ApiWhitelistServiceExportWhitelistedAddressesRequest {
	r.scoreFilterCoinfirmFiltersScoreGreater = &scoreFilterCoinfirmFiltersScoreGreater
	return r
}

// Filter addresses with a Chainalysis risk score above threshold.
func (r ApiWhitelistServiceExportWhitelistedAddressesRequest) ScoreFilterChainalysisFiltersScoreGreater(scoreFilterChainalysisFiltersScoreGreater string) ApiWhitelistServiceExportWhitelistedAddressesRequest {
	r.scoreFilterChainalysisFiltersScoreGreater = &scoreFilterChainalysisFiltersScoreGreater
	return r
}

// Filter addresses with an Elliptic risk score above threshold.
func (r ApiWhitelistServiceExportWhitelistedAddressesRequest) ScoreFilterEllipticFiltersScoreGreater(scoreFilterEllipticFiltersScoreGreater string) ApiWhitelistServiceExportWhitelistedAddressesRequest {
	r.scoreFilterEllipticFiltersScoreGreater = &scoreFilterEllipticFiltersScoreGreater
	return r
}

// Filter addresses with an TRM Labs risk score above threshold.
func (r ApiWhitelistServiceExportWhitelistedAddressesRequest) ScoreFilterTrmlabsFiltersScoreGreater(scoreFilterTrmlabsFiltersScoreGreater string) ApiWhitelistServiceExportWhitelistedAddressesRequest {
	r.scoreFilterTrmlabsFiltersScoreGreater = &scoreFilterTrmlabsFiltersScoreGreater
	return r
}

func (r ApiWhitelistServiceExportWhitelistedAddressesRequest) Execute() (*TgvalidatordExportWhitelistedAddressesReply, *http.Response, error) {
	return r.ApiService.WhitelistServiceExportWhitelistedAddressesExecute(r)
}

/*
WhitelistServiceExportWhitelistedAddresses Export whitelisted addresses

This endpoint exports a list of whitelisted addresses

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiWhitelistServiceExportWhitelistedAddressesRequest
*/
func (a *AddressWhitelistingAPIService) WhitelistServiceExportWhitelistedAddresses(ctx context.Context) ApiWhitelistServiceExportWhitelistedAddressesRequest {
	return ApiWhitelistServiceExportWhitelistedAddressesRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return TgvalidatordExportWhitelistedAddressesReply
func (a *AddressWhitelistingAPIService) WhitelistServiceExportWhitelistedAddressesExecute(r ApiWhitelistServiceExportWhitelistedAddressesRequest) (*TgvalidatordExportWhitelistedAddressesReply, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *TgvalidatordExportWhitelistedAddressesReply
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AddressWhitelistingAPIService.WhitelistServiceExportWhitelistedAddresses")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/rest/v1/whitelists/addresses/export"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.format != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "format", r.format, "", "")
	}
	if r.exchangeAccountId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "exchangeAccountId", r.exchangeAccountId, "", "")
	}
	if r.addressType != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "addressType", r.addressType, "", "")
	}
	if r.query != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "query", r.query, "", "")
	}
	if r.currency != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "currency", r.currency, "", "")
	}
	if r.scoreProvider != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "scoreProvider", r.scoreProvider, "", "")
	}
	if r.scoreInBelow != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "scoreInBelow", r.scoreInBelow, "", "")
	}
	if r.scoreOutBelow != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "scoreOutBelow", r.scoreOutBelow, "", "")
	}
	if r.scoreExclusive != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "scoreExclusive", r.scoreExclusive, "", "")
	}
	if r.exchangeAccountIds != nil {
		t := *r.exchangeAccountIds
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "exchangeAccountIds", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "exchangeAccountIds", t, "form", "multi")
		}
	}
	if r.coinfirmScoreGreater != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "coinfirmScoreGreater", r.coinfirmScoreGreater, "", "")
	}
	if r.tags != nil {
		t := *r.tags
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "tags", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "tags", t, "form", "multi")
		}
	}
	if r.chainalysisScoreGreater != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "chainalysisScoreGreater", r.chainalysisScoreGreater, "", "")
	}
	if r.blockchain != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "blockchain", r.blockchain, "", "")
	}
	if r.addresses != nil {
		t := *r.addresses
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "addresses", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "addresses", t, "form", "multi")
		}
	}
	if r.network != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "network", r.network, "", "")
	}
	if r.scoreFilterScoreProvider != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "scoreFilter.scoreProvider", r.scoreFilterScoreProvider, "", "")
	}
	if r.scoreFilterScorechainFiltersScoreInBelow != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "scoreFilter.scorechainFilters.scoreInBelow", r.scoreFilterScorechainFiltersScoreInBelow, "", "")
	}
	if r.scoreFilterScorechainFiltersScoreOutBelow != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "scoreFilter.scorechainFilters.scoreOutBelow", r.scoreFilterScorechainFiltersScoreOutBelow, "", "")
	}
	if r.scoreFilterScorechainFiltersScoreExclusive != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "scoreFilter.scorechainFilters.scoreExclusive", r.scoreFilterScorechainFiltersScoreExclusive, "", "")
	}
	if r.scoreFilterCoinfirmFiltersScoreGreater != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "scoreFilter.coinfirmFilters.scoreGreater", r.scoreFilterCoinfirmFiltersScoreGreater, "", "")
	}
	if r.scoreFilterChainalysisFiltersScoreGreater != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "scoreFilter.chainalysisFilters.scoreGreater", r.scoreFilterChainalysisFiltersScoreGreater, "", "")
	}
	if r.scoreFilterEllipticFiltersScoreGreater != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "scoreFilter.ellipticFilters.scoreGreater", r.scoreFilterEllipticFiltersScoreGreater, "", "")
	}
	if r.scoreFilterTrmlabsFiltersScoreGreater != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "scoreFilter.trmlabsFilters.scoreGreater", r.scoreFilterTrmlabsFiltersScoreGreater, "", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["ApiKeyTPV1"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v map[string]interface{}
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v map[string]interface{}
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v map[string]interface{}
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v map[string]interface{}
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v map[string]interface{}
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 503 {
			var v map[string]interface{}
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
			var v GooglerpcStatus
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiWhitelistServiceGetWhitelistedAddressRequest struct {
	ctx context.Context
	ApiService *AddressWhitelistingAPIService
	id string
}

func (r ApiWhitelistServiceGetWhitelistedAddressRequest) Execute() (*TgvalidatordGetSignedWhitelistedAddressEnvelopeReply, *http.Response, error) {
	return r.ApiService.WhitelistServiceGetWhitelistedAddressExecute(r)
}

/*
WhitelistServiceGetWhitelistedAddress Get a whitelisted address

This endpoint returns a whitelisted address

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id
 @return ApiWhitelistServiceGetWhitelistedAddressRequest
*/
func (a *AddressWhitelistingAPIService) WhitelistServiceGetWhitelistedAddress(ctx context.Context, id string) ApiWhitelistServiceGetWhitelistedAddressRequest {
	return ApiWhitelistServiceGetWhitelistedAddressRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
//  @return TgvalidatordGetSignedWhitelistedAddressEnvelopeReply
func (a *AddressWhitelistingAPIService) WhitelistServiceGetWhitelistedAddressExecute(r ApiWhitelistServiceGetWhitelistedAddressRequest) (*TgvalidatordGetSignedWhitelistedAddressEnvelopeReply, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *TgvalidatordGetSignedWhitelistedAddressEnvelopeReply
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AddressWhitelistingAPIService.WhitelistServiceGetWhitelistedAddress")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/rest/v1/whitelists/addresses/{id}"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["ApiKeyTPV1"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v map[string]interface{}
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v map[string]interface{}
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v map[string]interface{}
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v map[string]interface{}
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v map[string]interface{}
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 503 {
			var v map[string]interface{}
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
			var v GooglerpcStatus
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiWhitelistServiceGetWhitelistedAddressAttributeRequest struct {
	ctx context.Context
	ApiService *AddressWhitelistingAPIService
	whitelistedAddressId string
	id string
}

func (r ApiWhitelistServiceGetWhitelistedAddressAttributeRequest) Execute() (*TgvalidatordGetWhitelistedAddressAttributeReply, *http.Response, error) {
	return r.ApiService.WhitelistServiceGetWhitelistedAddressAttributeExecute(r)
}

/*
WhitelistServiceGetWhitelistedAddressAttribute List attributes

This endpoint returns a list of attributes of a given whitelisted address

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param whitelistedAddressId uint64; The ID of the whitelisted address for the attribute
 @param id uint64; The ID of the attribute
 @return ApiWhitelistServiceGetWhitelistedAddressAttributeRequest
*/
func (a *AddressWhitelistingAPIService) WhitelistServiceGetWhitelistedAddressAttribute(ctx context.Context, whitelistedAddressId string, id string) ApiWhitelistServiceGetWhitelistedAddressAttributeRequest {
	return ApiWhitelistServiceGetWhitelistedAddressAttributeRequest{
		ApiService: a,
		ctx: ctx,
		whitelistedAddressId: whitelistedAddressId,
		id: id,
	}
}

// Execute executes the request
//  @return TgvalidatordGetWhitelistedAddressAttributeReply
func (a *AddressWhitelistingAPIService) WhitelistServiceGetWhitelistedAddressAttributeExecute(r ApiWhitelistServiceGetWhitelistedAddressAttributeRequest) (*TgvalidatordGetWhitelistedAddressAttributeReply, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *TgvalidatordGetWhitelistedAddressAttributeReply
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AddressWhitelistingAPIService.WhitelistServiceGetWhitelistedAddressAttribute")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/rest/v1/whitelists/addresses/{whitelistedAddressId}/attributes/{id}"
	localVarPath = strings.Replace(localVarPath, "{"+"whitelistedAddressId"+"}", url.PathEscape(parameterValueToString(r.whitelistedAddressId, "whitelistedAddressId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["ApiKeyTPV1"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v map[string]interface{}
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v map[string]interface{}
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v map[string]interface{}
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v map[string]interface{}
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v map[string]interface{}
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 503 {
			var v map[string]interface{}
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
			var v GooglerpcStatus
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiWhitelistServiceGetWhitelistedAddressesRequest struct {
	ctx context.Context
	ApiService *AddressWhitelistingAPIService
	limit *string
	offset *string
	exchangeAccountId *string
	addressType *string
	query *string
	currency *string
	scoreProvider *string
	scoreInBelow *string
	scoreOutBelow *string
	scoreExclusive *bool
	rulesContainerNormalized *bool
	exchangeAccountIds *[]string
	coinfirmScoreGreater *string
	tagIDs *[]string
	chainalysisScoreGreater *string
	contractType *string
	allowedForAddressId *string
	allowedForWalletId *string
	blockchain *string
	includeForApproval *bool
	addresses *[]string
	network *string
	ids *[]string
	tnParticipantID *string
	scoreFilterScoreProvider *string
	scoreFilterScorechainFiltersScoreInBelow *string
	scoreFilterScorechainFiltersScoreOutBelow *string
	scoreFilterScorechainFiltersScoreExclusive *bool
	scoreFilterCoinfirmFiltersScoreGreater *string
	scoreFilterChainalysisFiltersScoreGreater *string
	scoreFilterEllipticFiltersScoreGreater *string
	scoreFilterTrmlabsFiltersScoreGreater *string
	lastIncomingTxFromWhitelistedAddress *time.Time
	contractTypes *[]string
	attributeFiltersJson *string
	attributeFiltersOperator *string
}

// uint64; Return maximum &#x60;limit&#x60; items for a query; Max 100.
func (r ApiWhitelistServiceGetWhitelistedAddressesRequest) Limit(limit string) ApiWhitelistServiceGetWhitelistedAddressesRequest {
	r.limit = &limit
	return r
}

// uint64; Start retrieving items starting at &#x60;offset&#x60; id
func (r ApiWhitelistServiceGetWhitelistedAddressesRequest) Offset(offset string) ApiWhitelistServiceGetWhitelistedAddressesRequest {
	r.offset = &offset
	return r
}

// uint64; **Deprecated:** Use exchangeAccountIds instead
func (r ApiWhitelistServiceGetWhitelistedAddressesRequest) ExchangeAccountId(exchangeAccountId string) ApiWhitelistServiceGetWhitelistedAddressesRequest {
	r.exchangeAccountId = &exchangeAccountId
	return r
}

// Can be one of the following: &#x60;individual&#x60;, &#x60;exchange&#x60;, &#x60;baker&#x60;, &#x60;stakepool&#x60;, &#x60;contract&#x60;, &#x60;validator&#x60;, node, &#x60;fiatprovider&#x60;
func (r ApiWhitelistServiceGetWhitelistedAddressesRequest) AddressType(addressType string) ApiWhitelistServiceGetWhitelistedAddressesRequest {
	r.addressType = &addressType
	return r
}

// Will find a match in any part of the value. Filter applies to the following fields: &#x60;customerid&#x60;, &#x60;address&#x60;, &#x60;blockchain&#x60;, &#x60;label&#x60;, &#x60;memo&#x60;, &#x60;addresstype&#x60;
func (r ApiWhitelistServiceGetWhitelistedAddressesRequest) Query(query string) ApiWhitelistServiceGetWhitelistedAddressesRequest {
	r.query = &query
	return r
}

// **Deprecated:** Use &#x60;blockchain&#x60; instead
func (r ApiWhitelistServiceGetWhitelistedAddressesRequest) Currency(currency string) ApiWhitelistServiceGetWhitelistedAddressesRequest {
	r.currency = &currency
	return r
}

// **Deprecated:** Use &#x60;scoreFilter&#x60; instead. Can be either of the following: &#x60;scorechain&#x60;, &#x60;coinfirm&#x60;, &#x60;chainalysis&#x60;, &#x60;elliptic&#x60;, &#x60;trmlabs&#x60;
func (r ApiWhitelistServiceGetWhitelistedAddressesRequest) ScoreProvider(scoreProvider string) ApiWhitelistServiceGetWhitelistedAddressesRequest {
	r.scoreProvider = &scoreProvider
	return r
}

// numeric; **Deprecated:** Use &#x60;scoreFilter&#x60; instead
func (r ApiWhitelistServiceGetWhitelistedAddressesRequest) ScoreInBelow(scoreInBelow string) ApiWhitelistServiceGetWhitelistedAddressesRequest {
	r.scoreInBelow = &scoreInBelow
	return r
}

// numeric; **Deprecated:** Use &#x60;scoreFilter&#x60; instead
func (r ApiWhitelistServiceGetWhitelistedAddressesRequest) ScoreOutBelow(scoreOutBelow string) ApiWhitelistServiceGetWhitelistedAddressesRequest {
	r.scoreOutBelow = &scoreOutBelow
	return r
}

// **Deprecated:** Use &#x60;scoreFilter&#x60; instead
func (r ApiWhitelistServiceGetWhitelistedAddressesRequest) ScoreExclusive(scoreExclusive bool) ApiWhitelistServiceGetWhitelistedAddressesRequest {
	r.scoreExclusive = &scoreExclusive
	return r
}

// Normalize rules containers in its own object
func (r ApiWhitelistServiceGetWhitelistedAddressesRequest) RulesContainerNormalized(rulesContainerNormalized bool) ApiWhitelistServiceGetWhitelistedAddressesRequest {
	r.rulesContainerNormalized = &rulesContainerNormalized
	return r
}

// uint64; Array containing the list of IDs for exchange accounts
func (r ApiWhitelistServiceGetWhitelistedAddressesRequest) ExchangeAccountIds(exchangeAccountIds []string) ApiWhitelistServiceGetWhitelistedAddressesRequest {
	r.exchangeAccountIds = &exchangeAccountIds
	return r
}

// uint64; **Deprecated:** Use &#x60;scoreFilter&#x60; instead
func (r ApiWhitelistServiceGetWhitelistedAddressesRequest) CoinfirmScoreGreater(coinfirmScoreGreater string) ApiWhitelistServiceGetWhitelistedAddressesRequest {
	r.coinfirmScoreGreater = &coinfirmScoreGreater
	return r
}

// Filter addresses with a &#39;OR&#39; combination of tag IDs
func (r ApiWhitelistServiceGetWhitelistedAddressesRequest) TagIDs(tagIDs []string) ApiWhitelistServiceGetWhitelistedAddressesRequest {
	r.tagIDs = &tagIDs
	return r
}

// uint64; **Deprecated:** Use &#x60;scoreFilter&#x60; instead
func (r ApiWhitelistServiceGetWhitelistedAddressesRequest) ChainalysisScoreGreater(chainalysisScoreGreater string) ApiWhitelistServiceGetWhitelistedAddressesRequest {
	r.chainalysisScoreGreater = &chainalysisScoreGreater
	return r
}

// **Deprecated:** Use &#x60;contractTypes&#x60; instead
func (r ApiWhitelistServiceGetWhitelistedAddressesRequest) ContractType(contractType string) ApiWhitelistServiceGetWhitelistedAddressesRequest {
	r.contractType = &contractType
	return r
}

// uint64; Filter addresses allowed to receive funds from this address id
func (r ApiWhitelistServiceGetWhitelistedAddressesRequest) AllowedForAddressId(allowedForAddressId string) ApiWhitelistServiceGetWhitelistedAddressesRequest {
	r.allowedForAddressId = &allowedForAddressId
	return r
}

// uint64; Filter addresses allowed to receive funds from this wallet id. Will be ignored if allowedForAddressId is filled
func (r ApiWhitelistServiceGetWhitelistedAddressesRequest) AllowedForWalletId(allowedForWalletId string) ApiWhitelistServiceGetWhitelistedAddressesRequest {
	r.allowedForWalletId = &allowedForWalletId
	return r
}

// Filter on the blockchain of the WLA.
func (r ApiWhitelistServiceGetWhitelistedAddressesRequest) Blockchain(blockchain string) ApiWhitelistServiceGetWhitelistedAddressesRequest {
	r.blockchain = &blockchain
	return r
}

// If true, include also addresses waiting for approval in the results.
func (r ApiWhitelistServiceGetWhitelistedAddressesRequest) IncludeForApproval(includeForApproval bool) ApiWhitelistServiceGetWhitelistedAddressesRequest {
	r.includeForApproval = &includeForApproval
	return r
}

// Filter on the specific addresses to return. This field is using the blockchain&#39;s native address syntax
func (r ApiWhitelistServiceGetWhitelistedAddressesRequest) Addresses(addresses []string) ApiWhitelistServiceGetWhitelistedAddressesRequest {
	r.addresses = &addresses
	return r
}

// Name of the blockchain network, eg. &#x60;mainnet&#x60;, &#x60;testnet&#x60;, or &#x60;sepolia&#x60;
func (r ApiWhitelistServiceGetWhitelistedAddressesRequest) Network(network string) ApiWhitelistServiceGetWhitelistedAddressesRequest {
	r.network = &network
	return r
}

// uint64; List of IDs to return
func (r ApiWhitelistServiceGetWhitelistedAddressesRequest) Ids(ids []string) ApiWhitelistServiceGetWhitelistedAddressesRequest {
	r.ids = &ids
	return r
}

// uuid; UUID of the Taurus-NETWORK participant to whom the address belongs
func (r ApiWhitelistServiceGetWhitelistedAddressesRequest) TnParticipantID(tnParticipantID string) ApiWhitelistServiceGetWhitelistedAddressesRequest {
	r.tnParticipantID = &tnParticipantID
	return r
}

// Specify the score provider to filter on, or empty.Each provider has associated filter parameters that can be set.Supported values: &#x60;scorechain&#x60;, &#x60;coinfirm&#x60;, &#x60;chainalysis&#x60;, &#x60;elliptic&#x60;, &#x60;trmlabs&#x60;
func (r ApiWhitelistServiceGetWhitelistedAddressesRequest) ScoreFilterScoreProvider(scoreFilterScoreProvider string) ApiWhitelistServiceGetWhitelistedAddressesRequest {
	r.scoreFilterScoreProvider = &scoreFilterScoreProvider
	return r
}

// Filter addresses under a Scorechain incoming score threshold.
func (r ApiWhitelistServiceGetWhitelistedAddressesRequest) ScoreFilterScorechainFiltersScoreInBelow(scoreFilterScorechainFiltersScoreInBelow string) ApiWhitelistServiceGetWhitelistedAddressesRequest {
	r.scoreFilterScorechainFiltersScoreInBelow = &scoreFilterScorechainFiltersScoreInBelow
	return r
}

// Filter addresses under a Scorechain outgoing score threshold.
func (r ApiWhitelistServiceGetWhitelistedAddressesRequest) ScoreFilterScorechainFiltersScoreOutBelow(scoreFilterScorechainFiltersScoreOutBelow string) ApiWhitelistServiceGetWhitelistedAddressesRequest {
	r.scoreFilterScorechainFiltersScoreOutBelow = &scoreFilterScorechainFiltersScoreOutBelow
	return r
}

// By default when both Scorechain scores scoreInBelow and scoreOutBelow are provided, it returns the addresses matching (scoreInBelow AND scoreOutBelow). When scoreExclusive is set to true, it will return the addresses matching (scoreInBelow OR scoreOutBelow).
func (r ApiWhitelistServiceGetWhitelistedAddressesRequest) ScoreFilterScorechainFiltersScoreExclusive(scoreFilterScorechainFiltersScoreExclusive bool) ApiWhitelistServiceGetWhitelistedAddressesRequest {
	r.scoreFilterScorechainFiltersScoreExclusive = &scoreFilterScorechainFiltersScoreExclusive
	return r
}

// Filter addresses with a Coinfirm C-score above threshold.
func (r ApiWhitelistServiceGetWhitelistedAddressesRequest) ScoreFilterCoinfirmFiltersScoreGreater(scoreFilterCoinfirmFiltersScoreGreater string) ApiWhitelistServiceGetWhitelistedAddressesRequest {
	r.scoreFilterCoinfirmFiltersScoreGreater = &scoreFilterCoinfirmFiltersScoreGreater
	return r
}

// Filter addresses with a Chainalysis risk score above threshold.
func (r ApiWhitelistServiceGetWhitelistedAddressesRequest) ScoreFilterChainalysisFiltersScoreGreater(scoreFilterChainalysisFiltersScoreGreater string) ApiWhitelistServiceGetWhitelistedAddressesRequest {
	r.scoreFilterChainalysisFiltersScoreGreater = &scoreFilterChainalysisFiltersScoreGreater
	return r
}

// Filter addresses with an Elliptic risk score above threshold.
func (r ApiWhitelistServiceGetWhitelistedAddressesRequest) ScoreFilterEllipticFiltersScoreGreater(scoreFilterEllipticFiltersScoreGreater string) ApiWhitelistServiceGetWhitelistedAddressesRequest {
	r.scoreFilterEllipticFiltersScoreGreater = &scoreFilterEllipticFiltersScoreGreater
	return r
}

// Filter addresses with an TRM Labs risk score above threshold.
func (r ApiWhitelistServiceGetWhitelistedAddressesRequest) ScoreFilterTrmlabsFiltersScoreGreater(scoreFilterTrmlabsFiltersScoreGreater string) ApiWhitelistServiceGetWhitelistedAddressesRequest {
	r.scoreFilterTrmlabsFiltersScoreGreater = &scoreFilterTrmlabsFiltersScoreGreater
	return r
}

// Filtered addresses with the last incoming transaction older than lastIncomingTransactionDate  won&#39;t appear in the result. The default value is never
func (r ApiWhitelistServiceGetWhitelistedAddressesRequest) LastIncomingTxFromWhitelistedAddress(lastIncomingTxFromWhitelistedAddress time.Time) ApiWhitelistServiceGetWhitelistedAddressesRequest {
	r.lastIncomingTxFromWhitelistedAddress = &lastIncomingTxFromWhitelistedAddress
	return r
}

// Filter addresses by multiple Contract Types. Can be any of: &#x60;GENERIC&#x60;, &#x60;CMTA20&#x60;, &#x60;CMTA20-KYC&#x60;, &#x60;CMTA20-RULEENGINE&#x60;, &#x60;CMTAT&#x60;, &#x60;ERC20&#x60;, &#x60;DEFI&#x60;, &#x60;ERC2771-PROXY-ADMIN&#x60;, &#x60;TERC1155A&#x60;, &#x60;GSN_FORWARDER&#x60;, &#x60;OPEN_ZEPPELIN_FORWARDER&#x60;, &#x60;TAURUS_CONTRACT_CREATOR&#x60;, &#x60;SMARTPY-FA2&#x60;, &#x60;SMARTPY-FA12&#x60;, &#x60;ASA&#x60;, &#x60;FIGMENT_STAKING&#x60;
func (r ApiWhitelistServiceGetWhitelistedAddressesRequest) ContractTypes(contractTypes []string) ApiWhitelistServiceGetWhitelistedAddressesRequest {
	r.contractTypes = &contractTypes
	return r
}

// A JSON representation of a list of AttributeFilter objects. The filters are combined with an attributeFiltersOperator (&#39;OR&#39; by default). Each AttributeFilter can use different comparison operators: &#x60;&#x3D;&#x60; (default if not specified), &#x60;&lt;&gt;&#x60; (not equal), &#x60;&gt;&#x60; (greater than), &#x60;&gt;&#x3D;&#x60; (greater than or equal), &#x60;&lt;&#x60; (less than), &#x60;&lt;&#x3D;&#x60; (less than or equal)
func (r ApiWhitelistServiceGetWhitelistedAddressesRequest) AttributeFiltersJson(attributeFiltersJson string) ApiWhitelistServiceGetWhitelistedAddressesRequest {
	r.attributeFiltersJson = &attributeFiltersJson
	return r
}

// Specifies how attribute filters are combined. Accepted values: &#39;OR&#39; (default), &#39;AND&#39;.
func (r ApiWhitelistServiceGetWhitelistedAddressesRequest) AttributeFiltersOperator(attributeFiltersOperator string) ApiWhitelistServiceGetWhitelistedAddressesRequest {
	r.attributeFiltersOperator = &attributeFiltersOperator
	return r
}

func (r ApiWhitelistServiceGetWhitelistedAddressesRequest) Execute() (*TgvalidatordGetSignedWhitelistedAddressEnvelopesReply, *http.Response, error) {
	return r.ApiService.WhitelistServiceGetWhitelistedAddressesExecute(r)
}

/*
WhitelistServiceGetWhitelistedAddresses List whitelisted addresses

This endpoint returns a list of whitelisted addresses

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiWhitelistServiceGetWhitelistedAddressesRequest
*/
func (a *AddressWhitelistingAPIService) WhitelistServiceGetWhitelistedAddresses(ctx context.Context) ApiWhitelistServiceGetWhitelistedAddressesRequest {
	return ApiWhitelistServiceGetWhitelistedAddressesRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return TgvalidatordGetSignedWhitelistedAddressEnvelopesReply
func (a *AddressWhitelistingAPIService) WhitelistServiceGetWhitelistedAddressesExecute(r ApiWhitelistServiceGetWhitelistedAddressesRequest) (*TgvalidatordGetSignedWhitelistedAddressEnvelopesReply, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *TgvalidatordGetSignedWhitelistedAddressEnvelopesReply
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AddressWhitelistingAPIService.WhitelistServiceGetWhitelistedAddresses")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/rest/v1/whitelists/addresses"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.limit != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "limit", r.limit, "", "")
	}
	if r.offset != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "offset", r.offset, "", "")
	}
	if r.exchangeAccountId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "exchangeAccountId", r.exchangeAccountId, "", "")
	}
	if r.addressType != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "addressType", r.addressType, "", "")
	}
	if r.query != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "query", r.query, "", "")
	}
	if r.currency != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "currency", r.currency, "", "")
	}
	if r.scoreProvider != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "scoreProvider", r.scoreProvider, "", "")
	}
	if r.scoreInBelow != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "scoreInBelow", r.scoreInBelow, "", "")
	}
	if r.scoreOutBelow != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "scoreOutBelow", r.scoreOutBelow, "", "")
	}
	if r.scoreExclusive != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "scoreExclusive", r.scoreExclusive, "", "")
	}
	if r.rulesContainerNormalized != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "rulesContainerNormalized", r.rulesContainerNormalized, "", "")
	}
	if r.exchangeAccountIds != nil {
		t := *r.exchangeAccountIds
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "exchangeAccountIds", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "exchangeAccountIds", t, "form", "multi")
		}
	}
	if r.coinfirmScoreGreater != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "coinfirmScoreGreater", r.coinfirmScoreGreater, "", "")
	}
	if r.tagIDs != nil {
		t := *r.tagIDs
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "tagIDs", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "tagIDs", t, "form", "multi")
		}
	}
	if r.chainalysisScoreGreater != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "chainalysisScoreGreater", r.chainalysisScoreGreater, "", "")
	}
	if r.contractType != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "contractType", r.contractType, "", "")
	}
	if r.allowedForAddressId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "allowedForAddressId", r.allowedForAddressId, "", "")
	}
	if r.allowedForWalletId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "allowedForWalletId", r.allowedForWalletId, "", "")
	}
	if r.blockchain != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "blockchain", r.blockchain, "", "")
	}
	if r.includeForApproval != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "includeForApproval", r.includeForApproval, "", "")
	}
	if r.addresses != nil {
		t := *r.addresses
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "addresses", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "addresses", t, "form", "multi")
		}
	}
	if r.network != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "network", r.network, "", "")
	}
	if r.ids != nil {
		t := *r.ids
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "ids", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "ids", t, "form", "multi")
		}
	}
	if r.tnParticipantID != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "tnParticipantID", r.tnParticipantID, "", "")
	}
	if r.scoreFilterScoreProvider != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "scoreFilter.scoreProvider", r.scoreFilterScoreProvider, "", "")
	}
	if r.scoreFilterScorechainFiltersScoreInBelow != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "scoreFilter.scorechainFilters.scoreInBelow", r.scoreFilterScorechainFiltersScoreInBelow, "", "")
	}
	if r.scoreFilterScorechainFiltersScoreOutBelow != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "scoreFilter.scorechainFilters.scoreOutBelow", r.scoreFilterScorechainFiltersScoreOutBelow, "", "")
	}
	if r.scoreFilterScorechainFiltersScoreExclusive != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "scoreFilter.scorechainFilters.scoreExclusive", r.scoreFilterScorechainFiltersScoreExclusive, "", "")
	}
	if r.scoreFilterCoinfirmFiltersScoreGreater != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "scoreFilter.coinfirmFilters.scoreGreater", r.scoreFilterCoinfirmFiltersScoreGreater, "", "")
	}
	if r.scoreFilterChainalysisFiltersScoreGreater != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "scoreFilter.chainalysisFilters.scoreGreater", r.scoreFilterChainalysisFiltersScoreGreater, "", "")
	}
	if r.scoreFilterEllipticFiltersScoreGreater != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "scoreFilter.ellipticFilters.scoreGreater", r.scoreFilterEllipticFiltersScoreGreater, "", "")
	}
	if r.scoreFilterTrmlabsFiltersScoreGreater != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "scoreFilter.trmlabsFilters.scoreGreater", r.scoreFilterTrmlabsFiltersScoreGreater, "", "")
	}
	if r.lastIncomingTxFromWhitelistedAddress != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "lastIncomingTxFromWhitelistedAddress", r.lastIncomingTxFromWhitelistedAddress, "", "")
	}
	if r.contractTypes != nil {
		t := *r.contractTypes
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "contractTypes", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "contractTypes", t, "form", "multi")
		}
	}
	if r.attributeFiltersJson != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "attributeFiltersJson", r.attributeFiltersJson, "", "")
	}
	if r.attributeFiltersOperator != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "attributeFiltersOperator", r.attributeFiltersOperator, "", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["ApiKeyTPV1"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v map[string]interface{}
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v map[string]interface{}
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v map[string]interface{}
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v map[string]interface{}
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v map[string]interface{}
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 503 {
			var v map[string]interface{}
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
			var v GooglerpcStatus
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiWhitelistServiceGetWhitelistedAddressesForApprovalRequest struct {
	ctx context.Context
	ApiService *AddressWhitelistingAPIService
	limit *string
	offset *string
	ids *[]string
	blockchain *string
	addressType *string
	query *string
	network *string
	includeAlreadySignedByUser *bool
}

// uint64; The amount of unapproved whitelisted address returned per request. Max 100.
func (r ApiWhitelistServiceGetWhitelistedAddressesForApprovalRequest) Limit(limit string) ApiWhitelistServiceGetWhitelistedAddressesForApprovalRequest {
	r.limit = &limit
	return r
}

// uint64; The offset from which to begin selection of unapproved whitelisted addresses.
func (r ApiWhitelistServiceGetWhitelistedAddressesForApprovalRequest) Offset(offset string) ApiWhitelistServiceGetWhitelistedAddressesForApprovalRequest {
	r.offset = &offset
	return r
}

// uint64 Array; The ids to filter your requests selection by.
func (r ApiWhitelistServiceGetWhitelistedAddressesForApprovalRequest) Ids(ids []string) ApiWhitelistServiceGetWhitelistedAddressesForApprovalRequest {
	r.ids = &ids
	return r
}

// The blockchain associated with the unapproved whitelisted addresses. (ex. eth, btc)
func (r ApiWhitelistServiceGetWhitelistedAddressesForApprovalRequest) Blockchain(blockchain string) ApiWhitelistServiceGetWhitelistedAddressesForApprovalRequest {
	r.blockchain = &blockchain
	return r
}

// The type of unapproved whitelisted address (ex. individual, exchange, baker, contract, stakepool, validator, node, fiatprovider).
func (r ApiWhitelistServiceGetWhitelistedAddressesForApprovalRequest) AddressType(addressType string) ApiWhitelistServiceGetWhitelistedAddressesForApprovalRequest {
	r.addressType = &addressType
	return r
}

// A search query to filter your request with. Will search the label or address fields.
func (r ApiWhitelistServiceGetWhitelistedAddressesForApprovalRequest) Query(query string) ApiWhitelistServiceGetWhitelistedAddressesForApprovalRequest {
	r.query = &query
	return r
}

// The network of the associated blockchain the address is in. (ex. mainnet, sepolia)
func (r ApiWhitelistServiceGetWhitelistedAddressesForApprovalRequest) Network(network string) ApiWhitelistServiceGetWhitelistedAddressesForApprovalRequest {
	r.network = &network
	return r
}

// Set to true to include the pending approval whitelisted addresses already signed by the user. Default: false
func (r ApiWhitelistServiceGetWhitelistedAddressesForApprovalRequest) IncludeAlreadySignedByUser(includeAlreadySignedByUser bool) ApiWhitelistServiceGetWhitelistedAddressesForApprovalRequest {
	r.includeAlreadySignedByUser = &includeAlreadySignedByUser
	return r
}

func (r ApiWhitelistServiceGetWhitelistedAddressesForApprovalRequest) Execute() (*TgvalidatordGetSignedWhitelistedAddressEnvelopesReply, *http.Response, error) {
	return r.ApiService.WhitelistServiceGetWhitelistedAddressesForApprovalExecute(r)
}

/*
WhitelistServiceGetWhitelistedAddressesForApproval List whitelisted addresses for approval

This endpoint returns a list of whitelisted addresses for approval

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiWhitelistServiceGetWhitelistedAddressesForApprovalRequest
*/
func (a *AddressWhitelistingAPIService) WhitelistServiceGetWhitelistedAddressesForApproval(ctx context.Context) ApiWhitelistServiceGetWhitelistedAddressesForApprovalRequest {
	return ApiWhitelistServiceGetWhitelistedAddressesForApprovalRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return TgvalidatordGetSignedWhitelistedAddressEnvelopesReply
func (a *AddressWhitelistingAPIService) WhitelistServiceGetWhitelistedAddressesForApprovalExecute(r ApiWhitelistServiceGetWhitelistedAddressesForApprovalRequest) (*TgvalidatordGetSignedWhitelistedAddressEnvelopesReply, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *TgvalidatordGetSignedWhitelistedAddressEnvelopesReply
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AddressWhitelistingAPIService.WhitelistServiceGetWhitelistedAddressesForApproval")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/rest/v1/whitelists/addresses/for-approval"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.limit != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "limit", r.limit, "", "")
	}
	if r.offset != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "offset", r.offset, "", "")
	}
	if r.ids != nil {
		t := *r.ids
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "ids", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "ids", t, "form", "multi")
		}
	}
	if r.blockchain != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "blockchain", r.blockchain, "", "")
	}
	if r.addressType != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "addressType", r.addressType, "", "")
	}
	if r.query != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "query", r.query, "", "")
	}
	if r.network != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "network", r.network, "", "")
	}
	if r.includeAlreadySignedByUser != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "includeAlreadySignedByUser", r.includeAlreadySignedByUser, "", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["ApiKeyTPV1"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v map[string]interface{}
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v map[string]interface{}
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v map[string]interface{}
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v map[string]interface{}
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v map[string]interface{}
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 503 {
			var v map[string]interface{}
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
			var v GooglerpcStatus
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiWhitelistServiceRejectWhitelistedAddressRequest struct {
	ctx context.Context
	ApiService *AddressWhitelistingAPIService
	body *TgvalidatordRejectWhitelistedAddressRequest
}

func (r ApiWhitelistServiceRejectWhitelistedAddressRequest) Body(body TgvalidatordRejectWhitelistedAddressRequest) ApiWhitelistServiceRejectWhitelistedAddressRequest {
	r.body = &body
	return r
}

func (r ApiWhitelistServiceRejectWhitelistedAddressRequest) Execute() (map[string]interface{}, *http.Response, error) {
	return r.ApiService.WhitelistServiceRejectWhitelistedAddressExecute(r)
}

/*
WhitelistServiceRejectWhitelistedAddress Reject a whitelisted address

This endpoint rejects a whitelisted address.
 Required role: **WhitelistedAddressApprover**.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiWhitelistServiceRejectWhitelistedAddressRequest
*/
func (a *AddressWhitelistingAPIService) WhitelistServiceRejectWhitelistedAddress(ctx context.Context) ApiWhitelistServiceRejectWhitelistedAddressRequest {
	return ApiWhitelistServiceRejectWhitelistedAddressRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return map[string]interface{}
func (a *AddressWhitelistingAPIService) WhitelistServiceRejectWhitelistedAddressExecute(r ApiWhitelistServiceRejectWhitelistedAddressRequest) (map[string]interface{}, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  map[string]interface{}
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AddressWhitelistingAPIService.WhitelistServiceRejectWhitelistedAddress")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/rest/v1/whitelists/addresses/reject"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.body == nil {
		return localVarReturnValue, nil, reportError("body is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["ApiKeyTPV1"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v map[string]interface{}
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v map[string]interface{}
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v map[string]interface{}
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v map[string]interface{}
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v map[string]interface{}
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 503 {
			var v map[string]interface{}
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
			var v GooglerpcStatus
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}
