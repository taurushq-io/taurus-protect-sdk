// Code generated by protoc-gen-ts_proto. DO NOT EDIT.
// versions:
//   protoc-gen-ts_proto  v1.181.2
//   protoc               v6.33.4
// source: staking-service.proto

/* eslint-disable */
import Long from "long";
import _m0 from "protobufjs/minimal";
import { RequestCursor, ResponseCursor } from "./cursor";
import { Timestamp } from "./google/protobuf/timestamp";
import { StakeAccount, StakeAccountType, stakeAccountTypeFromJSON, stakeAccountTypeToJSON } from "./staking";

export const protobufPackage = "tgvalidatord";

export interface GetADAStakePoolInfoRequest {
  network: string;
  stakePoolId: string;
}

export interface GetADAStakePoolInfoReply {
  pledge: string;
  margin: number;
  fixedCost: string;
  url: string;
  activeStake: string;
  epoch: number;
}

export interface GetFTMValidatorInfoRequest {
  network: string;
  validatorAddress: string;
}

export interface GetFTMValidatorInfoReply {
  validatorID: number;
  address: string;
  isActive: boolean;
  totalStake: string;
  selfStake: string;
  deactivatedAtDateUnix: number;
  createdAtDateUnix: number;
}

export interface GetXTZAddressStakingRewardsRequest {
  network: string;
  addressID: number;
  from: Date | undefined;
  to: Date | undefined;
}

export interface GetXTZAddressStakingRewardsReply {
  receivedRewardsAmount: string;
}

export interface GetNEARValidatorInfoRequest {
  network: string;
  validatorAddress: string;
}

export interface GetNEARValidatorInfoReply {
  validatorAddress: string;
  ownerId: string;
  totalStakedBalance: string;
  rewardFeeFraction: number;
  stakingKey: string;
  isStakingPaused: boolean;
}

export interface GetETHValidatorsInfoRequest {
  network: string;
  ids: string[];
}

export interface GetETHValidatorsInfoReply {
  validators: ETHValidatorInfo[];
}

export interface ETHValidatorInfo {
  id: string;
  pubkey: string;
  status: string;
  balance: string;
  network: string;
  provider: string;
  addressID: number;
}

export interface GetICPNeuronInfoRequest {
  network: string;
  neuronID: number;
}

export interface ICPKnownNeuronData {
  name: string;
  description: string;
}

export interface GetICPNeuronInfoReply {
  neuronId: number;
  retrieveAtTimestampSeconds: number;
  neuronState: GetICPNeuronInfoReply_NeuronState;
  ageSeconds: number;
  dissolveDelaySeconds: number;
  votingPower: number;
  createdTimestampSeconds: number;
  stakeE8S: number;
  joinedCommunityFundTimestampSeconds: number;
  knownNeuronData: ICPKnownNeuronData | undefined;
}

export enum GetICPNeuronInfoReply_NeuronState {
  NeuronStateUnspecified = 0,
  NeuronStateNotDissolving = 1,
  NeuronStateDissolving = 2,
  NeuronStateDissolved = 3,
  NeuronStateSpawning = 4,
  UNRECOGNIZED = -1,
}

export function getICPNeuronInfoReply_NeuronStateFromJSON(object: any): GetICPNeuronInfoReply_NeuronState {
  switch (object) {
    case 0:
    case "NeuronStateUnspecified":
      return GetICPNeuronInfoReply_NeuronState.NeuronStateUnspecified;
    case 1:
    case "NeuronStateNotDissolving":
      return GetICPNeuronInfoReply_NeuronState.NeuronStateNotDissolving;
    case 2:
    case "NeuronStateDissolving":
      return GetICPNeuronInfoReply_NeuronState.NeuronStateDissolving;
    case 3:
    case "NeuronStateDissolved":
      return GetICPNeuronInfoReply_NeuronState.NeuronStateDissolved;
    case 4:
    case "NeuronStateSpawning":
      return GetICPNeuronInfoReply_NeuronState.NeuronStateSpawning;
    case -1:
    case "UNRECOGNIZED":
    default:
      return GetICPNeuronInfoReply_NeuronState.UNRECOGNIZED;
  }
}

export function getICPNeuronInfoReply_NeuronStateToJSON(object: GetICPNeuronInfoReply_NeuronState): string {
  switch (object) {
    case GetICPNeuronInfoReply_NeuronState.NeuronStateUnspecified:
      return "NeuronStateUnspecified";
    case GetICPNeuronInfoReply_NeuronState.NeuronStateNotDissolving:
      return "NeuronStateNotDissolving";
    case GetICPNeuronInfoReply_NeuronState.NeuronStateDissolving:
      return "NeuronStateDissolving";
    case GetICPNeuronInfoReply_NeuronState.NeuronStateDissolved:
      return "NeuronStateDissolved";
    case GetICPNeuronInfoReply_NeuronState.NeuronStateSpawning:
      return "NeuronStateSpawning";
    case GetICPNeuronInfoReply_NeuronState.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

export interface GetStakeAccountsRequest {
  addressId: number;
  accountType: StakeAccountType;
  accountAddress: string;
  cursor: RequestCursor | undefined;
}

export interface GetStakeAccountsReply {
  stakeAccounts: StakeAccount[];
  cursor: ResponseCursor | undefined;
}

function createBaseGetADAStakePoolInfoRequest(): GetADAStakePoolInfoRequest {
  return { network: "", stakePoolId: "" };
}

export const GetADAStakePoolInfoRequest = {
  encode(message: GetADAStakePoolInfoRequest, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.network !== "") {
      writer.uint32(10).string(message.network);
    }
    if (message.stakePoolId !== "") {
      writer.uint32(18).string(message.stakePoolId);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): GetADAStakePoolInfoRequest {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetADAStakePoolInfoRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.network = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.stakePoolId = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetADAStakePoolInfoRequest {
    return {
      network: isSet(object.network) ? globalThis.String(object.network) : "",
      stakePoolId: isSet(object.stakePoolId) ? globalThis.String(object.stakePoolId) : "",
    };
  },

  toJSON(message: GetADAStakePoolInfoRequest): unknown {
    const obj: any = {};
    if (message.network !== "") {
      obj.network = message.network;
    }
    if (message.stakePoolId !== "") {
      obj.stakePoolId = message.stakePoolId;
    }
    return obj;
  },

  create(base?: DeepPartial<GetADAStakePoolInfoRequest>): GetADAStakePoolInfoRequest {
    return GetADAStakePoolInfoRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<GetADAStakePoolInfoRequest>): GetADAStakePoolInfoRequest {
    const message = createBaseGetADAStakePoolInfoRequest();
    message.network = object.network ?? "";
    message.stakePoolId = object.stakePoolId ?? "";
    return message;
  },
};

function createBaseGetADAStakePoolInfoReply(): GetADAStakePoolInfoReply {
  return { pledge: "", margin: 0, fixedCost: "", url: "", activeStake: "", epoch: 0 };
}

export const GetADAStakePoolInfoReply = {
  encode(message: GetADAStakePoolInfoReply, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.pledge !== "") {
      writer.uint32(10).string(message.pledge);
    }
    if (message.margin !== 0) {
      writer.uint32(21).float(message.margin);
    }
    if (message.fixedCost !== "") {
      writer.uint32(26).string(message.fixedCost);
    }
    if (message.url !== "") {
      writer.uint32(34).string(message.url);
    }
    if (message.activeStake !== "") {
      writer.uint32(42).string(message.activeStake);
    }
    if (message.epoch !== 0) {
      writer.uint32(48).uint64(message.epoch);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): GetADAStakePoolInfoReply {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetADAStakePoolInfoReply();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.pledge = reader.string();
          continue;
        case 2:
          if (tag !== 21) {
            break;
          }

          message.margin = reader.float();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.fixedCost = reader.string();
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.url = reader.string();
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.activeStake = reader.string();
          continue;
        case 6:
          if (tag !== 48) {
            break;
          }

          message.epoch = longToNumber(reader.uint64() as Long);
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetADAStakePoolInfoReply {
    return {
      pledge: isSet(object.pledge) ? globalThis.String(object.pledge) : "",
      margin: isSet(object.margin) ? globalThis.Number(object.margin) : 0,
      fixedCost: isSet(object.fixedCost) ? globalThis.String(object.fixedCost) : "",
      url: isSet(object.url) ? globalThis.String(object.url) : "",
      activeStake: isSet(object.activeStake) ? globalThis.String(object.activeStake) : "",
      epoch: isSet(object.epoch) ? globalThis.Number(object.epoch) : 0,
    };
  },

  toJSON(message: GetADAStakePoolInfoReply): unknown {
    const obj: any = {};
    if (message.pledge !== "") {
      obj.pledge = message.pledge;
    }
    if (message.margin !== 0) {
      obj.margin = message.margin;
    }
    if (message.fixedCost !== "") {
      obj.fixedCost = message.fixedCost;
    }
    if (message.url !== "") {
      obj.url = message.url;
    }
    if (message.activeStake !== "") {
      obj.activeStake = message.activeStake;
    }
    if (message.epoch !== 0) {
      obj.epoch = Math.round(message.epoch);
    }
    return obj;
  },

  create(base?: DeepPartial<GetADAStakePoolInfoReply>): GetADAStakePoolInfoReply {
    return GetADAStakePoolInfoReply.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<GetADAStakePoolInfoReply>): GetADAStakePoolInfoReply {
    const message = createBaseGetADAStakePoolInfoReply();
    message.pledge = object.pledge ?? "";
    message.margin = object.margin ?? 0;
    message.fixedCost = object.fixedCost ?? "";
    message.url = object.url ?? "";
    message.activeStake = object.activeStake ?? "";
    message.epoch = object.epoch ?? 0;
    return message;
  },
};

function createBaseGetFTMValidatorInfoRequest(): GetFTMValidatorInfoRequest {
  return { network: "", validatorAddress: "" };
}

export const GetFTMValidatorInfoRequest = {
  encode(message: GetFTMValidatorInfoRequest, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.network !== "") {
      writer.uint32(10).string(message.network);
    }
    if (message.validatorAddress !== "") {
      writer.uint32(18).string(message.validatorAddress);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): GetFTMValidatorInfoRequest {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetFTMValidatorInfoRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.network = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.validatorAddress = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetFTMValidatorInfoRequest {
    return {
      network: isSet(object.network) ? globalThis.String(object.network) : "",
      validatorAddress: isSet(object.validatorAddress) ? globalThis.String(object.validatorAddress) : "",
    };
  },

  toJSON(message: GetFTMValidatorInfoRequest): unknown {
    const obj: any = {};
    if (message.network !== "") {
      obj.network = message.network;
    }
    if (message.validatorAddress !== "") {
      obj.validatorAddress = message.validatorAddress;
    }
    return obj;
  },

  create(base?: DeepPartial<GetFTMValidatorInfoRequest>): GetFTMValidatorInfoRequest {
    return GetFTMValidatorInfoRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<GetFTMValidatorInfoRequest>): GetFTMValidatorInfoRequest {
    const message = createBaseGetFTMValidatorInfoRequest();
    message.network = object.network ?? "";
    message.validatorAddress = object.validatorAddress ?? "";
    return message;
  },
};

function createBaseGetFTMValidatorInfoReply(): GetFTMValidatorInfoReply {
  return {
    validatorID: 0,
    address: "",
    isActive: false,
    totalStake: "",
    selfStake: "",
    deactivatedAtDateUnix: 0,
    createdAtDateUnix: 0,
  };
}

export const GetFTMValidatorInfoReply = {
  encode(message: GetFTMValidatorInfoReply, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.validatorID !== 0) {
      writer.uint32(8).uint64(message.validatorID);
    }
    if (message.address !== "") {
      writer.uint32(18).string(message.address);
    }
    if (message.isActive !== false) {
      writer.uint32(24).bool(message.isActive);
    }
    if (message.totalStake !== "") {
      writer.uint32(34).string(message.totalStake);
    }
    if (message.selfStake !== "") {
      writer.uint32(42).string(message.selfStake);
    }
    if (message.deactivatedAtDateUnix !== 0) {
      writer.uint32(48).uint64(message.deactivatedAtDateUnix);
    }
    if (message.createdAtDateUnix !== 0) {
      writer.uint32(56).uint64(message.createdAtDateUnix);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): GetFTMValidatorInfoReply {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetFTMValidatorInfoReply();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.validatorID = longToNumber(reader.uint64() as Long);
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.address = reader.string();
          continue;
        case 3:
          if (tag !== 24) {
            break;
          }

          message.isActive = reader.bool();
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.totalStake = reader.string();
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.selfStake = reader.string();
          continue;
        case 6:
          if (tag !== 48) {
            break;
          }

          message.deactivatedAtDateUnix = longToNumber(reader.uint64() as Long);
          continue;
        case 7:
          if (tag !== 56) {
            break;
          }

          message.createdAtDateUnix = longToNumber(reader.uint64() as Long);
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetFTMValidatorInfoReply {
    return {
      validatorID: isSet(object.validatorID) ? globalThis.Number(object.validatorID) : 0,
      address: isSet(object.address) ? globalThis.String(object.address) : "",
      isActive: isSet(object.isActive) ? globalThis.Boolean(object.isActive) : false,
      totalStake: isSet(object.totalStake) ? globalThis.String(object.totalStake) : "",
      selfStake: isSet(object.selfStake) ? globalThis.String(object.selfStake) : "",
      deactivatedAtDateUnix: isSet(object.deactivatedAtDateUnix) ? globalThis.Number(object.deactivatedAtDateUnix) : 0,
      createdAtDateUnix: isSet(object.createdAtDateUnix) ? globalThis.Number(object.createdAtDateUnix) : 0,
    };
  },

  toJSON(message: GetFTMValidatorInfoReply): unknown {
    const obj: any = {};
    if (message.validatorID !== 0) {
      obj.validatorID = Math.round(message.validatorID);
    }
    if (message.address !== "") {
      obj.address = message.address;
    }
    if (message.isActive !== false) {
      obj.isActive = message.isActive;
    }
    if (message.totalStake !== "") {
      obj.totalStake = message.totalStake;
    }
    if (message.selfStake !== "") {
      obj.selfStake = message.selfStake;
    }
    if (message.deactivatedAtDateUnix !== 0) {
      obj.deactivatedAtDateUnix = Math.round(message.deactivatedAtDateUnix);
    }
    if (message.createdAtDateUnix !== 0) {
      obj.createdAtDateUnix = Math.round(message.createdAtDateUnix);
    }
    return obj;
  },

  create(base?: DeepPartial<GetFTMValidatorInfoReply>): GetFTMValidatorInfoReply {
    return GetFTMValidatorInfoReply.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<GetFTMValidatorInfoReply>): GetFTMValidatorInfoReply {
    const message = createBaseGetFTMValidatorInfoReply();
    message.validatorID = object.validatorID ?? 0;
    message.address = object.address ?? "";
    message.isActive = object.isActive ?? false;
    message.totalStake = object.totalStake ?? "";
    message.selfStake = object.selfStake ?? "";
    message.deactivatedAtDateUnix = object.deactivatedAtDateUnix ?? 0;
    message.createdAtDateUnix = object.createdAtDateUnix ?? 0;
    return message;
  },
};

function createBaseGetXTZAddressStakingRewardsRequest(): GetXTZAddressStakingRewardsRequest {
  return { network: "", addressID: 0, from: undefined, to: undefined };
}

export const GetXTZAddressStakingRewardsRequest = {
  encode(message: GetXTZAddressStakingRewardsRequest, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.network !== "") {
      writer.uint32(10).string(message.network);
    }
    if (message.addressID !== 0) {
      writer.uint32(16).uint64(message.addressID);
    }
    if (message.from !== undefined) {
      Timestamp.encode(toTimestamp(message.from), writer.uint32(26).fork()).ldelim();
    }
    if (message.to !== undefined) {
      Timestamp.encode(toTimestamp(message.to), writer.uint32(34).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): GetXTZAddressStakingRewardsRequest {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetXTZAddressStakingRewardsRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.network = reader.string();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.addressID = longToNumber(reader.uint64() as Long);
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.from = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.to = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetXTZAddressStakingRewardsRequest {
    return {
      network: isSet(object.network) ? globalThis.String(object.network) : "",
      addressID: isSet(object.addressID) ? globalThis.Number(object.addressID) : 0,
      from: isSet(object.from) ? fromJsonTimestamp(object.from) : undefined,
      to: isSet(object.to) ? fromJsonTimestamp(object.to) : undefined,
    };
  },

  toJSON(message: GetXTZAddressStakingRewardsRequest): unknown {
    const obj: any = {};
    if (message.network !== "") {
      obj.network = message.network;
    }
    if (message.addressID !== 0) {
      obj.addressID = Math.round(message.addressID);
    }
    if (message.from !== undefined) {
      obj.from = message.from.toISOString();
    }
    if (message.to !== undefined) {
      obj.to = message.to.toISOString();
    }
    return obj;
  },

  create(base?: DeepPartial<GetXTZAddressStakingRewardsRequest>): GetXTZAddressStakingRewardsRequest {
    return GetXTZAddressStakingRewardsRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<GetXTZAddressStakingRewardsRequest>): GetXTZAddressStakingRewardsRequest {
    const message = createBaseGetXTZAddressStakingRewardsRequest();
    message.network = object.network ?? "";
    message.addressID = object.addressID ?? 0;
    message.from = object.from ?? undefined;
    message.to = object.to ?? undefined;
    return message;
  },
};

function createBaseGetXTZAddressStakingRewardsReply(): GetXTZAddressStakingRewardsReply {
  return { receivedRewardsAmount: "" };
}

export const GetXTZAddressStakingRewardsReply = {
  encode(message: GetXTZAddressStakingRewardsReply, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.receivedRewardsAmount !== "") {
      writer.uint32(10).string(message.receivedRewardsAmount);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): GetXTZAddressStakingRewardsReply {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetXTZAddressStakingRewardsReply();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.receivedRewardsAmount = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetXTZAddressStakingRewardsReply {
    return {
      receivedRewardsAmount: isSet(object.receivedRewardsAmount) ? globalThis.String(object.receivedRewardsAmount) : "",
    };
  },

  toJSON(message: GetXTZAddressStakingRewardsReply): unknown {
    const obj: any = {};
    if (message.receivedRewardsAmount !== "") {
      obj.receivedRewardsAmount = message.receivedRewardsAmount;
    }
    return obj;
  },

  create(base?: DeepPartial<GetXTZAddressStakingRewardsReply>): GetXTZAddressStakingRewardsReply {
    return GetXTZAddressStakingRewardsReply.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<GetXTZAddressStakingRewardsReply>): GetXTZAddressStakingRewardsReply {
    const message = createBaseGetXTZAddressStakingRewardsReply();
    message.receivedRewardsAmount = object.receivedRewardsAmount ?? "";
    return message;
  },
};

function createBaseGetNEARValidatorInfoRequest(): GetNEARValidatorInfoRequest {
  return { network: "", validatorAddress: "" };
}

export const GetNEARValidatorInfoRequest = {
  encode(message: GetNEARValidatorInfoRequest, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.network !== "") {
      writer.uint32(10).string(message.network);
    }
    if (message.validatorAddress !== "") {
      writer.uint32(18).string(message.validatorAddress);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): GetNEARValidatorInfoRequest {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetNEARValidatorInfoRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.network = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.validatorAddress = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetNEARValidatorInfoRequest {
    return {
      network: isSet(object.network) ? globalThis.String(object.network) : "",
      validatorAddress: isSet(object.validatorAddress) ? globalThis.String(object.validatorAddress) : "",
    };
  },

  toJSON(message: GetNEARValidatorInfoRequest): unknown {
    const obj: any = {};
    if (message.network !== "") {
      obj.network = message.network;
    }
    if (message.validatorAddress !== "") {
      obj.validatorAddress = message.validatorAddress;
    }
    return obj;
  },

  create(base?: DeepPartial<GetNEARValidatorInfoRequest>): GetNEARValidatorInfoRequest {
    return GetNEARValidatorInfoRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<GetNEARValidatorInfoRequest>): GetNEARValidatorInfoRequest {
    const message = createBaseGetNEARValidatorInfoRequest();
    message.network = object.network ?? "";
    message.validatorAddress = object.validatorAddress ?? "";
    return message;
  },
};

function createBaseGetNEARValidatorInfoReply(): GetNEARValidatorInfoReply {
  return {
    validatorAddress: "",
    ownerId: "",
    totalStakedBalance: "",
    rewardFeeFraction: 0,
    stakingKey: "",
    isStakingPaused: false,
  };
}

export const GetNEARValidatorInfoReply = {
  encode(message: GetNEARValidatorInfoReply, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.validatorAddress !== "") {
      writer.uint32(10).string(message.validatorAddress);
    }
    if (message.ownerId !== "") {
      writer.uint32(18).string(message.ownerId);
    }
    if (message.totalStakedBalance !== "") {
      writer.uint32(26).string(message.totalStakedBalance);
    }
    if (message.rewardFeeFraction !== 0) {
      writer.uint32(37).float(message.rewardFeeFraction);
    }
    if (message.stakingKey !== "") {
      writer.uint32(42).string(message.stakingKey);
    }
    if (message.isStakingPaused !== false) {
      writer.uint32(48).bool(message.isStakingPaused);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): GetNEARValidatorInfoReply {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetNEARValidatorInfoReply();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.validatorAddress = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.ownerId = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.totalStakedBalance = reader.string();
          continue;
        case 4:
          if (tag !== 37) {
            break;
          }

          message.rewardFeeFraction = reader.float();
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.stakingKey = reader.string();
          continue;
        case 6:
          if (tag !== 48) {
            break;
          }

          message.isStakingPaused = reader.bool();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetNEARValidatorInfoReply {
    return {
      validatorAddress: isSet(object.validatorAddress) ? globalThis.String(object.validatorAddress) : "",
      ownerId: isSet(object.ownerId) ? globalThis.String(object.ownerId) : "",
      totalStakedBalance: isSet(object.totalStakedBalance) ? globalThis.String(object.totalStakedBalance) : "",
      rewardFeeFraction: isSet(object.rewardFeeFraction) ? globalThis.Number(object.rewardFeeFraction) : 0,
      stakingKey: isSet(object.stakingKey) ? globalThis.String(object.stakingKey) : "",
      isStakingPaused: isSet(object.isStakingPaused) ? globalThis.Boolean(object.isStakingPaused) : false,
    };
  },

  toJSON(message: GetNEARValidatorInfoReply): unknown {
    const obj: any = {};
    if (message.validatorAddress !== "") {
      obj.validatorAddress = message.validatorAddress;
    }
    if (message.ownerId !== "") {
      obj.ownerId = message.ownerId;
    }
    if (message.totalStakedBalance !== "") {
      obj.totalStakedBalance = message.totalStakedBalance;
    }
    if (message.rewardFeeFraction !== 0) {
      obj.rewardFeeFraction = message.rewardFeeFraction;
    }
    if (message.stakingKey !== "") {
      obj.stakingKey = message.stakingKey;
    }
    if (message.isStakingPaused !== false) {
      obj.isStakingPaused = message.isStakingPaused;
    }
    return obj;
  },

  create(base?: DeepPartial<GetNEARValidatorInfoReply>): GetNEARValidatorInfoReply {
    return GetNEARValidatorInfoReply.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<GetNEARValidatorInfoReply>): GetNEARValidatorInfoReply {
    const message = createBaseGetNEARValidatorInfoReply();
    message.validatorAddress = object.validatorAddress ?? "";
    message.ownerId = object.ownerId ?? "";
    message.totalStakedBalance = object.totalStakedBalance ?? "";
    message.rewardFeeFraction = object.rewardFeeFraction ?? 0;
    message.stakingKey = object.stakingKey ?? "";
    message.isStakingPaused = object.isStakingPaused ?? false;
    return message;
  },
};

function createBaseGetETHValidatorsInfoRequest(): GetETHValidatorsInfoRequest {
  return { network: "", ids: [] };
}

export const GetETHValidatorsInfoRequest = {
  encode(message: GetETHValidatorsInfoRequest, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.network !== "") {
      writer.uint32(10).string(message.network);
    }
    for (const v of message.ids) {
      writer.uint32(18).string(v!);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): GetETHValidatorsInfoRequest {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetETHValidatorsInfoRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.network = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.ids.push(reader.string());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetETHValidatorsInfoRequest {
    return {
      network: isSet(object.network) ? globalThis.String(object.network) : "",
      ids: globalThis.Array.isArray(object?.ids) ? object.ids.map((e: any) => globalThis.String(e)) : [],
    };
  },

  toJSON(message: GetETHValidatorsInfoRequest): unknown {
    const obj: any = {};
    if (message.network !== "") {
      obj.network = message.network;
    }
    if (message.ids?.length) {
      obj.ids = message.ids;
    }
    return obj;
  },

  create(base?: DeepPartial<GetETHValidatorsInfoRequest>): GetETHValidatorsInfoRequest {
    return GetETHValidatorsInfoRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<GetETHValidatorsInfoRequest>): GetETHValidatorsInfoRequest {
    const message = createBaseGetETHValidatorsInfoRequest();
    message.network = object.network ?? "";
    message.ids = object.ids?.map((e) => e) || [];
    return message;
  },
};

function createBaseGetETHValidatorsInfoReply(): GetETHValidatorsInfoReply {
  return { validators: [] };
}

export const GetETHValidatorsInfoReply = {
  encode(message: GetETHValidatorsInfoReply, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    for (const v of message.validators) {
      ETHValidatorInfo.encode(v!, writer.uint32(10).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): GetETHValidatorsInfoReply {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetETHValidatorsInfoReply();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.validators.push(ETHValidatorInfo.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetETHValidatorsInfoReply {
    return {
      validators: globalThis.Array.isArray(object?.validators)
        ? object.validators.map((e: any) => ETHValidatorInfo.fromJSON(e))
        : [],
    };
  },

  toJSON(message: GetETHValidatorsInfoReply): unknown {
    const obj: any = {};
    if (message.validators?.length) {
      obj.validators = message.validators.map((e) => ETHValidatorInfo.toJSON(e));
    }
    return obj;
  },

  create(base?: DeepPartial<GetETHValidatorsInfoReply>): GetETHValidatorsInfoReply {
    return GetETHValidatorsInfoReply.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<GetETHValidatorsInfoReply>): GetETHValidatorsInfoReply {
    const message = createBaseGetETHValidatorsInfoReply();
    message.validators = object.validators?.map((e) => ETHValidatorInfo.fromPartial(e)) || [];
    return message;
  },
};

function createBaseETHValidatorInfo(): ETHValidatorInfo {
  return { id: "", pubkey: "", status: "", balance: "", network: "", provider: "", addressID: 0 };
}

export const ETHValidatorInfo = {
  encode(message: ETHValidatorInfo, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.id !== "") {
      writer.uint32(10).string(message.id);
    }
    if (message.pubkey !== "") {
      writer.uint32(18).string(message.pubkey);
    }
    if (message.status !== "") {
      writer.uint32(26).string(message.status);
    }
    if (message.balance !== "") {
      writer.uint32(34).string(message.balance);
    }
    if (message.network !== "") {
      writer.uint32(42).string(message.network);
    }
    if (message.provider !== "") {
      writer.uint32(50).string(message.provider);
    }
    if (message.addressID !== 0) {
      writer.uint32(56).uint64(message.addressID);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): ETHValidatorInfo {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseETHValidatorInfo();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.id = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.pubkey = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.status = reader.string();
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.balance = reader.string();
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.network = reader.string();
          continue;
        case 6:
          if (tag !== 50) {
            break;
          }

          message.provider = reader.string();
          continue;
        case 7:
          if (tag !== 56) {
            break;
          }

          message.addressID = longToNumber(reader.uint64() as Long);
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ETHValidatorInfo {
    return {
      id: isSet(object.id) ? globalThis.String(object.id) : "",
      pubkey: isSet(object.pubkey) ? globalThis.String(object.pubkey) : "",
      status: isSet(object.status) ? globalThis.String(object.status) : "",
      balance: isSet(object.balance) ? globalThis.String(object.balance) : "",
      network: isSet(object.network) ? globalThis.String(object.network) : "",
      provider: isSet(object.provider) ? globalThis.String(object.provider) : "",
      addressID: isSet(object.addressID) ? globalThis.Number(object.addressID) : 0,
    };
  },

  toJSON(message: ETHValidatorInfo): unknown {
    const obj: any = {};
    if (message.id !== "") {
      obj.id = message.id;
    }
    if (message.pubkey !== "") {
      obj.pubkey = message.pubkey;
    }
    if (message.status !== "") {
      obj.status = message.status;
    }
    if (message.balance !== "") {
      obj.balance = message.balance;
    }
    if (message.network !== "") {
      obj.network = message.network;
    }
    if (message.provider !== "") {
      obj.provider = message.provider;
    }
    if (message.addressID !== 0) {
      obj.addressID = Math.round(message.addressID);
    }
    return obj;
  },

  create(base?: DeepPartial<ETHValidatorInfo>): ETHValidatorInfo {
    return ETHValidatorInfo.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ETHValidatorInfo>): ETHValidatorInfo {
    const message = createBaseETHValidatorInfo();
    message.id = object.id ?? "";
    message.pubkey = object.pubkey ?? "";
    message.status = object.status ?? "";
    message.balance = object.balance ?? "";
    message.network = object.network ?? "";
    message.provider = object.provider ?? "";
    message.addressID = object.addressID ?? 0;
    return message;
  },
};

function createBaseGetICPNeuronInfoRequest(): GetICPNeuronInfoRequest {
  return { network: "", neuronID: 0 };
}

export const GetICPNeuronInfoRequest = {
  encode(message: GetICPNeuronInfoRequest, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.network !== "") {
      writer.uint32(10).string(message.network);
    }
    if (message.neuronID !== 0) {
      writer.uint32(16).uint64(message.neuronID);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): GetICPNeuronInfoRequest {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetICPNeuronInfoRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.network = reader.string();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.neuronID = longToNumber(reader.uint64() as Long);
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetICPNeuronInfoRequest {
    return {
      network: isSet(object.network) ? globalThis.String(object.network) : "",
      neuronID: isSet(object.neuronID) ? globalThis.Number(object.neuronID) : 0,
    };
  },

  toJSON(message: GetICPNeuronInfoRequest): unknown {
    const obj: any = {};
    if (message.network !== "") {
      obj.network = message.network;
    }
    if (message.neuronID !== 0) {
      obj.neuronID = Math.round(message.neuronID);
    }
    return obj;
  },

  create(base?: DeepPartial<GetICPNeuronInfoRequest>): GetICPNeuronInfoRequest {
    return GetICPNeuronInfoRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<GetICPNeuronInfoRequest>): GetICPNeuronInfoRequest {
    const message = createBaseGetICPNeuronInfoRequest();
    message.network = object.network ?? "";
    message.neuronID = object.neuronID ?? 0;
    return message;
  },
};

function createBaseICPKnownNeuronData(): ICPKnownNeuronData {
  return { name: "", description: "" };
}

export const ICPKnownNeuronData = {
  encode(message: ICPKnownNeuronData, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    if (message.description !== "") {
      writer.uint32(18).string(message.description);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): ICPKnownNeuronData {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseICPKnownNeuronData();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.description = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ICPKnownNeuronData {
    return {
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      description: isSet(object.description) ? globalThis.String(object.description) : "",
    };
  },

  toJSON(message: ICPKnownNeuronData): unknown {
    const obj: any = {};
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.description !== "") {
      obj.description = message.description;
    }
    return obj;
  },

  create(base?: DeepPartial<ICPKnownNeuronData>): ICPKnownNeuronData {
    return ICPKnownNeuronData.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ICPKnownNeuronData>): ICPKnownNeuronData {
    const message = createBaseICPKnownNeuronData();
    message.name = object.name ?? "";
    message.description = object.description ?? "";
    return message;
  },
};

function createBaseGetICPNeuronInfoReply(): GetICPNeuronInfoReply {
  return {
    neuronId: 0,
    retrieveAtTimestampSeconds: 0,
    neuronState: 0,
    ageSeconds: 0,
    dissolveDelaySeconds: 0,
    votingPower: 0,
    createdTimestampSeconds: 0,
    stakeE8S: 0,
    joinedCommunityFundTimestampSeconds: 0,
    knownNeuronData: undefined,
  };
}

export const GetICPNeuronInfoReply = {
  encode(message: GetICPNeuronInfoReply, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.neuronId !== 0) {
      writer.uint32(8).uint64(message.neuronId);
    }
    if (message.retrieveAtTimestampSeconds !== 0) {
      writer.uint32(16).uint64(message.retrieveAtTimestampSeconds);
    }
    if (message.neuronState !== 0) {
      writer.uint32(24).int32(message.neuronState);
    }
    if (message.ageSeconds !== 0) {
      writer.uint32(32).uint64(message.ageSeconds);
    }
    if (message.dissolveDelaySeconds !== 0) {
      writer.uint32(40).uint64(message.dissolveDelaySeconds);
    }
    if (message.votingPower !== 0) {
      writer.uint32(48).uint64(message.votingPower);
    }
    if (message.createdTimestampSeconds !== 0) {
      writer.uint32(56).uint64(message.createdTimestampSeconds);
    }
    if (message.stakeE8S !== 0) {
      writer.uint32(64).uint64(message.stakeE8S);
    }
    if (message.joinedCommunityFundTimestampSeconds !== 0) {
      writer.uint32(72).uint64(message.joinedCommunityFundTimestampSeconds);
    }
    if (message.knownNeuronData !== undefined) {
      ICPKnownNeuronData.encode(message.knownNeuronData, writer.uint32(82).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): GetICPNeuronInfoReply {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetICPNeuronInfoReply();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.neuronId = longToNumber(reader.uint64() as Long);
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.retrieveAtTimestampSeconds = longToNumber(reader.uint64() as Long);
          continue;
        case 3:
          if (tag !== 24) {
            break;
          }

          message.neuronState = reader.int32() as any;
          continue;
        case 4:
          if (tag !== 32) {
            break;
          }

          message.ageSeconds = longToNumber(reader.uint64() as Long);
          continue;
        case 5:
          if (tag !== 40) {
            break;
          }

          message.dissolveDelaySeconds = longToNumber(reader.uint64() as Long);
          continue;
        case 6:
          if (tag !== 48) {
            break;
          }

          message.votingPower = longToNumber(reader.uint64() as Long);
          continue;
        case 7:
          if (tag !== 56) {
            break;
          }

          message.createdTimestampSeconds = longToNumber(reader.uint64() as Long);
          continue;
        case 8:
          if (tag !== 64) {
            break;
          }

          message.stakeE8S = longToNumber(reader.uint64() as Long);
          continue;
        case 9:
          if (tag !== 72) {
            break;
          }

          message.joinedCommunityFundTimestampSeconds = longToNumber(reader.uint64() as Long);
          continue;
        case 10:
          if (tag !== 82) {
            break;
          }

          message.knownNeuronData = ICPKnownNeuronData.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetICPNeuronInfoReply {
    return {
      neuronId: isSet(object.neuronId) ? globalThis.Number(object.neuronId) : 0,
      retrieveAtTimestampSeconds: isSet(object.retrieveAtTimestampSeconds)
        ? globalThis.Number(object.retrieveAtTimestampSeconds)
        : 0,
      neuronState: isSet(object.neuronState) ? getICPNeuronInfoReply_NeuronStateFromJSON(object.neuronState) : 0,
      ageSeconds: isSet(object.ageSeconds) ? globalThis.Number(object.ageSeconds) : 0,
      dissolveDelaySeconds: isSet(object.dissolveDelaySeconds) ? globalThis.Number(object.dissolveDelaySeconds) : 0,
      votingPower: isSet(object.votingPower) ? globalThis.Number(object.votingPower) : 0,
      createdTimestampSeconds: isSet(object.createdTimestampSeconds)
        ? globalThis.Number(object.createdTimestampSeconds)
        : 0,
      stakeE8S: isSet(object.stakeE8S) ? globalThis.Number(object.stakeE8S) : 0,
      joinedCommunityFundTimestampSeconds: isSet(object.joinedCommunityFundTimestampSeconds)
        ? globalThis.Number(object.joinedCommunityFundTimestampSeconds)
        : 0,
      knownNeuronData: isSet(object.knownNeuronData) ? ICPKnownNeuronData.fromJSON(object.knownNeuronData) : undefined,
    };
  },

  toJSON(message: GetICPNeuronInfoReply): unknown {
    const obj: any = {};
    if (message.neuronId !== 0) {
      obj.neuronId = Math.round(message.neuronId);
    }
    if (message.retrieveAtTimestampSeconds !== 0) {
      obj.retrieveAtTimestampSeconds = Math.round(message.retrieveAtTimestampSeconds);
    }
    if (message.neuronState !== 0) {
      obj.neuronState = getICPNeuronInfoReply_NeuronStateToJSON(message.neuronState);
    }
    if (message.ageSeconds !== 0) {
      obj.ageSeconds = Math.round(message.ageSeconds);
    }
    if (message.dissolveDelaySeconds !== 0) {
      obj.dissolveDelaySeconds = Math.round(message.dissolveDelaySeconds);
    }
    if (message.votingPower !== 0) {
      obj.votingPower = Math.round(message.votingPower);
    }
    if (message.createdTimestampSeconds !== 0) {
      obj.createdTimestampSeconds = Math.round(message.createdTimestampSeconds);
    }
    if (message.stakeE8S !== 0) {
      obj.stakeE8S = Math.round(message.stakeE8S);
    }
    if (message.joinedCommunityFundTimestampSeconds !== 0) {
      obj.joinedCommunityFundTimestampSeconds = Math.round(message.joinedCommunityFundTimestampSeconds);
    }
    if (message.knownNeuronData !== undefined) {
      obj.knownNeuronData = ICPKnownNeuronData.toJSON(message.knownNeuronData);
    }
    return obj;
  },

  create(base?: DeepPartial<GetICPNeuronInfoReply>): GetICPNeuronInfoReply {
    return GetICPNeuronInfoReply.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<GetICPNeuronInfoReply>): GetICPNeuronInfoReply {
    const message = createBaseGetICPNeuronInfoReply();
    message.neuronId = object.neuronId ?? 0;
    message.retrieveAtTimestampSeconds = object.retrieveAtTimestampSeconds ?? 0;
    message.neuronState = object.neuronState ?? 0;
    message.ageSeconds = object.ageSeconds ?? 0;
    message.dissolveDelaySeconds = object.dissolveDelaySeconds ?? 0;
    message.votingPower = object.votingPower ?? 0;
    message.createdTimestampSeconds = object.createdTimestampSeconds ?? 0;
    message.stakeE8S = object.stakeE8S ?? 0;
    message.joinedCommunityFundTimestampSeconds = object.joinedCommunityFundTimestampSeconds ?? 0;
    message.knownNeuronData = (object.knownNeuronData !== undefined && object.knownNeuronData !== null)
      ? ICPKnownNeuronData.fromPartial(object.knownNeuronData)
      : undefined;
    return message;
  },
};

function createBaseGetStakeAccountsRequest(): GetStakeAccountsRequest {
  return { addressId: 0, accountType: 0, accountAddress: "", cursor: undefined };
}

export const GetStakeAccountsRequest = {
  encode(message: GetStakeAccountsRequest, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.addressId !== 0) {
      writer.uint32(8).uint64(message.addressId);
    }
    if (message.accountType !== 0) {
      writer.uint32(16).int32(message.accountType);
    }
    if (message.accountAddress !== "") {
      writer.uint32(26).string(message.accountAddress);
    }
    if (message.cursor !== undefined) {
      RequestCursor.encode(message.cursor, writer.uint32(34).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): GetStakeAccountsRequest {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetStakeAccountsRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.addressId = longToNumber(reader.uint64() as Long);
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.accountType = reader.int32() as any;
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.accountAddress = reader.string();
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.cursor = RequestCursor.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetStakeAccountsRequest {
    return {
      addressId: isSet(object.addressId) ? globalThis.Number(object.addressId) : 0,
      accountType: isSet(object.accountType) ? stakeAccountTypeFromJSON(object.accountType) : 0,
      accountAddress: isSet(object.accountAddress) ? globalThis.String(object.accountAddress) : "",
      cursor: isSet(object.cursor) ? RequestCursor.fromJSON(object.cursor) : undefined,
    };
  },

  toJSON(message: GetStakeAccountsRequest): unknown {
    const obj: any = {};
    if (message.addressId !== 0) {
      obj.addressId = Math.round(message.addressId);
    }
    if (message.accountType !== 0) {
      obj.accountType = stakeAccountTypeToJSON(message.accountType);
    }
    if (message.accountAddress !== "") {
      obj.accountAddress = message.accountAddress;
    }
    if (message.cursor !== undefined) {
      obj.cursor = RequestCursor.toJSON(message.cursor);
    }
    return obj;
  },

  create(base?: DeepPartial<GetStakeAccountsRequest>): GetStakeAccountsRequest {
    return GetStakeAccountsRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<GetStakeAccountsRequest>): GetStakeAccountsRequest {
    const message = createBaseGetStakeAccountsRequest();
    message.addressId = object.addressId ?? 0;
    message.accountType = object.accountType ?? 0;
    message.accountAddress = object.accountAddress ?? "";
    message.cursor = (object.cursor !== undefined && object.cursor !== null)
      ? RequestCursor.fromPartial(object.cursor)
      : undefined;
    return message;
  },
};

function createBaseGetStakeAccountsReply(): GetStakeAccountsReply {
  return { stakeAccounts: [], cursor: undefined };
}

export const GetStakeAccountsReply = {
  encode(message: GetStakeAccountsReply, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    for (const v of message.stakeAccounts) {
      StakeAccount.encode(v!, writer.uint32(10).fork()).ldelim();
    }
    if (message.cursor !== undefined) {
      ResponseCursor.encode(message.cursor, writer.uint32(18).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): GetStakeAccountsReply {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetStakeAccountsReply();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.stakeAccounts.push(StakeAccount.decode(reader, reader.uint32()));
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.cursor = ResponseCursor.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetStakeAccountsReply {
    return {
      stakeAccounts: globalThis.Array.isArray(object?.stakeAccounts)
        ? object.stakeAccounts.map((e: any) => StakeAccount.fromJSON(e))
        : [],
      cursor: isSet(object.cursor) ? ResponseCursor.fromJSON(object.cursor) : undefined,
    };
  },

  toJSON(message: GetStakeAccountsReply): unknown {
    const obj: any = {};
    if (message.stakeAccounts?.length) {
      obj.stakeAccounts = message.stakeAccounts.map((e) => StakeAccount.toJSON(e));
    }
    if (message.cursor !== undefined) {
      obj.cursor = ResponseCursor.toJSON(message.cursor);
    }
    return obj;
  },

  create(base?: DeepPartial<GetStakeAccountsReply>): GetStakeAccountsReply {
    return GetStakeAccountsReply.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<GetStakeAccountsReply>): GetStakeAccountsReply {
    const message = createBaseGetStakeAccountsReply();
    message.stakeAccounts = object.stakeAccounts?.map((e) => StakeAccount.fromPartial(e)) || [];
    message.cursor = (object.cursor !== undefined && object.cursor !== null)
      ? ResponseCursor.fromPartial(object.cursor)
      : undefined;
    return message;
  },
};

export interface StakingService {
  GetADAStakePoolInfo(request: GetADAStakePoolInfoRequest): Promise<GetADAStakePoolInfoReply>;
  GetFTMValidatorInfo(request: GetFTMValidatorInfoRequest): Promise<GetFTMValidatorInfoReply>;
  GetNEARValidatorInfo(request: GetNEARValidatorInfoRequest): Promise<GetNEARValidatorInfoReply>;
  GetETHValidatorsInfo(request: GetETHValidatorsInfoRequest): Promise<GetETHValidatorsInfoReply>;
  GetXTZAddressStakingRewards(request: GetXTZAddressStakingRewardsRequest): Promise<GetXTZAddressStakingRewardsReply>;
  GetICPNeuronInfo(request: GetICPNeuronInfoRequest): Promise<GetICPNeuronInfoReply>;
  GetStakeAccounts(request: GetStakeAccountsRequest): Promise<GetStakeAccountsReply>;
}

export const StakingServiceServiceName = "tgvalidatord.StakingService";
export class StakingServiceClientImpl implements StakingService {
  private readonly rpc: Rpc;
  private readonly service: string;
  constructor(rpc: Rpc, opts?: { service?: string }) {
    this.service = opts?.service || StakingServiceServiceName;
    this.rpc = rpc;
    this.GetADAStakePoolInfo = this.GetADAStakePoolInfo.bind(this);
    this.GetFTMValidatorInfo = this.GetFTMValidatorInfo.bind(this);
    this.GetNEARValidatorInfo = this.GetNEARValidatorInfo.bind(this);
    this.GetETHValidatorsInfo = this.GetETHValidatorsInfo.bind(this);
    this.GetXTZAddressStakingRewards = this.GetXTZAddressStakingRewards.bind(this);
    this.GetICPNeuronInfo = this.GetICPNeuronInfo.bind(this);
    this.GetStakeAccounts = this.GetStakeAccounts.bind(this);
  }
  GetADAStakePoolInfo(request: GetADAStakePoolInfoRequest): Promise<GetADAStakePoolInfoReply> {
    const data = GetADAStakePoolInfoRequest.encode(request).finish();
    const promise = this.rpc.request(this.service, "GetADAStakePoolInfo", data);
    return promise.then((data) => GetADAStakePoolInfoReply.decode(_m0.Reader.create(data)));
  }

  GetFTMValidatorInfo(request: GetFTMValidatorInfoRequest): Promise<GetFTMValidatorInfoReply> {
    const data = GetFTMValidatorInfoRequest.encode(request).finish();
    const promise = this.rpc.request(this.service, "GetFTMValidatorInfo", data);
    return promise.then((data) => GetFTMValidatorInfoReply.decode(_m0.Reader.create(data)));
  }

  GetNEARValidatorInfo(request: GetNEARValidatorInfoRequest): Promise<GetNEARValidatorInfoReply> {
    const data = GetNEARValidatorInfoRequest.encode(request).finish();
    const promise = this.rpc.request(this.service, "GetNEARValidatorInfo", data);
    return promise.then((data) => GetNEARValidatorInfoReply.decode(_m0.Reader.create(data)));
  }

  GetETHValidatorsInfo(request: GetETHValidatorsInfoRequest): Promise<GetETHValidatorsInfoReply> {
    const data = GetETHValidatorsInfoRequest.encode(request).finish();
    const promise = this.rpc.request(this.service, "GetETHValidatorsInfo", data);
    return promise.then((data) => GetETHValidatorsInfoReply.decode(_m0.Reader.create(data)));
  }

  GetXTZAddressStakingRewards(request: GetXTZAddressStakingRewardsRequest): Promise<GetXTZAddressStakingRewardsReply> {
    const data = GetXTZAddressStakingRewardsRequest.encode(request).finish();
    const promise = this.rpc.request(this.service, "GetXTZAddressStakingRewards", data);
    return promise.then((data) => GetXTZAddressStakingRewardsReply.decode(_m0.Reader.create(data)));
  }

  GetICPNeuronInfo(request: GetICPNeuronInfoRequest): Promise<GetICPNeuronInfoReply> {
    const data = GetICPNeuronInfoRequest.encode(request).finish();
    const promise = this.rpc.request(this.service, "GetICPNeuronInfo", data);
    return promise.then((data) => GetICPNeuronInfoReply.decode(_m0.Reader.create(data)));
  }

  GetStakeAccounts(request: GetStakeAccountsRequest): Promise<GetStakeAccountsReply> {
    const data = GetStakeAccountsRequest.encode(request).finish();
    const promise = this.rpc.request(this.service, "GetStakeAccounts", data);
    return promise.then((data) => GetStakeAccountsReply.decode(_m0.Reader.create(data)));
  }
}

interface Rpc {
  request(service: string, method: string, data: Uint8Array): Promise<Uint8Array>;
}

type Builtin = Date | Function | Uint8Array | string | number | boolean | undefined;

export type DeepPartial<T> = T extends Builtin ? T
  : T extends globalThis.Array<infer U> ? globalThis.Array<DeepPartial<U>>
  : T extends ReadonlyArray<infer U> ? ReadonlyArray<DeepPartial<U>>
  : T extends {} ? { [K in keyof T]?: DeepPartial<T[K]> }
  : Partial<T>;

function toTimestamp(date: Date): Timestamp {
  const seconds = Math.trunc(date.getTime() / 1_000);
  const nanos = (date.getTime() % 1_000) * 1_000_000;
  return { seconds, nanos };
}

function fromTimestamp(t: Timestamp): Date {
  let millis = (t.seconds || 0) * 1_000;
  millis += (t.nanos || 0) / 1_000_000;
  return new globalThis.Date(millis);
}

function fromJsonTimestamp(o: any): Date {
  if (o instanceof globalThis.Date) {
    return o;
  } else if (typeof o === "string") {
    return new globalThis.Date(o);
  } else {
    return fromTimestamp(Timestamp.fromJSON(o));
  }
}

function longToNumber(long: Long): number {
  if (long.gt(globalThis.Number.MAX_SAFE_INTEGER)) {
    throw new globalThis.Error("Value is larger than Number.MAX_SAFE_INTEGER");
  }
  if (long.lt(globalThis.Number.MIN_SAFE_INTEGER)) {
    throw new globalThis.Error("Value is smaller than Number.MIN_SAFE_INTEGER");
  }
  return long.toNumber();
}

if (_m0.util.Long !== Long) {
  _m0.util.Long = Long as any;
  _m0.configure();
}

function isSet(value: any): boolean {
  return value !== null && value !== undefined;
}
