// Code generated by protoc-gen-ts_proto. DO NOT EDIT.
// versions:
//   protoc-gen-ts_proto  v1.181.2
//   protoc               v6.33.4
// source: price-service.proto

/* eslint-disable */
import Long from "long";
import _m0 from "protobufjs/minimal";
import { Currency } from "./currency";
import { Empty } from "./google/protobuf/empty";
import { ConversionValue, CurrencyPrice, PricesHistoryPoint } from "./price";

export const protobufPackage = "tgvalidatord";

export interface GetPricesReply {
  baseCurrency: string;
  result: CurrencyPrice[];
}

export interface UpdatePricesRequest {
  prices: CurrencyPrice[];
}

export interface ConversionRequest {
  currency: string;
  /** An amount can be specified, otherwise it will convert an amount of 1. */
  amount: string;
  /**
   * The Symbols of the currencies can be specified to filter the results. By
   * default, it will use all the symbols known.
   */
  symbols: string[];
  targetCurrencyIds: string[];
}

export interface ConversionReply {
  currencyFrom: string;
  baseCurrency: string;
  result: ConversionValue[];
  fullCurrencyFrom: Currency | undefined;
  fullBaseCurrency: Currency | undefined;
}

export interface GetPricesHistoryRequest {
  base: string;
  quote: string;
  limit: number;
}

export interface GetPricesHistoryReply {
  result: PricesHistoryPoint[];
  period: string;
}

export interface ExportPricesHistoryRequest {
  currencyPairs: string[];
  limit: number;
  format: string;
}

export interface ExportPricesHistoryReply {
  result: string;
  period: string;
}

function createBaseGetPricesReply(): GetPricesReply {
  return { baseCurrency: "", result: [] };
}

export const GetPricesReply = {
  encode(message: GetPricesReply, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.baseCurrency !== "") {
      writer.uint32(10).string(message.baseCurrency);
    }
    for (const v of message.result) {
      CurrencyPrice.encode(v!, writer.uint32(18).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): GetPricesReply {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetPricesReply();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.baseCurrency = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.result.push(CurrencyPrice.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetPricesReply {
    return {
      baseCurrency: isSet(object.baseCurrency) ? globalThis.String(object.baseCurrency) : "",
      result: globalThis.Array.isArray(object?.result) ? object.result.map((e: any) => CurrencyPrice.fromJSON(e)) : [],
    };
  },

  toJSON(message: GetPricesReply): unknown {
    const obj: any = {};
    if (message.baseCurrency !== "") {
      obj.baseCurrency = message.baseCurrency;
    }
    if (message.result?.length) {
      obj.result = message.result.map((e) => CurrencyPrice.toJSON(e));
    }
    return obj;
  },

  create(base?: DeepPartial<GetPricesReply>): GetPricesReply {
    return GetPricesReply.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<GetPricesReply>): GetPricesReply {
    const message = createBaseGetPricesReply();
    message.baseCurrency = object.baseCurrency ?? "";
    message.result = object.result?.map((e) => CurrencyPrice.fromPartial(e)) || [];
    return message;
  },
};

function createBaseUpdatePricesRequest(): UpdatePricesRequest {
  return { prices: [] };
}

export const UpdatePricesRequest = {
  encode(message: UpdatePricesRequest, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    for (const v of message.prices) {
      CurrencyPrice.encode(v!, writer.uint32(10).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): UpdatePricesRequest {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseUpdatePricesRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.prices.push(CurrencyPrice.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): UpdatePricesRequest {
    return {
      prices: globalThis.Array.isArray(object?.prices) ? object.prices.map((e: any) => CurrencyPrice.fromJSON(e)) : [],
    };
  },

  toJSON(message: UpdatePricesRequest): unknown {
    const obj: any = {};
    if (message.prices?.length) {
      obj.prices = message.prices.map((e) => CurrencyPrice.toJSON(e));
    }
    return obj;
  },

  create(base?: DeepPartial<UpdatePricesRequest>): UpdatePricesRequest {
    return UpdatePricesRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<UpdatePricesRequest>): UpdatePricesRequest {
    const message = createBaseUpdatePricesRequest();
    message.prices = object.prices?.map((e) => CurrencyPrice.fromPartial(e)) || [];
    return message;
  },
};

function createBaseConversionRequest(): ConversionRequest {
  return { currency: "", amount: "", symbols: [], targetCurrencyIds: [] };
}

export const ConversionRequest = {
  encode(message: ConversionRequest, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.currency !== "") {
      writer.uint32(10).string(message.currency);
    }
    if (message.amount !== "") {
      writer.uint32(18).string(message.amount);
    }
    for (const v of message.symbols) {
      writer.uint32(26).string(v!);
    }
    for (const v of message.targetCurrencyIds) {
      writer.uint32(34).string(v!);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): ConversionRequest {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseConversionRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.currency = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.amount = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.symbols.push(reader.string());
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.targetCurrencyIds.push(reader.string());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ConversionRequest {
    return {
      currency: isSet(object.currency) ? globalThis.String(object.currency) : "",
      amount: isSet(object.amount) ? globalThis.String(object.amount) : "",
      symbols: globalThis.Array.isArray(object?.symbols) ? object.symbols.map((e: any) => globalThis.String(e)) : [],
      targetCurrencyIds: globalThis.Array.isArray(object?.targetCurrencyIds)
        ? object.targetCurrencyIds.map((e: any) => globalThis.String(e))
        : [],
    };
  },

  toJSON(message: ConversionRequest): unknown {
    const obj: any = {};
    if (message.currency !== "") {
      obj.currency = message.currency;
    }
    if (message.amount !== "") {
      obj.amount = message.amount;
    }
    if (message.symbols?.length) {
      obj.symbols = message.symbols;
    }
    if (message.targetCurrencyIds?.length) {
      obj.targetCurrencyIds = message.targetCurrencyIds;
    }
    return obj;
  },

  create(base?: DeepPartial<ConversionRequest>): ConversionRequest {
    return ConversionRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ConversionRequest>): ConversionRequest {
    const message = createBaseConversionRequest();
    message.currency = object.currency ?? "";
    message.amount = object.amount ?? "";
    message.symbols = object.symbols?.map((e) => e) || [];
    message.targetCurrencyIds = object.targetCurrencyIds?.map((e) => e) || [];
    return message;
  },
};

function createBaseConversionReply(): ConversionReply {
  return { currencyFrom: "", baseCurrency: "", result: [], fullCurrencyFrom: undefined, fullBaseCurrency: undefined };
}

export const ConversionReply = {
  encode(message: ConversionReply, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.currencyFrom !== "") {
      writer.uint32(10).string(message.currencyFrom);
    }
    if (message.baseCurrency !== "") {
      writer.uint32(26).string(message.baseCurrency);
    }
    for (const v of message.result) {
      ConversionValue.encode(v!, writer.uint32(18).fork()).ldelim();
    }
    if (message.fullCurrencyFrom !== undefined) {
      Currency.encode(message.fullCurrencyFrom, writer.uint32(34).fork()).ldelim();
    }
    if (message.fullBaseCurrency !== undefined) {
      Currency.encode(message.fullBaseCurrency, writer.uint32(42).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): ConversionReply {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseConversionReply();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.currencyFrom = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.baseCurrency = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.result.push(ConversionValue.decode(reader, reader.uint32()));
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.fullCurrencyFrom = Currency.decode(reader, reader.uint32());
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.fullBaseCurrency = Currency.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ConversionReply {
    return {
      currencyFrom: isSet(object.currencyFrom) ? globalThis.String(object.currencyFrom) : "",
      baseCurrency: isSet(object.baseCurrency) ? globalThis.String(object.baseCurrency) : "",
      result: globalThis.Array.isArray(object?.result)
        ? object.result.map((e: any) => ConversionValue.fromJSON(e))
        : [],
      fullCurrencyFrom: isSet(object.fullCurrencyFrom) ? Currency.fromJSON(object.fullCurrencyFrom) : undefined,
      fullBaseCurrency: isSet(object.fullBaseCurrency) ? Currency.fromJSON(object.fullBaseCurrency) : undefined,
    };
  },

  toJSON(message: ConversionReply): unknown {
    const obj: any = {};
    if (message.currencyFrom !== "") {
      obj.currencyFrom = message.currencyFrom;
    }
    if (message.baseCurrency !== "") {
      obj.baseCurrency = message.baseCurrency;
    }
    if (message.result?.length) {
      obj.result = message.result.map((e) => ConversionValue.toJSON(e));
    }
    if (message.fullCurrencyFrom !== undefined) {
      obj.fullCurrencyFrom = Currency.toJSON(message.fullCurrencyFrom);
    }
    if (message.fullBaseCurrency !== undefined) {
      obj.fullBaseCurrency = Currency.toJSON(message.fullBaseCurrency);
    }
    return obj;
  },

  create(base?: DeepPartial<ConversionReply>): ConversionReply {
    return ConversionReply.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ConversionReply>): ConversionReply {
    const message = createBaseConversionReply();
    message.currencyFrom = object.currencyFrom ?? "";
    message.baseCurrency = object.baseCurrency ?? "";
    message.result = object.result?.map((e) => ConversionValue.fromPartial(e)) || [];
    message.fullCurrencyFrom = (object.fullCurrencyFrom !== undefined && object.fullCurrencyFrom !== null)
      ? Currency.fromPartial(object.fullCurrencyFrom)
      : undefined;
    message.fullBaseCurrency = (object.fullBaseCurrency !== undefined && object.fullBaseCurrency !== null)
      ? Currency.fromPartial(object.fullBaseCurrency)
      : undefined;
    return message;
  },
};

function createBaseGetPricesHistoryRequest(): GetPricesHistoryRequest {
  return { base: "", quote: "", limit: 0 };
}

export const GetPricesHistoryRequest = {
  encode(message: GetPricesHistoryRequest, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.base !== "") {
      writer.uint32(10).string(message.base);
    }
    if (message.quote !== "") {
      writer.uint32(18).string(message.quote);
    }
    if (message.limit !== 0) {
      writer.uint32(24).uint64(message.limit);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): GetPricesHistoryRequest {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetPricesHistoryRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.base = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.quote = reader.string();
          continue;
        case 3:
          if (tag !== 24) {
            break;
          }

          message.limit = longToNumber(reader.uint64() as Long);
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetPricesHistoryRequest {
    return {
      base: isSet(object.base) ? globalThis.String(object.base) : "",
      quote: isSet(object.quote) ? globalThis.String(object.quote) : "",
      limit: isSet(object.limit) ? globalThis.Number(object.limit) : 0,
    };
  },

  toJSON(message: GetPricesHistoryRequest): unknown {
    const obj: any = {};
    if (message.base !== "") {
      obj.base = message.base;
    }
    if (message.quote !== "") {
      obj.quote = message.quote;
    }
    if (message.limit !== 0) {
      obj.limit = Math.round(message.limit);
    }
    return obj;
  },

  create(base?: DeepPartial<GetPricesHistoryRequest>): GetPricesHistoryRequest {
    return GetPricesHistoryRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<GetPricesHistoryRequest>): GetPricesHistoryRequest {
    const message = createBaseGetPricesHistoryRequest();
    message.base = object.base ?? "";
    message.quote = object.quote ?? "";
    message.limit = object.limit ?? 0;
    return message;
  },
};

function createBaseGetPricesHistoryReply(): GetPricesHistoryReply {
  return { result: [], period: "" };
}

export const GetPricesHistoryReply = {
  encode(message: GetPricesHistoryReply, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    for (const v of message.result) {
      PricesHistoryPoint.encode(v!, writer.uint32(10).fork()).ldelim();
    }
    if (message.period !== "") {
      writer.uint32(18).string(message.period);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): GetPricesHistoryReply {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetPricesHistoryReply();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.result.push(PricesHistoryPoint.decode(reader, reader.uint32()));
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.period = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetPricesHistoryReply {
    return {
      result: globalThis.Array.isArray(object?.result)
        ? object.result.map((e: any) => PricesHistoryPoint.fromJSON(e))
        : [],
      period: isSet(object.period) ? globalThis.String(object.period) : "",
    };
  },

  toJSON(message: GetPricesHistoryReply): unknown {
    const obj: any = {};
    if (message.result?.length) {
      obj.result = message.result.map((e) => PricesHistoryPoint.toJSON(e));
    }
    if (message.period !== "") {
      obj.period = message.period;
    }
    return obj;
  },

  create(base?: DeepPartial<GetPricesHistoryReply>): GetPricesHistoryReply {
    return GetPricesHistoryReply.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<GetPricesHistoryReply>): GetPricesHistoryReply {
    const message = createBaseGetPricesHistoryReply();
    message.result = object.result?.map((e) => PricesHistoryPoint.fromPartial(e)) || [];
    message.period = object.period ?? "";
    return message;
  },
};

function createBaseExportPricesHistoryRequest(): ExportPricesHistoryRequest {
  return { currencyPairs: [], limit: 0, format: "" };
}

export const ExportPricesHistoryRequest = {
  encode(message: ExportPricesHistoryRequest, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    for (const v of message.currencyPairs) {
      writer.uint32(10).string(v!);
    }
    if (message.limit !== 0) {
      writer.uint32(16).uint64(message.limit);
    }
    if (message.format !== "") {
      writer.uint32(26).string(message.format);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): ExportPricesHistoryRequest {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseExportPricesHistoryRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.currencyPairs.push(reader.string());
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.limit = longToNumber(reader.uint64() as Long);
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.format = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ExportPricesHistoryRequest {
    return {
      currencyPairs: globalThis.Array.isArray(object?.currencyPairs)
        ? object.currencyPairs.map((e: any) => globalThis.String(e))
        : [],
      limit: isSet(object.limit) ? globalThis.Number(object.limit) : 0,
      format: isSet(object.format) ? globalThis.String(object.format) : "",
    };
  },

  toJSON(message: ExportPricesHistoryRequest): unknown {
    const obj: any = {};
    if (message.currencyPairs?.length) {
      obj.currencyPairs = message.currencyPairs;
    }
    if (message.limit !== 0) {
      obj.limit = Math.round(message.limit);
    }
    if (message.format !== "") {
      obj.format = message.format;
    }
    return obj;
  },

  create(base?: DeepPartial<ExportPricesHistoryRequest>): ExportPricesHistoryRequest {
    return ExportPricesHistoryRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ExportPricesHistoryRequest>): ExportPricesHistoryRequest {
    const message = createBaseExportPricesHistoryRequest();
    message.currencyPairs = object.currencyPairs?.map((e) => e) || [];
    message.limit = object.limit ?? 0;
    message.format = object.format ?? "";
    return message;
  },
};

function createBaseExportPricesHistoryReply(): ExportPricesHistoryReply {
  return { result: "", period: "" };
}

export const ExportPricesHistoryReply = {
  encode(message: ExportPricesHistoryReply, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.result !== "") {
      writer.uint32(10).string(message.result);
    }
    if (message.period !== "") {
      writer.uint32(18).string(message.period);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): ExportPricesHistoryReply {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseExportPricesHistoryReply();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.result = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.period = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ExportPricesHistoryReply {
    return {
      result: isSet(object.result) ? globalThis.String(object.result) : "",
      period: isSet(object.period) ? globalThis.String(object.period) : "",
    };
  },

  toJSON(message: ExportPricesHistoryReply): unknown {
    const obj: any = {};
    if (message.result !== "") {
      obj.result = message.result;
    }
    if (message.period !== "") {
      obj.period = message.period;
    }
    return obj;
  },

  create(base?: DeepPartial<ExportPricesHistoryReply>): ExportPricesHistoryReply {
    return ExportPricesHistoryReply.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ExportPricesHistoryReply>): ExportPricesHistoryReply {
    const message = createBaseExportPricesHistoryReply();
    message.result = object.result ?? "";
    message.period = object.period ?? "";
    return message;
  },
};

export interface PriceService {
  GetPrices(request: Empty): Promise<GetPricesReply>;
  UpdatePrices(request: UpdatePricesRequest): Promise<Empty>;
  GetPricesHistory(request: GetPricesHistoryRequest): Promise<GetPricesHistoryReply>;
  /**
   * It is important that this is defined AFTER the more generic /api/rest/v1/prices/{base}/{quote}/history routes
   * This endpoint converts the currency and an amount to a list of other
   * currencies specified by the symbols, or a default list.
   */
  Convert(request: ConversionRequest): Promise<ConversionReply>;
  ExportPricesHistory(request: ExportPricesHistoryRequest): Promise<ExportPricesHistoryReply>;
}

export const PriceServiceServiceName = "tgvalidatord.PriceService";
export class PriceServiceClientImpl implements PriceService {
  private readonly rpc: Rpc;
  private readonly service: string;
  constructor(rpc: Rpc, opts?: { service?: string }) {
    this.service = opts?.service || PriceServiceServiceName;
    this.rpc = rpc;
    this.GetPrices = this.GetPrices.bind(this);
    this.UpdatePrices = this.UpdatePrices.bind(this);
    this.GetPricesHistory = this.GetPricesHistory.bind(this);
    this.Convert = this.Convert.bind(this);
    this.ExportPricesHistory = this.ExportPricesHistory.bind(this);
  }
  GetPrices(request: Empty): Promise<GetPricesReply> {
    const data = Empty.encode(request).finish();
    const promise = this.rpc.request(this.service, "GetPrices", data);
    return promise.then((data) => GetPricesReply.decode(_m0.Reader.create(data)));
  }

  UpdatePrices(request: UpdatePricesRequest): Promise<Empty> {
    const data = UpdatePricesRequest.encode(request).finish();
    const promise = this.rpc.request(this.service, "UpdatePrices", data);
    return promise.then((data) => Empty.decode(_m0.Reader.create(data)));
  }

  GetPricesHistory(request: GetPricesHistoryRequest): Promise<GetPricesHistoryReply> {
    const data = GetPricesHistoryRequest.encode(request).finish();
    const promise = this.rpc.request(this.service, "GetPricesHistory", data);
    return promise.then((data) => GetPricesHistoryReply.decode(_m0.Reader.create(data)));
  }

  Convert(request: ConversionRequest): Promise<ConversionReply> {
    const data = ConversionRequest.encode(request).finish();
    const promise = this.rpc.request(this.service, "Convert", data);
    return promise.then((data) => ConversionReply.decode(_m0.Reader.create(data)));
  }

  ExportPricesHistory(request: ExportPricesHistoryRequest): Promise<ExportPricesHistoryReply> {
    const data = ExportPricesHistoryRequest.encode(request).finish();
    const promise = this.rpc.request(this.service, "ExportPricesHistory", data);
    return promise.then((data) => ExportPricesHistoryReply.decode(_m0.Reader.create(data)));
  }
}

interface Rpc {
  request(service: string, method: string, data: Uint8Array): Promise<Uint8Array>;
}

type Builtin = Date | Function | Uint8Array | string | number | boolean | undefined;

export type DeepPartial<T> = T extends Builtin ? T
  : T extends globalThis.Array<infer U> ? globalThis.Array<DeepPartial<U>>
  : T extends ReadonlyArray<infer U> ? ReadonlyArray<DeepPartial<U>>
  : T extends {} ? { [K in keyof T]?: DeepPartial<T[K]> }
  : Partial<T>;

function longToNumber(long: Long): number {
  if (long.gt(globalThis.Number.MAX_SAFE_INTEGER)) {
    throw new globalThis.Error("Value is larger than Number.MAX_SAFE_INTEGER");
  }
  if (long.lt(globalThis.Number.MIN_SAFE_INTEGER)) {
    throw new globalThis.Error("Value is smaller than Number.MIN_SAFE_INTEGER");
  }
  return long.toNumber();
}

if (_m0.util.Long !== Long) {
  _m0.util.Long = Long as any;
  _m0.configure();
}

function isSet(value: any): boolean {
  return value !== null && value !== undefined;
}
