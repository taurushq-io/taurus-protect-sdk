/*
 * Taurus-PROTECT APIs
 * Taurus-PROTECT APIs description
 *
 * The version of the OpenAPI document: 1.0
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


package com.taurushq.sdk.protect.openapi.model;

import java.util.Objects;
import com.google.gson.TypeAdapter;
import com.google.gson.annotations.JsonAdapter;
import com.google.gson.annotations.SerializedName;
import com.google.gson.stream.JsonReader;
import com.google.gson.stream.JsonWriter;
import java.io.IOException;
import java.util.Arrays;

import com.google.gson.Gson;
import com.google.gson.GsonBuilder;
import com.google.gson.JsonArray;
import com.google.gson.JsonDeserializationContext;
import com.google.gson.JsonDeserializer;
import com.google.gson.JsonElement;
import com.google.gson.JsonObject;
import com.google.gson.JsonParseException;
import com.google.gson.TypeAdapterFactory;
import com.google.gson.reflect.TypeToken;
import com.google.gson.TypeAdapter;
import com.google.gson.stream.JsonReader;
import com.google.gson.stream.JsonWriter;
import java.io.IOException;

import java.util.HashMap;
import java.util.HashSet;
import java.util.List;
import java.util.Map;
import java.util.Set;

import com.taurushq.sdk.protect.openapi.JSON;

/**
 * TgvalidatordXTZBaker
 */
@javax.annotation.Generated(value = "org.openapitools.codegen.languages.JavaClientCodegen", date = "2026-01-23T15:56:06.931912+01:00[Europe/Zurich]", comments = "Generator version: 7.9.0")
public class TgvalidatordXTZBaker {
  public static final String SERIALIZED_NAME_ADDRESS = "address";
  @SerializedName(SERIALIZED_NAME_ADDRESS)
  private String address;

  public static final String SERIALIZED_NAME_STAKING_BOND = "stakingBond";
  @SerializedName(SERIALIZED_NAME_STAKING_BOND)
  private String stakingBond;

  public static final String SERIALIZED_NAME_STAKING_BALANCE = "stakingBalance";
  @SerializedName(SERIALIZED_NAME_STAKING_BALANCE)
  private String stakingBalance;

  public static final String SERIALIZED_NAME_STAKING_CAPACITY = "stakingCapacity";
  @SerializedName(SERIALIZED_NAME_STAKING_CAPACITY)
  private String stakingCapacity;

  public static final String SERIALIZED_NAME_AVAILABLE_CAPACITY = "availableCapacity";
  @SerializedName(SERIALIZED_NAME_AVAILABLE_CAPACITY)
  private String availableCapacity;

  public static final String SERIALIZED_NAME_ACTIVE = "active";
  @SerializedName(SERIALIZED_NAME_ACTIVE)
  private Boolean active;

  public static final String SERIALIZED_NAME_IS_STAKING_ALLOWED = "isStakingAllowed";
  @SerializedName(SERIALIZED_NAME_IS_STAKING_ALLOWED)
  private Boolean isStakingAllowed;

  public static final String SERIALIZED_NAME_TOTAL_STAKED = "totalStaked";
  @SerializedName(SERIALIZED_NAME_TOTAL_STAKED)
  private String totalStaked;

  public static final String SERIALIZED_NAME_EXTERNAL_STAKED = "externalStaked";
  @SerializedName(SERIALIZED_NAME_EXTERNAL_STAKED)
  private String externalStaked;

  public static final String SERIALIZED_NAME_OVER_STAKED = "overStaked";
  @SerializedName(SERIALIZED_NAME_OVER_STAKED)
  private String overStaked;

  public static final String SERIALIZED_NAME_EXTERNAL_STAKING_CAPACITY = "externalStakingCapacity";
  @SerializedName(SERIALIZED_NAME_EXTERNAL_STAKING_CAPACITY)
  private String externalStakingCapacity;

  public static final String SERIALIZED_NAME_TOTAL_DELEGATED = "totalDelegated";
  @SerializedName(SERIALIZED_NAME_TOTAL_DELEGATED)
  private String totalDelegated;

  public static final String SERIALIZED_NAME_EXTERNAL_DELEGATED = "externalDelegated";
  @SerializedName(SERIALIZED_NAME_EXTERNAL_DELEGATED)
  private String externalDelegated;

  public static final String SERIALIZED_NAME_DELEGATION_CAPACITY = "delegationCapacity";
  @SerializedName(SERIALIZED_NAME_DELEGATION_CAPACITY)
  private String delegationCapacity;

  public static final String SERIALIZED_NAME_AVAILABLE_DELEGATION_CAPACITY = "availableDelegationCapacity";
  @SerializedName(SERIALIZED_NAME_AVAILABLE_DELEGATION_CAPACITY)
  private String availableDelegationCapacity;

  public static final String SERIALIZED_NAME_EDGE_OF_BAKING_OVER_STAKING = "edgeOfBakingOverStaking";
  @SerializedName(SERIALIZED_NAME_EDGE_OF_BAKING_OVER_STAKING)
  private String edgeOfBakingOverStaking;

  public TgvalidatordXTZBaker() {
  }

  public TgvalidatordXTZBaker address(String address) {
    this.address = address;
    return this;
  }

  /**
   * Get address
   * @return address
   */
  @javax.annotation.Nullable
  public String getAddress() {
    return address;
  }

  public void setAddress(String address) {
    this.address = address;
  }


  public TgvalidatordXTZBaker stakingBond(String stakingBond) {
    this.stakingBond = stakingBond;
    return this;
  }

  /**
   * Get stakingBond
   * @return stakingBond
   */
  @javax.annotation.Nullable
  public String getStakingBond() {
    return stakingBond;
  }

  public void setStakingBond(String stakingBond) {
    this.stakingBond = stakingBond;
  }


  public TgvalidatordXTZBaker stakingBalance(String stakingBalance) {
    this.stakingBalance = stakingBalance;
    return this;
  }

  /**
   * Get stakingBalance
   * @return stakingBalance
   */
  @javax.annotation.Nullable
  public String getStakingBalance() {
    return stakingBalance;
  }

  public void setStakingBalance(String stakingBalance) {
    this.stakingBalance = stakingBalance;
  }


  public TgvalidatordXTZBaker stakingCapacity(String stakingCapacity) {
    this.stakingCapacity = stakingCapacity;
    return this;
  }

  /**
   * Get stakingCapacity
   * @return stakingCapacity
   */
  @javax.annotation.Nullable
  public String getStakingCapacity() {
    return stakingCapacity;
  }

  public void setStakingCapacity(String stakingCapacity) {
    this.stakingCapacity = stakingCapacity;
  }


  public TgvalidatordXTZBaker availableCapacity(String availableCapacity) {
    this.availableCapacity = availableCapacity;
    return this;
  }

  /**
   * Get availableCapacity
   * @return availableCapacity
   */
  @javax.annotation.Nullable
  public String getAvailableCapacity() {
    return availableCapacity;
  }

  public void setAvailableCapacity(String availableCapacity) {
    this.availableCapacity = availableCapacity;
  }


  public TgvalidatordXTZBaker active(Boolean active) {
    this.active = active;
    return this;
  }

  /**
   * Get active
   * @return active
   */
  @javax.annotation.Nullable
  public Boolean getActive() {
    return active;
  }

  public void setActive(Boolean active) {
    this.active = active;
  }


  public TgvalidatordXTZBaker isStakingAllowed(Boolean isStakingAllowed) {
    this.isStakingAllowed = isStakingAllowed;
    return this;
  }

  /**
   * Get isStakingAllowed
   * @return isStakingAllowed
   */
  @javax.annotation.Nullable
  public Boolean getIsStakingAllowed() {
    return isStakingAllowed;
  }

  public void setIsStakingAllowed(Boolean isStakingAllowed) {
    this.isStakingAllowed = isStakingAllowed;
  }


  public TgvalidatordXTZBaker totalStaked(String totalStaked) {
    this.totalStaked = totalStaked;
    return this;
  }

  /**
   * Get totalStaked
   * @return totalStaked
   */
  @javax.annotation.Nullable
  public String getTotalStaked() {
    return totalStaked;
  }

  public void setTotalStaked(String totalStaked) {
    this.totalStaked = totalStaked;
  }


  public TgvalidatordXTZBaker externalStaked(String externalStaked) {
    this.externalStaked = externalStaked;
    return this;
  }

  /**
   * Get externalStaked
   * @return externalStaked
   */
  @javax.annotation.Nullable
  public String getExternalStaked() {
    return externalStaked;
  }

  public void setExternalStaked(String externalStaked) {
    this.externalStaked = externalStaked;
  }


  public TgvalidatordXTZBaker overStaked(String overStaked) {
    this.overStaked = overStaked;
    return this;
  }

  /**
   * Get overStaked
   * @return overStaked
   */
  @javax.annotation.Nullable
  public String getOverStaked() {
    return overStaked;
  }

  public void setOverStaked(String overStaked) {
    this.overStaked = overStaked;
  }


  public TgvalidatordXTZBaker externalStakingCapacity(String externalStakingCapacity) {
    this.externalStakingCapacity = externalStakingCapacity;
    return this;
  }

  /**
   * Get externalStakingCapacity
   * @return externalStakingCapacity
   */
  @javax.annotation.Nullable
  public String getExternalStakingCapacity() {
    return externalStakingCapacity;
  }

  public void setExternalStakingCapacity(String externalStakingCapacity) {
    this.externalStakingCapacity = externalStakingCapacity;
  }


  public TgvalidatordXTZBaker totalDelegated(String totalDelegated) {
    this.totalDelegated = totalDelegated;
    return this;
  }

  /**
   * Get totalDelegated
   * @return totalDelegated
   */
  @javax.annotation.Nullable
  public String getTotalDelegated() {
    return totalDelegated;
  }

  public void setTotalDelegated(String totalDelegated) {
    this.totalDelegated = totalDelegated;
  }


  public TgvalidatordXTZBaker externalDelegated(String externalDelegated) {
    this.externalDelegated = externalDelegated;
    return this;
  }

  /**
   * Get externalDelegated
   * @return externalDelegated
   */
  @javax.annotation.Nullable
  public String getExternalDelegated() {
    return externalDelegated;
  }

  public void setExternalDelegated(String externalDelegated) {
    this.externalDelegated = externalDelegated;
  }


  public TgvalidatordXTZBaker delegationCapacity(String delegationCapacity) {
    this.delegationCapacity = delegationCapacity;
    return this;
  }

  /**
   * Get delegationCapacity
   * @return delegationCapacity
   */
  @javax.annotation.Nullable
  public String getDelegationCapacity() {
    return delegationCapacity;
  }

  public void setDelegationCapacity(String delegationCapacity) {
    this.delegationCapacity = delegationCapacity;
  }


  public TgvalidatordXTZBaker availableDelegationCapacity(String availableDelegationCapacity) {
    this.availableDelegationCapacity = availableDelegationCapacity;
    return this;
  }

  /**
   * Get availableDelegationCapacity
   * @return availableDelegationCapacity
   */
  @javax.annotation.Nullable
  public String getAvailableDelegationCapacity() {
    return availableDelegationCapacity;
  }

  public void setAvailableDelegationCapacity(String availableDelegationCapacity) {
    this.availableDelegationCapacity = availableDelegationCapacity;
  }


  public TgvalidatordXTZBaker edgeOfBakingOverStaking(String edgeOfBakingOverStaking) {
    this.edgeOfBakingOverStaking = edgeOfBakingOverStaking;
    return this;
  }

  /**
   * Get edgeOfBakingOverStaking
   * @return edgeOfBakingOverStaking
   */
  @javax.annotation.Nullable
  public String getEdgeOfBakingOverStaking() {
    return edgeOfBakingOverStaking;
  }

  public void setEdgeOfBakingOverStaking(String edgeOfBakingOverStaking) {
    this.edgeOfBakingOverStaking = edgeOfBakingOverStaking;
  }

  /**
   * A container for additional, undeclared properties.
   * This is a holder for any undeclared properties as specified with
   * the 'additionalProperties' keyword in the OAS document.
   */
  private Map<String, Object> additionalProperties;

  /**
   * Set the additional (undeclared) property with the specified name and value.
   * If the property does not already exist, create it otherwise replace it.
   *
   * @param key name of the property
   * @param value value of the property
   * @return the TgvalidatordXTZBaker instance itself
   */
  public TgvalidatordXTZBaker putAdditionalProperty(String key, Object value) {
    if (this.additionalProperties == null) {
        this.additionalProperties = new HashMap<String, Object>();
    }
    this.additionalProperties.put(key, value);
    return this;
  }

  /**
   * Return the additional (undeclared) property.
   *
   * @return a map of objects
   */
  public Map<String, Object> getAdditionalProperties() {
    return additionalProperties;
  }

  /**
   * Return the additional (undeclared) property with the specified name.
   *
   * @param key name of the property
   * @return an object
   */
  public Object getAdditionalProperty(String key) {
    if (this.additionalProperties == null) {
        return null;
    }
    return this.additionalProperties.get(key);
  }


  @Override
  public boolean equals(Object o) {
    if (this == o) {
      return true;
    }
    if (o == null || getClass() != o.getClass()) {
      return false;
    }
    TgvalidatordXTZBaker tgvalidatordXTZBaker = (TgvalidatordXTZBaker) o;
    return Objects.equals(this.address, tgvalidatordXTZBaker.address) &&
        Objects.equals(this.stakingBond, tgvalidatordXTZBaker.stakingBond) &&
        Objects.equals(this.stakingBalance, tgvalidatordXTZBaker.stakingBalance) &&
        Objects.equals(this.stakingCapacity, tgvalidatordXTZBaker.stakingCapacity) &&
        Objects.equals(this.availableCapacity, tgvalidatordXTZBaker.availableCapacity) &&
        Objects.equals(this.active, tgvalidatordXTZBaker.active) &&
        Objects.equals(this.isStakingAllowed, tgvalidatordXTZBaker.isStakingAllowed) &&
        Objects.equals(this.totalStaked, tgvalidatordXTZBaker.totalStaked) &&
        Objects.equals(this.externalStaked, tgvalidatordXTZBaker.externalStaked) &&
        Objects.equals(this.overStaked, tgvalidatordXTZBaker.overStaked) &&
        Objects.equals(this.externalStakingCapacity, tgvalidatordXTZBaker.externalStakingCapacity) &&
        Objects.equals(this.totalDelegated, tgvalidatordXTZBaker.totalDelegated) &&
        Objects.equals(this.externalDelegated, tgvalidatordXTZBaker.externalDelegated) &&
        Objects.equals(this.delegationCapacity, tgvalidatordXTZBaker.delegationCapacity) &&
        Objects.equals(this.availableDelegationCapacity, tgvalidatordXTZBaker.availableDelegationCapacity) &&
        Objects.equals(this.edgeOfBakingOverStaking, tgvalidatordXTZBaker.edgeOfBakingOverStaking)&&
        Objects.equals(this.additionalProperties, tgvalidatordXTZBaker.additionalProperties);
  }

  @Override
  public int hashCode() {
    return Objects.hash(address, stakingBond, stakingBalance, stakingCapacity, availableCapacity, active, isStakingAllowed, totalStaked, externalStaked, overStaked, externalStakingCapacity, totalDelegated, externalDelegated, delegationCapacity, availableDelegationCapacity, edgeOfBakingOverStaking, additionalProperties);
  }

  @Override
  public String toString() {
    StringBuilder sb = new StringBuilder();
    sb.append("class TgvalidatordXTZBaker {\n");
    sb.append("    address: ").append(toIndentedString(address)).append("\n");
    sb.append("    stakingBond: ").append(toIndentedString(stakingBond)).append("\n");
    sb.append("    stakingBalance: ").append(toIndentedString(stakingBalance)).append("\n");
    sb.append("    stakingCapacity: ").append(toIndentedString(stakingCapacity)).append("\n");
    sb.append("    availableCapacity: ").append(toIndentedString(availableCapacity)).append("\n");
    sb.append("    active: ").append(toIndentedString(active)).append("\n");
    sb.append("    isStakingAllowed: ").append(toIndentedString(isStakingAllowed)).append("\n");
    sb.append("    totalStaked: ").append(toIndentedString(totalStaked)).append("\n");
    sb.append("    externalStaked: ").append(toIndentedString(externalStaked)).append("\n");
    sb.append("    overStaked: ").append(toIndentedString(overStaked)).append("\n");
    sb.append("    externalStakingCapacity: ").append(toIndentedString(externalStakingCapacity)).append("\n");
    sb.append("    totalDelegated: ").append(toIndentedString(totalDelegated)).append("\n");
    sb.append("    externalDelegated: ").append(toIndentedString(externalDelegated)).append("\n");
    sb.append("    delegationCapacity: ").append(toIndentedString(delegationCapacity)).append("\n");
    sb.append("    availableDelegationCapacity: ").append(toIndentedString(availableDelegationCapacity)).append("\n");
    sb.append("    edgeOfBakingOverStaking: ").append(toIndentedString(edgeOfBakingOverStaking)).append("\n");
    sb.append("    additionalProperties: ").append(toIndentedString(additionalProperties)).append("\n");
    sb.append("}");
    return sb.toString();
  }

  /**
   * Convert the given object to string with each line indented by 4 spaces
   * (except the first line).
   */
  private String toIndentedString(Object o) {
    if (o == null) {
      return "null";
    }
    return o.toString().replace("\n", "\n    ");
  }


  public static HashSet<String> openapiFields;
  public static HashSet<String> openapiRequiredFields;

  static {
    // a set of all properties/fields (JSON key names)
    openapiFields = new HashSet<String>();
    openapiFields.add("address");
    openapiFields.add("stakingBond");
    openapiFields.add("stakingBalance");
    openapiFields.add("stakingCapacity");
    openapiFields.add("availableCapacity");
    openapiFields.add("active");
    openapiFields.add("isStakingAllowed");
    openapiFields.add("totalStaked");
    openapiFields.add("externalStaked");
    openapiFields.add("overStaked");
    openapiFields.add("externalStakingCapacity");
    openapiFields.add("totalDelegated");
    openapiFields.add("externalDelegated");
    openapiFields.add("delegationCapacity");
    openapiFields.add("availableDelegationCapacity");
    openapiFields.add("edgeOfBakingOverStaking");

    // a set of required properties/fields (JSON key names)
    openapiRequiredFields = new HashSet<String>();
  }

  /**
   * Validates the JSON Element and throws an exception if issues found
   *
   * @param jsonElement JSON Element
   * @throws IOException if the JSON Element is invalid with respect to TgvalidatordXTZBaker
   */
  public static void validateJsonElement(JsonElement jsonElement) throws IOException {
      if (jsonElement == null) {
        if (!TgvalidatordXTZBaker.openapiRequiredFields.isEmpty()) { // has required fields but JSON element is null
          throw new IllegalArgumentException(String.format("The required field(s) %s in TgvalidatordXTZBaker is not found in the empty JSON string", TgvalidatordXTZBaker.openapiRequiredFields.toString()));
        }
      }
        JsonObject jsonObj = jsonElement.getAsJsonObject();
      if ((jsonObj.get("address") != null && !jsonObj.get("address").isJsonNull()) && !jsonObj.get("address").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `address` to be a primitive type in the JSON string but got `%s`", jsonObj.get("address").toString()));
      }
      if ((jsonObj.get("stakingBond") != null && !jsonObj.get("stakingBond").isJsonNull()) && !jsonObj.get("stakingBond").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `stakingBond` to be a primitive type in the JSON string but got `%s`", jsonObj.get("stakingBond").toString()));
      }
      if ((jsonObj.get("stakingBalance") != null && !jsonObj.get("stakingBalance").isJsonNull()) && !jsonObj.get("stakingBalance").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `stakingBalance` to be a primitive type in the JSON string but got `%s`", jsonObj.get("stakingBalance").toString()));
      }
      if ((jsonObj.get("stakingCapacity") != null && !jsonObj.get("stakingCapacity").isJsonNull()) && !jsonObj.get("stakingCapacity").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `stakingCapacity` to be a primitive type in the JSON string but got `%s`", jsonObj.get("stakingCapacity").toString()));
      }
      if ((jsonObj.get("availableCapacity") != null && !jsonObj.get("availableCapacity").isJsonNull()) && !jsonObj.get("availableCapacity").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `availableCapacity` to be a primitive type in the JSON string but got `%s`", jsonObj.get("availableCapacity").toString()));
      }
      if ((jsonObj.get("totalStaked") != null && !jsonObj.get("totalStaked").isJsonNull()) && !jsonObj.get("totalStaked").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `totalStaked` to be a primitive type in the JSON string but got `%s`", jsonObj.get("totalStaked").toString()));
      }
      if ((jsonObj.get("externalStaked") != null && !jsonObj.get("externalStaked").isJsonNull()) && !jsonObj.get("externalStaked").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `externalStaked` to be a primitive type in the JSON string but got `%s`", jsonObj.get("externalStaked").toString()));
      }
      if ((jsonObj.get("overStaked") != null && !jsonObj.get("overStaked").isJsonNull()) && !jsonObj.get("overStaked").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `overStaked` to be a primitive type in the JSON string but got `%s`", jsonObj.get("overStaked").toString()));
      }
      if ((jsonObj.get("externalStakingCapacity") != null && !jsonObj.get("externalStakingCapacity").isJsonNull()) && !jsonObj.get("externalStakingCapacity").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `externalStakingCapacity` to be a primitive type in the JSON string but got `%s`", jsonObj.get("externalStakingCapacity").toString()));
      }
      if ((jsonObj.get("totalDelegated") != null && !jsonObj.get("totalDelegated").isJsonNull()) && !jsonObj.get("totalDelegated").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `totalDelegated` to be a primitive type in the JSON string but got `%s`", jsonObj.get("totalDelegated").toString()));
      }
      if ((jsonObj.get("externalDelegated") != null && !jsonObj.get("externalDelegated").isJsonNull()) && !jsonObj.get("externalDelegated").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `externalDelegated` to be a primitive type in the JSON string but got `%s`", jsonObj.get("externalDelegated").toString()));
      }
      if ((jsonObj.get("delegationCapacity") != null && !jsonObj.get("delegationCapacity").isJsonNull()) && !jsonObj.get("delegationCapacity").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `delegationCapacity` to be a primitive type in the JSON string but got `%s`", jsonObj.get("delegationCapacity").toString()));
      }
      if ((jsonObj.get("availableDelegationCapacity") != null && !jsonObj.get("availableDelegationCapacity").isJsonNull()) && !jsonObj.get("availableDelegationCapacity").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `availableDelegationCapacity` to be a primitive type in the JSON string but got `%s`", jsonObj.get("availableDelegationCapacity").toString()));
      }
      if ((jsonObj.get("edgeOfBakingOverStaking") != null && !jsonObj.get("edgeOfBakingOverStaking").isJsonNull()) && !jsonObj.get("edgeOfBakingOverStaking").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `edgeOfBakingOverStaking` to be a primitive type in the JSON string but got `%s`", jsonObj.get("edgeOfBakingOverStaking").toString()));
      }
  }

  public static class CustomTypeAdapterFactory implements TypeAdapterFactory {
    @SuppressWarnings("unchecked")
    @Override
    public <T> TypeAdapter<T> create(Gson gson, TypeToken<T> type) {
       if (!TgvalidatordXTZBaker.class.isAssignableFrom(type.getRawType())) {
         return null; // this class only serializes 'TgvalidatordXTZBaker' and its subtypes
       }
       final TypeAdapter<JsonElement> elementAdapter = gson.getAdapter(JsonElement.class);
       final TypeAdapter<TgvalidatordXTZBaker> thisAdapter
                        = gson.getDelegateAdapter(this, TypeToken.get(TgvalidatordXTZBaker.class));

       return (TypeAdapter<T>) new TypeAdapter<TgvalidatordXTZBaker>() {
           @Override
           public void write(JsonWriter out, TgvalidatordXTZBaker value) throws IOException {
             JsonObject obj = thisAdapter.toJsonTree(value).getAsJsonObject();
             obj.remove("additionalProperties");
             // serialize additional properties
             if (value.getAdditionalProperties() != null) {
               for (Map.Entry<String, Object> entry : value.getAdditionalProperties().entrySet()) {
                 if (entry.getValue() instanceof String)
                   obj.addProperty(entry.getKey(), (String) entry.getValue());
                 else if (entry.getValue() instanceof Number)
                   obj.addProperty(entry.getKey(), (Number) entry.getValue());
                 else if (entry.getValue() instanceof Boolean)
                   obj.addProperty(entry.getKey(), (Boolean) entry.getValue());
                 else if (entry.getValue() instanceof Character)
                   obj.addProperty(entry.getKey(), (Character) entry.getValue());
                 else {
                   JsonElement jsonElement = gson.toJsonTree(entry.getValue());
                   if (jsonElement.isJsonArray()) {
                     obj.add(entry.getKey(), jsonElement.getAsJsonArray());
                   } else {
                     obj.add(entry.getKey(), jsonElement.getAsJsonObject());
                   }
                 }
               }
             }
             elementAdapter.write(out, obj);
           }

           @Override
           public TgvalidatordXTZBaker read(JsonReader in) throws IOException {
             JsonElement jsonElement = elementAdapter.read(in);
             validateJsonElement(jsonElement);
             JsonObject jsonObj = jsonElement.getAsJsonObject();
             // store additional fields in the deserialized instance
             TgvalidatordXTZBaker instance = thisAdapter.fromJsonTree(jsonObj);
             for (Map.Entry<String, JsonElement> entry : jsonObj.entrySet()) {
               if (!openapiFields.contains(entry.getKey())) {
                 if (entry.getValue().isJsonPrimitive()) { // primitive type
                   if (entry.getValue().getAsJsonPrimitive().isString())
                     instance.putAdditionalProperty(entry.getKey(), entry.getValue().getAsString());
                   else if (entry.getValue().getAsJsonPrimitive().isNumber())
                     instance.putAdditionalProperty(entry.getKey(), entry.getValue().getAsNumber());
                   else if (entry.getValue().getAsJsonPrimitive().isBoolean())
                     instance.putAdditionalProperty(entry.getKey(), entry.getValue().getAsBoolean());
                   else
                     throw new IllegalArgumentException(String.format("The field `%s` has unknown primitive type. Value: %s", entry.getKey(), entry.getValue().toString()));
                 } else if (entry.getValue().isJsonArray()) {
                     instance.putAdditionalProperty(entry.getKey(), gson.fromJson(entry.getValue(), List.class));
                 } else { // JSON object
                     instance.putAdditionalProperty(entry.getKey(), gson.fromJson(entry.getValue(), HashMap.class));
                 }
               }
             }
             return instance;
           }

       }.nullSafe();
    }
  }

  /**
   * Create an instance of TgvalidatordXTZBaker given an JSON string
   *
   * @param jsonString JSON string
   * @return An instance of TgvalidatordXTZBaker
   * @throws IOException if the JSON string is invalid with respect to TgvalidatordXTZBaker
   */
  public static TgvalidatordXTZBaker fromJson(String jsonString) throws IOException {
    return JSON.getGson().fromJson(jsonString, TgvalidatordXTZBaker.class);
  }

  /**
   * Convert an instance of TgvalidatordXTZBaker to an JSON string
   *
   * @return JSON string
   */
  public String toJson() {
    return JSON.getGson().toJson(this);
  }
}

