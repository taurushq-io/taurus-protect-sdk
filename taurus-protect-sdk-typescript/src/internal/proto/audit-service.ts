// Code generated by protoc-gen-ts_proto. DO NOT EDIT.
// versions:
//   protoc-gen-ts_proto  v1.181.2
//   protoc               v6.33.4
// source: audit-service.proto

/* eslint-disable */
import Long from "long";
import _m0 from "protobufjs/minimal";
import { AuditTrail } from "./audit";
import { RequestCursor, ResponseCursor } from "./cursor";
import { Timestamp } from "./google/protobuf/timestamp";
import { StringValue } from "./google/protobuf/wrappers";

export const protobufPackage = "tgvalidatord";

export interface GetAuditTrailsRequest {
  externalUserId: string | undefined;
  entities: string[];
  actions: string[];
  creationDateFrom: Date | undefined;
  creationDateTo: Date | undefined;
  cursor: RequestCursor | undefined;
  sorting: GetAuditTrailsRequest_Sorting | undefined;
}

export interface GetAuditTrailsRequest_Sorting {
  /**
   * The columns to order by.
   * Can be `CreationDate` (default)
   */
  sortBy: string[];
  /** Can be `DESC` (default), `ASC` */
  sortOrder: string;
}

export interface GetAuditTrailsReply {
  result: AuditTrail[];
  cursor: ResponseCursor | undefined;
}

export interface ExportAuditTrailsRequest {
  externalUserId: string | undefined;
  entities: string[];
  actions: string[];
  creationDateFrom: Date | undefined;
  creationDateTo: Date | undefined;
  format: string;
}

export interface ExportAuditTrailsReply {
  result: string;
  totalItems: number;
}

function createBaseGetAuditTrailsRequest(): GetAuditTrailsRequest {
  return {
    externalUserId: undefined,
    entities: [],
    actions: [],
    creationDateFrom: undefined,
    creationDateTo: undefined,
    cursor: undefined,
    sorting: undefined,
  };
}

export const GetAuditTrailsRequest = {
  encode(message: GetAuditTrailsRequest, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.externalUserId !== undefined) {
      StringValue.encode({ value: message.externalUserId! }, writer.uint32(10).fork()).ldelim();
    }
    for (const v of message.entities) {
      writer.uint32(18).string(v!);
    }
    for (const v of message.actions) {
      writer.uint32(26).string(v!);
    }
    if (message.creationDateFrom !== undefined) {
      Timestamp.encode(toTimestamp(message.creationDateFrom), writer.uint32(34).fork()).ldelim();
    }
    if (message.creationDateTo !== undefined) {
      Timestamp.encode(toTimestamp(message.creationDateTo), writer.uint32(42).fork()).ldelim();
    }
    if (message.cursor !== undefined) {
      RequestCursor.encode(message.cursor, writer.uint32(50).fork()).ldelim();
    }
    if (message.sorting !== undefined) {
      GetAuditTrailsRequest_Sorting.encode(message.sorting, writer.uint32(58).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): GetAuditTrailsRequest {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetAuditTrailsRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.externalUserId = StringValue.decode(reader, reader.uint32()).value;
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.entities.push(reader.string());
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.actions.push(reader.string());
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.creationDateFrom = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.creationDateTo = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        case 6:
          if (tag !== 50) {
            break;
          }

          message.cursor = RequestCursor.decode(reader, reader.uint32());
          continue;
        case 7:
          if (tag !== 58) {
            break;
          }

          message.sorting = GetAuditTrailsRequest_Sorting.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetAuditTrailsRequest {
    return {
      externalUserId: isSet(object.externalUserId) ? String(object.externalUserId) : undefined,
      entities: globalThis.Array.isArray(object?.entities) ? object.entities.map((e: any) => globalThis.String(e)) : [],
      actions: globalThis.Array.isArray(object?.actions) ? object.actions.map((e: any) => globalThis.String(e)) : [],
      creationDateFrom: isSet(object.creationDateFrom) ? fromJsonTimestamp(object.creationDateFrom) : undefined,
      creationDateTo: isSet(object.creationDateTo) ? fromJsonTimestamp(object.creationDateTo) : undefined,
      cursor: isSet(object.cursor) ? RequestCursor.fromJSON(object.cursor) : undefined,
      sorting: isSet(object.sorting) ? GetAuditTrailsRequest_Sorting.fromJSON(object.sorting) : undefined,
    };
  },

  toJSON(message: GetAuditTrailsRequest): unknown {
    const obj: any = {};
    if (message.externalUserId !== undefined) {
      obj.externalUserId = message.externalUserId;
    }
    if (message.entities?.length) {
      obj.entities = message.entities;
    }
    if (message.actions?.length) {
      obj.actions = message.actions;
    }
    if (message.creationDateFrom !== undefined) {
      obj.creationDateFrom = message.creationDateFrom.toISOString();
    }
    if (message.creationDateTo !== undefined) {
      obj.creationDateTo = message.creationDateTo.toISOString();
    }
    if (message.cursor !== undefined) {
      obj.cursor = RequestCursor.toJSON(message.cursor);
    }
    if (message.sorting !== undefined) {
      obj.sorting = GetAuditTrailsRequest_Sorting.toJSON(message.sorting);
    }
    return obj;
  },

  create(base?: DeepPartial<GetAuditTrailsRequest>): GetAuditTrailsRequest {
    return GetAuditTrailsRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<GetAuditTrailsRequest>): GetAuditTrailsRequest {
    const message = createBaseGetAuditTrailsRequest();
    message.externalUserId = object.externalUserId ?? undefined;
    message.entities = object.entities?.map((e) => e) || [];
    message.actions = object.actions?.map((e) => e) || [];
    message.creationDateFrom = object.creationDateFrom ?? undefined;
    message.creationDateTo = object.creationDateTo ?? undefined;
    message.cursor = (object.cursor !== undefined && object.cursor !== null)
      ? RequestCursor.fromPartial(object.cursor)
      : undefined;
    message.sorting = (object.sorting !== undefined && object.sorting !== null)
      ? GetAuditTrailsRequest_Sorting.fromPartial(object.sorting)
      : undefined;
    return message;
  },
};

function createBaseGetAuditTrailsRequest_Sorting(): GetAuditTrailsRequest_Sorting {
  return { sortBy: [], sortOrder: "" };
}

export const GetAuditTrailsRequest_Sorting = {
  encode(message: GetAuditTrailsRequest_Sorting, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    for (const v of message.sortBy) {
      writer.uint32(10).string(v!);
    }
    if (message.sortOrder !== "") {
      writer.uint32(18).string(message.sortOrder);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): GetAuditTrailsRequest_Sorting {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetAuditTrailsRequest_Sorting();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.sortBy.push(reader.string());
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.sortOrder = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetAuditTrailsRequest_Sorting {
    return {
      sortBy: globalThis.Array.isArray(object?.sortBy) ? object.sortBy.map((e: any) => globalThis.String(e)) : [],
      sortOrder: isSet(object.sortOrder) ? globalThis.String(object.sortOrder) : "",
    };
  },

  toJSON(message: GetAuditTrailsRequest_Sorting): unknown {
    const obj: any = {};
    if (message.sortBy?.length) {
      obj.sortBy = message.sortBy;
    }
    if (message.sortOrder !== "") {
      obj.sortOrder = message.sortOrder;
    }
    return obj;
  },

  create(base?: DeepPartial<GetAuditTrailsRequest_Sorting>): GetAuditTrailsRequest_Sorting {
    return GetAuditTrailsRequest_Sorting.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<GetAuditTrailsRequest_Sorting>): GetAuditTrailsRequest_Sorting {
    const message = createBaseGetAuditTrailsRequest_Sorting();
    message.sortBy = object.sortBy?.map((e) => e) || [];
    message.sortOrder = object.sortOrder ?? "";
    return message;
  },
};

function createBaseGetAuditTrailsReply(): GetAuditTrailsReply {
  return { result: [], cursor: undefined };
}

export const GetAuditTrailsReply = {
  encode(message: GetAuditTrailsReply, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    for (const v of message.result) {
      AuditTrail.encode(v!, writer.uint32(10).fork()).ldelim();
    }
    if (message.cursor !== undefined) {
      ResponseCursor.encode(message.cursor, writer.uint32(18).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): GetAuditTrailsReply {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetAuditTrailsReply();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.result.push(AuditTrail.decode(reader, reader.uint32()));
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.cursor = ResponseCursor.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetAuditTrailsReply {
    return {
      result: globalThis.Array.isArray(object?.result) ? object.result.map((e: any) => AuditTrail.fromJSON(e)) : [],
      cursor: isSet(object.cursor) ? ResponseCursor.fromJSON(object.cursor) : undefined,
    };
  },

  toJSON(message: GetAuditTrailsReply): unknown {
    const obj: any = {};
    if (message.result?.length) {
      obj.result = message.result.map((e) => AuditTrail.toJSON(e));
    }
    if (message.cursor !== undefined) {
      obj.cursor = ResponseCursor.toJSON(message.cursor);
    }
    return obj;
  },

  create(base?: DeepPartial<GetAuditTrailsReply>): GetAuditTrailsReply {
    return GetAuditTrailsReply.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<GetAuditTrailsReply>): GetAuditTrailsReply {
    const message = createBaseGetAuditTrailsReply();
    message.result = object.result?.map((e) => AuditTrail.fromPartial(e)) || [];
    message.cursor = (object.cursor !== undefined && object.cursor !== null)
      ? ResponseCursor.fromPartial(object.cursor)
      : undefined;
    return message;
  },
};

function createBaseExportAuditTrailsRequest(): ExportAuditTrailsRequest {
  return {
    externalUserId: undefined,
    entities: [],
    actions: [],
    creationDateFrom: undefined,
    creationDateTo: undefined,
    format: "",
  };
}

export const ExportAuditTrailsRequest = {
  encode(message: ExportAuditTrailsRequest, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.externalUserId !== undefined) {
      StringValue.encode({ value: message.externalUserId! }, writer.uint32(10).fork()).ldelim();
    }
    for (const v of message.entities) {
      writer.uint32(18).string(v!);
    }
    for (const v of message.actions) {
      writer.uint32(26).string(v!);
    }
    if (message.creationDateFrom !== undefined) {
      Timestamp.encode(toTimestamp(message.creationDateFrom), writer.uint32(34).fork()).ldelim();
    }
    if (message.creationDateTo !== undefined) {
      Timestamp.encode(toTimestamp(message.creationDateTo), writer.uint32(42).fork()).ldelim();
    }
    if (message.format !== "") {
      writer.uint32(50).string(message.format);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): ExportAuditTrailsRequest {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseExportAuditTrailsRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.externalUserId = StringValue.decode(reader, reader.uint32()).value;
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.entities.push(reader.string());
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.actions.push(reader.string());
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.creationDateFrom = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.creationDateTo = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        case 6:
          if (tag !== 50) {
            break;
          }

          message.format = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ExportAuditTrailsRequest {
    return {
      externalUserId: isSet(object.externalUserId) ? String(object.externalUserId) : undefined,
      entities: globalThis.Array.isArray(object?.entities) ? object.entities.map((e: any) => globalThis.String(e)) : [],
      actions: globalThis.Array.isArray(object?.actions) ? object.actions.map((e: any) => globalThis.String(e)) : [],
      creationDateFrom: isSet(object.creationDateFrom) ? fromJsonTimestamp(object.creationDateFrom) : undefined,
      creationDateTo: isSet(object.creationDateTo) ? fromJsonTimestamp(object.creationDateTo) : undefined,
      format: isSet(object.format) ? globalThis.String(object.format) : "",
    };
  },

  toJSON(message: ExportAuditTrailsRequest): unknown {
    const obj: any = {};
    if (message.externalUserId !== undefined) {
      obj.externalUserId = message.externalUserId;
    }
    if (message.entities?.length) {
      obj.entities = message.entities;
    }
    if (message.actions?.length) {
      obj.actions = message.actions;
    }
    if (message.creationDateFrom !== undefined) {
      obj.creationDateFrom = message.creationDateFrom.toISOString();
    }
    if (message.creationDateTo !== undefined) {
      obj.creationDateTo = message.creationDateTo.toISOString();
    }
    if (message.format !== "") {
      obj.format = message.format;
    }
    return obj;
  },

  create(base?: DeepPartial<ExportAuditTrailsRequest>): ExportAuditTrailsRequest {
    return ExportAuditTrailsRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ExportAuditTrailsRequest>): ExportAuditTrailsRequest {
    const message = createBaseExportAuditTrailsRequest();
    message.externalUserId = object.externalUserId ?? undefined;
    message.entities = object.entities?.map((e) => e) || [];
    message.actions = object.actions?.map((e) => e) || [];
    message.creationDateFrom = object.creationDateFrom ?? undefined;
    message.creationDateTo = object.creationDateTo ?? undefined;
    message.format = object.format ?? "";
    return message;
  },
};

function createBaseExportAuditTrailsReply(): ExportAuditTrailsReply {
  return { result: "", totalItems: 0 };
}

export const ExportAuditTrailsReply = {
  encode(message: ExportAuditTrailsReply, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.result !== "") {
      writer.uint32(10).string(message.result);
    }
    if (message.totalItems !== 0) {
      writer.uint32(16).uint64(message.totalItems);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): ExportAuditTrailsReply {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseExportAuditTrailsReply();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.result = reader.string();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.totalItems = longToNumber(reader.uint64() as Long);
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ExportAuditTrailsReply {
    return {
      result: isSet(object.result) ? globalThis.String(object.result) : "",
      totalItems: isSet(object.totalItems) ? globalThis.Number(object.totalItems) : 0,
    };
  },

  toJSON(message: ExportAuditTrailsReply): unknown {
    const obj: any = {};
    if (message.result !== "") {
      obj.result = message.result;
    }
    if (message.totalItems !== 0) {
      obj.totalItems = Math.round(message.totalItems);
    }
    return obj;
  },

  create(base?: DeepPartial<ExportAuditTrailsReply>): ExportAuditTrailsReply {
    return ExportAuditTrailsReply.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ExportAuditTrailsReply>): ExportAuditTrailsReply {
    const message = createBaseExportAuditTrailsReply();
    message.result = object.result ?? "";
    message.totalItems = object.totalItems ?? 0;
    return message;
  },
};

export interface AuditService {
  GetAuditTrails(request: GetAuditTrailsRequest): Promise<GetAuditTrailsReply>;
  ExportAuditTrails(request: ExportAuditTrailsRequest): Promise<ExportAuditTrailsReply>;
}

export const AuditServiceServiceName = "tgvalidatord.AuditService";
export class AuditServiceClientImpl implements AuditService {
  private readonly rpc: Rpc;
  private readonly service: string;
  constructor(rpc: Rpc, opts?: { service?: string }) {
    this.service = opts?.service || AuditServiceServiceName;
    this.rpc = rpc;
    this.GetAuditTrails = this.GetAuditTrails.bind(this);
    this.ExportAuditTrails = this.ExportAuditTrails.bind(this);
  }
  GetAuditTrails(request: GetAuditTrailsRequest): Promise<GetAuditTrailsReply> {
    const data = GetAuditTrailsRequest.encode(request).finish();
    const promise = this.rpc.request(this.service, "GetAuditTrails", data);
    return promise.then((data) => GetAuditTrailsReply.decode(_m0.Reader.create(data)));
  }

  ExportAuditTrails(request: ExportAuditTrailsRequest): Promise<ExportAuditTrailsReply> {
    const data = ExportAuditTrailsRequest.encode(request).finish();
    const promise = this.rpc.request(this.service, "ExportAuditTrails", data);
    return promise.then((data) => ExportAuditTrailsReply.decode(_m0.Reader.create(data)));
  }
}

interface Rpc {
  request(service: string, method: string, data: Uint8Array): Promise<Uint8Array>;
}

type Builtin = Date | Function | Uint8Array | string | number | boolean | undefined;

export type DeepPartial<T> = T extends Builtin ? T
  : T extends globalThis.Array<infer U> ? globalThis.Array<DeepPartial<U>>
  : T extends ReadonlyArray<infer U> ? ReadonlyArray<DeepPartial<U>>
  : T extends {} ? { [K in keyof T]?: DeepPartial<T[K]> }
  : Partial<T>;

function toTimestamp(date: Date): Timestamp {
  const seconds = Math.trunc(date.getTime() / 1_000);
  const nanos = (date.getTime() % 1_000) * 1_000_000;
  return { seconds, nanos };
}

function fromTimestamp(t: Timestamp): Date {
  let millis = (t.seconds || 0) * 1_000;
  millis += (t.nanos || 0) / 1_000_000;
  return new globalThis.Date(millis);
}

function fromJsonTimestamp(o: any): Date {
  if (o instanceof globalThis.Date) {
    return o;
  } else if (typeof o === "string") {
    return new globalThis.Date(o);
  } else {
    return fromTimestamp(Timestamp.fromJSON(o));
  }
}

function longToNumber(long: Long): number {
  if (long.gt(globalThis.Number.MAX_SAFE_INTEGER)) {
    throw new globalThis.Error("Value is larger than Number.MAX_SAFE_INTEGER");
  }
  if (long.lt(globalThis.Number.MIN_SAFE_INTEGER)) {
    throw new globalThis.Error("Value is smaller than Number.MIN_SAFE_INTEGER");
  }
  return long.toNumber();
}

if (_m0.util.Long !== Long) {
  _m0.util.Long = Long as any;
  _m0.configure();
}

function isSet(value: any): boolean {
  return value !== null && value !== undefined;
}
