# coding: utf-8

"""
    Taurus-PROTECT APIs

    Taurus-PROTECT APIs description

    The version of the OpenAPI document: 1.0
    Generated by OpenAPI Generator (https://openapi-generator.tech)

    Do not edit the class manually.
"""  # noqa: E501

import warnings
from pydantic import validate_call, Field, StrictFloat, StrictStr, StrictInt
from typing import Any, Dict, List, Optional, Tuple, Union
from typing_extensions import Annotated

from datetime import datetime
from pydantic import Field, StrictBool, StrictBytes, StrictStr, field_validator
from typing import Any, Dict, List, Optional, Union
from typing_extensions import Annotated
from taurus_protect._internal.openapi.models.api_http_body import ApiHttpBody
from taurus_protect._internal.openapi.models.tgvalidatord_btc_sign_message_reply import TgvalidatordBTCSignMessageReply
from taurus_protect._internal.openapi.models.tgvalidatord_compute_addresses_signature_reply import TgvalidatordComputeAddressesSignatureReply
from taurus_protect._internal.openapi.models.tgvalidatord_compute_addresses_signature_request import TgvalidatordComputeAddressesSignatureRequest
from taurus_protect._internal.openapi.models.tgvalidatord_create_address_attributes_reply import TgvalidatordCreateAddressAttributesReply
from taurus_protect._internal.openapi.models.tgvalidatord_create_address_reply import TgvalidatordCreateAddressReply
from taurus_protect._internal.openapi.models.tgvalidatord_create_address_request import TgvalidatordCreateAddressRequest
from taurus_protect._internal.openapi.models.tgvalidatord_create_addresses_reply import TgvalidatordCreateAddressesReply
from taurus_protect._internal.openapi.models.tgvalidatord_create_addresses_request import TgvalidatordCreateAddressesRequest
from taurus_protect._internal.openapi.models.tgvalidatord_eth_sign_message_reply import TgvalidatordETHSignMessageReply
from taurus_protect._internal.openapi.models.tgvalidatord_export_address_balance_history_reply import TgvalidatordExportAddressBalanceHistoryReply
from taurus_protect._internal.openapi.models.tgvalidatord_export_addresses_reply import TgvalidatordExportAddressesReply
from taurus_protect._internal.openapi.models.tgvalidatord_get_address_balance_history_reply import TgvalidatordGetAddressBalanceHistoryReply
from taurus_protect._internal.openapi.models.tgvalidatord_get_address_proof_of_reserve_reply import TgvalidatordGetAddressProofOfReserveReply
from taurus_protect._internal.openapi.models.tgvalidatord_get_address_reply import TgvalidatordGetAddressReply
from taurus_protect._internal.openapi.models.tgvalidatord_get_address_tokens_reply import TgvalidatordGetAddressTokensReply
from taurus_protect._internal.openapi.models.tgvalidatord_get_address_utxos_reply import TgvalidatordGetAddressUTXOsReply
from taurus_protect._internal.openapi.models.tgvalidatord_get_addresses_proof_of_reserve_reply import TgvalidatordGetAddressesProofOfReserveReply
from taurus_protect._internal.openapi.models.tgvalidatord_get_addresses_reply import TgvalidatordGetAddressesReply
from taurus_protect._internal.openapi.models.tgvalidatord_get_addresses_status_reply import TgvalidatordGetAddressesStatusReply
from taurus_protect._internal.openapi.models.tgvalidatord_get_light_addresses_reply import TgvalidatordGetLightAddressesReply
from taurus_protect._internal.openapi.models.wallet_service_create_address_attributes_body import WalletServiceCreateAddressAttributesBody

from taurus_protect._internal.openapi.api_client import ApiClient, RequestSerialized
from taurus_protect._internal.openapi.api_response import ApiResponse
from taurus_protect._internal.openapi.rest import RESTResponseType


class AddressesApi:
    """NOTE: This class is auto generated by OpenAPI Generator
    Ref: https://openapi-generator.tech

    Do not edit the class manually.
    """

    def __init__(self, api_client=None) -> None:
        if api_client is None:
            api_client = ApiClient.get_default()
        self.api_client = api_client


    @validate_call
    def report_service_swift_mt535_balance_report(
        self,
        blockchain: Optional[StrictStr] = None,
        blockchainaddress: Optional[StrictStr] = None,
        for_date: Optional[datetime] = None,
        network: Optional[StrictStr] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiHttpBody:
        """Get the balance of the address

        Returns the MT535 statement of holdings for the address. By default, the response is a JSON, with the swift content formatted in base64. To get the plain swift as a response, use the request header **'Accept: text/plain'**. A date can be passed to get the balance at a particular date. If no date is given, the last closing date is used.

        :param blockchain:
        :type blockchain: str
        :param blockchainaddress:
        :type blockchainaddress: str
        :param for_date:
        :type for_date: datetime
        :param network:
        :type network: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._report_service_swift_mt535_balance_report_serialize(
            blockchain=blockchain,
            blockchainaddress=blockchainaddress,
            for_date=for_date,
            network=network,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "ApiHttpBody",
            '400': "object",
            '401': "object",
            '403': "object",
            '404': "object",
            '500': "object",
            '503': "object",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def report_service_swift_mt535_balance_report_with_http_info(
        self,
        blockchain: Optional[StrictStr] = None,
        blockchainaddress: Optional[StrictStr] = None,
        for_date: Optional[datetime] = None,
        network: Optional[StrictStr] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[ApiHttpBody]:
        """Get the balance of the address

        Returns the MT535 statement of holdings for the address. By default, the response is a JSON, with the swift content formatted in base64. To get the plain swift as a response, use the request header **'Accept: text/plain'**. A date can be passed to get the balance at a particular date. If no date is given, the last closing date is used.

        :param blockchain:
        :type blockchain: str
        :param blockchainaddress:
        :type blockchainaddress: str
        :param for_date:
        :type for_date: datetime
        :param network:
        :type network: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._report_service_swift_mt535_balance_report_serialize(
            blockchain=blockchain,
            blockchainaddress=blockchainaddress,
            for_date=for_date,
            network=network,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "ApiHttpBody",
            '400': "object",
            '401': "object",
            '403': "object",
            '404': "object",
            '500': "object",
            '503': "object",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def report_service_swift_mt535_balance_report_without_preload_content(
        self,
        blockchain: Optional[StrictStr] = None,
        blockchainaddress: Optional[StrictStr] = None,
        for_date: Optional[datetime] = None,
        network: Optional[StrictStr] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """Get the balance of the address

        Returns the MT535 statement of holdings for the address. By default, the response is a JSON, with the swift content formatted in base64. To get the plain swift as a response, use the request header **'Accept: text/plain'**. A date can be passed to get the balance at a particular date. If no date is given, the last closing date is used.

        :param blockchain:
        :type blockchain: str
        :param blockchainaddress:
        :type blockchainaddress: str
        :param for_date:
        :type for_date: datetime
        :param network:
        :type network: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._report_service_swift_mt535_balance_report_serialize(
            blockchain=blockchain,
            blockchainaddress=blockchainaddress,
            for_date=for_date,
            network=network,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "ApiHttpBody",
            '400': "object",
            '401': "object",
            '403': "object",
            '404': "object",
            '500': "object",
            '503': "object",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _report_service_swift_mt535_balance_report_serialize(
        self,
        blockchain,
        blockchainaddress,
        for_date,
        network,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        # process the query parameters
        if blockchain is not None:
            
            _query_params.append(('blockchain', blockchain))
            
        if blockchainaddress is not None:
            
            _query_params.append(('blockchainaddress', blockchainaddress))
            
        if for_date is not None:
            if isinstance(for_date, datetime):
                _query_params.append(
                    (
                        'forDate',
                        for_date.strftime(
                            self.api_client.configuration.datetime_format
                        )
                    )
                )
            else:
                _query_params.append(('forDate', for_date))
            
        if network is not None:
            
            _query_params.append(('network', network))
            
        # process the header parameters
        # process the form parameters
        # process the body parameter


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json'
                ]
            )


        # authentication setting
        _auth_settings: List[str] = [
            'ApiKeyTPV1'
        ]

        return self.api_client.param_serialize(
            method='GET',
            resource_path='/api/rest/v1/reports/mt535',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def report_service_swift_mt536_transactions_report(
        self,
        blockchain: Optional[StrictStr] = None,
        blockchainaddress: Optional[StrictStr] = None,
        for_date: Optional[datetime] = None,
        network: Optional[StrictStr] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiHttpBody:
        """Get the daily transactions of the address

        Returns the MT536 statement of transactions for the address. By default, the response is a JSON, with the swift content formatted in base64. To get the plain swift as a response, use the request header **'Accept: text/plain'**. A date can be passed to get the transactions of a particular day. If no date is given, the last day is used.

        :param blockchain:
        :type blockchain: str
        :param blockchainaddress:
        :type blockchainaddress: str
        :param for_date:
        :type for_date: datetime
        :param network:
        :type network: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._report_service_swift_mt536_transactions_report_serialize(
            blockchain=blockchain,
            blockchainaddress=blockchainaddress,
            for_date=for_date,
            network=network,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "ApiHttpBody",
            '400': "object",
            '401': "object",
            '403': "object",
            '404': "object",
            '500': "object",
            '503': "object",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def report_service_swift_mt536_transactions_report_with_http_info(
        self,
        blockchain: Optional[StrictStr] = None,
        blockchainaddress: Optional[StrictStr] = None,
        for_date: Optional[datetime] = None,
        network: Optional[StrictStr] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[ApiHttpBody]:
        """Get the daily transactions of the address

        Returns the MT536 statement of transactions for the address. By default, the response is a JSON, with the swift content formatted in base64. To get the plain swift as a response, use the request header **'Accept: text/plain'**. A date can be passed to get the transactions of a particular day. If no date is given, the last day is used.

        :param blockchain:
        :type blockchain: str
        :param blockchainaddress:
        :type blockchainaddress: str
        :param for_date:
        :type for_date: datetime
        :param network:
        :type network: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._report_service_swift_mt536_transactions_report_serialize(
            blockchain=blockchain,
            blockchainaddress=blockchainaddress,
            for_date=for_date,
            network=network,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "ApiHttpBody",
            '400': "object",
            '401': "object",
            '403': "object",
            '404': "object",
            '500': "object",
            '503': "object",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def report_service_swift_mt536_transactions_report_without_preload_content(
        self,
        blockchain: Optional[StrictStr] = None,
        blockchainaddress: Optional[StrictStr] = None,
        for_date: Optional[datetime] = None,
        network: Optional[StrictStr] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """Get the daily transactions of the address

        Returns the MT536 statement of transactions for the address. By default, the response is a JSON, with the swift content formatted in base64. To get the plain swift as a response, use the request header **'Accept: text/plain'**. A date can be passed to get the transactions of a particular day. If no date is given, the last day is used.

        :param blockchain:
        :type blockchain: str
        :param blockchainaddress:
        :type blockchainaddress: str
        :param for_date:
        :type for_date: datetime
        :param network:
        :type network: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._report_service_swift_mt536_transactions_report_serialize(
            blockchain=blockchain,
            blockchainaddress=blockchainaddress,
            for_date=for_date,
            network=network,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "ApiHttpBody",
            '400': "object",
            '401': "object",
            '403': "object",
            '404': "object",
            '500': "object",
            '503': "object",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _report_service_swift_mt536_transactions_report_serialize(
        self,
        blockchain,
        blockchainaddress,
        for_date,
        network,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        # process the query parameters
        if blockchain is not None:
            
            _query_params.append(('blockchain', blockchain))
            
        if blockchainaddress is not None:
            
            _query_params.append(('blockchainaddress', blockchainaddress))
            
        if for_date is not None:
            if isinstance(for_date, datetime):
                _query_params.append(
                    (
                        'forDate',
                        for_date.strftime(
                            self.api_client.configuration.datetime_format
                        )
                    )
                )
            else:
                _query_params.append(('forDate', for_date))
            
        if network is not None:
            
            _query_params.append(('network', network))
            
        # process the header parameters
        # process the form parameters
        # process the body parameter


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json'
                ]
            )


        # authentication setting
        _auth_settings: List[str] = [
            'ApiKeyTPV1'
        ]

        return self.api_client.param_serialize(
            method='GET',
            resource_path='/api/rest/v1/reports/mt536',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def wallet_service_btc_sign_message(
        self,
        address_id: StrictStr,
        message: Optional[StrictStr] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> TgvalidatordBTCSignMessageReply:
        """Calculate a BTC specific signature of a message

        This endpoint returns a BTC specific signature from a given message and address as input.

        :param address_id: (required)
        :type address_id: str
        :param message:
        :type message: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._wallet_service_btc_sign_message_serialize(
            address_id=address_id,
            message=message,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "TgvalidatordBTCSignMessageReply",
            '400': "object",
            '401': "object",
            '403': "object",
            '404': "object",
            '500': "object",
            '503': "object",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def wallet_service_btc_sign_message_with_http_info(
        self,
        address_id: StrictStr,
        message: Optional[StrictStr] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[TgvalidatordBTCSignMessageReply]:
        """Calculate a BTC specific signature of a message

        This endpoint returns a BTC specific signature from a given message and address as input.

        :param address_id: (required)
        :type address_id: str
        :param message:
        :type message: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._wallet_service_btc_sign_message_serialize(
            address_id=address_id,
            message=message,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "TgvalidatordBTCSignMessageReply",
            '400': "object",
            '401': "object",
            '403': "object",
            '404': "object",
            '500': "object",
            '503': "object",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def wallet_service_btc_sign_message_without_preload_content(
        self,
        address_id: StrictStr,
        message: Optional[StrictStr] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """Calculate a BTC specific signature of a message

        This endpoint returns a BTC specific signature from a given message and address as input.

        :param address_id: (required)
        :type address_id: str
        :param message:
        :type message: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._wallet_service_btc_sign_message_serialize(
            address_id=address_id,
            message=message,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "TgvalidatordBTCSignMessageReply",
            '400': "object",
            '401': "object",
            '403': "object",
            '404': "object",
            '500': "object",
            '503': "object",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _wallet_service_btc_sign_message_serialize(
        self,
        address_id,
        message,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        if address_id is not None:
            _path_params['addressId'] = address_id
        # process the query parameters
        if message is not None:
            
            _query_params.append(('message', message))
            
        # process the header parameters
        # process the form parameters
        # process the body parameter


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json'
                ]
            )


        # authentication setting
        _auth_settings: List[str] = [
            'ApiKeyTPV1'
        ]

        return self.api_client.param_serialize(
            method='GET',
            resource_path='/api/rest/v1/addresses/{addressId}/btc_sign',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def wallet_service_compute_addresses_signature(
        self,
        body: TgvalidatordComputeAddressesSignatureRequest,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> TgvalidatordComputeAddressesSignatureReply:
        """Recompute addresses signatures

        This endpoint forces a recompute of all addresses signatures.  Required role: **Admin**.

        :param body: (required)
        :type body: TgvalidatordComputeAddressesSignatureRequest
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._wallet_service_compute_addresses_signature_serialize(
            body=body,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "TgvalidatordComputeAddressesSignatureReply",
            '400': "object",
            '401': "object",
            '403': "object",
            '404': "object",
            '500': "object",
            '503': "object",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def wallet_service_compute_addresses_signature_with_http_info(
        self,
        body: TgvalidatordComputeAddressesSignatureRequest,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[TgvalidatordComputeAddressesSignatureReply]:
        """Recompute addresses signatures

        This endpoint forces a recompute of all addresses signatures.  Required role: **Admin**.

        :param body: (required)
        :type body: TgvalidatordComputeAddressesSignatureRequest
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._wallet_service_compute_addresses_signature_serialize(
            body=body,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "TgvalidatordComputeAddressesSignatureReply",
            '400': "object",
            '401': "object",
            '403': "object",
            '404': "object",
            '500': "object",
            '503': "object",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def wallet_service_compute_addresses_signature_without_preload_content(
        self,
        body: TgvalidatordComputeAddressesSignatureRequest,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """Recompute addresses signatures

        This endpoint forces a recompute of all addresses signatures.  Required role: **Admin**.

        :param body: (required)
        :type body: TgvalidatordComputeAddressesSignatureRequest
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._wallet_service_compute_addresses_signature_serialize(
            body=body,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "TgvalidatordComputeAddressesSignatureReply",
            '400': "object",
            '401': "object",
            '403': "object",
            '404': "object",
            '500': "object",
            '503': "object",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _wallet_service_compute_addresses_signature_serialize(
        self,
        body,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        # process the query parameters
        # process the header parameters
        # process the form parameters
        # process the body parameter
        if body is not None:
            _body_params = body


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json'
                ]
            )

        # set the HTTP header `Content-Type`
        if _content_type:
            _header_params['Content-Type'] = _content_type
        else:
            _default_content_type = (
                self.api_client.select_header_content_type(
                    [
                        'application/json'
                    ]
                )
            )
            if _default_content_type is not None:
                _header_params['Content-Type'] = _default_content_type

        # authentication setting
        _auth_settings: List[str] = [
            'ApiKeyTPV1'
        ]

        return self.api_client.param_serialize(
            method='POST',
            resource_path='/api/rest/v1/addresses/signature/compute',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def wallet_service_create_address(
        self,
        body: TgvalidatordCreateAddressRequest,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> TgvalidatordCreateAddressReply:
        """Create an address

        This endpoint creates a new address within a specified Wallet. All addresses _must_ be associated with a parent wallet. Addresses created with this endpoint are internal to Protect. To create an external address, you need to create a [whitelisted address request](https://docs.taurushq.com/protect-capital/reference/whitelistservice_createwhitelistedaddress).  For more information about whitelisted assets, see our [user guides](https://docs.taurushq.com/user-and-technical-guides/docs/smart-contracts).  Address creation requires HSM signature, which makes it synchronous. Therefore, address creation can be slow, and failures may occur if the HSM is either unavailable or takes too long to process. If this happens, the API can be safely called again.  **Required role:** AccountCreator.

        :param body: (required)
        :type body: TgvalidatordCreateAddressRequest
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._wallet_service_create_address_serialize(
            body=body,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "TgvalidatordCreateAddressReply",
            '400': "object",
            '401': "object",
            '403': "object",
            '404': "object",
            '500': "object",
            '503': "object",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def wallet_service_create_address_with_http_info(
        self,
        body: TgvalidatordCreateAddressRequest,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[TgvalidatordCreateAddressReply]:
        """Create an address

        This endpoint creates a new address within a specified Wallet. All addresses _must_ be associated with a parent wallet. Addresses created with this endpoint are internal to Protect. To create an external address, you need to create a [whitelisted address request](https://docs.taurushq.com/protect-capital/reference/whitelistservice_createwhitelistedaddress).  For more information about whitelisted assets, see our [user guides](https://docs.taurushq.com/user-and-technical-guides/docs/smart-contracts).  Address creation requires HSM signature, which makes it synchronous. Therefore, address creation can be slow, and failures may occur if the HSM is either unavailable or takes too long to process. If this happens, the API can be safely called again.  **Required role:** AccountCreator.

        :param body: (required)
        :type body: TgvalidatordCreateAddressRequest
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._wallet_service_create_address_serialize(
            body=body,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "TgvalidatordCreateAddressReply",
            '400': "object",
            '401': "object",
            '403': "object",
            '404': "object",
            '500': "object",
            '503': "object",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def wallet_service_create_address_without_preload_content(
        self,
        body: TgvalidatordCreateAddressRequest,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """Create an address

        This endpoint creates a new address within a specified Wallet. All addresses _must_ be associated with a parent wallet. Addresses created with this endpoint are internal to Protect. To create an external address, you need to create a [whitelisted address request](https://docs.taurushq.com/protect-capital/reference/whitelistservice_createwhitelistedaddress).  For more information about whitelisted assets, see our [user guides](https://docs.taurushq.com/user-and-technical-guides/docs/smart-contracts).  Address creation requires HSM signature, which makes it synchronous. Therefore, address creation can be slow, and failures may occur if the HSM is either unavailable or takes too long to process. If this happens, the API can be safely called again.  **Required role:** AccountCreator.

        :param body: (required)
        :type body: TgvalidatordCreateAddressRequest
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._wallet_service_create_address_serialize(
            body=body,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "TgvalidatordCreateAddressReply",
            '400': "object",
            '401': "object",
            '403': "object",
            '404': "object",
            '500': "object",
            '503': "object",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _wallet_service_create_address_serialize(
        self,
        body,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        # process the query parameters
        # process the header parameters
        # process the form parameters
        # process the body parameter
        if body is not None:
            _body_params = body


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json'
                ]
            )

        # set the HTTP header `Content-Type`
        if _content_type:
            _header_params['Content-Type'] = _content_type
        else:
            _default_content_type = (
                self.api_client.select_header_content_type(
                    [
                        'application/json'
                    ]
                )
            )
            if _default_content_type is not None:
                _header_params['Content-Type'] = _default_content_type

        # authentication setting
        _auth_settings: List[str] = [
            'ApiKeyTPV1'
        ]

        return self.api_client.param_serialize(
            method='POST',
            resource_path='/api/rest/v1/addresses',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def wallet_service_create_address_attributes(
        self,
        address_id: StrictStr,
        body: WalletServiceCreateAddressAttributesBody,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> TgvalidatordCreateAddressAttributesReply:
        """Create attributes

        This endpoint creates attributes for a given address.   Required role: **AccountCreator**.

        :param address_id: (required)
        :type address_id: str
        :param body: (required)
        :type body: WalletServiceCreateAddressAttributesBody
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._wallet_service_create_address_attributes_serialize(
            address_id=address_id,
            body=body,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "TgvalidatordCreateAddressAttributesReply",
            '400': "object",
            '401': "object",
            '403': "object",
            '404': "object",
            '500': "object",
            '503': "object",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def wallet_service_create_address_attributes_with_http_info(
        self,
        address_id: StrictStr,
        body: WalletServiceCreateAddressAttributesBody,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[TgvalidatordCreateAddressAttributesReply]:
        """Create attributes

        This endpoint creates attributes for a given address.   Required role: **AccountCreator**.

        :param address_id: (required)
        :type address_id: str
        :param body: (required)
        :type body: WalletServiceCreateAddressAttributesBody
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._wallet_service_create_address_attributes_serialize(
            address_id=address_id,
            body=body,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "TgvalidatordCreateAddressAttributesReply",
            '400': "object",
            '401': "object",
            '403': "object",
            '404': "object",
            '500': "object",
            '503': "object",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def wallet_service_create_address_attributes_without_preload_content(
        self,
        address_id: StrictStr,
        body: WalletServiceCreateAddressAttributesBody,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """Create attributes

        This endpoint creates attributes for a given address.   Required role: **AccountCreator**.

        :param address_id: (required)
        :type address_id: str
        :param body: (required)
        :type body: WalletServiceCreateAddressAttributesBody
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._wallet_service_create_address_attributes_serialize(
            address_id=address_id,
            body=body,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "TgvalidatordCreateAddressAttributesReply",
            '400': "object",
            '401': "object",
            '403': "object",
            '404': "object",
            '500': "object",
            '503': "object",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _wallet_service_create_address_attributes_serialize(
        self,
        address_id,
        body,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        if address_id is not None:
            _path_params['addressId'] = address_id
        # process the query parameters
        # process the header parameters
        # process the form parameters
        # process the body parameter
        if body is not None:
            _body_params = body


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json'
                ]
            )

        # set the HTTP header `Content-Type`
        if _content_type:
            _header_params['Content-Type'] = _content_type
        else:
            _default_content_type = (
                self.api_client.select_header_content_type(
                    [
                        'application/json'
                    ]
                )
            )
            if _default_content_type is not None:
                _header_params['Content-Type'] = _default_content_type

        # authentication setting
        _auth_settings: List[str] = [
            'ApiKeyTPV1'
        ]

        return self.api_client.param_serialize(
            method='POST',
            resource_path='/api/rest/v1/addresses/{addressId}/attributes',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def wallet_service_create_addresses_batch(
        self,
        body: TgvalidatordCreateAddressesRequest,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> TgvalidatordCreateAddressesReply:
        """Create a batch of addresses

        Required role: **AccountCreator**.   This endpoint creates a batch of addresses.   Address created from this endpoint will start with a **created** and will not be ready to use until the HSM process them. 

        :param body: (required)
        :type body: TgvalidatordCreateAddressesRequest
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._wallet_service_create_addresses_batch_serialize(
            body=body,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "TgvalidatordCreateAddressesReply",
            '400': "object",
            '401': "object",
            '403': "object",
            '404': "object",
            '500': "object",
            '503': "object",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def wallet_service_create_addresses_batch_with_http_info(
        self,
        body: TgvalidatordCreateAddressesRequest,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[TgvalidatordCreateAddressesReply]:
        """Create a batch of addresses

        Required role: **AccountCreator**.   This endpoint creates a batch of addresses.   Address created from this endpoint will start with a **created** and will not be ready to use until the HSM process them. 

        :param body: (required)
        :type body: TgvalidatordCreateAddressesRequest
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._wallet_service_create_addresses_batch_serialize(
            body=body,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "TgvalidatordCreateAddressesReply",
            '400': "object",
            '401': "object",
            '403': "object",
            '404': "object",
            '500': "object",
            '503': "object",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def wallet_service_create_addresses_batch_without_preload_content(
        self,
        body: TgvalidatordCreateAddressesRequest,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """Create a batch of addresses

        Required role: **AccountCreator**.   This endpoint creates a batch of addresses.   Address created from this endpoint will start with a **created** and will not be ready to use until the HSM process them. 

        :param body: (required)
        :type body: TgvalidatordCreateAddressesRequest
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._wallet_service_create_addresses_batch_serialize(
            body=body,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "TgvalidatordCreateAddressesReply",
            '400': "object",
            '401': "object",
            '403': "object",
            '404': "object",
            '500': "object",
            '503': "object",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _wallet_service_create_addresses_batch_serialize(
        self,
        body,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        # process the query parameters
        # process the header parameters
        # process the form parameters
        # process the body parameter
        if body is not None:
            _body_params = body


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json'
                ]
            )

        # set the HTTP header `Content-Type`
        if _content_type:
            _header_params['Content-Type'] = _content_type
        else:
            _default_content_type = (
                self.api_client.select_header_content_type(
                    [
                        'application/json'
                    ]
                )
            )
            if _default_content_type is not None:
                _header_params['Content-Type'] = _default_content_type

        # authentication setting
        _auth_settings: List[str] = [
            'ApiKeyTPV1'
        ]

        return self.api_client.param_serialize(
            method='POST',
            resource_path='/api/rest/v1/addresses/batch',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def wallet_service_delete_address_attribute(
        self,
        address_id: StrictStr,
        id: StrictStr,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> object:
        """Delete an attribute

        This endpoint deletes an attribute of a given address.   Required role: **AccountCreator**.

        :param address_id: (required)
        :type address_id: str
        :param id: (required)
        :type id: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._wallet_service_delete_address_attribute_serialize(
            address_id=address_id,
            id=id,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "object",
            '400': "object",
            '401': "object",
            '403': "object",
            '404': "object",
            '500': "object",
            '503': "object",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def wallet_service_delete_address_attribute_with_http_info(
        self,
        address_id: StrictStr,
        id: StrictStr,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[object]:
        """Delete an attribute

        This endpoint deletes an attribute of a given address.   Required role: **AccountCreator**.

        :param address_id: (required)
        :type address_id: str
        :param id: (required)
        :type id: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._wallet_service_delete_address_attribute_serialize(
            address_id=address_id,
            id=id,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "object",
            '400': "object",
            '401': "object",
            '403': "object",
            '404': "object",
            '500': "object",
            '503': "object",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def wallet_service_delete_address_attribute_without_preload_content(
        self,
        address_id: StrictStr,
        id: StrictStr,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """Delete an attribute

        This endpoint deletes an attribute of a given address.   Required role: **AccountCreator**.

        :param address_id: (required)
        :type address_id: str
        :param id: (required)
        :type id: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._wallet_service_delete_address_attribute_serialize(
            address_id=address_id,
            id=id,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "object",
            '400': "object",
            '401': "object",
            '403': "object",
            '404': "object",
            '500': "object",
            '503': "object",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _wallet_service_delete_address_attribute_serialize(
        self,
        address_id,
        id,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        if address_id is not None:
            _path_params['addressId'] = address_id
        if id is not None:
            _path_params['id'] = id
        # process the query parameters
        # process the header parameters
        # process the form parameters
        # process the body parameter


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json'
                ]
            )


        # authentication setting
        _auth_settings: List[str] = [
            'ApiKeyTPV1'
        ]

        return self.api_client.param_serialize(
            method='DELETE',
            resource_path='/api/rest/v1/addresses/{addressId}/attributes/{id}',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def wallet_service_eth_sign_message(
        self,
        address_id: StrictStr,
        message: Optional[StrictStr] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> TgvalidatordETHSignMessageReply:
        """Calculate an ETH specific signature of a message

        This endpoint returns an ETH specific signature from a given message and address as input.

        :param address_id: (required)
        :type address_id: str
        :param message:
        :type message: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._wallet_service_eth_sign_message_serialize(
            address_id=address_id,
            message=message,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "TgvalidatordETHSignMessageReply",
            '400': "object",
            '401': "object",
            '403': "object",
            '404': "object",
            '500': "object",
            '503': "object",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def wallet_service_eth_sign_message_with_http_info(
        self,
        address_id: StrictStr,
        message: Optional[StrictStr] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[TgvalidatordETHSignMessageReply]:
        """Calculate an ETH specific signature of a message

        This endpoint returns an ETH specific signature from a given message and address as input.

        :param address_id: (required)
        :type address_id: str
        :param message:
        :type message: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._wallet_service_eth_sign_message_serialize(
            address_id=address_id,
            message=message,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "TgvalidatordETHSignMessageReply",
            '400': "object",
            '401': "object",
            '403': "object",
            '404': "object",
            '500': "object",
            '503': "object",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def wallet_service_eth_sign_message_without_preload_content(
        self,
        address_id: StrictStr,
        message: Optional[StrictStr] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """Calculate an ETH specific signature of a message

        This endpoint returns an ETH specific signature from a given message and address as input.

        :param address_id: (required)
        :type address_id: str
        :param message:
        :type message: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._wallet_service_eth_sign_message_serialize(
            address_id=address_id,
            message=message,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "TgvalidatordETHSignMessageReply",
            '400': "object",
            '401': "object",
            '403': "object",
            '404': "object",
            '500': "object",
            '503': "object",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _wallet_service_eth_sign_message_serialize(
        self,
        address_id,
        message,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        if address_id is not None:
            _path_params['addressId'] = address_id
        # process the query parameters
        if message is not None:
            
            _query_params.append(('message', message))
            
        # process the header parameters
        # process the form parameters
        # process the body parameter


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json'
                ]
            )


        # authentication setting
        _auth_settings: List[str] = [
            'ApiKeyTPV1'
        ]

        return self.api_client.param_serialize(
            method='GET',
            resource_path='/api/rest/v1/addresses/{addressId}/eth_sign',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def wallet_service_export_address_balance_history(
        self,
        id: Annotated[StrictStr, Field(description="Desired address ID")],
        interval_hours: Optional[StrictStr] = None,
        format: Annotated[Optional[StrictStr], Field(description="Desired file format, can be csv or json.")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> TgvalidatordExportAddressBalanceHistoryReply:
        """Export address' balances history

        This endpoint exports a list of address' balances history

        :param id: Desired address ID (required)
        :type id: str
        :param interval_hours:
        :type interval_hours: str
        :param format: Desired file format, can be csv or json.
        :type format: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._wallet_service_export_address_balance_history_serialize(
            id=id,
            interval_hours=interval_hours,
            format=format,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "TgvalidatordExportAddressBalanceHistoryReply",
            '400': "object",
            '401': "object",
            '403': "object",
            '404': "object",
            '500': "object",
            '503': "object",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def wallet_service_export_address_balance_history_with_http_info(
        self,
        id: Annotated[StrictStr, Field(description="Desired address ID")],
        interval_hours: Optional[StrictStr] = None,
        format: Annotated[Optional[StrictStr], Field(description="Desired file format, can be csv or json.")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[TgvalidatordExportAddressBalanceHistoryReply]:
        """Export address' balances history

        This endpoint exports a list of address' balances history

        :param id: Desired address ID (required)
        :type id: str
        :param interval_hours:
        :type interval_hours: str
        :param format: Desired file format, can be csv or json.
        :type format: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._wallet_service_export_address_balance_history_serialize(
            id=id,
            interval_hours=interval_hours,
            format=format,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "TgvalidatordExportAddressBalanceHistoryReply",
            '400': "object",
            '401': "object",
            '403': "object",
            '404': "object",
            '500': "object",
            '503': "object",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def wallet_service_export_address_balance_history_without_preload_content(
        self,
        id: Annotated[StrictStr, Field(description="Desired address ID")],
        interval_hours: Optional[StrictStr] = None,
        format: Annotated[Optional[StrictStr], Field(description="Desired file format, can be csv or json.")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """Export address' balances history

        This endpoint exports a list of address' balances history

        :param id: Desired address ID (required)
        :type id: str
        :param interval_hours:
        :type interval_hours: str
        :param format: Desired file format, can be csv or json.
        :type format: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._wallet_service_export_address_balance_history_serialize(
            id=id,
            interval_hours=interval_hours,
            format=format,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "TgvalidatordExportAddressBalanceHistoryReply",
            '400': "object",
            '401': "object",
            '403': "object",
            '404': "object",
            '500': "object",
            '503': "object",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _wallet_service_export_address_balance_history_serialize(
        self,
        id,
        interval_hours,
        format,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        if id is not None:
            _path_params['id'] = id
        # process the query parameters
        if interval_hours is not None:
            
            _query_params.append(('intervalHours', interval_hours))
            
        if format is not None:
            
            _query_params.append(('format', format))
            
        # process the header parameters
        # process the form parameters
        # process the body parameter


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json'
                ]
            )


        # authentication setting
        _auth_settings: List[str] = [
            'ApiKeyTPV1'
        ]

        return self.api_client.param_serialize(
            method='GET',
            resource_path='/api/rest/v1/addresses/{id}/balances/history/export',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def wallet_service_export_addresses(
        self,
        wallet_id: Optional[StrictStr] = None,
        currency: Annotated[Optional[StrictStr], Field(description="Filter on ID or symbol of the currency")] = None,
        format: Annotated[Optional[StrictStr], Field(description="Desired file format, can be csv or json.")] = None,
        query: Optional[StrictStr] = None,
        score_provider: Annotated[Optional[StrictStr], Field(description="Deprecated. Use scoreFilter instead.")] = None,
        score_in_below: Annotated[Optional[StrictStr], Field(description="Deprecated. Use scoreFilter instead.")] = None,
        score_out_below: Annotated[Optional[StrictStr], Field(description="Deprecated. Use scoreFilter instead.")] = None,
        score_exclusive: Annotated[Optional[StrictBool], Field(description="Deprecated. Use scoreFilter instead.")] = None,
        customer_id: Optional[StrictStr] = None,
        coinfirm_score_greater: Annotated[Optional[StrictStr], Field(description="Deprecated. Use scoreFilter instead.")] = None,
        chainalysis_score_greater: Annotated[Optional[StrictStr], Field(description="Deprecated. Use scoreFilter instead.")] = None,
        score_filter_score_provider: Annotated[Optional[StrictStr], Field(description="Specify the score provider to filter on, or empty.Each provider has associated filter parameters that can be set.Supported values: `scorechain`, `coinfirm`, `chainalysis`, `elliptic`, `trmlabs`")] = None,
        score_filter_scorechain_filters_score_in_below: Annotated[Optional[StrictStr], Field(description="Filter addresses under a Scorechain incoming score threshold.")] = None,
        score_filter_scorechain_filters_score_out_below: Annotated[Optional[StrictStr], Field(description="Filter addresses under a Scorechain outgoing score threshold.")] = None,
        score_filter_scorechain_filters_score_exclusive: Annotated[Optional[StrictBool], Field(description="By default when both Scorechain scores scoreInBelow and scoreOutBelow are provided, it returns the addresses matching (scoreInBelow AND scoreOutBelow). When scoreExclusive is set to true, it will return the addresses matching (scoreInBelow OR scoreOutBelow).")] = None,
        score_filter_coinfirm_filters_score_greater: Annotated[Optional[StrictStr], Field(description="Filter addresses with a Coinfirm C-score above threshold.")] = None,
        score_filter_chainalysis_filters_score_greater: Annotated[Optional[StrictStr], Field(description="Filter addresses with a Chainalysis risk score above threshold.")] = None,
        score_filter_elliptic_filters_score_greater: Annotated[Optional[StrictStr], Field(description="Filter addresses with an Elliptic risk score above threshold.")] = None,
        score_filter_trmlabs_filters_score_greater: Annotated[Optional[StrictStr], Field(description="Filter addresses with an TRM Labs risk score above threshold.")] = None,
        blockchain: Optional[StrictStr] = None,
        network: Optional[StrictStr] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> TgvalidatordExportAddressesReply:
        """Export addresses

        This endpoint exports a list of addresses

        :param wallet_id:
        :type wallet_id: str
        :param currency: Filter on ID or symbol of the currency
        :type currency: str
        :param format: Desired file format, can be csv or json.
        :type format: str
        :param query:
        :type query: str
        :param score_provider: Deprecated. Use scoreFilter instead.
        :type score_provider: str
        :param score_in_below: Deprecated. Use scoreFilter instead.
        :type score_in_below: str
        :param score_out_below: Deprecated. Use scoreFilter instead.
        :type score_out_below: str
        :param score_exclusive: Deprecated. Use scoreFilter instead.
        :type score_exclusive: bool
        :param customer_id:
        :type customer_id: str
        :param coinfirm_score_greater: Deprecated. Use scoreFilter instead.
        :type coinfirm_score_greater: str
        :param chainalysis_score_greater: Deprecated. Use scoreFilter instead.
        :type chainalysis_score_greater: str
        :param score_filter_score_provider: Specify the score provider to filter on, or empty.Each provider has associated filter parameters that can be set.Supported values: `scorechain`, `coinfirm`, `chainalysis`, `elliptic`, `trmlabs`
        :type score_filter_score_provider: str
        :param score_filter_scorechain_filters_score_in_below: Filter addresses under a Scorechain incoming score threshold.
        :type score_filter_scorechain_filters_score_in_below: str
        :param score_filter_scorechain_filters_score_out_below: Filter addresses under a Scorechain outgoing score threshold.
        :type score_filter_scorechain_filters_score_out_below: str
        :param score_filter_scorechain_filters_score_exclusive: By default when both Scorechain scores scoreInBelow and scoreOutBelow are provided, it returns the addresses matching (scoreInBelow AND scoreOutBelow). When scoreExclusive is set to true, it will return the addresses matching (scoreInBelow OR scoreOutBelow).
        :type score_filter_scorechain_filters_score_exclusive: bool
        :param score_filter_coinfirm_filters_score_greater: Filter addresses with a Coinfirm C-score above threshold.
        :type score_filter_coinfirm_filters_score_greater: str
        :param score_filter_chainalysis_filters_score_greater: Filter addresses with a Chainalysis risk score above threshold.
        :type score_filter_chainalysis_filters_score_greater: str
        :param score_filter_elliptic_filters_score_greater: Filter addresses with an Elliptic risk score above threshold.
        :type score_filter_elliptic_filters_score_greater: str
        :param score_filter_trmlabs_filters_score_greater: Filter addresses with an TRM Labs risk score above threshold.
        :type score_filter_trmlabs_filters_score_greater: str
        :param blockchain:
        :type blockchain: str
        :param network:
        :type network: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._wallet_service_export_addresses_serialize(
            wallet_id=wallet_id,
            currency=currency,
            format=format,
            query=query,
            score_provider=score_provider,
            score_in_below=score_in_below,
            score_out_below=score_out_below,
            score_exclusive=score_exclusive,
            customer_id=customer_id,
            coinfirm_score_greater=coinfirm_score_greater,
            chainalysis_score_greater=chainalysis_score_greater,
            score_filter_score_provider=score_filter_score_provider,
            score_filter_scorechain_filters_score_in_below=score_filter_scorechain_filters_score_in_below,
            score_filter_scorechain_filters_score_out_below=score_filter_scorechain_filters_score_out_below,
            score_filter_scorechain_filters_score_exclusive=score_filter_scorechain_filters_score_exclusive,
            score_filter_coinfirm_filters_score_greater=score_filter_coinfirm_filters_score_greater,
            score_filter_chainalysis_filters_score_greater=score_filter_chainalysis_filters_score_greater,
            score_filter_elliptic_filters_score_greater=score_filter_elliptic_filters_score_greater,
            score_filter_trmlabs_filters_score_greater=score_filter_trmlabs_filters_score_greater,
            blockchain=blockchain,
            network=network,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "TgvalidatordExportAddressesReply",
            '400': "object",
            '401': "object",
            '403': "object",
            '404': "object",
            '500': "object",
            '503': "object",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def wallet_service_export_addresses_with_http_info(
        self,
        wallet_id: Optional[StrictStr] = None,
        currency: Annotated[Optional[StrictStr], Field(description="Filter on ID or symbol of the currency")] = None,
        format: Annotated[Optional[StrictStr], Field(description="Desired file format, can be csv or json.")] = None,
        query: Optional[StrictStr] = None,
        score_provider: Annotated[Optional[StrictStr], Field(description="Deprecated. Use scoreFilter instead.")] = None,
        score_in_below: Annotated[Optional[StrictStr], Field(description="Deprecated. Use scoreFilter instead.")] = None,
        score_out_below: Annotated[Optional[StrictStr], Field(description="Deprecated. Use scoreFilter instead.")] = None,
        score_exclusive: Annotated[Optional[StrictBool], Field(description="Deprecated. Use scoreFilter instead.")] = None,
        customer_id: Optional[StrictStr] = None,
        coinfirm_score_greater: Annotated[Optional[StrictStr], Field(description="Deprecated. Use scoreFilter instead.")] = None,
        chainalysis_score_greater: Annotated[Optional[StrictStr], Field(description="Deprecated. Use scoreFilter instead.")] = None,
        score_filter_score_provider: Annotated[Optional[StrictStr], Field(description="Specify the score provider to filter on, or empty.Each provider has associated filter parameters that can be set.Supported values: `scorechain`, `coinfirm`, `chainalysis`, `elliptic`, `trmlabs`")] = None,
        score_filter_scorechain_filters_score_in_below: Annotated[Optional[StrictStr], Field(description="Filter addresses under a Scorechain incoming score threshold.")] = None,
        score_filter_scorechain_filters_score_out_below: Annotated[Optional[StrictStr], Field(description="Filter addresses under a Scorechain outgoing score threshold.")] = None,
        score_filter_scorechain_filters_score_exclusive: Annotated[Optional[StrictBool], Field(description="By default when both Scorechain scores scoreInBelow and scoreOutBelow are provided, it returns the addresses matching (scoreInBelow AND scoreOutBelow). When scoreExclusive is set to true, it will return the addresses matching (scoreInBelow OR scoreOutBelow).")] = None,
        score_filter_coinfirm_filters_score_greater: Annotated[Optional[StrictStr], Field(description="Filter addresses with a Coinfirm C-score above threshold.")] = None,
        score_filter_chainalysis_filters_score_greater: Annotated[Optional[StrictStr], Field(description="Filter addresses with a Chainalysis risk score above threshold.")] = None,
        score_filter_elliptic_filters_score_greater: Annotated[Optional[StrictStr], Field(description="Filter addresses with an Elliptic risk score above threshold.")] = None,
        score_filter_trmlabs_filters_score_greater: Annotated[Optional[StrictStr], Field(description="Filter addresses with an TRM Labs risk score above threshold.")] = None,
        blockchain: Optional[StrictStr] = None,
        network: Optional[StrictStr] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[TgvalidatordExportAddressesReply]:
        """Export addresses

        This endpoint exports a list of addresses

        :param wallet_id:
        :type wallet_id: str
        :param currency: Filter on ID or symbol of the currency
        :type currency: str
        :param format: Desired file format, can be csv or json.
        :type format: str
        :param query:
        :type query: str
        :param score_provider: Deprecated. Use scoreFilter instead.
        :type score_provider: str
        :param score_in_below: Deprecated. Use scoreFilter instead.
        :type score_in_below: str
        :param score_out_below: Deprecated. Use scoreFilter instead.
        :type score_out_below: str
        :param score_exclusive: Deprecated. Use scoreFilter instead.
        :type score_exclusive: bool
        :param customer_id:
        :type customer_id: str
        :param coinfirm_score_greater: Deprecated. Use scoreFilter instead.
        :type coinfirm_score_greater: str
        :param chainalysis_score_greater: Deprecated. Use scoreFilter instead.
        :type chainalysis_score_greater: str
        :param score_filter_score_provider: Specify the score provider to filter on, or empty.Each provider has associated filter parameters that can be set.Supported values: `scorechain`, `coinfirm`, `chainalysis`, `elliptic`, `trmlabs`
        :type score_filter_score_provider: str
        :param score_filter_scorechain_filters_score_in_below: Filter addresses under a Scorechain incoming score threshold.
        :type score_filter_scorechain_filters_score_in_below: str
        :param score_filter_scorechain_filters_score_out_below: Filter addresses under a Scorechain outgoing score threshold.
        :type score_filter_scorechain_filters_score_out_below: str
        :param score_filter_scorechain_filters_score_exclusive: By default when both Scorechain scores scoreInBelow and scoreOutBelow are provided, it returns the addresses matching (scoreInBelow AND scoreOutBelow). When scoreExclusive is set to true, it will return the addresses matching (scoreInBelow OR scoreOutBelow).
        :type score_filter_scorechain_filters_score_exclusive: bool
        :param score_filter_coinfirm_filters_score_greater: Filter addresses with a Coinfirm C-score above threshold.
        :type score_filter_coinfirm_filters_score_greater: str
        :param score_filter_chainalysis_filters_score_greater: Filter addresses with a Chainalysis risk score above threshold.
        :type score_filter_chainalysis_filters_score_greater: str
        :param score_filter_elliptic_filters_score_greater: Filter addresses with an Elliptic risk score above threshold.
        :type score_filter_elliptic_filters_score_greater: str
        :param score_filter_trmlabs_filters_score_greater: Filter addresses with an TRM Labs risk score above threshold.
        :type score_filter_trmlabs_filters_score_greater: str
        :param blockchain:
        :type blockchain: str
        :param network:
        :type network: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._wallet_service_export_addresses_serialize(
            wallet_id=wallet_id,
            currency=currency,
            format=format,
            query=query,
            score_provider=score_provider,
            score_in_below=score_in_below,
            score_out_below=score_out_below,
            score_exclusive=score_exclusive,
            customer_id=customer_id,
            coinfirm_score_greater=coinfirm_score_greater,
            chainalysis_score_greater=chainalysis_score_greater,
            score_filter_score_provider=score_filter_score_provider,
            score_filter_scorechain_filters_score_in_below=score_filter_scorechain_filters_score_in_below,
            score_filter_scorechain_filters_score_out_below=score_filter_scorechain_filters_score_out_below,
            score_filter_scorechain_filters_score_exclusive=score_filter_scorechain_filters_score_exclusive,
            score_filter_coinfirm_filters_score_greater=score_filter_coinfirm_filters_score_greater,
            score_filter_chainalysis_filters_score_greater=score_filter_chainalysis_filters_score_greater,
            score_filter_elliptic_filters_score_greater=score_filter_elliptic_filters_score_greater,
            score_filter_trmlabs_filters_score_greater=score_filter_trmlabs_filters_score_greater,
            blockchain=blockchain,
            network=network,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "TgvalidatordExportAddressesReply",
            '400': "object",
            '401': "object",
            '403': "object",
            '404': "object",
            '500': "object",
            '503': "object",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def wallet_service_export_addresses_without_preload_content(
        self,
        wallet_id: Optional[StrictStr] = None,
        currency: Annotated[Optional[StrictStr], Field(description="Filter on ID or symbol of the currency")] = None,
        format: Annotated[Optional[StrictStr], Field(description="Desired file format, can be csv or json.")] = None,
        query: Optional[StrictStr] = None,
        score_provider: Annotated[Optional[StrictStr], Field(description="Deprecated. Use scoreFilter instead.")] = None,
        score_in_below: Annotated[Optional[StrictStr], Field(description="Deprecated. Use scoreFilter instead.")] = None,
        score_out_below: Annotated[Optional[StrictStr], Field(description="Deprecated. Use scoreFilter instead.")] = None,
        score_exclusive: Annotated[Optional[StrictBool], Field(description="Deprecated. Use scoreFilter instead.")] = None,
        customer_id: Optional[StrictStr] = None,
        coinfirm_score_greater: Annotated[Optional[StrictStr], Field(description="Deprecated. Use scoreFilter instead.")] = None,
        chainalysis_score_greater: Annotated[Optional[StrictStr], Field(description="Deprecated. Use scoreFilter instead.")] = None,
        score_filter_score_provider: Annotated[Optional[StrictStr], Field(description="Specify the score provider to filter on, or empty.Each provider has associated filter parameters that can be set.Supported values: `scorechain`, `coinfirm`, `chainalysis`, `elliptic`, `trmlabs`")] = None,
        score_filter_scorechain_filters_score_in_below: Annotated[Optional[StrictStr], Field(description="Filter addresses under a Scorechain incoming score threshold.")] = None,
        score_filter_scorechain_filters_score_out_below: Annotated[Optional[StrictStr], Field(description="Filter addresses under a Scorechain outgoing score threshold.")] = None,
        score_filter_scorechain_filters_score_exclusive: Annotated[Optional[StrictBool], Field(description="By default when both Scorechain scores scoreInBelow and scoreOutBelow are provided, it returns the addresses matching (scoreInBelow AND scoreOutBelow). When scoreExclusive is set to true, it will return the addresses matching (scoreInBelow OR scoreOutBelow).")] = None,
        score_filter_coinfirm_filters_score_greater: Annotated[Optional[StrictStr], Field(description="Filter addresses with a Coinfirm C-score above threshold.")] = None,
        score_filter_chainalysis_filters_score_greater: Annotated[Optional[StrictStr], Field(description="Filter addresses with a Chainalysis risk score above threshold.")] = None,
        score_filter_elliptic_filters_score_greater: Annotated[Optional[StrictStr], Field(description="Filter addresses with an Elliptic risk score above threshold.")] = None,
        score_filter_trmlabs_filters_score_greater: Annotated[Optional[StrictStr], Field(description="Filter addresses with an TRM Labs risk score above threshold.")] = None,
        blockchain: Optional[StrictStr] = None,
        network: Optional[StrictStr] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """Export addresses

        This endpoint exports a list of addresses

        :param wallet_id:
        :type wallet_id: str
        :param currency: Filter on ID or symbol of the currency
        :type currency: str
        :param format: Desired file format, can be csv or json.
        :type format: str
        :param query:
        :type query: str
        :param score_provider: Deprecated. Use scoreFilter instead.
        :type score_provider: str
        :param score_in_below: Deprecated. Use scoreFilter instead.
        :type score_in_below: str
        :param score_out_below: Deprecated. Use scoreFilter instead.
        :type score_out_below: str
        :param score_exclusive: Deprecated. Use scoreFilter instead.
        :type score_exclusive: bool
        :param customer_id:
        :type customer_id: str
        :param coinfirm_score_greater: Deprecated. Use scoreFilter instead.
        :type coinfirm_score_greater: str
        :param chainalysis_score_greater: Deprecated. Use scoreFilter instead.
        :type chainalysis_score_greater: str
        :param score_filter_score_provider: Specify the score provider to filter on, or empty.Each provider has associated filter parameters that can be set.Supported values: `scorechain`, `coinfirm`, `chainalysis`, `elliptic`, `trmlabs`
        :type score_filter_score_provider: str
        :param score_filter_scorechain_filters_score_in_below: Filter addresses under a Scorechain incoming score threshold.
        :type score_filter_scorechain_filters_score_in_below: str
        :param score_filter_scorechain_filters_score_out_below: Filter addresses under a Scorechain outgoing score threshold.
        :type score_filter_scorechain_filters_score_out_below: str
        :param score_filter_scorechain_filters_score_exclusive: By default when both Scorechain scores scoreInBelow and scoreOutBelow are provided, it returns the addresses matching (scoreInBelow AND scoreOutBelow). When scoreExclusive is set to true, it will return the addresses matching (scoreInBelow OR scoreOutBelow).
        :type score_filter_scorechain_filters_score_exclusive: bool
        :param score_filter_coinfirm_filters_score_greater: Filter addresses with a Coinfirm C-score above threshold.
        :type score_filter_coinfirm_filters_score_greater: str
        :param score_filter_chainalysis_filters_score_greater: Filter addresses with a Chainalysis risk score above threshold.
        :type score_filter_chainalysis_filters_score_greater: str
        :param score_filter_elliptic_filters_score_greater: Filter addresses with an Elliptic risk score above threshold.
        :type score_filter_elliptic_filters_score_greater: str
        :param score_filter_trmlabs_filters_score_greater: Filter addresses with an TRM Labs risk score above threshold.
        :type score_filter_trmlabs_filters_score_greater: str
        :param blockchain:
        :type blockchain: str
        :param network:
        :type network: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._wallet_service_export_addresses_serialize(
            wallet_id=wallet_id,
            currency=currency,
            format=format,
            query=query,
            score_provider=score_provider,
            score_in_below=score_in_below,
            score_out_below=score_out_below,
            score_exclusive=score_exclusive,
            customer_id=customer_id,
            coinfirm_score_greater=coinfirm_score_greater,
            chainalysis_score_greater=chainalysis_score_greater,
            score_filter_score_provider=score_filter_score_provider,
            score_filter_scorechain_filters_score_in_below=score_filter_scorechain_filters_score_in_below,
            score_filter_scorechain_filters_score_out_below=score_filter_scorechain_filters_score_out_below,
            score_filter_scorechain_filters_score_exclusive=score_filter_scorechain_filters_score_exclusive,
            score_filter_coinfirm_filters_score_greater=score_filter_coinfirm_filters_score_greater,
            score_filter_chainalysis_filters_score_greater=score_filter_chainalysis_filters_score_greater,
            score_filter_elliptic_filters_score_greater=score_filter_elliptic_filters_score_greater,
            score_filter_trmlabs_filters_score_greater=score_filter_trmlabs_filters_score_greater,
            blockchain=blockchain,
            network=network,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "TgvalidatordExportAddressesReply",
            '400': "object",
            '401': "object",
            '403': "object",
            '404': "object",
            '500': "object",
            '503': "object",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _wallet_service_export_addresses_serialize(
        self,
        wallet_id,
        currency,
        format,
        query,
        score_provider,
        score_in_below,
        score_out_below,
        score_exclusive,
        customer_id,
        coinfirm_score_greater,
        chainalysis_score_greater,
        score_filter_score_provider,
        score_filter_scorechain_filters_score_in_below,
        score_filter_scorechain_filters_score_out_below,
        score_filter_scorechain_filters_score_exclusive,
        score_filter_coinfirm_filters_score_greater,
        score_filter_chainalysis_filters_score_greater,
        score_filter_elliptic_filters_score_greater,
        score_filter_trmlabs_filters_score_greater,
        blockchain,
        network,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        # process the query parameters
        if wallet_id is not None:
            
            _query_params.append(('walletId', wallet_id))
            
        if currency is not None:
            
            _query_params.append(('currency', currency))
            
        if format is not None:
            
            _query_params.append(('format', format))
            
        if query is not None:
            
            _query_params.append(('query', query))
            
        if score_provider is not None:
            
            _query_params.append(('scoreProvider', score_provider))
            
        if score_in_below is not None:
            
            _query_params.append(('scoreInBelow', score_in_below))
            
        if score_out_below is not None:
            
            _query_params.append(('scoreOutBelow', score_out_below))
            
        if score_exclusive is not None:
            
            _query_params.append(('scoreExclusive', score_exclusive))
            
        if customer_id is not None:
            
            _query_params.append(('customerId', customer_id))
            
        if coinfirm_score_greater is not None:
            
            _query_params.append(('coinfirmScoreGreater', coinfirm_score_greater))
            
        if chainalysis_score_greater is not None:
            
            _query_params.append(('chainalysisScoreGreater', chainalysis_score_greater))
            
        if score_filter_score_provider is not None:
            
            _query_params.append(('scoreFilter.scoreProvider', score_filter_score_provider))
            
        if score_filter_scorechain_filters_score_in_below is not None:
            
            _query_params.append(('scoreFilter.scorechainFilters.scoreInBelow', score_filter_scorechain_filters_score_in_below))
            
        if score_filter_scorechain_filters_score_out_below is not None:
            
            _query_params.append(('scoreFilter.scorechainFilters.scoreOutBelow', score_filter_scorechain_filters_score_out_below))
            
        if score_filter_scorechain_filters_score_exclusive is not None:
            
            _query_params.append(('scoreFilter.scorechainFilters.scoreExclusive', score_filter_scorechain_filters_score_exclusive))
            
        if score_filter_coinfirm_filters_score_greater is not None:
            
            _query_params.append(('scoreFilter.coinfirmFilters.scoreGreater', score_filter_coinfirm_filters_score_greater))
            
        if score_filter_chainalysis_filters_score_greater is not None:
            
            _query_params.append(('scoreFilter.chainalysisFilters.scoreGreater', score_filter_chainalysis_filters_score_greater))
            
        if score_filter_elliptic_filters_score_greater is not None:
            
            _query_params.append(('scoreFilter.ellipticFilters.scoreGreater', score_filter_elliptic_filters_score_greater))
            
        if score_filter_trmlabs_filters_score_greater is not None:
            
            _query_params.append(('scoreFilter.trmlabsFilters.scoreGreater', score_filter_trmlabs_filters_score_greater))
            
        if blockchain is not None:
            
            _query_params.append(('blockchain', blockchain))
            
        if network is not None:
            
            _query_params.append(('network', network))
            
        # process the header parameters
        # process the form parameters
        # process the body parameter


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json'
                ]
            )


        # authentication setting
        _auth_settings: List[str] = [
            'ApiKeyTPV1'
        ]

        return self.api_client.param_serialize(
            method='GET',
            resource_path='/api/rest/v1/addresses/export',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def wallet_service_get_address(
        self,
        id: StrictStr,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> TgvalidatordGetAddressReply:
        """Get an address

        This endpoint accepts a unique address ID and returns the address alongside related information including:  * additional risk score data (if applicable). * information about the related wallet and currency. * related whitelisted address IDs.  To search across all addresses with query parameters, use the [List Addresses](https://docs.taurushq.com/protect-capital/reference/walletservice_getaddresses) endpoint.

        :param id: (required)
        :type id: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._wallet_service_get_address_serialize(
            id=id,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "TgvalidatordGetAddressReply",
            '400': "object",
            '401': "object",
            '403': "object",
            '404': "object",
            '500': "object",
            '503': "object",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def wallet_service_get_address_with_http_info(
        self,
        id: StrictStr,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[TgvalidatordGetAddressReply]:
        """Get an address

        This endpoint accepts a unique address ID and returns the address alongside related information including:  * additional risk score data (if applicable). * information about the related wallet and currency. * related whitelisted address IDs.  To search across all addresses with query parameters, use the [List Addresses](https://docs.taurushq.com/protect-capital/reference/walletservice_getaddresses) endpoint.

        :param id: (required)
        :type id: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._wallet_service_get_address_serialize(
            id=id,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "TgvalidatordGetAddressReply",
            '400': "object",
            '401': "object",
            '403': "object",
            '404': "object",
            '500': "object",
            '503': "object",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def wallet_service_get_address_without_preload_content(
        self,
        id: StrictStr,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """Get an address

        This endpoint accepts a unique address ID and returns the address alongside related information including:  * additional risk score data (if applicable). * information about the related wallet and currency. * related whitelisted address IDs.  To search across all addresses with query parameters, use the [List Addresses](https://docs.taurushq.com/protect-capital/reference/walletservice_getaddresses) endpoint.

        :param id: (required)
        :type id: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._wallet_service_get_address_serialize(
            id=id,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "TgvalidatordGetAddressReply",
            '400': "object",
            '401': "object",
            '403': "object",
            '404': "object",
            '500': "object",
            '503': "object",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _wallet_service_get_address_serialize(
        self,
        id,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        if id is not None:
            _path_params['id'] = id
        # process the query parameters
        # process the header parameters
        # process the form parameters
        # process the body parameter


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json'
                ]
            )


        # authentication setting
        _auth_settings: List[str] = [
            'ApiKeyTPV1'
        ]

        return self.api_client.param_serialize(
            method='GET',
            resource_path='/api/rest/v1/addresses/{id}',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def wallet_service_get_address_balance_history(
        self,
        id: StrictStr,
        interval_hours: Optional[StrictStr] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> TgvalidatordGetAddressBalanceHistoryReply:
        """List address' balances history

        This endpoint returns the balances history of a given address

        :param id: (required)
        :type id: str
        :param interval_hours:
        :type interval_hours: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._wallet_service_get_address_balance_history_serialize(
            id=id,
            interval_hours=interval_hours,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "TgvalidatordGetAddressBalanceHistoryReply",
            '400': "object",
            '401': "object",
            '403': "object",
            '404': "object",
            '500': "object",
            '503': "object",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def wallet_service_get_address_balance_history_with_http_info(
        self,
        id: StrictStr,
        interval_hours: Optional[StrictStr] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[TgvalidatordGetAddressBalanceHistoryReply]:
        """List address' balances history

        This endpoint returns the balances history of a given address

        :param id: (required)
        :type id: str
        :param interval_hours:
        :type interval_hours: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._wallet_service_get_address_balance_history_serialize(
            id=id,
            interval_hours=interval_hours,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "TgvalidatordGetAddressBalanceHistoryReply",
            '400': "object",
            '401': "object",
            '403': "object",
            '404': "object",
            '500': "object",
            '503': "object",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def wallet_service_get_address_balance_history_without_preload_content(
        self,
        id: StrictStr,
        interval_hours: Optional[StrictStr] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """List address' balances history

        This endpoint returns the balances history of a given address

        :param id: (required)
        :type id: str
        :param interval_hours:
        :type interval_hours: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._wallet_service_get_address_balance_history_serialize(
            id=id,
            interval_hours=interval_hours,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "TgvalidatordGetAddressBalanceHistoryReply",
            '400': "object",
            '401': "object",
            '403': "object",
            '404': "object",
            '500': "object",
            '503': "object",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _wallet_service_get_address_balance_history_serialize(
        self,
        id,
        interval_hours,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        if id is not None:
            _path_params['id'] = id
        # process the query parameters
        if interval_hours is not None:
            
            _query_params.append(('intervalHours', interval_hours))
            
        # process the header parameters
        # process the form parameters
        # process the body parameter


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json'
                ]
            )


        # authentication setting
        _auth_settings: List[str] = [
            'ApiKeyTPV1'
        ]

        return self.api_client.param_serialize(
            method='GET',
            resource_path='/api/rest/v1/addresses/{id}/balances/history',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def wallet_service_get_address_proof_of_reserve(
        self,
        id: StrictStr,
        challenge: Optional[StrictStr] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> TgvalidatordGetAddressProofOfReserveReply:
        """Get the proof of reserve of an address

        This endpoint returns the proof of reserve of an address. The relevance of response fields is specific to the request type.

        :param id: (required)
        :type id: str
        :param challenge:
        :type challenge: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._wallet_service_get_address_proof_of_reserve_serialize(
            id=id,
            challenge=challenge,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "TgvalidatordGetAddressProofOfReserveReply",
            '400': "object",
            '401': "object",
            '403': "object",
            '404': "object",
            '500': "object",
            '503': "object",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def wallet_service_get_address_proof_of_reserve_with_http_info(
        self,
        id: StrictStr,
        challenge: Optional[StrictStr] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[TgvalidatordGetAddressProofOfReserveReply]:
        """Get the proof of reserve of an address

        This endpoint returns the proof of reserve of an address. The relevance of response fields is specific to the request type.

        :param id: (required)
        :type id: str
        :param challenge:
        :type challenge: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._wallet_service_get_address_proof_of_reserve_serialize(
            id=id,
            challenge=challenge,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "TgvalidatordGetAddressProofOfReserveReply",
            '400': "object",
            '401': "object",
            '403': "object",
            '404': "object",
            '500': "object",
            '503': "object",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def wallet_service_get_address_proof_of_reserve_without_preload_content(
        self,
        id: StrictStr,
        challenge: Optional[StrictStr] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """Get the proof of reserve of an address

        This endpoint returns the proof of reserve of an address. The relevance of response fields is specific to the request type.

        :param id: (required)
        :type id: str
        :param challenge:
        :type challenge: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._wallet_service_get_address_proof_of_reserve_serialize(
            id=id,
            challenge=challenge,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "TgvalidatordGetAddressProofOfReserveReply",
            '400': "object",
            '401': "object",
            '403': "object",
            '404': "object",
            '500': "object",
            '503': "object",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _wallet_service_get_address_proof_of_reserve_serialize(
        self,
        id,
        challenge,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        if id is not None:
            _path_params['id'] = id
        # process the query parameters
        if challenge is not None:
            
            _query_params.append(('challenge', challenge))
            
        # process the header parameters
        # process the form parameters
        # process the body parameter


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json'
                ]
            )


        # authentication setting
        _auth_settings: List[str] = [
            'ApiKeyTPV1'
        ]

        return self.api_client.param_serialize(
            method='GET',
            resource_path='/api/rest/v1/addresses/{id}/proofofreserve',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def wallet_service_get_address_tokens(
        self,
        id: StrictStr,
        limit: Optional[StrictStr] = None,
        cursor: Optional[Union[StrictBytes, StrictStr]] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> TgvalidatordGetAddressTokensReply:
        """Get the list of tokens for an address

        This endpoint returns the list of tokens with their balances held by a given address.

        :param id: (required)
        :type id: str
        :param limit:
        :type limit: str
        :param cursor:
        :type cursor: bytearray
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._wallet_service_get_address_tokens_serialize(
            id=id,
            limit=limit,
            cursor=cursor,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "TgvalidatordGetAddressTokensReply",
            '400': "object",
            '401': "object",
            '403': "object",
            '404': "object",
            '500': "object",
            '503': "object",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def wallet_service_get_address_tokens_with_http_info(
        self,
        id: StrictStr,
        limit: Optional[StrictStr] = None,
        cursor: Optional[Union[StrictBytes, StrictStr]] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[TgvalidatordGetAddressTokensReply]:
        """Get the list of tokens for an address

        This endpoint returns the list of tokens with their balances held by a given address.

        :param id: (required)
        :type id: str
        :param limit:
        :type limit: str
        :param cursor:
        :type cursor: bytearray
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._wallet_service_get_address_tokens_serialize(
            id=id,
            limit=limit,
            cursor=cursor,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "TgvalidatordGetAddressTokensReply",
            '400': "object",
            '401': "object",
            '403': "object",
            '404': "object",
            '500': "object",
            '503': "object",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def wallet_service_get_address_tokens_without_preload_content(
        self,
        id: StrictStr,
        limit: Optional[StrictStr] = None,
        cursor: Optional[Union[StrictBytes, StrictStr]] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """Get the list of tokens for an address

        This endpoint returns the list of tokens with their balances held by a given address.

        :param id: (required)
        :type id: str
        :param limit:
        :type limit: str
        :param cursor:
        :type cursor: bytearray
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._wallet_service_get_address_tokens_serialize(
            id=id,
            limit=limit,
            cursor=cursor,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "TgvalidatordGetAddressTokensReply",
            '400': "object",
            '401': "object",
            '403': "object",
            '404': "object",
            '500': "object",
            '503': "object",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _wallet_service_get_address_tokens_serialize(
        self,
        id,
        limit,
        cursor,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        if id is not None:
            _path_params['id'] = id
        # process the query parameters
        if limit is not None:
            
            _query_params.append(('limit', limit))
            
        if cursor is not None:
            
            _query_params.append(('cursor', cursor))
            
        # process the header parameters
        # process the form parameters
        # process the body parameter


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json'
                ]
            )


        # authentication setting
        _auth_settings: List[str] = [
            'ApiKeyTPV1'
        ]

        return self.api_client.param_serialize(
            method='GET',
            resource_path='/api/rest/v1/addresses/{id}/tokens',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def wallet_service_get_address_utxos(
        self,
        id: StrictStr,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> TgvalidatordGetAddressUTXOsReply:
        """List UTXOs of an address

        This endpoint returns a list of UTXOs of a given address. In the case of the ADA blockchain, the value returned is the one from the native currency. Result is sorted by (address, id) DESC.

        :param id: (required)
        :type id: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._wallet_service_get_address_utxos_serialize(
            id=id,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "TgvalidatordGetAddressUTXOsReply",
            '400': "object",
            '401': "object",
            '403': "object",
            '404': "object",
            '500': "object",
            '503': "object",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def wallet_service_get_address_utxos_with_http_info(
        self,
        id: StrictStr,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[TgvalidatordGetAddressUTXOsReply]:
        """List UTXOs of an address

        This endpoint returns a list of UTXOs of a given address. In the case of the ADA blockchain, the value returned is the one from the native currency. Result is sorted by (address, id) DESC.

        :param id: (required)
        :type id: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._wallet_service_get_address_utxos_serialize(
            id=id,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "TgvalidatordGetAddressUTXOsReply",
            '400': "object",
            '401': "object",
            '403': "object",
            '404': "object",
            '500': "object",
            '503': "object",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def wallet_service_get_address_utxos_without_preload_content(
        self,
        id: StrictStr,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """List UTXOs of an address

        This endpoint returns a list of UTXOs of a given address. In the case of the ADA blockchain, the value returned is the one from the native currency. Result is sorted by (address, id) DESC.

        :param id: (required)
        :type id: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._wallet_service_get_address_utxos_serialize(
            id=id,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "TgvalidatordGetAddressUTXOsReply",
            '400': "object",
            '401': "object",
            '403': "object",
            '404': "object",
            '500': "object",
            '503': "object",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _wallet_service_get_address_utxos_serialize(
        self,
        id,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        if id is not None:
            _path_params['id'] = id
        # process the query parameters
        # process the header parameters
        # process the form parameters
        # process the body parameter


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json'
                ]
            )


        # authentication setting
        _auth_settings: List[str] = [
            'ApiKeyTPV1'
        ]

        return self.api_client.param_serialize(
            method='GET',
            resource_path='/api/rest/v1/addresses/{id}/utxos',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def wallet_service_get_addresses(
        self,
        currency: Annotated[Optional[StrictStr], Field(description="Filter on IDs or symbols of the currency")] = None,
        query: Optional[StrictStr] = None,
        limit: Optional[StrictStr] = None,
        offset: Optional[StrictStr] = None,
        score_provider: Annotated[Optional[StrictStr], Field(description="Deprecated. Use scoreFilter instead.")] = None,
        score_in_below: Annotated[Optional[StrictStr], Field(description="Deprecated. Use scoreFilter instead.")] = None,
        score_out_below: Annotated[Optional[StrictStr], Field(description="Deprecated. Use scoreFilter instead.")] = None,
        score_exclusive: Annotated[Optional[StrictBool], Field(description="Deprecated. Use scoreFilter instead.")] = None,
        only_positive_balance: Annotated[Optional[StrictBool], Field(description="Set this parameter to true to get only addresses with a positive unconfirmed balance")] = None,
        sort_by: Annotated[Optional[StrictStr], Field(description="Set this parameter to select the type on which you want to sort.The types accepted yet are: BALANCE and ADDRESSID")] = None,
        sort_order: Annotated[Optional[StrictStr], Field(description="Set this parameter to ASC to get the addresses sorted in ascending order or DESC to get them in descending order.")] = None,
        balance_below: Annotated[Optional[StrictStr], Field(description="Filter addresses and keep only addresses with a balance below the threshold.")] = None,
        balance_above: Annotated[Optional[StrictStr], Field(description="Filter addresses and keep only addresses with a balance above the threshold.")] = None,
        wallet_id: Optional[StrictStr] = None,
        customer_id: Optional[StrictStr] = None,
        coinfirm_score_greater: Annotated[Optional[StrictStr], Field(description="Deprecated. Use scoreFilter instead.")] = None,
        chainalysis_score_greater: Annotated[Optional[StrictStr], Field(description="Deprecated. Use scoreFilter instead.")] = None,
        tag_ids: Annotated[Optional[List[StrictStr]], Field(description="Filter addresses with a 'OR' combination of tag IDs")] = None,
        blockchain: Optional[StrictStr] = None,
        network: Optional[StrictStr] = None,
        address_ids: Annotated[Optional[List[StrictStr]], Field(description="Filter addresses with a list of address IDs.")] = None,
        nfts: Annotated[Optional[StrictStr], Field(description="One of include / exclude / only depending on whether you want to include addresses of type NFTs (or you want only those)")] = None,
        addresses: Annotated[Optional[List[StrictStr]], Field(description="Filter addresses with a list of blockchain addresses (hashes).The blockchain needs to be specified when using this filter.")] = None,
        score_filter_score_provider: Annotated[Optional[StrictStr], Field(description="Specify the score provider to filter on, or empty.Each provider has associated filter parameters that can be set.Supported values: `scorechain`, `coinfirm`, `chainalysis`, `elliptic`, `trmlabs`")] = None,
        score_filter_scorechain_filters_score_in_below: Annotated[Optional[StrictStr], Field(description="Filter addresses under a Scorechain incoming score threshold.")] = None,
        score_filter_scorechain_filters_score_out_below: Annotated[Optional[StrictStr], Field(description="Filter addresses under a Scorechain outgoing score threshold.")] = None,
        score_filter_scorechain_filters_score_exclusive: Annotated[Optional[StrictBool], Field(description="By default when both Scorechain scores scoreInBelow and scoreOutBelow are provided, it returns the addresses matching (scoreInBelow AND scoreOutBelow). When scoreExclusive is set to true, it will return the addresses matching (scoreInBelow OR scoreOutBelow).")] = None,
        score_filter_coinfirm_filters_score_greater: Annotated[Optional[StrictStr], Field(description="Filter addresses with a Coinfirm C-score above threshold.")] = None,
        score_filter_chainalysis_filters_score_greater: Annotated[Optional[StrictStr], Field(description="Filter addresses with a Chainalysis risk score above threshold.")] = None,
        score_filter_elliptic_filters_score_greater: Annotated[Optional[StrictStr], Field(description="Filter addresses with an Elliptic risk score above threshold.")] = None,
        score_filter_trmlabs_filters_score_greater: Annotated[Optional[StrictStr], Field(description="Filter addresses with an TRM Labs risk score above threshold.")] = None,
        attribute_filters_json: Annotated[Optional[StrictStr], Field(description="A JSON representation of a list of AttributeFilter objects. The filters are combined with an attributeFiltersOperator ('OR' by default). Each AttributeFilter can use different comparison operators: `=` (default if not specified), `<>` (not equal), `>` (greater than), `>=` (greater than or equal), `<` (less than), `<=` (less than or equal)")] = None,
        attribute_filters_operator: Annotated[Optional[StrictStr], Field(description="Specifies how attribute filters are combined. Accepted values: 'OR' (default), 'AND'.")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> TgvalidatordGetAddressesReply:
        """List addresses

        This endpoint returns a list of addresses

        :param currency: Filter on IDs or symbols of the currency
        :type currency: str
        :param query:
        :type query: str
        :param limit:
        :type limit: str
        :param offset:
        :type offset: str
        :param score_provider: Deprecated. Use scoreFilter instead.
        :type score_provider: str
        :param score_in_below: Deprecated. Use scoreFilter instead.
        :type score_in_below: str
        :param score_out_below: Deprecated. Use scoreFilter instead.
        :type score_out_below: str
        :param score_exclusive: Deprecated. Use scoreFilter instead.
        :type score_exclusive: bool
        :param only_positive_balance: Set this parameter to true to get only addresses with a positive unconfirmed balance
        :type only_positive_balance: bool
        :param sort_by: Set this parameter to select the type on which you want to sort.The types accepted yet are: BALANCE and ADDRESSID
        :type sort_by: str
        :param sort_order: Set this parameter to ASC to get the addresses sorted in ascending order or DESC to get them in descending order.
        :type sort_order: str
        :param balance_below: Filter addresses and keep only addresses with a balance below the threshold.
        :type balance_below: str
        :param balance_above: Filter addresses and keep only addresses with a balance above the threshold.
        :type balance_above: str
        :param wallet_id:
        :type wallet_id: str
        :param customer_id:
        :type customer_id: str
        :param coinfirm_score_greater: Deprecated. Use scoreFilter instead.
        :type coinfirm_score_greater: str
        :param chainalysis_score_greater: Deprecated. Use scoreFilter instead.
        :type chainalysis_score_greater: str
        :param tag_ids: Filter addresses with a 'OR' combination of tag IDs
        :type tag_ids: List[str]
        :param blockchain:
        :type blockchain: str
        :param network:
        :type network: str
        :param address_ids: Filter addresses with a list of address IDs.
        :type address_ids: List[str]
        :param nfts: One of include / exclude / only depending on whether you want to include addresses of type NFTs (or you want only those)
        :type nfts: str
        :param addresses: Filter addresses with a list of blockchain addresses (hashes).The blockchain needs to be specified when using this filter.
        :type addresses: List[str]
        :param score_filter_score_provider: Specify the score provider to filter on, or empty.Each provider has associated filter parameters that can be set.Supported values: `scorechain`, `coinfirm`, `chainalysis`, `elliptic`, `trmlabs`
        :type score_filter_score_provider: str
        :param score_filter_scorechain_filters_score_in_below: Filter addresses under a Scorechain incoming score threshold.
        :type score_filter_scorechain_filters_score_in_below: str
        :param score_filter_scorechain_filters_score_out_below: Filter addresses under a Scorechain outgoing score threshold.
        :type score_filter_scorechain_filters_score_out_below: str
        :param score_filter_scorechain_filters_score_exclusive: By default when both Scorechain scores scoreInBelow and scoreOutBelow are provided, it returns the addresses matching (scoreInBelow AND scoreOutBelow). When scoreExclusive is set to true, it will return the addresses matching (scoreInBelow OR scoreOutBelow).
        :type score_filter_scorechain_filters_score_exclusive: bool
        :param score_filter_coinfirm_filters_score_greater: Filter addresses with a Coinfirm C-score above threshold.
        :type score_filter_coinfirm_filters_score_greater: str
        :param score_filter_chainalysis_filters_score_greater: Filter addresses with a Chainalysis risk score above threshold.
        :type score_filter_chainalysis_filters_score_greater: str
        :param score_filter_elliptic_filters_score_greater: Filter addresses with an Elliptic risk score above threshold.
        :type score_filter_elliptic_filters_score_greater: str
        :param score_filter_trmlabs_filters_score_greater: Filter addresses with an TRM Labs risk score above threshold.
        :type score_filter_trmlabs_filters_score_greater: str
        :param attribute_filters_json: A JSON representation of a list of AttributeFilter objects. The filters are combined with an attributeFiltersOperator ('OR' by default). Each AttributeFilter can use different comparison operators: `=` (default if not specified), `<>` (not equal), `>` (greater than), `>=` (greater than or equal), `<` (less than), `<=` (less than or equal)
        :type attribute_filters_json: str
        :param attribute_filters_operator: Specifies how attribute filters are combined. Accepted values: 'OR' (default), 'AND'.
        :type attribute_filters_operator: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._wallet_service_get_addresses_serialize(
            currency=currency,
            query=query,
            limit=limit,
            offset=offset,
            score_provider=score_provider,
            score_in_below=score_in_below,
            score_out_below=score_out_below,
            score_exclusive=score_exclusive,
            only_positive_balance=only_positive_balance,
            sort_by=sort_by,
            sort_order=sort_order,
            balance_below=balance_below,
            balance_above=balance_above,
            wallet_id=wallet_id,
            customer_id=customer_id,
            coinfirm_score_greater=coinfirm_score_greater,
            chainalysis_score_greater=chainalysis_score_greater,
            tag_ids=tag_ids,
            blockchain=blockchain,
            network=network,
            address_ids=address_ids,
            nfts=nfts,
            addresses=addresses,
            score_filter_score_provider=score_filter_score_provider,
            score_filter_scorechain_filters_score_in_below=score_filter_scorechain_filters_score_in_below,
            score_filter_scorechain_filters_score_out_below=score_filter_scorechain_filters_score_out_below,
            score_filter_scorechain_filters_score_exclusive=score_filter_scorechain_filters_score_exclusive,
            score_filter_coinfirm_filters_score_greater=score_filter_coinfirm_filters_score_greater,
            score_filter_chainalysis_filters_score_greater=score_filter_chainalysis_filters_score_greater,
            score_filter_elliptic_filters_score_greater=score_filter_elliptic_filters_score_greater,
            score_filter_trmlabs_filters_score_greater=score_filter_trmlabs_filters_score_greater,
            attribute_filters_json=attribute_filters_json,
            attribute_filters_operator=attribute_filters_operator,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "TgvalidatordGetAddressesReply",
            '400': "object",
            '401': "object",
            '403': "object",
            '404': "object",
            '500': "object",
            '503': "object",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def wallet_service_get_addresses_with_http_info(
        self,
        currency: Annotated[Optional[StrictStr], Field(description="Filter on IDs or symbols of the currency")] = None,
        query: Optional[StrictStr] = None,
        limit: Optional[StrictStr] = None,
        offset: Optional[StrictStr] = None,
        score_provider: Annotated[Optional[StrictStr], Field(description="Deprecated. Use scoreFilter instead.")] = None,
        score_in_below: Annotated[Optional[StrictStr], Field(description="Deprecated. Use scoreFilter instead.")] = None,
        score_out_below: Annotated[Optional[StrictStr], Field(description="Deprecated. Use scoreFilter instead.")] = None,
        score_exclusive: Annotated[Optional[StrictBool], Field(description="Deprecated. Use scoreFilter instead.")] = None,
        only_positive_balance: Annotated[Optional[StrictBool], Field(description="Set this parameter to true to get only addresses with a positive unconfirmed balance")] = None,
        sort_by: Annotated[Optional[StrictStr], Field(description="Set this parameter to select the type on which you want to sort.The types accepted yet are: BALANCE and ADDRESSID")] = None,
        sort_order: Annotated[Optional[StrictStr], Field(description="Set this parameter to ASC to get the addresses sorted in ascending order or DESC to get them in descending order.")] = None,
        balance_below: Annotated[Optional[StrictStr], Field(description="Filter addresses and keep only addresses with a balance below the threshold.")] = None,
        balance_above: Annotated[Optional[StrictStr], Field(description="Filter addresses and keep only addresses with a balance above the threshold.")] = None,
        wallet_id: Optional[StrictStr] = None,
        customer_id: Optional[StrictStr] = None,
        coinfirm_score_greater: Annotated[Optional[StrictStr], Field(description="Deprecated. Use scoreFilter instead.")] = None,
        chainalysis_score_greater: Annotated[Optional[StrictStr], Field(description="Deprecated. Use scoreFilter instead.")] = None,
        tag_ids: Annotated[Optional[List[StrictStr]], Field(description="Filter addresses with a 'OR' combination of tag IDs")] = None,
        blockchain: Optional[StrictStr] = None,
        network: Optional[StrictStr] = None,
        address_ids: Annotated[Optional[List[StrictStr]], Field(description="Filter addresses with a list of address IDs.")] = None,
        nfts: Annotated[Optional[StrictStr], Field(description="One of include / exclude / only depending on whether you want to include addresses of type NFTs (or you want only those)")] = None,
        addresses: Annotated[Optional[List[StrictStr]], Field(description="Filter addresses with a list of blockchain addresses (hashes).The blockchain needs to be specified when using this filter.")] = None,
        score_filter_score_provider: Annotated[Optional[StrictStr], Field(description="Specify the score provider to filter on, or empty.Each provider has associated filter parameters that can be set.Supported values: `scorechain`, `coinfirm`, `chainalysis`, `elliptic`, `trmlabs`")] = None,
        score_filter_scorechain_filters_score_in_below: Annotated[Optional[StrictStr], Field(description="Filter addresses under a Scorechain incoming score threshold.")] = None,
        score_filter_scorechain_filters_score_out_below: Annotated[Optional[StrictStr], Field(description="Filter addresses under a Scorechain outgoing score threshold.")] = None,
        score_filter_scorechain_filters_score_exclusive: Annotated[Optional[StrictBool], Field(description="By default when both Scorechain scores scoreInBelow and scoreOutBelow are provided, it returns the addresses matching (scoreInBelow AND scoreOutBelow). When scoreExclusive is set to true, it will return the addresses matching (scoreInBelow OR scoreOutBelow).")] = None,
        score_filter_coinfirm_filters_score_greater: Annotated[Optional[StrictStr], Field(description="Filter addresses with a Coinfirm C-score above threshold.")] = None,
        score_filter_chainalysis_filters_score_greater: Annotated[Optional[StrictStr], Field(description="Filter addresses with a Chainalysis risk score above threshold.")] = None,
        score_filter_elliptic_filters_score_greater: Annotated[Optional[StrictStr], Field(description="Filter addresses with an Elliptic risk score above threshold.")] = None,
        score_filter_trmlabs_filters_score_greater: Annotated[Optional[StrictStr], Field(description="Filter addresses with an TRM Labs risk score above threshold.")] = None,
        attribute_filters_json: Annotated[Optional[StrictStr], Field(description="A JSON representation of a list of AttributeFilter objects. The filters are combined with an attributeFiltersOperator ('OR' by default). Each AttributeFilter can use different comparison operators: `=` (default if not specified), `<>` (not equal), `>` (greater than), `>=` (greater than or equal), `<` (less than), `<=` (less than or equal)")] = None,
        attribute_filters_operator: Annotated[Optional[StrictStr], Field(description="Specifies how attribute filters are combined. Accepted values: 'OR' (default), 'AND'.")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[TgvalidatordGetAddressesReply]:
        """List addresses

        This endpoint returns a list of addresses

        :param currency: Filter on IDs or symbols of the currency
        :type currency: str
        :param query:
        :type query: str
        :param limit:
        :type limit: str
        :param offset:
        :type offset: str
        :param score_provider: Deprecated. Use scoreFilter instead.
        :type score_provider: str
        :param score_in_below: Deprecated. Use scoreFilter instead.
        :type score_in_below: str
        :param score_out_below: Deprecated. Use scoreFilter instead.
        :type score_out_below: str
        :param score_exclusive: Deprecated. Use scoreFilter instead.
        :type score_exclusive: bool
        :param only_positive_balance: Set this parameter to true to get only addresses with a positive unconfirmed balance
        :type only_positive_balance: bool
        :param sort_by: Set this parameter to select the type on which you want to sort.The types accepted yet are: BALANCE and ADDRESSID
        :type sort_by: str
        :param sort_order: Set this parameter to ASC to get the addresses sorted in ascending order or DESC to get them in descending order.
        :type sort_order: str
        :param balance_below: Filter addresses and keep only addresses with a balance below the threshold.
        :type balance_below: str
        :param balance_above: Filter addresses and keep only addresses with a balance above the threshold.
        :type balance_above: str
        :param wallet_id:
        :type wallet_id: str
        :param customer_id:
        :type customer_id: str
        :param coinfirm_score_greater: Deprecated. Use scoreFilter instead.
        :type coinfirm_score_greater: str
        :param chainalysis_score_greater: Deprecated. Use scoreFilter instead.
        :type chainalysis_score_greater: str
        :param tag_ids: Filter addresses with a 'OR' combination of tag IDs
        :type tag_ids: List[str]
        :param blockchain:
        :type blockchain: str
        :param network:
        :type network: str
        :param address_ids: Filter addresses with a list of address IDs.
        :type address_ids: List[str]
        :param nfts: One of include / exclude / only depending on whether you want to include addresses of type NFTs (or you want only those)
        :type nfts: str
        :param addresses: Filter addresses with a list of blockchain addresses (hashes).The blockchain needs to be specified when using this filter.
        :type addresses: List[str]
        :param score_filter_score_provider: Specify the score provider to filter on, or empty.Each provider has associated filter parameters that can be set.Supported values: `scorechain`, `coinfirm`, `chainalysis`, `elliptic`, `trmlabs`
        :type score_filter_score_provider: str
        :param score_filter_scorechain_filters_score_in_below: Filter addresses under a Scorechain incoming score threshold.
        :type score_filter_scorechain_filters_score_in_below: str
        :param score_filter_scorechain_filters_score_out_below: Filter addresses under a Scorechain outgoing score threshold.
        :type score_filter_scorechain_filters_score_out_below: str
        :param score_filter_scorechain_filters_score_exclusive: By default when both Scorechain scores scoreInBelow and scoreOutBelow are provided, it returns the addresses matching (scoreInBelow AND scoreOutBelow). When scoreExclusive is set to true, it will return the addresses matching (scoreInBelow OR scoreOutBelow).
        :type score_filter_scorechain_filters_score_exclusive: bool
        :param score_filter_coinfirm_filters_score_greater: Filter addresses with a Coinfirm C-score above threshold.
        :type score_filter_coinfirm_filters_score_greater: str
        :param score_filter_chainalysis_filters_score_greater: Filter addresses with a Chainalysis risk score above threshold.
        :type score_filter_chainalysis_filters_score_greater: str
        :param score_filter_elliptic_filters_score_greater: Filter addresses with an Elliptic risk score above threshold.
        :type score_filter_elliptic_filters_score_greater: str
        :param score_filter_trmlabs_filters_score_greater: Filter addresses with an TRM Labs risk score above threshold.
        :type score_filter_trmlabs_filters_score_greater: str
        :param attribute_filters_json: A JSON representation of a list of AttributeFilter objects. The filters are combined with an attributeFiltersOperator ('OR' by default). Each AttributeFilter can use different comparison operators: `=` (default if not specified), `<>` (not equal), `>` (greater than), `>=` (greater than or equal), `<` (less than), `<=` (less than or equal)
        :type attribute_filters_json: str
        :param attribute_filters_operator: Specifies how attribute filters are combined. Accepted values: 'OR' (default), 'AND'.
        :type attribute_filters_operator: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._wallet_service_get_addresses_serialize(
            currency=currency,
            query=query,
            limit=limit,
            offset=offset,
            score_provider=score_provider,
            score_in_below=score_in_below,
            score_out_below=score_out_below,
            score_exclusive=score_exclusive,
            only_positive_balance=only_positive_balance,
            sort_by=sort_by,
            sort_order=sort_order,
            balance_below=balance_below,
            balance_above=balance_above,
            wallet_id=wallet_id,
            customer_id=customer_id,
            coinfirm_score_greater=coinfirm_score_greater,
            chainalysis_score_greater=chainalysis_score_greater,
            tag_ids=tag_ids,
            blockchain=blockchain,
            network=network,
            address_ids=address_ids,
            nfts=nfts,
            addresses=addresses,
            score_filter_score_provider=score_filter_score_provider,
            score_filter_scorechain_filters_score_in_below=score_filter_scorechain_filters_score_in_below,
            score_filter_scorechain_filters_score_out_below=score_filter_scorechain_filters_score_out_below,
            score_filter_scorechain_filters_score_exclusive=score_filter_scorechain_filters_score_exclusive,
            score_filter_coinfirm_filters_score_greater=score_filter_coinfirm_filters_score_greater,
            score_filter_chainalysis_filters_score_greater=score_filter_chainalysis_filters_score_greater,
            score_filter_elliptic_filters_score_greater=score_filter_elliptic_filters_score_greater,
            score_filter_trmlabs_filters_score_greater=score_filter_trmlabs_filters_score_greater,
            attribute_filters_json=attribute_filters_json,
            attribute_filters_operator=attribute_filters_operator,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "TgvalidatordGetAddressesReply",
            '400': "object",
            '401': "object",
            '403': "object",
            '404': "object",
            '500': "object",
            '503': "object",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def wallet_service_get_addresses_without_preload_content(
        self,
        currency: Annotated[Optional[StrictStr], Field(description="Filter on IDs or symbols of the currency")] = None,
        query: Optional[StrictStr] = None,
        limit: Optional[StrictStr] = None,
        offset: Optional[StrictStr] = None,
        score_provider: Annotated[Optional[StrictStr], Field(description="Deprecated. Use scoreFilter instead.")] = None,
        score_in_below: Annotated[Optional[StrictStr], Field(description="Deprecated. Use scoreFilter instead.")] = None,
        score_out_below: Annotated[Optional[StrictStr], Field(description="Deprecated. Use scoreFilter instead.")] = None,
        score_exclusive: Annotated[Optional[StrictBool], Field(description="Deprecated. Use scoreFilter instead.")] = None,
        only_positive_balance: Annotated[Optional[StrictBool], Field(description="Set this parameter to true to get only addresses with a positive unconfirmed balance")] = None,
        sort_by: Annotated[Optional[StrictStr], Field(description="Set this parameter to select the type on which you want to sort.The types accepted yet are: BALANCE and ADDRESSID")] = None,
        sort_order: Annotated[Optional[StrictStr], Field(description="Set this parameter to ASC to get the addresses sorted in ascending order or DESC to get them in descending order.")] = None,
        balance_below: Annotated[Optional[StrictStr], Field(description="Filter addresses and keep only addresses with a balance below the threshold.")] = None,
        balance_above: Annotated[Optional[StrictStr], Field(description="Filter addresses and keep only addresses with a balance above the threshold.")] = None,
        wallet_id: Optional[StrictStr] = None,
        customer_id: Optional[StrictStr] = None,
        coinfirm_score_greater: Annotated[Optional[StrictStr], Field(description="Deprecated. Use scoreFilter instead.")] = None,
        chainalysis_score_greater: Annotated[Optional[StrictStr], Field(description="Deprecated. Use scoreFilter instead.")] = None,
        tag_ids: Annotated[Optional[List[StrictStr]], Field(description="Filter addresses with a 'OR' combination of tag IDs")] = None,
        blockchain: Optional[StrictStr] = None,
        network: Optional[StrictStr] = None,
        address_ids: Annotated[Optional[List[StrictStr]], Field(description="Filter addresses with a list of address IDs.")] = None,
        nfts: Annotated[Optional[StrictStr], Field(description="One of include / exclude / only depending on whether you want to include addresses of type NFTs (or you want only those)")] = None,
        addresses: Annotated[Optional[List[StrictStr]], Field(description="Filter addresses with a list of blockchain addresses (hashes).The blockchain needs to be specified when using this filter.")] = None,
        score_filter_score_provider: Annotated[Optional[StrictStr], Field(description="Specify the score provider to filter on, or empty.Each provider has associated filter parameters that can be set.Supported values: `scorechain`, `coinfirm`, `chainalysis`, `elliptic`, `trmlabs`")] = None,
        score_filter_scorechain_filters_score_in_below: Annotated[Optional[StrictStr], Field(description="Filter addresses under a Scorechain incoming score threshold.")] = None,
        score_filter_scorechain_filters_score_out_below: Annotated[Optional[StrictStr], Field(description="Filter addresses under a Scorechain outgoing score threshold.")] = None,
        score_filter_scorechain_filters_score_exclusive: Annotated[Optional[StrictBool], Field(description="By default when both Scorechain scores scoreInBelow and scoreOutBelow are provided, it returns the addresses matching (scoreInBelow AND scoreOutBelow). When scoreExclusive is set to true, it will return the addresses matching (scoreInBelow OR scoreOutBelow).")] = None,
        score_filter_coinfirm_filters_score_greater: Annotated[Optional[StrictStr], Field(description="Filter addresses with a Coinfirm C-score above threshold.")] = None,
        score_filter_chainalysis_filters_score_greater: Annotated[Optional[StrictStr], Field(description="Filter addresses with a Chainalysis risk score above threshold.")] = None,
        score_filter_elliptic_filters_score_greater: Annotated[Optional[StrictStr], Field(description="Filter addresses with an Elliptic risk score above threshold.")] = None,
        score_filter_trmlabs_filters_score_greater: Annotated[Optional[StrictStr], Field(description="Filter addresses with an TRM Labs risk score above threshold.")] = None,
        attribute_filters_json: Annotated[Optional[StrictStr], Field(description="A JSON representation of a list of AttributeFilter objects. The filters are combined with an attributeFiltersOperator ('OR' by default). Each AttributeFilter can use different comparison operators: `=` (default if not specified), `<>` (not equal), `>` (greater than), `>=` (greater than or equal), `<` (less than), `<=` (less than or equal)")] = None,
        attribute_filters_operator: Annotated[Optional[StrictStr], Field(description="Specifies how attribute filters are combined. Accepted values: 'OR' (default), 'AND'.")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """List addresses

        This endpoint returns a list of addresses

        :param currency: Filter on IDs or symbols of the currency
        :type currency: str
        :param query:
        :type query: str
        :param limit:
        :type limit: str
        :param offset:
        :type offset: str
        :param score_provider: Deprecated. Use scoreFilter instead.
        :type score_provider: str
        :param score_in_below: Deprecated. Use scoreFilter instead.
        :type score_in_below: str
        :param score_out_below: Deprecated. Use scoreFilter instead.
        :type score_out_below: str
        :param score_exclusive: Deprecated. Use scoreFilter instead.
        :type score_exclusive: bool
        :param only_positive_balance: Set this parameter to true to get only addresses with a positive unconfirmed balance
        :type only_positive_balance: bool
        :param sort_by: Set this parameter to select the type on which you want to sort.The types accepted yet are: BALANCE and ADDRESSID
        :type sort_by: str
        :param sort_order: Set this parameter to ASC to get the addresses sorted in ascending order or DESC to get them in descending order.
        :type sort_order: str
        :param balance_below: Filter addresses and keep only addresses with a balance below the threshold.
        :type balance_below: str
        :param balance_above: Filter addresses and keep only addresses with a balance above the threshold.
        :type balance_above: str
        :param wallet_id:
        :type wallet_id: str
        :param customer_id:
        :type customer_id: str
        :param coinfirm_score_greater: Deprecated. Use scoreFilter instead.
        :type coinfirm_score_greater: str
        :param chainalysis_score_greater: Deprecated. Use scoreFilter instead.
        :type chainalysis_score_greater: str
        :param tag_ids: Filter addresses with a 'OR' combination of tag IDs
        :type tag_ids: List[str]
        :param blockchain:
        :type blockchain: str
        :param network:
        :type network: str
        :param address_ids: Filter addresses with a list of address IDs.
        :type address_ids: List[str]
        :param nfts: One of include / exclude / only depending on whether you want to include addresses of type NFTs (or you want only those)
        :type nfts: str
        :param addresses: Filter addresses with a list of blockchain addresses (hashes).The blockchain needs to be specified when using this filter.
        :type addresses: List[str]
        :param score_filter_score_provider: Specify the score provider to filter on, or empty.Each provider has associated filter parameters that can be set.Supported values: `scorechain`, `coinfirm`, `chainalysis`, `elliptic`, `trmlabs`
        :type score_filter_score_provider: str
        :param score_filter_scorechain_filters_score_in_below: Filter addresses under a Scorechain incoming score threshold.
        :type score_filter_scorechain_filters_score_in_below: str
        :param score_filter_scorechain_filters_score_out_below: Filter addresses under a Scorechain outgoing score threshold.
        :type score_filter_scorechain_filters_score_out_below: str
        :param score_filter_scorechain_filters_score_exclusive: By default when both Scorechain scores scoreInBelow and scoreOutBelow are provided, it returns the addresses matching (scoreInBelow AND scoreOutBelow). When scoreExclusive is set to true, it will return the addresses matching (scoreInBelow OR scoreOutBelow).
        :type score_filter_scorechain_filters_score_exclusive: bool
        :param score_filter_coinfirm_filters_score_greater: Filter addresses with a Coinfirm C-score above threshold.
        :type score_filter_coinfirm_filters_score_greater: str
        :param score_filter_chainalysis_filters_score_greater: Filter addresses with a Chainalysis risk score above threshold.
        :type score_filter_chainalysis_filters_score_greater: str
        :param score_filter_elliptic_filters_score_greater: Filter addresses with an Elliptic risk score above threshold.
        :type score_filter_elliptic_filters_score_greater: str
        :param score_filter_trmlabs_filters_score_greater: Filter addresses with an TRM Labs risk score above threshold.
        :type score_filter_trmlabs_filters_score_greater: str
        :param attribute_filters_json: A JSON representation of a list of AttributeFilter objects. The filters are combined with an attributeFiltersOperator ('OR' by default). Each AttributeFilter can use different comparison operators: `=` (default if not specified), `<>` (not equal), `>` (greater than), `>=` (greater than or equal), `<` (less than), `<=` (less than or equal)
        :type attribute_filters_json: str
        :param attribute_filters_operator: Specifies how attribute filters are combined. Accepted values: 'OR' (default), 'AND'.
        :type attribute_filters_operator: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._wallet_service_get_addresses_serialize(
            currency=currency,
            query=query,
            limit=limit,
            offset=offset,
            score_provider=score_provider,
            score_in_below=score_in_below,
            score_out_below=score_out_below,
            score_exclusive=score_exclusive,
            only_positive_balance=only_positive_balance,
            sort_by=sort_by,
            sort_order=sort_order,
            balance_below=balance_below,
            balance_above=balance_above,
            wallet_id=wallet_id,
            customer_id=customer_id,
            coinfirm_score_greater=coinfirm_score_greater,
            chainalysis_score_greater=chainalysis_score_greater,
            tag_ids=tag_ids,
            blockchain=blockchain,
            network=network,
            address_ids=address_ids,
            nfts=nfts,
            addresses=addresses,
            score_filter_score_provider=score_filter_score_provider,
            score_filter_scorechain_filters_score_in_below=score_filter_scorechain_filters_score_in_below,
            score_filter_scorechain_filters_score_out_below=score_filter_scorechain_filters_score_out_below,
            score_filter_scorechain_filters_score_exclusive=score_filter_scorechain_filters_score_exclusive,
            score_filter_coinfirm_filters_score_greater=score_filter_coinfirm_filters_score_greater,
            score_filter_chainalysis_filters_score_greater=score_filter_chainalysis_filters_score_greater,
            score_filter_elliptic_filters_score_greater=score_filter_elliptic_filters_score_greater,
            score_filter_trmlabs_filters_score_greater=score_filter_trmlabs_filters_score_greater,
            attribute_filters_json=attribute_filters_json,
            attribute_filters_operator=attribute_filters_operator,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "TgvalidatordGetAddressesReply",
            '400': "object",
            '401': "object",
            '403': "object",
            '404': "object",
            '500': "object",
            '503': "object",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _wallet_service_get_addresses_serialize(
        self,
        currency,
        query,
        limit,
        offset,
        score_provider,
        score_in_below,
        score_out_below,
        score_exclusive,
        only_positive_balance,
        sort_by,
        sort_order,
        balance_below,
        balance_above,
        wallet_id,
        customer_id,
        coinfirm_score_greater,
        chainalysis_score_greater,
        tag_ids,
        blockchain,
        network,
        address_ids,
        nfts,
        addresses,
        score_filter_score_provider,
        score_filter_scorechain_filters_score_in_below,
        score_filter_scorechain_filters_score_out_below,
        score_filter_scorechain_filters_score_exclusive,
        score_filter_coinfirm_filters_score_greater,
        score_filter_chainalysis_filters_score_greater,
        score_filter_elliptic_filters_score_greater,
        score_filter_trmlabs_filters_score_greater,
        attribute_filters_json,
        attribute_filters_operator,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
            'tagIDs': 'multi',
            'addressIds': 'multi',
            'addresses': 'multi',
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        # process the query parameters
        if currency is not None:
            
            _query_params.append(('currency', currency))
            
        if query is not None:
            
            _query_params.append(('query', query))
            
        if limit is not None:
            
            _query_params.append(('limit', limit))
            
        if offset is not None:
            
            _query_params.append(('offset', offset))
            
        if score_provider is not None:
            
            _query_params.append(('scoreProvider', score_provider))
            
        if score_in_below is not None:
            
            _query_params.append(('scoreInBelow', score_in_below))
            
        if score_out_below is not None:
            
            _query_params.append(('scoreOutBelow', score_out_below))
            
        if score_exclusive is not None:
            
            _query_params.append(('scoreExclusive', score_exclusive))
            
        if only_positive_balance is not None:
            
            _query_params.append(('onlyPositiveBalance', only_positive_balance))
            
        if sort_by is not None:
            
            _query_params.append(('sortBy', sort_by))
            
        if sort_order is not None:
            
            _query_params.append(('sortOrder', sort_order))
            
        if balance_below is not None:
            
            _query_params.append(('balanceBelow', balance_below))
            
        if balance_above is not None:
            
            _query_params.append(('balanceAbove', balance_above))
            
        if wallet_id is not None:
            
            _query_params.append(('walletId', wallet_id))
            
        if customer_id is not None:
            
            _query_params.append(('customerId', customer_id))
            
        if coinfirm_score_greater is not None:
            
            _query_params.append(('coinfirmScoreGreater', coinfirm_score_greater))
            
        if chainalysis_score_greater is not None:
            
            _query_params.append(('chainalysisScoreGreater', chainalysis_score_greater))
            
        if tag_ids is not None:
            
            _query_params.append(('tagIDs', tag_ids))
            
        if blockchain is not None:
            
            _query_params.append(('blockchain', blockchain))
            
        if network is not None:
            
            _query_params.append(('network', network))
            
        if address_ids is not None:
            
            _query_params.append(('addressIds', address_ids))
            
        if nfts is not None:
            
            _query_params.append(('nfts', nfts))
            
        if addresses is not None:
            
            _query_params.append(('addresses', addresses))
            
        if score_filter_score_provider is not None:
            
            _query_params.append(('scoreFilter.scoreProvider', score_filter_score_provider))
            
        if score_filter_scorechain_filters_score_in_below is not None:
            
            _query_params.append(('scoreFilter.scorechainFilters.scoreInBelow', score_filter_scorechain_filters_score_in_below))
            
        if score_filter_scorechain_filters_score_out_below is not None:
            
            _query_params.append(('scoreFilter.scorechainFilters.scoreOutBelow', score_filter_scorechain_filters_score_out_below))
            
        if score_filter_scorechain_filters_score_exclusive is not None:
            
            _query_params.append(('scoreFilter.scorechainFilters.scoreExclusive', score_filter_scorechain_filters_score_exclusive))
            
        if score_filter_coinfirm_filters_score_greater is not None:
            
            _query_params.append(('scoreFilter.coinfirmFilters.scoreGreater', score_filter_coinfirm_filters_score_greater))
            
        if score_filter_chainalysis_filters_score_greater is not None:
            
            _query_params.append(('scoreFilter.chainalysisFilters.scoreGreater', score_filter_chainalysis_filters_score_greater))
            
        if score_filter_elliptic_filters_score_greater is not None:
            
            _query_params.append(('scoreFilter.ellipticFilters.scoreGreater', score_filter_elliptic_filters_score_greater))
            
        if score_filter_trmlabs_filters_score_greater is not None:
            
            _query_params.append(('scoreFilter.trmlabsFilters.scoreGreater', score_filter_trmlabs_filters_score_greater))
            
        if attribute_filters_json is not None:
            
            _query_params.append(('attributeFiltersJson', attribute_filters_json))
            
        if attribute_filters_operator is not None:
            
            _query_params.append(('attributeFiltersOperator', attribute_filters_operator))
            
        # process the header parameters
        # process the form parameters
        # process the body parameter


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json'
                ]
            )


        # authentication setting
        _auth_settings: List[str] = [
            'ApiKeyTPV1'
        ]

        return self.api_client.param_serialize(
            method='GET',
            resource_path='/api/rest/v1/addresses',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def wallet_service_get_addresses_proof_of_reserve(
        self,
        blockchain: StrictStr,
        addresses: Optional[List[StrictStr]] = None,
        challenge: Optional[StrictStr] = None,
        network: Optional[StrictStr] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> TgvalidatordGetAddressesProofOfReserveReply:
        """Get the proof of reserve of a list of addresses

        This endpoint returns the proof of reserve for a list of addresses.  The relevance of response fields is specific to the request type.

        :param blockchain: (required)
        :type blockchain: str
        :param addresses:
        :type addresses: List[str]
        :param challenge:
        :type challenge: str
        :param network:
        :type network: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._wallet_service_get_addresses_proof_of_reserve_serialize(
            blockchain=blockchain,
            addresses=addresses,
            challenge=challenge,
            network=network,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "TgvalidatordGetAddressesProofOfReserveReply",
            '400': "object",
            '401': "object",
            '403': "object",
            '404': "object",
            '500': "object",
            '503': "object",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def wallet_service_get_addresses_proof_of_reserve_with_http_info(
        self,
        blockchain: StrictStr,
        addresses: Optional[List[StrictStr]] = None,
        challenge: Optional[StrictStr] = None,
        network: Optional[StrictStr] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[TgvalidatordGetAddressesProofOfReserveReply]:
        """Get the proof of reserve of a list of addresses

        This endpoint returns the proof of reserve for a list of addresses.  The relevance of response fields is specific to the request type.

        :param blockchain: (required)
        :type blockchain: str
        :param addresses:
        :type addresses: List[str]
        :param challenge:
        :type challenge: str
        :param network:
        :type network: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._wallet_service_get_addresses_proof_of_reserve_serialize(
            blockchain=blockchain,
            addresses=addresses,
            challenge=challenge,
            network=network,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "TgvalidatordGetAddressesProofOfReserveReply",
            '400': "object",
            '401': "object",
            '403': "object",
            '404': "object",
            '500': "object",
            '503': "object",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def wallet_service_get_addresses_proof_of_reserve_without_preload_content(
        self,
        blockchain: StrictStr,
        addresses: Optional[List[StrictStr]] = None,
        challenge: Optional[StrictStr] = None,
        network: Optional[StrictStr] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """Get the proof of reserve of a list of addresses

        This endpoint returns the proof of reserve for a list of addresses.  The relevance of response fields is specific to the request type.

        :param blockchain: (required)
        :type blockchain: str
        :param addresses:
        :type addresses: List[str]
        :param challenge:
        :type challenge: str
        :param network:
        :type network: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._wallet_service_get_addresses_proof_of_reserve_serialize(
            blockchain=blockchain,
            addresses=addresses,
            challenge=challenge,
            network=network,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "TgvalidatordGetAddressesProofOfReserveReply",
            '400': "object",
            '401': "object",
            '403': "object",
            '404': "object",
            '500': "object",
            '503': "object",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _wallet_service_get_addresses_proof_of_reserve_serialize(
        self,
        blockchain,
        addresses,
        challenge,
        network,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
            'addresses': 'multi',
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        if blockchain is not None:
            _path_params['blockchain'] = blockchain
        # process the query parameters
        if addresses is not None:
            
            _query_params.append(('addresses', addresses))
            
        if challenge is not None:
            
            _query_params.append(('challenge', challenge))
            
        if network is not None:
            
            _query_params.append(('network', network))
            
        # process the header parameters
        # process the form parameters
        # process the body parameter


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json'
                ]
            )


        # authentication setting
        _auth_settings: List[str] = [
            'ApiKeyTPV1'
        ]

        return self.api_client.param_serialize(
            method='GET',
            resource_path='/api/rest/v1/{blockchain}/addresses/proofofreserve',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def wallet_service_get_addresses_status(
        self,
        wallet_ids: Optional[List[StrictStr]] = None,
        address_ids: Optional[List[StrictStr]] = None,
        currency_ids: Optional[List[StrictStr]] = None,
        sorting_sort_order: Optional[StrictStr] = None,
        cursor_current_page: Annotated[Optional[StrictStr], Field(description="Base64-encoded string representing the current window of data")] = None,
        cursor_page_request: Annotated[Optional[StrictStr], Field(description="The page to request, w.r.t the current page. Can be one of `FIRST`, `PREVIOUS`, `NEXT`, `LAST`")] = None,
        cursor_page_size: Annotated[Optional[StrictStr], Field(description="The size of the page requested. The handling service should impose a hard limit on this")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> TgvalidatordGetAddressesStatusReply:
        """List addresses's status

        This endpoint returns a list of addresses with their status

        :param wallet_ids:
        :type wallet_ids: List[str]
        :param address_ids:
        :type address_ids: List[str]
        :param currency_ids:
        :type currency_ids: List[str]
        :param sorting_sort_order:
        :type sorting_sort_order: str
        :param cursor_current_page: Base64-encoded string representing the current window of data
        :type cursor_current_page: str
        :param cursor_page_request: The page to request, w.r.t the current page. Can be one of `FIRST`, `PREVIOUS`, `NEXT`, `LAST`
        :type cursor_page_request: str
        :param cursor_page_size: The size of the page requested. The handling service should impose a hard limit on this
        :type cursor_page_size: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._wallet_service_get_addresses_status_serialize(
            wallet_ids=wallet_ids,
            address_ids=address_ids,
            currency_ids=currency_ids,
            sorting_sort_order=sorting_sort_order,
            cursor_current_page=cursor_current_page,
            cursor_page_request=cursor_page_request,
            cursor_page_size=cursor_page_size,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "TgvalidatordGetAddressesStatusReply",
            '400': "object",
            '401': "object",
            '403': "object",
            '404': "object",
            '500': "object",
            '503': "object",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def wallet_service_get_addresses_status_with_http_info(
        self,
        wallet_ids: Optional[List[StrictStr]] = None,
        address_ids: Optional[List[StrictStr]] = None,
        currency_ids: Optional[List[StrictStr]] = None,
        sorting_sort_order: Optional[StrictStr] = None,
        cursor_current_page: Annotated[Optional[StrictStr], Field(description="Base64-encoded string representing the current window of data")] = None,
        cursor_page_request: Annotated[Optional[StrictStr], Field(description="The page to request, w.r.t the current page. Can be one of `FIRST`, `PREVIOUS`, `NEXT`, `LAST`")] = None,
        cursor_page_size: Annotated[Optional[StrictStr], Field(description="The size of the page requested. The handling service should impose a hard limit on this")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[TgvalidatordGetAddressesStatusReply]:
        """List addresses's status

        This endpoint returns a list of addresses with their status

        :param wallet_ids:
        :type wallet_ids: List[str]
        :param address_ids:
        :type address_ids: List[str]
        :param currency_ids:
        :type currency_ids: List[str]
        :param sorting_sort_order:
        :type sorting_sort_order: str
        :param cursor_current_page: Base64-encoded string representing the current window of data
        :type cursor_current_page: str
        :param cursor_page_request: The page to request, w.r.t the current page. Can be one of `FIRST`, `PREVIOUS`, `NEXT`, `LAST`
        :type cursor_page_request: str
        :param cursor_page_size: The size of the page requested. The handling service should impose a hard limit on this
        :type cursor_page_size: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._wallet_service_get_addresses_status_serialize(
            wallet_ids=wallet_ids,
            address_ids=address_ids,
            currency_ids=currency_ids,
            sorting_sort_order=sorting_sort_order,
            cursor_current_page=cursor_current_page,
            cursor_page_request=cursor_page_request,
            cursor_page_size=cursor_page_size,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "TgvalidatordGetAddressesStatusReply",
            '400': "object",
            '401': "object",
            '403': "object",
            '404': "object",
            '500': "object",
            '503': "object",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def wallet_service_get_addresses_status_without_preload_content(
        self,
        wallet_ids: Optional[List[StrictStr]] = None,
        address_ids: Optional[List[StrictStr]] = None,
        currency_ids: Optional[List[StrictStr]] = None,
        sorting_sort_order: Optional[StrictStr] = None,
        cursor_current_page: Annotated[Optional[StrictStr], Field(description="Base64-encoded string representing the current window of data")] = None,
        cursor_page_request: Annotated[Optional[StrictStr], Field(description="The page to request, w.r.t the current page. Can be one of `FIRST`, `PREVIOUS`, `NEXT`, `LAST`")] = None,
        cursor_page_size: Annotated[Optional[StrictStr], Field(description="The size of the page requested. The handling service should impose a hard limit on this")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """List addresses's status

        This endpoint returns a list of addresses with their status

        :param wallet_ids:
        :type wallet_ids: List[str]
        :param address_ids:
        :type address_ids: List[str]
        :param currency_ids:
        :type currency_ids: List[str]
        :param sorting_sort_order:
        :type sorting_sort_order: str
        :param cursor_current_page: Base64-encoded string representing the current window of data
        :type cursor_current_page: str
        :param cursor_page_request: The page to request, w.r.t the current page. Can be one of `FIRST`, `PREVIOUS`, `NEXT`, `LAST`
        :type cursor_page_request: str
        :param cursor_page_size: The size of the page requested. The handling service should impose a hard limit on this
        :type cursor_page_size: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._wallet_service_get_addresses_status_serialize(
            wallet_ids=wallet_ids,
            address_ids=address_ids,
            currency_ids=currency_ids,
            sorting_sort_order=sorting_sort_order,
            cursor_current_page=cursor_current_page,
            cursor_page_request=cursor_page_request,
            cursor_page_size=cursor_page_size,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "TgvalidatordGetAddressesStatusReply",
            '400': "object",
            '401': "object",
            '403': "object",
            '404': "object",
            '500': "object",
            '503': "object",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _wallet_service_get_addresses_status_serialize(
        self,
        wallet_ids,
        address_ids,
        currency_ids,
        sorting_sort_order,
        cursor_current_page,
        cursor_page_request,
        cursor_page_size,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
            'walletIds': 'multi',
            'addressIds': 'multi',
            'currencyIds': 'multi',
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        # process the query parameters
        if wallet_ids is not None:
            
            _query_params.append(('walletIds', wallet_ids))
            
        if address_ids is not None:
            
            _query_params.append(('addressIds', address_ids))
            
        if currency_ids is not None:
            
            _query_params.append(('currencyIds', currency_ids))
            
        if sorting_sort_order is not None:
            
            _query_params.append(('sorting.sortOrder', sorting_sort_order))
            
        if cursor_current_page is not None:
            
            _query_params.append(('cursor.currentPage', cursor_current_page))
            
        if cursor_page_request is not None:
            
            _query_params.append(('cursor.pageRequest', cursor_page_request))
            
        if cursor_page_size is not None:
            
            _query_params.append(('cursor.pageSize', cursor_page_size))
            
        # process the header parameters
        # process the form parameters
        # process the body parameter


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json'
                ]
            )


        # authentication setting
        _auth_settings: List[str] = [
            'ApiKeyTPV1'
        ]

        return self.api_client.param_serialize(
            method='GET',
            resource_path='/api/rest/v1/addresses/status',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def wallet_service_get_light_addresses(
        self,
        unique_currency_filter_blockchain: Annotated[StrictStr, Field(description="Required: The Blockchain to filter by (e.g. ETH, BTC). Can be found using the blockchain endpoint `/api/rest/v1/blockchains`")],
        unique_currency_filter_network: Annotated[StrictStr, Field(description="Required: Network or environment the currency is used on (e.g. 'mainnet', 'testnet').")],
        currency_id: Annotated[Optional[StrictStr], Field(description="One of the currencyID or uniqueCurrencyFilter fields must be provided")] = None,
        unique_currency_filter_token_contract_address: Annotated[Optional[StrictStr], Field(description="If this parameter is set, the currency returned will be a token with the specified contract address. If not set, the currency returned will be the native currency of the blockchain.")] = None,
        unique_currency_filter_token_id: Annotated[Optional[StrictStr], Field(description="For some blockchains (ex. ALGO, XTZ) a tokenContractAddress might contain multiple assets. The tokenID is used to differentiate between those assets. If not set, the currency returned won't have any tokenID defined.")] = None,
        addresses: Optional[List[StrictStr]] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> TgvalidatordGetLightAddressesReply:
        """List light addresses

        This endpoint returns a list of addresses with light information filtered by a unique currency and a list of addresses. The light address information mainly contains the identifiers. There is no balance, risk score or attributes.

        :param unique_currency_filter_blockchain: Required: The Blockchain to filter by (e.g. ETH, BTC). Can be found using the blockchain endpoint `/api/rest/v1/blockchains` (required)
        :type unique_currency_filter_blockchain: str
        :param unique_currency_filter_network: Required: Network or environment the currency is used on (e.g. 'mainnet', 'testnet'). (required)
        :type unique_currency_filter_network: str
        :param currency_id: One of the currencyID or uniqueCurrencyFilter fields must be provided
        :type currency_id: str
        :param unique_currency_filter_token_contract_address: If this parameter is set, the currency returned will be a token with the specified contract address. If not set, the currency returned will be the native currency of the blockchain.
        :type unique_currency_filter_token_contract_address: str
        :param unique_currency_filter_token_id: For some blockchains (ex. ALGO, XTZ) a tokenContractAddress might contain multiple assets. The tokenID is used to differentiate between those assets. If not set, the currency returned won't have any tokenID defined.
        :type unique_currency_filter_token_id: str
        :param addresses:
        :type addresses: List[str]
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._wallet_service_get_light_addresses_serialize(
            unique_currency_filter_blockchain=unique_currency_filter_blockchain,
            unique_currency_filter_network=unique_currency_filter_network,
            currency_id=currency_id,
            unique_currency_filter_token_contract_address=unique_currency_filter_token_contract_address,
            unique_currency_filter_token_id=unique_currency_filter_token_id,
            addresses=addresses,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "TgvalidatordGetLightAddressesReply",
            '400': "object",
            '401': "object",
            '403': "object",
            '404': "object",
            '500': "object",
            '503': "object",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def wallet_service_get_light_addresses_with_http_info(
        self,
        unique_currency_filter_blockchain: Annotated[StrictStr, Field(description="Required: The Blockchain to filter by (e.g. ETH, BTC). Can be found using the blockchain endpoint `/api/rest/v1/blockchains`")],
        unique_currency_filter_network: Annotated[StrictStr, Field(description="Required: Network or environment the currency is used on (e.g. 'mainnet', 'testnet').")],
        currency_id: Annotated[Optional[StrictStr], Field(description="One of the currencyID or uniqueCurrencyFilter fields must be provided")] = None,
        unique_currency_filter_token_contract_address: Annotated[Optional[StrictStr], Field(description="If this parameter is set, the currency returned will be a token with the specified contract address. If not set, the currency returned will be the native currency of the blockchain.")] = None,
        unique_currency_filter_token_id: Annotated[Optional[StrictStr], Field(description="For some blockchains (ex. ALGO, XTZ) a tokenContractAddress might contain multiple assets. The tokenID is used to differentiate between those assets. If not set, the currency returned won't have any tokenID defined.")] = None,
        addresses: Optional[List[StrictStr]] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[TgvalidatordGetLightAddressesReply]:
        """List light addresses

        This endpoint returns a list of addresses with light information filtered by a unique currency and a list of addresses. The light address information mainly contains the identifiers. There is no balance, risk score or attributes.

        :param unique_currency_filter_blockchain: Required: The Blockchain to filter by (e.g. ETH, BTC). Can be found using the blockchain endpoint `/api/rest/v1/blockchains` (required)
        :type unique_currency_filter_blockchain: str
        :param unique_currency_filter_network: Required: Network or environment the currency is used on (e.g. 'mainnet', 'testnet'). (required)
        :type unique_currency_filter_network: str
        :param currency_id: One of the currencyID or uniqueCurrencyFilter fields must be provided
        :type currency_id: str
        :param unique_currency_filter_token_contract_address: If this parameter is set, the currency returned will be a token with the specified contract address. If not set, the currency returned will be the native currency of the blockchain.
        :type unique_currency_filter_token_contract_address: str
        :param unique_currency_filter_token_id: For some blockchains (ex. ALGO, XTZ) a tokenContractAddress might contain multiple assets. The tokenID is used to differentiate between those assets. If not set, the currency returned won't have any tokenID defined.
        :type unique_currency_filter_token_id: str
        :param addresses:
        :type addresses: List[str]
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._wallet_service_get_light_addresses_serialize(
            unique_currency_filter_blockchain=unique_currency_filter_blockchain,
            unique_currency_filter_network=unique_currency_filter_network,
            currency_id=currency_id,
            unique_currency_filter_token_contract_address=unique_currency_filter_token_contract_address,
            unique_currency_filter_token_id=unique_currency_filter_token_id,
            addresses=addresses,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "TgvalidatordGetLightAddressesReply",
            '400': "object",
            '401': "object",
            '403': "object",
            '404': "object",
            '500': "object",
            '503': "object",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def wallet_service_get_light_addresses_without_preload_content(
        self,
        unique_currency_filter_blockchain: Annotated[StrictStr, Field(description="Required: The Blockchain to filter by (e.g. ETH, BTC). Can be found using the blockchain endpoint `/api/rest/v1/blockchains`")],
        unique_currency_filter_network: Annotated[StrictStr, Field(description="Required: Network or environment the currency is used on (e.g. 'mainnet', 'testnet').")],
        currency_id: Annotated[Optional[StrictStr], Field(description="One of the currencyID or uniqueCurrencyFilter fields must be provided")] = None,
        unique_currency_filter_token_contract_address: Annotated[Optional[StrictStr], Field(description="If this parameter is set, the currency returned will be a token with the specified contract address. If not set, the currency returned will be the native currency of the blockchain.")] = None,
        unique_currency_filter_token_id: Annotated[Optional[StrictStr], Field(description="For some blockchains (ex. ALGO, XTZ) a tokenContractAddress might contain multiple assets. The tokenID is used to differentiate between those assets. If not set, the currency returned won't have any tokenID defined.")] = None,
        addresses: Optional[List[StrictStr]] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """List light addresses

        This endpoint returns a list of addresses with light information filtered by a unique currency and a list of addresses. The light address information mainly contains the identifiers. There is no balance, risk score or attributes.

        :param unique_currency_filter_blockchain: Required: The Blockchain to filter by (e.g. ETH, BTC). Can be found using the blockchain endpoint `/api/rest/v1/blockchains` (required)
        :type unique_currency_filter_blockchain: str
        :param unique_currency_filter_network: Required: Network or environment the currency is used on (e.g. 'mainnet', 'testnet'). (required)
        :type unique_currency_filter_network: str
        :param currency_id: One of the currencyID or uniqueCurrencyFilter fields must be provided
        :type currency_id: str
        :param unique_currency_filter_token_contract_address: If this parameter is set, the currency returned will be a token with the specified contract address. If not set, the currency returned will be the native currency of the blockchain.
        :type unique_currency_filter_token_contract_address: str
        :param unique_currency_filter_token_id: For some blockchains (ex. ALGO, XTZ) a tokenContractAddress might contain multiple assets. The tokenID is used to differentiate between those assets. If not set, the currency returned won't have any tokenID defined.
        :type unique_currency_filter_token_id: str
        :param addresses:
        :type addresses: List[str]
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._wallet_service_get_light_addresses_serialize(
            unique_currency_filter_blockchain=unique_currency_filter_blockchain,
            unique_currency_filter_network=unique_currency_filter_network,
            currency_id=currency_id,
            unique_currency_filter_token_contract_address=unique_currency_filter_token_contract_address,
            unique_currency_filter_token_id=unique_currency_filter_token_id,
            addresses=addresses,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "TgvalidatordGetLightAddressesReply",
            '400': "object",
            '401': "object",
            '403': "object",
            '404': "object",
            '500': "object",
            '503': "object",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _wallet_service_get_light_addresses_serialize(
        self,
        unique_currency_filter_blockchain,
        unique_currency_filter_network,
        currency_id,
        unique_currency_filter_token_contract_address,
        unique_currency_filter_token_id,
        addresses,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
            'addresses': 'multi',
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        # process the query parameters
        if currency_id is not None:
            
            _query_params.append(('currencyID', currency_id))
            
        if unique_currency_filter_blockchain is not None:
            
            _query_params.append(('uniqueCurrencyFilter.blockchain', unique_currency_filter_blockchain))
            
        if unique_currency_filter_network is not None:
            
            _query_params.append(('uniqueCurrencyFilter.network', unique_currency_filter_network))
            
        if unique_currency_filter_token_contract_address is not None:
            
            _query_params.append(('uniqueCurrencyFilter.tokenContractAddress', unique_currency_filter_token_contract_address))
            
        if unique_currency_filter_token_id is not None:
            
            _query_params.append(('uniqueCurrencyFilter.tokenID', unique_currency_filter_token_id))
            
        if addresses is not None:
            
            _query_params.append(('addresses', addresses))
            
        # process the header parameters
        # process the form parameters
        # process the body parameter


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json'
                ]
            )


        # authentication setting
        _auth_settings: List[str] = [
            'ApiKeyTPV1'
        ]

        return self.api_client.param_serialize(
            method='GET',
            resource_path='/api/rest/v1/addresses/light',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )


