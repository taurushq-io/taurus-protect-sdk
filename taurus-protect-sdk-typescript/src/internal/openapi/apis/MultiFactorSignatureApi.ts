/* tslint:disable */
/* eslint-disable */
/**
 * Taurus-PROTECT APIs
 * Taurus-PROTECT APIs description
 *
 * The version of the OpenAPI document: 1.0
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import * as runtime from '../runtime';
import type {
  GooglerpcStatus,
  MultiFactorSignatureServiceApproveMultiFactorSignatureBody,
  MultiFactorSignatureServiceRejectMultiFactorSignatureBody,
  TgvalidatordApproveMultiFactorSignatureReply,
  TgvalidatordCreateMultiFactorSignaturesReply,
  TgvalidatordCreateMultiFactorSignaturesRequest,
  TgvalidatordGetMultiFactorSignatureEntitiesInfoReply,
} from '../models/index';
import {
    GooglerpcStatusFromJSON,
    GooglerpcStatusToJSON,
    MultiFactorSignatureServiceApproveMultiFactorSignatureBodyFromJSON,
    MultiFactorSignatureServiceApproveMultiFactorSignatureBodyToJSON,
    MultiFactorSignatureServiceRejectMultiFactorSignatureBodyFromJSON,
    MultiFactorSignatureServiceRejectMultiFactorSignatureBodyToJSON,
    TgvalidatordApproveMultiFactorSignatureReplyFromJSON,
    TgvalidatordApproveMultiFactorSignatureReplyToJSON,
    TgvalidatordCreateMultiFactorSignaturesReplyFromJSON,
    TgvalidatordCreateMultiFactorSignaturesReplyToJSON,
    TgvalidatordCreateMultiFactorSignaturesRequestFromJSON,
    TgvalidatordCreateMultiFactorSignaturesRequestToJSON,
    TgvalidatordGetMultiFactorSignatureEntitiesInfoReplyFromJSON,
    TgvalidatordGetMultiFactorSignatureEntitiesInfoReplyToJSON,
} from '../models/index';

export interface MultiFactorSignatureServiceApproveMultiFactorSignatureRequest {
    id: string;
    body: MultiFactorSignatureServiceApproveMultiFactorSignatureBody;
}

export interface MultiFactorSignatureServiceCreateMultiFactorSignatureBatchRequest {
    body: TgvalidatordCreateMultiFactorSignaturesRequest;
}

export interface MultiFactorSignatureServiceGetMultiFactorSignatureEntitiesInfoRequest {
    id: string;
}

export interface MultiFactorSignatureServiceRejectMultiFactorSignatureRequest {
    id: string;
    body: MultiFactorSignatureServiceRejectMultiFactorSignatureBody;
}

/**
 * MultiFactorSignatureApi - interface
 * 
 * @export
 * @interface MultiFactorSignatureApiInterface
 */
export interface MultiFactorSignatureApiInterface {
    /**
     * Approve the entities previously associated, using a multifactor approach. Needs either \'RequestMobileAppSigner\' or \'WhitelistedAddressMobileAppSigner\' role, depending on the targeted resource/entity
     * @summary Approve the underlying entities using a multifactor approach
     * @param {string} id the multifactor signature id
     * @param {MultiFactorSignatureServiceApproveMultiFactorSignatureBody} body 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MultiFactorSignatureApiInterface
     */
    multiFactorSignatureServiceApproveMultiFactorSignatureRaw(requestParameters: MultiFactorSignatureServiceApproveMultiFactorSignatureRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<TgvalidatordApproveMultiFactorSignatureReply>>;

    /**
     * Approve the entities previously associated, using a multifactor approach. Needs either \'RequestMobileAppSigner\' or \'WhitelistedAddressMobileAppSigner\' role, depending on the targeted resource/entity
     * Approve the underlying entities using a multifactor approach
     */
    multiFactorSignatureServiceApproveMultiFactorSignature(requestParameters: MultiFactorSignatureServiceApproveMultiFactorSignatureRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<TgvalidatordApproveMultiFactorSignatureReply>;

    /**
     * It creates a signature process which needs multifactor approvals. Given a resource (entityType, entityID), an id is returned and needs to be used by another factor device to be signed. Needs either \'RequestApprover\' or \'WhitelistedAddressApprover\' role, depending on the targeted resource
     * @summary Creates a multifactor signature
     * @param {TgvalidatordCreateMultiFactorSignaturesRequest} body 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MultiFactorSignatureApiInterface
     */
    multiFactorSignatureServiceCreateMultiFactorSignatureBatchRaw(requestParameters: MultiFactorSignatureServiceCreateMultiFactorSignatureBatchRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<TgvalidatordCreateMultiFactorSignaturesReply>>;

    /**
     * It creates a signature process which needs multifactor approvals. Given a resource (entityType, entityID), an id is returned and needs to be used by another factor device to be signed. Needs either \'RequestApprover\' or \'WhitelistedAddressApprover\' role, depending on the targeted resource
     * Creates a multifactor signature
     */
    multiFactorSignatureServiceCreateMultiFactorSignatureBatch(requestParameters: MultiFactorSignatureServiceCreateMultiFactorSignatureBatchRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<TgvalidatordCreateMultiFactorSignaturesReply>;

    /**
     * Get the associated entities\' metadata information to be signed. Needs either \'RequestMobileAppSigner\' or \'WhitelistedAddressMobileAppSigner\' role, depending on the targeted resource/entity
     * @summary Get the associated entities information
     * @param {string} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MultiFactorSignatureApiInterface
     */
    multiFactorSignatureServiceGetMultiFactorSignatureEntitiesInfoRaw(requestParameters: MultiFactorSignatureServiceGetMultiFactorSignatureEntitiesInfoRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<TgvalidatordGetMultiFactorSignatureEntitiesInfoReply>>;

    /**
     * Get the associated entities\' metadata information to be signed. Needs either \'RequestMobileAppSigner\' or \'WhitelistedAddressMobileAppSigner\' role, depending on the targeted resource/entity
     * Get the associated entities information
     */
    multiFactorSignatureServiceGetMultiFactorSignatureEntitiesInfo(requestParameters: MultiFactorSignatureServiceGetMultiFactorSignatureEntitiesInfoRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<TgvalidatordGetMultiFactorSignatureEntitiesInfoReply>;

    /**
     * Reject the entities previously associated. Needs either \'RequestMobileAppSigner\' or \'WhitelistedAddressMobileAppSigner\' role, depending on the targeted resource/entity
     * @summary Reject the underlying entities
     * @param {string} id the multifactor signature id
     * @param {MultiFactorSignatureServiceRejectMultiFactorSignatureBody} body 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MultiFactorSignatureApiInterface
     */
    multiFactorSignatureServiceRejectMultiFactorSignatureRaw(requestParameters: MultiFactorSignatureServiceRejectMultiFactorSignatureRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<object>>;

    /**
     * Reject the entities previously associated. Needs either \'RequestMobileAppSigner\' or \'WhitelistedAddressMobileAppSigner\' role, depending on the targeted resource/entity
     * Reject the underlying entities
     */
    multiFactorSignatureServiceRejectMultiFactorSignature(requestParameters: MultiFactorSignatureServiceRejectMultiFactorSignatureRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<object>;

}

/**
 * 
 */
export class MultiFactorSignatureApi extends runtime.BaseAPI implements MultiFactorSignatureApiInterface {

    /**
     * Approve the entities previously associated, using a multifactor approach. Needs either \'RequestMobileAppSigner\' or \'WhitelistedAddressMobileAppSigner\' role, depending on the targeted resource/entity
     * Approve the underlying entities using a multifactor approach
     */
    async multiFactorSignatureServiceApproveMultiFactorSignatureRaw(requestParameters: MultiFactorSignatureServiceApproveMultiFactorSignatureRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<TgvalidatordApproveMultiFactorSignatureReply>> {
        if (requestParameters['id'] == null) {
            throw new runtime.RequiredError(
                'id',
                'Required parameter "id" was null or undefined when calling multiFactorSignatureServiceApproveMultiFactorSignature().'
            );
        }

        if (requestParameters['body'] == null) {
            throw new runtime.RequiredError(
                'body',
                'Required parameter "body" was null or undefined when calling multiFactorSignatureServiceApproveMultiFactorSignature().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = await this.configuration.apiKey("Authorization"); // ApiKeyTPV1 authentication
        }

        const response = await this.request({
            path: `/api/rest/v1/multifactor-signature/{id}/approve`.replace(`{${"id"}}`, encodeURIComponent(String(requestParameters['id']))),
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: MultiFactorSignatureServiceApproveMultiFactorSignatureBodyToJSON(requestParameters['body']),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => TgvalidatordApproveMultiFactorSignatureReplyFromJSON(jsonValue));
    }

    /**
     * Approve the entities previously associated, using a multifactor approach. Needs either \'RequestMobileAppSigner\' or \'WhitelistedAddressMobileAppSigner\' role, depending on the targeted resource/entity
     * Approve the underlying entities using a multifactor approach
     */
    async multiFactorSignatureServiceApproveMultiFactorSignature(requestParameters: MultiFactorSignatureServiceApproveMultiFactorSignatureRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<TgvalidatordApproveMultiFactorSignatureReply> {
        const response = await this.multiFactorSignatureServiceApproveMultiFactorSignatureRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * It creates a signature process which needs multifactor approvals. Given a resource (entityType, entityID), an id is returned and needs to be used by another factor device to be signed. Needs either \'RequestApprover\' or \'WhitelistedAddressApprover\' role, depending on the targeted resource
     * Creates a multifactor signature
     */
    async multiFactorSignatureServiceCreateMultiFactorSignatureBatchRaw(requestParameters: MultiFactorSignatureServiceCreateMultiFactorSignatureBatchRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<TgvalidatordCreateMultiFactorSignaturesReply>> {
        if (requestParameters['body'] == null) {
            throw new runtime.RequiredError(
                'body',
                'Required parameter "body" was null or undefined when calling multiFactorSignatureServiceCreateMultiFactorSignatureBatch().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = await this.configuration.apiKey("Authorization"); // ApiKeyTPV1 authentication
        }

        const response = await this.request({
            path: `/api/rest/v1/multifactor-signatures`,
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: TgvalidatordCreateMultiFactorSignaturesRequestToJSON(requestParameters['body']),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => TgvalidatordCreateMultiFactorSignaturesReplyFromJSON(jsonValue));
    }

    /**
     * It creates a signature process which needs multifactor approvals. Given a resource (entityType, entityID), an id is returned and needs to be used by another factor device to be signed. Needs either \'RequestApprover\' or \'WhitelistedAddressApprover\' role, depending on the targeted resource
     * Creates a multifactor signature
     */
    async multiFactorSignatureServiceCreateMultiFactorSignatureBatch(requestParameters: MultiFactorSignatureServiceCreateMultiFactorSignatureBatchRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<TgvalidatordCreateMultiFactorSignaturesReply> {
        const response = await this.multiFactorSignatureServiceCreateMultiFactorSignatureBatchRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Get the associated entities\' metadata information to be signed. Needs either \'RequestMobileAppSigner\' or \'WhitelistedAddressMobileAppSigner\' role, depending on the targeted resource/entity
     * Get the associated entities information
     */
    async multiFactorSignatureServiceGetMultiFactorSignatureEntitiesInfoRaw(requestParameters: MultiFactorSignatureServiceGetMultiFactorSignatureEntitiesInfoRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<TgvalidatordGetMultiFactorSignatureEntitiesInfoReply>> {
        if (requestParameters['id'] == null) {
            throw new runtime.RequiredError(
                'id',
                'Required parameter "id" was null or undefined when calling multiFactorSignatureServiceGetMultiFactorSignatureEntitiesInfo().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = await this.configuration.apiKey("Authorization"); // ApiKeyTPV1 authentication
        }

        const response = await this.request({
            path: `/api/rest/v1/multifactor-signature/{id}`.replace(`{${"id"}}`, encodeURIComponent(String(requestParameters['id']))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => TgvalidatordGetMultiFactorSignatureEntitiesInfoReplyFromJSON(jsonValue));
    }

    /**
     * Get the associated entities\' metadata information to be signed. Needs either \'RequestMobileAppSigner\' or \'WhitelistedAddressMobileAppSigner\' role, depending on the targeted resource/entity
     * Get the associated entities information
     */
    async multiFactorSignatureServiceGetMultiFactorSignatureEntitiesInfo(requestParameters: MultiFactorSignatureServiceGetMultiFactorSignatureEntitiesInfoRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<TgvalidatordGetMultiFactorSignatureEntitiesInfoReply> {
        const response = await this.multiFactorSignatureServiceGetMultiFactorSignatureEntitiesInfoRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Reject the entities previously associated. Needs either \'RequestMobileAppSigner\' or \'WhitelistedAddressMobileAppSigner\' role, depending on the targeted resource/entity
     * Reject the underlying entities
     */
    async multiFactorSignatureServiceRejectMultiFactorSignatureRaw(requestParameters: MultiFactorSignatureServiceRejectMultiFactorSignatureRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<object>> {
        if (requestParameters['id'] == null) {
            throw new runtime.RequiredError(
                'id',
                'Required parameter "id" was null or undefined when calling multiFactorSignatureServiceRejectMultiFactorSignature().'
            );
        }

        if (requestParameters['body'] == null) {
            throw new runtime.RequiredError(
                'body',
                'Required parameter "body" was null or undefined when calling multiFactorSignatureServiceRejectMultiFactorSignature().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = await this.configuration.apiKey("Authorization"); // ApiKeyTPV1 authentication
        }

        const response = await this.request({
            path: `/api/rest/v1/multifactor-signature/{id}/reject`.replace(`{${"id"}}`, encodeURIComponent(String(requestParameters['id']))),
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: MultiFactorSignatureServiceRejectMultiFactorSignatureBodyToJSON(requestParameters['body']),
        }, initOverrides);

        return new runtime.JSONApiResponse<any>(response);
    }

    /**
     * Reject the entities previously associated. Needs either \'RequestMobileAppSigner\' or \'WhitelistedAddressMobileAppSigner\' role, depending on the targeted resource/entity
     * Reject the underlying entities
     */
    async multiFactorSignatureServiceRejectMultiFactorSignature(requestParameters: MultiFactorSignatureServiceRejectMultiFactorSignatureRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<object> {
        const response = await this.multiFactorSignatureServiceRejectMultiFactorSignatureRaw(requestParameters, initOverrides);
        return await response.value();
    }

}
