/*
 * Taurus-PROTECT APIs
 * Taurus-PROTECT APIs description
 *
 * The version of the OpenAPI document: 1.0
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


package com.taurushq.sdk.protect.openapi.model;

import java.util.Objects;
import com.google.gson.TypeAdapter;
import com.google.gson.annotations.JsonAdapter;
import com.google.gson.annotations.SerializedName;
import com.google.gson.stream.JsonReader;
import com.google.gson.stream.JsonWriter;
import java.io.IOException;
import java.util.Arrays;

import com.google.gson.Gson;
import com.google.gson.GsonBuilder;
import com.google.gson.JsonArray;
import com.google.gson.JsonDeserializationContext;
import com.google.gson.JsonDeserializer;
import com.google.gson.JsonElement;
import com.google.gson.JsonObject;
import com.google.gson.JsonParseException;
import com.google.gson.TypeAdapterFactory;
import com.google.gson.reflect.TypeToken;
import com.google.gson.TypeAdapter;
import com.google.gson.stream.JsonReader;
import com.google.gson.stream.JsonWriter;
import java.io.IOException;

import java.util.HashMap;
import java.util.HashSet;
import java.util.List;
import java.util.Map;
import java.util.Set;

import com.taurushq.sdk.protect.openapi.JSON;

/**
 * TgvalidatordCreateWalletRequest
 */
@javax.annotation.Generated(value = "org.openapitools.codegen.languages.JavaClientCodegen", date = "2026-01-23T15:56:06.931912+01:00[Europe/Zurich]", comments = "Generator version: 7.9.0")
public class TgvalidatordCreateWalletRequest {
  public static final String SERIALIZED_NAME_CURRENCY = "currency";
  @SerializedName(SERIALIZED_NAME_CURRENCY)
  private String currency;

  public static final String SERIALIZED_NAME_NAME = "name";
  @SerializedName(SERIALIZED_NAME_NAME)
  private String name;

  public static final String SERIALIZED_NAME_CONTAINER = "container";
  @SerializedName(SERIALIZED_NAME_CONTAINER)
  private String container;

  public static final String SERIALIZED_NAME_IS_OMNIBUS = "isOmnibus";
  @SerializedName(SERIALIZED_NAME_IS_OMNIBUS)
  private Boolean isOmnibus;

  public static final String SERIALIZED_NAME_COMMENT = "comment";
  @SerializedName(SERIALIZED_NAME_COMMENT)
  private String comment;

  public static final String SERIALIZED_NAME_CUSTOMER_ID = "customerId";
  @SerializedName(SERIALIZED_NAME_CUSTOMER_ID)
  private String customerId;

  public static final String SERIALIZED_NAME_BLOCKCHAIN = "blockchain";
  @SerializedName(SERIALIZED_NAME_BLOCKCHAIN)
  private String blockchain;

  public static final String SERIALIZED_NAME_NETWORK = "network";
  @SerializedName(SERIALIZED_NAME_NETWORK)
  private String network;

  public static final String SERIALIZED_NAME_VISIBILITY_GROUP_I_D = "visibilityGroupID";
  @SerializedName(SERIALIZED_NAME_VISIBILITY_GROUP_I_D)
  private String visibilityGroupID;

  public static final String SERIALIZED_NAME_EXTERNAL_WALLET_ID = "externalWalletId";
  @SerializedName(SERIALIZED_NAME_EXTERNAL_WALLET_ID)
  private String externalWalletId;

  public TgvalidatordCreateWalletRequest() {
  }

  public TgvalidatordCreateWalletRequest currency(String currency) {
    this.currency = currency;
    return this;
  }

  /**
   * This can be a currency name or a currency ID. Needs to be the native currency of a blockchain.
   * @return currency
   */
  @javax.annotation.Nullable
  public String getCurrency() {
    return currency;
  }

  public void setCurrency(String currency) {
    this.currency = currency;
  }


  public TgvalidatordCreateWalletRequest name(String name) {
    this.name = name;
    return this;
  }

  /**
   * The name of the wallet has to be unique per blockchain, network.
   * @return name
   */
  @javax.annotation.Nonnull
  public String getName() {
    return name;
  }

  public void setName(String name) {
    this.name = name;
  }


  public TgvalidatordCreateWalletRequest container(String container) {
    this.container = container;
    return this;
  }

  /**
   * Deprecated: Do not use
   * @return container
   */
  @javax.annotation.Nullable
  public String getContainer() {
    return container;
  }

  public void setContainer(String container) {
    this.container = container;
  }


  public TgvalidatordCreateWalletRequest isOmnibus(Boolean isOmnibus) {
    this.isOmnibus = isOmnibus;
    return this;
  }

  /**
   * When set to &#x60;true&#x60;, the Wallet can be used as source of transactions allowing the system to pick addresses with adequate funds. (This is called *Single owner* in the GUI)
   * @return isOmnibus
   */
  @javax.annotation.Nullable
  public Boolean getIsOmnibus() {
    return isOmnibus;
  }

  public void setIsOmnibus(Boolean isOmnibus) {
    this.isOmnibus = isOmnibus;
  }


  public TgvalidatordCreateWalletRequest comment(String comment) {
    this.comment = comment;
    return this;
  }

  /**
   * Comment or description of the wallet (maximum 254 characters). It is not used or interpreted by the system and will be returned as is in the replies from endpoints such as &#x60;api/rest/v2/wallets&#x60;
   * @return comment
   */
  @javax.annotation.Nullable
  public String getComment() {
    return comment;
  }

  public void setComment(String comment) {
    this.comment = comment;
  }


  public TgvalidatordCreateWalletRequest customerId(String customerId) {
    this.customerId = customerId;
    return this;
  }

  /**
   * When *isOmnibus* is &#x60;true&#x60;, all addresses in the wallet will have this attribute set (maximum 254 characters)
   * @return customerId
   */
  @javax.annotation.Nullable
  public String getCustomerId() {
    return customerId;
  }

  public void setCustomerId(String customerId) {
    this.customerId = customerId;
  }


  public TgvalidatordCreateWalletRequest blockchain(String blockchain) {
    this.blockchain = blockchain;
    return this;
  }

  /**
   * A string identifying the blockchain (e.g. \&quot;BTC\&quot;). Required if currency is empty. If the blockchain is enabled on more than one network (e.g. \&quot;mainnet\&quot; and \&quot;testnet\&quot;), the network needs to be specified.
   * @return blockchain
   */
  @javax.annotation.Nullable
  public String getBlockchain() {
    return blockchain;
  }

  public void setBlockchain(String blockchain) {
    this.blockchain = blockchain;
  }


  public TgvalidatordCreateWalletRequest network(String network) {
    this.network = network;
    return this;
  }

  /**
   * A string identifying the network. Required if the specified blockchain is enabled on multiple networks
   * @return network
   */
  @javax.annotation.Nullable
  public String getNetwork() {
    return network;
  }

  public void setNetwork(String network) {
    this.network = network;
  }


  public TgvalidatordCreateWalletRequest visibilityGroupID(String visibilityGroupID) {
    this.visibilityGroupID = visibilityGroupID;
    return this;
  }

  /**
   * The UUID of a Visibility Group (uuid can be obtained from e.g. &#x60;api/rest/v1/visibilitygroups&#x60;). The created wallet will only be visible and can only be managed by users in this group.
   * @return visibilityGroupID
   */
  @javax.annotation.Nullable
  public String getVisibilityGroupID() {
    return visibilityGroupID;
  }

  public void setVisibilityGroupID(String visibilityGroupID) {
    this.visibilityGroupID = visibilityGroupID;
  }


  public TgvalidatordCreateWalletRequest externalWalletId(String externalWalletId) {
    this.externalWalletId = externalWalletId;
    return this;
  }

  /**
   * An optional external identifier for the wallet.
   * @return externalWalletId
   */
  @javax.annotation.Nullable
  public String getExternalWalletId() {
    return externalWalletId;
  }

  public void setExternalWalletId(String externalWalletId) {
    this.externalWalletId = externalWalletId;
  }

  /**
   * A container for additional, undeclared properties.
   * This is a holder for any undeclared properties as specified with
   * the 'additionalProperties' keyword in the OAS document.
   */
  private Map<String, Object> additionalProperties;

  /**
   * Set the additional (undeclared) property with the specified name and value.
   * If the property does not already exist, create it otherwise replace it.
   *
   * @param key name of the property
   * @param value value of the property
   * @return the TgvalidatordCreateWalletRequest instance itself
   */
  public TgvalidatordCreateWalletRequest putAdditionalProperty(String key, Object value) {
    if (this.additionalProperties == null) {
        this.additionalProperties = new HashMap<String, Object>();
    }
    this.additionalProperties.put(key, value);
    return this;
  }

  /**
   * Return the additional (undeclared) property.
   *
   * @return a map of objects
   */
  public Map<String, Object> getAdditionalProperties() {
    return additionalProperties;
  }

  /**
   * Return the additional (undeclared) property with the specified name.
   *
   * @param key name of the property
   * @return an object
   */
  public Object getAdditionalProperty(String key) {
    if (this.additionalProperties == null) {
        return null;
    }
    return this.additionalProperties.get(key);
  }


  @Override
  public boolean equals(Object o) {
    if (this == o) {
      return true;
    }
    if (o == null || getClass() != o.getClass()) {
      return false;
    }
    TgvalidatordCreateWalletRequest tgvalidatordCreateWalletRequest = (TgvalidatordCreateWalletRequest) o;
    return Objects.equals(this.currency, tgvalidatordCreateWalletRequest.currency) &&
        Objects.equals(this.name, tgvalidatordCreateWalletRequest.name) &&
        Objects.equals(this.container, tgvalidatordCreateWalletRequest.container) &&
        Objects.equals(this.isOmnibus, tgvalidatordCreateWalletRequest.isOmnibus) &&
        Objects.equals(this.comment, tgvalidatordCreateWalletRequest.comment) &&
        Objects.equals(this.customerId, tgvalidatordCreateWalletRequest.customerId) &&
        Objects.equals(this.blockchain, tgvalidatordCreateWalletRequest.blockchain) &&
        Objects.equals(this.network, tgvalidatordCreateWalletRequest.network) &&
        Objects.equals(this.visibilityGroupID, tgvalidatordCreateWalletRequest.visibilityGroupID) &&
        Objects.equals(this.externalWalletId, tgvalidatordCreateWalletRequest.externalWalletId)&&
        Objects.equals(this.additionalProperties, tgvalidatordCreateWalletRequest.additionalProperties);
  }

  @Override
  public int hashCode() {
    return Objects.hash(currency, name, container, isOmnibus, comment, customerId, blockchain, network, visibilityGroupID, externalWalletId, additionalProperties);
  }

  @Override
  public String toString() {
    StringBuilder sb = new StringBuilder();
    sb.append("class TgvalidatordCreateWalletRequest {\n");
    sb.append("    currency: ").append(toIndentedString(currency)).append("\n");
    sb.append("    name: ").append(toIndentedString(name)).append("\n");
    sb.append("    container: ").append(toIndentedString(container)).append("\n");
    sb.append("    isOmnibus: ").append(toIndentedString(isOmnibus)).append("\n");
    sb.append("    comment: ").append(toIndentedString(comment)).append("\n");
    sb.append("    customerId: ").append(toIndentedString(customerId)).append("\n");
    sb.append("    blockchain: ").append(toIndentedString(blockchain)).append("\n");
    sb.append("    network: ").append(toIndentedString(network)).append("\n");
    sb.append("    visibilityGroupID: ").append(toIndentedString(visibilityGroupID)).append("\n");
    sb.append("    externalWalletId: ").append(toIndentedString(externalWalletId)).append("\n");
    sb.append("    additionalProperties: ").append(toIndentedString(additionalProperties)).append("\n");
    sb.append("}");
    return sb.toString();
  }

  /**
   * Convert the given object to string with each line indented by 4 spaces
   * (except the first line).
   */
  private String toIndentedString(Object o) {
    if (o == null) {
      return "null";
    }
    return o.toString().replace("\n", "\n    ");
  }


  public static HashSet<String> openapiFields;
  public static HashSet<String> openapiRequiredFields;

  static {
    // a set of all properties/fields (JSON key names)
    openapiFields = new HashSet<String>();
    openapiFields.add("currency");
    openapiFields.add("name");
    openapiFields.add("container");
    openapiFields.add("isOmnibus");
    openapiFields.add("comment");
    openapiFields.add("customerId");
    openapiFields.add("blockchain");
    openapiFields.add("network");
    openapiFields.add("visibilityGroupID");
    openapiFields.add("externalWalletId");

    // a set of required properties/fields (JSON key names)
    openapiRequiredFields = new HashSet<String>();
    openapiRequiredFields.add("name");
  }

  /**
   * Validates the JSON Element and throws an exception if issues found
   *
   * @param jsonElement JSON Element
   * @throws IOException if the JSON Element is invalid with respect to TgvalidatordCreateWalletRequest
   */
  public static void validateJsonElement(JsonElement jsonElement) throws IOException {
      if (jsonElement == null) {
        if (!TgvalidatordCreateWalletRequest.openapiRequiredFields.isEmpty()) { // has required fields but JSON element is null
          throw new IllegalArgumentException(String.format("The required field(s) %s in TgvalidatordCreateWalletRequest is not found in the empty JSON string", TgvalidatordCreateWalletRequest.openapiRequiredFields.toString()));
        }
      }

      // check to make sure all required properties/fields are present in the JSON string
      for (String requiredField : TgvalidatordCreateWalletRequest.openapiRequiredFields) {
        if (jsonElement.getAsJsonObject().get(requiredField) == null) {
          throw new IllegalArgumentException(String.format("The required field `%s` is not found in the JSON string: %s", requiredField, jsonElement.toString()));
        }
      }
        JsonObject jsonObj = jsonElement.getAsJsonObject();
      if ((jsonObj.get("currency") != null && !jsonObj.get("currency").isJsonNull()) && !jsonObj.get("currency").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `currency` to be a primitive type in the JSON string but got `%s`", jsonObj.get("currency").toString()));
      }
      if (!jsonObj.get("name").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `name` to be a primitive type in the JSON string but got `%s`", jsonObj.get("name").toString()));
      }
      if ((jsonObj.get("container") != null && !jsonObj.get("container").isJsonNull()) && !jsonObj.get("container").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `container` to be a primitive type in the JSON string but got `%s`", jsonObj.get("container").toString()));
      }
      if ((jsonObj.get("comment") != null && !jsonObj.get("comment").isJsonNull()) && !jsonObj.get("comment").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `comment` to be a primitive type in the JSON string but got `%s`", jsonObj.get("comment").toString()));
      }
      if ((jsonObj.get("customerId") != null && !jsonObj.get("customerId").isJsonNull()) && !jsonObj.get("customerId").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `customerId` to be a primitive type in the JSON string but got `%s`", jsonObj.get("customerId").toString()));
      }
      if ((jsonObj.get("blockchain") != null && !jsonObj.get("blockchain").isJsonNull()) && !jsonObj.get("blockchain").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `blockchain` to be a primitive type in the JSON string but got `%s`", jsonObj.get("blockchain").toString()));
      }
      if ((jsonObj.get("network") != null && !jsonObj.get("network").isJsonNull()) && !jsonObj.get("network").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `network` to be a primitive type in the JSON string but got `%s`", jsonObj.get("network").toString()));
      }
      if ((jsonObj.get("visibilityGroupID") != null && !jsonObj.get("visibilityGroupID").isJsonNull()) && !jsonObj.get("visibilityGroupID").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `visibilityGroupID` to be a primitive type in the JSON string but got `%s`", jsonObj.get("visibilityGroupID").toString()));
      }
      if ((jsonObj.get("externalWalletId") != null && !jsonObj.get("externalWalletId").isJsonNull()) && !jsonObj.get("externalWalletId").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `externalWalletId` to be a primitive type in the JSON string but got `%s`", jsonObj.get("externalWalletId").toString()));
      }
  }

  public static class CustomTypeAdapterFactory implements TypeAdapterFactory {
    @SuppressWarnings("unchecked")
    @Override
    public <T> TypeAdapter<T> create(Gson gson, TypeToken<T> type) {
       if (!TgvalidatordCreateWalletRequest.class.isAssignableFrom(type.getRawType())) {
         return null; // this class only serializes 'TgvalidatordCreateWalletRequest' and its subtypes
       }
       final TypeAdapter<JsonElement> elementAdapter = gson.getAdapter(JsonElement.class);
       final TypeAdapter<TgvalidatordCreateWalletRequest> thisAdapter
                        = gson.getDelegateAdapter(this, TypeToken.get(TgvalidatordCreateWalletRequest.class));

       return (TypeAdapter<T>) new TypeAdapter<TgvalidatordCreateWalletRequest>() {
           @Override
           public void write(JsonWriter out, TgvalidatordCreateWalletRequest value) throws IOException {
             JsonObject obj = thisAdapter.toJsonTree(value).getAsJsonObject();
             obj.remove("additionalProperties");
             // serialize additional properties
             if (value.getAdditionalProperties() != null) {
               for (Map.Entry<String, Object> entry : value.getAdditionalProperties().entrySet()) {
                 if (entry.getValue() instanceof String)
                   obj.addProperty(entry.getKey(), (String) entry.getValue());
                 else if (entry.getValue() instanceof Number)
                   obj.addProperty(entry.getKey(), (Number) entry.getValue());
                 else if (entry.getValue() instanceof Boolean)
                   obj.addProperty(entry.getKey(), (Boolean) entry.getValue());
                 else if (entry.getValue() instanceof Character)
                   obj.addProperty(entry.getKey(), (Character) entry.getValue());
                 else {
                   JsonElement jsonElement = gson.toJsonTree(entry.getValue());
                   if (jsonElement.isJsonArray()) {
                     obj.add(entry.getKey(), jsonElement.getAsJsonArray());
                   } else {
                     obj.add(entry.getKey(), jsonElement.getAsJsonObject());
                   }
                 }
               }
             }
             elementAdapter.write(out, obj);
           }

           @Override
           public TgvalidatordCreateWalletRequest read(JsonReader in) throws IOException {
             JsonElement jsonElement = elementAdapter.read(in);
             validateJsonElement(jsonElement);
             JsonObject jsonObj = jsonElement.getAsJsonObject();
             // store additional fields in the deserialized instance
             TgvalidatordCreateWalletRequest instance = thisAdapter.fromJsonTree(jsonObj);
             for (Map.Entry<String, JsonElement> entry : jsonObj.entrySet()) {
               if (!openapiFields.contains(entry.getKey())) {
                 if (entry.getValue().isJsonPrimitive()) { // primitive type
                   if (entry.getValue().getAsJsonPrimitive().isString())
                     instance.putAdditionalProperty(entry.getKey(), entry.getValue().getAsString());
                   else if (entry.getValue().getAsJsonPrimitive().isNumber())
                     instance.putAdditionalProperty(entry.getKey(), entry.getValue().getAsNumber());
                   else if (entry.getValue().getAsJsonPrimitive().isBoolean())
                     instance.putAdditionalProperty(entry.getKey(), entry.getValue().getAsBoolean());
                   else
                     throw new IllegalArgumentException(String.format("The field `%s` has unknown primitive type. Value: %s", entry.getKey(), entry.getValue().toString()));
                 } else if (entry.getValue().isJsonArray()) {
                     instance.putAdditionalProperty(entry.getKey(), gson.fromJson(entry.getValue(), List.class));
                 } else { // JSON object
                     instance.putAdditionalProperty(entry.getKey(), gson.fromJson(entry.getValue(), HashMap.class));
                 }
               }
             }
             return instance;
           }

       }.nullSafe();
    }
  }

  /**
   * Create an instance of TgvalidatordCreateWalletRequest given an JSON string
   *
   * @param jsonString JSON string
   * @return An instance of TgvalidatordCreateWalletRequest
   * @throws IOException if the JSON string is invalid with respect to TgvalidatordCreateWalletRequest
   */
  public static TgvalidatordCreateWalletRequest fromJson(String jsonString) throws IOException {
    return JSON.getGson().fromJson(jsonString, TgvalidatordCreateWalletRequest.class);
  }

  /**
   * Convert an instance of TgvalidatordCreateWalletRequest to an JSON string
   *
   * @return JSON string
   */
  public String toJson() {
    return JSON.getGson().toJson(this);
  }
}

