// Code generated by protoc-gen-ts_proto. DO NOT EDIT.
// versions:
//   protoc-gen-ts_proto  v1.181.2
//   protoc               v6.33.4
// source: wallet.proto

/* eslint-disable */
import Long from "long";
import _m0 from "protobufjs/minimal";
import { Currency } from "./currency";
import { Timestamp } from "./google/protobuf/timestamp";
import { Score } from "./score";

export const protobufPackage = "tgvalidatord";

export interface Asset {
  currency: string;
  kind: string;
  nft: Asset_Nft | undefined;
  unknown: Asset_Unknown | undefined;
  currencyInfo: Currency | undefined;
}

export enum Asset_Kind {
  _default_ = 0,
  Unknown = 1,
  NFT = 2,
  UNRECOGNIZED = -1,
}

export function asset_KindFromJSON(object: any): Asset_Kind {
  switch (object) {
    case 0:
    case "_default_":
      return Asset_Kind._default_;
    case 1:
    case "Unknown":
      return Asset_Kind.Unknown;
    case 2:
    case "NFT":
      return Asset_Kind.NFT;
    case -1:
    case "UNRECOGNIZED":
    default:
      return Asset_Kind.UNRECOGNIZED;
  }
}

export function asset_KindToJSON(object: Asset_Kind): string {
  switch (object) {
    case Asset_Kind._default_:
      return "_default_";
    case Asset_Kind.Unknown:
      return "Unknown";
    case Asset_Kind.NFT:
      return "NFT";
    case Asset_Kind.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

export interface Asset_Nft {
  tokenid: string;
}

export interface Asset_Unknown {
  blockchain: string;
  arg1: string;
  arg2: string;
  network: string;
}

export interface AssetBalance {
  asset: Asset | undefined;
  balance: Balance | undefined;
}

export interface NFTCollectionBalance {
  currencyInfo: Currency | undefined;
  balance: Balance | undefined;
}

export interface Balance {
  totalConfirmed: string;
  totalUnconfirmed: string;
  availableConfirmed: string;
  availableUnconfirmed: string;
  reservedConfirmed: string;
  reservedUnconfirmed: string;
}

export interface BalanceHistoryPoint {
  pointDate: Date | undefined;
  balance: Balance | undefined;
}

/**
 * Deprecated: Wallets can have thousands of addresses. It is not a good idea to serialize a wallet with all its addresses.
 * Generally, WalletInfo should be used instead
 */
export interface Wallet {
  id: number;
  balance: Balance | undefined;
  currency: string;
  coin: string;
  name: string;
  container: string;
  seed: string;
  accountPath: string;
  addresses: Address[];
  isOmnibus: boolean;
  creationDate: Date | undefined;
  updateDate: Date | undefined;
  customerId: string;
  comment: string;
  disabled: boolean;
  blockchain: string;
  addressesCount: number;
  attributes: WalletAttribute[];
  currencyInfo: Currency | undefined;
  externalWalletId: string;
}

export interface WalletAttribute {
  key: string;
  value: string;
  id: number;
  contentType: string;
  owner: string;
  type: string;
  subtype: string;
  isfile: boolean;
}

export interface WalletInfo {
  id: number;
  balance: Balance | undefined;
  currency: string;
  coin: string;
  name: string;
  container: string;
  seed: string;
  accountPath: string;
  isOmnibus: boolean;
  creationDate: Date | undefined;
  updateDate: Date | undefined;
  customerId: string;
  comment: string;
  disabled: boolean;
  blockchain: string;
  addressesCount: number;
  currencyInfo: Currency | undefined;
  attributes: WalletAttribute[];
  network: string;
  visibilityGroupID: string;
  externalWalletId: string;
}

export interface Address {
  id: number;
  walletId: number;
  seed: string;
  currency: string;
  addressPath: string;
  addressIndex: number;
  address: string;
  alternateAddress: string;
  comment: string;
  label: string;
  customerId: string;
  nonce: number;
  balance: Balance | undefined;
  signature: string;
  scores: Score[];
  attributes: AddressAttribute[];
  linkedWhitelistedAddressIds: number[];
  creationDate: Date | undefined;
  updateDate: Date | undefined;
  walletInfo: WalletInfo | undefined;
  disabled: boolean;
  currencyInfo: Currency | undefined;
  canUseAllFunds: boolean;
  externalAddressId: string;
  status: string;
}

export interface AddressAttribute {
  key: string;
  value: string;
  id: number;
  contentType: string;
  owner: string;
  type: string;
  subtype: string;
  isfile: boolean;
}

export interface UTXO {
  id: number;
  hash: string;
  outputIndex: number;
  script: string;
  value: number;
  blockHeight: number;
  reservedByRequestId: number;
  reservationId: number;
  valueString: string;
}

export interface ProofOfReserve {
  curve: ProofOfReserve_Curve;
  cipher: ProofOfReserve_Cipher;
  path: string;
  address: string;
  publicKey: Uint8Array;
  challenge: string;
  challengeResponse: Uint8Array;
  type: ProofOfReserve_ReserveType;
  stakePublicKey: Uint8Array;
  stakeChallengeResponse: Uint8Array;
}

/**
 * _X because with grpc gateway 0 field of enum are not returned in JSON
 *  can use "runtime.WithMarshalerOption(runtime.MIMEWildcard, &runtime.JSONPb{OrigName: true, EmitDefaults: true})"
 *  but this will break other endpoints (e.g. without this option empty repeated message are display as null, with they are returned as empty array)
 */
export enum ProofOfReserve_Curve {
  _curve = 0,
  Secp256k1 = 1,
  Ed25519 = 2,
  Secp256r1 = 3,
  Pallas = 4,
  UNRECOGNIZED = -1,
}

export function proofOfReserve_CurveFromJSON(object: any): ProofOfReserve_Curve {
  switch (object) {
    case 0:
    case "_curve":
      return ProofOfReserve_Curve._curve;
    case 1:
    case "Secp256k1":
      return ProofOfReserve_Curve.Secp256k1;
    case 2:
    case "Ed25519":
      return ProofOfReserve_Curve.Ed25519;
    case 3:
    case "Secp256r1":
      return ProofOfReserve_Curve.Secp256r1;
    case 4:
    case "Pallas":
      return ProofOfReserve_Curve.Pallas;
    case -1:
    case "UNRECOGNIZED":
    default:
      return ProofOfReserve_Curve.UNRECOGNIZED;
  }
}

export function proofOfReserve_CurveToJSON(object: ProofOfReserve_Curve): string {
  switch (object) {
    case ProofOfReserve_Curve._curve:
      return "_curve";
    case ProofOfReserve_Curve.Secp256k1:
      return "Secp256k1";
    case ProofOfReserve_Curve.Ed25519:
      return "Ed25519";
    case ProofOfReserve_Curve.Secp256r1:
      return "Secp256r1";
    case ProofOfReserve_Curve.Pallas:
      return "Pallas";
    case ProofOfReserve_Curve.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

export enum ProofOfReserve_Cipher {
  _cipher = 0,
  ECDSA_SHA256 = 1,
  ECDSA_SHA512 = 2,
  EDDSA = 3,
  Schnorr = 4,
  UNRECOGNIZED = -1,
}

export function proofOfReserve_CipherFromJSON(object: any): ProofOfReserve_Cipher {
  switch (object) {
    case 0:
    case "_cipher":
      return ProofOfReserve_Cipher._cipher;
    case 1:
    case "ECDSA_SHA256":
      return ProofOfReserve_Cipher.ECDSA_SHA256;
    case 2:
    case "ECDSA_SHA512":
      return ProofOfReserve_Cipher.ECDSA_SHA512;
    case 3:
    case "EDDSA":
      return ProofOfReserve_Cipher.EDDSA;
    case 4:
    case "Schnorr":
      return ProofOfReserve_Cipher.Schnorr;
    case -1:
    case "UNRECOGNIZED":
    default:
      return ProofOfReserve_Cipher.UNRECOGNIZED;
  }
}

export function proofOfReserve_CipherToJSON(object: ProofOfReserve_Cipher): string {
  switch (object) {
    case ProofOfReserve_Cipher._cipher:
      return "_cipher";
    case ProofOfReserve_Cipher.ECDSA_SHA256:
      return "ECDSA_SHA256";
    case ProofOfReserve_Cipher.ECDSA_SHA512:
      return "ECDSA_SHA512";
    case ProofOfReserve_Cipher.EDDSA:
      return "EDDSA";
    case ProofOfReserve_Cipher.Schnorr:
      return "Schnorr";
    case ProofOfReserve_Cipher.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

export enum ProofOfReserve_ReserveType {
  Generic = 0,
  ADA = 1,
  UNRECOGNIZED = -1,
}

export function proofOfReserve_ReserveTypeFromJSON(object: any): ProofOfReserve_ReserveType {
  switch (object) {
    case 0:
    case "Generic":
      return ProofOfReserve_ReserveType.Generic;
    case 1:
    case "ADA":
      return ProofOfReserve_ReserveType.ADA;
    case -1:
    case "UNRECOGNIZED":
    default:
      return ProofOfReserve_ReserveType.UNRECOGNIZED;
  }
}

export function proofOfReserve_ReserveTypeToJSON(object: ProofOfReserve_ReserveType): string {
  switch (object) {
    case ProofOfReserve_ReserveType.Generic:
      return "Generic";
    case ProofOfReserve_ReserveType.ADA:
      return "ADA";
    case ProofOfReserve_ReserveType.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

export interface LightAddressInfo {
  id: number;
  walletId: number;
  address: string;
  customerId: string;
  network: string;
  label: string;
  comment: string;
  addressPath: string;
  status: string;
  currencyId: string;
  creationDate: Date | undefined;
  updateDate: Date | undefined;
  externalAddressId: string;
}

function createBaseAsset(): Asset {
  return { currency: "", kind: "", nft: undefined, unknown: undefined, currencyInfo: undefined };
}

export const Asset = {
  encode(message: Asset, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.currency !== "") {
      writer.uint32(10).string(message.currency);
    }
    if (message.kind !== "") {
      writer.uint32(18).string(message.kind);
    }
    if (message.nft !== undefined) {
      Asset_Nft.encode(message.nft, writer.uint32(26).fork()).ldelim();
    }
    if (message.unknown !== undefined) {
      Asset_Unknown.encode(message.unknown, writer.uint32(34).fork()).ldelim();
    }
    if (message.currencyInfo !== undefined) {
      Currency.encode(message.currencyInfo, writer.uint32(42).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): Asset {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseAsset();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.currency = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.kind = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.nft = Asset_Nft.decode(reader, reader.uint32());
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.unknown = Asset_Unknown.decode(reader, reader.uint32());
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.currencyInfo = Currency.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Asset {
    return {
      currency: isSet(object.currency) ? globalThis.String(object.currency) : "",
      kind: isSet(object.kind) ? globalThis.String(object.kind) : "",
      nft: isSet(object.nft) ? Asset_Nft.fromJSON(object.nft) : undefined,
      unknown: isSet(object.unknown) ? Asset_Unknown.fromJSON(object.unknown) : undefined,
      currencyInfo: isSet(object.currencyInfo) ? Currency.fromJSON(object.currencyInfo) : undefined,
    };
  },

  toJSON(message: Asset): unknown {
    const obj: any = {};
    if (message.currency !== "") {
      obj.currency = message.currency;
    }
    if (message.kind !== "") {
      obj.kind = message.kind;
    }
    if (message.nft !== undefined) {
      obj.nft = Asset_Nft.toJSON(message.nft);
    }
    if (message.unknown !== undefined) {
      obj.unknown = Asset_Unknown.toJSON(message.unknown);
    }
    if (message.currencyInfo !== undefined) {
      obj.currencyInfo = Currency.toJSON(message.currencyInfo);
    }
    return obj;
  },

  create(base?: DeepPartial<Asset>): Asset {
    return Asset.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<Asset>): Asset {
    const message = createBaseAsset();
    message.currency = object.currency ?? "";
    message.kind = object.kind ?? "";
    message.nft = (object.nft !== undefined && object.nft !== null) ? Asset_Nft.fromPartial(object.nft) : undefined;
    message.unknown = (object.unknown !== undefined && object.unknown !== null)
      ? Asset_Unknown.fromPartial(object.unknown)
      : undefined;
    message.currencyInfo = (object.currencyInfo !== undefined && object.currencyInfo !== null)
      ? Currency.fromPartial(object.currencyInfo)
      : undefined;
    return message;
  },
};

function createBaseAsset_Nft(): Asset_Nft {
  return { tokenid: "" };
}

export const Asset_Nft = {
  encode(message: Asset_Nft, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.tokenid !== "") {
      writer.uint32(10).string(message.tokenid);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): Asset_Nft {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseAsset_Nft();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.tokenid = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Asset_Nft {
    return { tokenid: isSet(object.tokenid) ? globalThis.String(object.tokenid) : "" };
  },

  toJSON(message: Asset_Nft): unknown {
    const obj: any = {};
    if (message.tokenid !== "") {
      obj.tokenid = message.tokenid;
    }
    return obj;
  },

  create(base?: DeepPartial<Asset_Nft>): Asset_Nft {
    return Asset_Nft.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<Asset_Nft>): Asset_Nft {
    const message = createBaseAsset_Nft();
    message.tokenid = object.tokenid ?? "";
    return message;
  },
};

function createBaseAsset_Unknown(): Asset_Unknown {
  return { blockchain: "", arg1: "", arg2: "", network: "" };
}

export const Asset_Unknown = {
  encode(message: Asset_Unknown, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.blockchain !== "") {
      writer.uint32(10).string(message.blockchain);
    }
    if (message.arg1 !== "") {
      writer.uint32(18).string(message.arg1);
    }
    if (message.arg2 !== "") {
      writer.uint32(26).string(message.arg2);
    }
    if (message.network !== "") {
      writer.uint32(34).string(message.network);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): Asset_Unknown {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseAsset_Unknown();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.blockchain = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.arg1 = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.arg2 = reader.string();
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.network = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Asset_Unknown {
    return {
      blockchain: isSet(object.blockchain) ? globalThis.String(object.blockchain) : "",
      arg1: isSet(object.arg1) ? globalThis.String(object.arg1) : "",
      arg2: isSet(object.arg2) ? globalThis.String(object.arg2) : "",
      network: isSet(object.network) ? globalThis.String(object.network) : "",
    };
  },

  toJSON(message: Asset_Unknown): unknown {
    const obj: any = {};
    if (message.blockchain !== "") {
      obj.blockchain = message.blockchain;
    }
    if (message.arg1 !== "") {
      obj.arg1 = message.arg1;
    }
    if (message.arg2 !== "") {
      obj.arg2 = message.arg2;
    }
    if (message.network !== "") {
      obj.network = message.network;
    }
    return obj;
  },

  create(base?: DeepPartial<Asset_Unknown>): Asset_Unknown {
    return Asset_Unknown.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<Asset_Unknown>): Asset_Unknown {
    const message = createBaseAsset_Unknown();
    message.blockchain = object.blockchain ?? "";
    message.arg1 = object.arg1 ?? "";
    message.arg2 = object.arg2 ?? "";
    message.network = object.network ?? "";
    return message;
  },
};

function createBaseAssetBalance(): AssetBalance {
  return { asset: undefined, balance: undefined };
}

export const AssetBalance = {
  encode(message: AssetBalance, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.asset !== undefined) {
      Asset.encode(message.asset, writer.uint32(10).fork()).ldelim();
    }
    if (message.balance !== undefined) {
      Balance.encode(message.balance, writer.uint32(18).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): AssetBalance {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseAssetBalance();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.asset = Asset.decode(reader, reader.uint32());
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.balance = Balance.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): AssetBalance {
    return {
      asset: isSet(object.asset) ? Asset.fromJSON(object.asset) : undefined,
      balance: isSet(object.balance) ? Balance.fromJSON(object.balance) : undefined,
    };
  },

  toJSON(message: AssetBalance): unknown {
    const obj: any = {};
    if (message.asset !== undefined) {
      obj.asset = Asset.toJSON(message.asset);
    }
    if (message.balance !== undefined) {
      obj.balance = Balance.toJSON(message.balance);
    }
    return obj;
  },

  create(base?: DeepPartial<AssetBalance>): AssetBalance {
    return AssetBalance.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<AssetBalance>): AssetBalance {
    const message = createBaseAssetBalance();
    message.asset = (object.asset !== undefined && object.asset !== null) ? Asset.fromPartial(object.asset) : undefined;
    message.balance = (object.balance !== undefined && object.balance !== null)
      ? Balance.fromPartial(object.balance)
      : undefined;
    return message;
  },
};

function createBaseNFTCollectionBalance(): NFTCollectionBalance {
  return { currencyInfo: undefined, balance: undefined };
}

export const NFTCollectionBalance = {
  encode(message: NFTCollectionBalance, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.currencyInfo !== undefined) {
      Currency.encode(message.currencyInfo, writer.uint32(10).fork()).ldelim();
    }
    if (message.balance !== undefined) {
      Balance.encode(message.balance, writer.uint32(18).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): NFTCollectionBalance {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseNFTCollectionBalance();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.currencyInfo = Currency.decode(reader, reader.uint32());
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.balance = Balance.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): NFTCollectionBalance {
    return {
      currencyInfo: isSet(object.currencyInfo) ? Currency.fromJSON(object.currencyInfo) : undefined,
      balance: isSet(object.balance) ? Balance.fromJSON(object.balance) : undefined,
    };
  },

  toJSON(message: NFTCollectionBalance): unknown {
    const obj: any = {};
    if (message.currencyInfo !== undefined) {
      obj.currencyInfo = Currency.toJSON(message.currencyInfo);
    }
    if (message.balance !== undefined) {
      obj.balance = Balance.toJSON(message.balance);
    }
    return obj;
  },

  create(base?: DeepPartial<NFTCollectionBalance>): NFTCollectionBalance {
    return NFTCollectionBalance.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<NFTCollectionBalance>): NFTCollectionBalance {
    const message = createBaseNFTCollectionBalance();
    message.currencyInfo = (object.currencyInfo !== undefined && object.currencyInfo !== null)
      ? Currency.fromPartial(object.currencyInfo)
      : undefined;
    message.balance = (object.balance !== undefined && object.balance !== null)
      ? Balance.fromPartial(object.balance)
      : undefined;
    return message;
  },
};

function createBaseBalance(): Balance {
  return {
    totalConfirmed: "",
    totalUnconfirmed: "",
    availableConfirmed: "",
    availableUnconfirmed: "",
    reservedConfirmed: "",
    reservedUnconfirmed: "",
  };
}

export const Balance = {
  encode(message: Balance, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.totalConfirmed !== "") {
      writer.uint32(10).string(message.totalConfirmed);
    }
    if (message.totalUnconfirmed !== "") {
      writer.uint32(18).string(message.totalUnconfirmed);
    }
    if (message.availableConfirmed !== "") {
      writer.uint32(26).string(message.availableConfirmed);
    }
    if (message.availableUnconfirmed !== "") {
      writer.uint32(34).string(message.availableUnconfirmed);
    }
    if (message.reservedConfirmed !== "") {
      writer.uint32(42).string(message.reservedConfirmed);
    }
    if (message.reservedUnconfirmed !== "") {
      writer.uint32(50).string(message.reservedUnconfirmed);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): Balance {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseBalance();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.totalConfirmed = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.totalUnconfirmed = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.availableConfirmed = reader.string();
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.availableUnconfirmed = reader.string();
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.reservedConfirmed = reader.string();
          continue;
        case 6:
          if (tag !== 50) {
            break;
          }

          message.reservedUnconfirmed = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Balance {
    return {
      totalConfirmed: isSet(object.totalConfirmed) ? globalThis.String(object.totalConfirmed) : "",
      totalUnconfirmed: isSet(object.totalUnconfirmed) ? globalThis.String(object.totalUnconfirmed) : "",
      availableConfirmed: isSet(object.availableConfirmed) ? globalThis.String(object.availableConfirmed) : "",
      availableUnconfirmed: isSet(object.availableUnconfirmed) ? globalThis.String(object.availableUnconfirmed) : "",
      reservedConfirmed: isSet(object.reservedConfirmed) ? globalThis.String(object.reservedConfirmed) : "",
      reservedUnconfirmed: isSet(object.reservedUnconfirmed) ? globalThis.String(object.reservedUnconfirmed) : "",
    };
  },

  toJSON(message: Balance): unknown {
    const obj: any = {};
    if (message.totalConfirmed !== "") {
      obj.totalConfirmed = message.totalConfirmed;
    }
    if (message.totalUnconfirmed !== "") {
      obj.totalUnconfirmed = message.totalUnconfirmed;
    }
    if (message.availableConfirmed !== "") {
      obj.availableConfirmed = message.availableConfirmed;
    }
    if (message.availableUnconfirmed !== "") {
      obj.availableUnconfirmed = message.availableUnconfirmed;
    }
    if (message.reservedConfirmed !== "") {
      obj.reservedConfirmed = message.reservedConfirmed;
    }
    if (message.reservedUnconfirmed !== "") {
      obj.reservedUnconfirmed = message.reservedUnconfirmed;
    }
    return obj;
  },

  create(base?: DeepPartial<Balance>): Balance {
    return Balance.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<Balance>): Balance {
    const message = createBaseBalance();
    message.totalConfirmed = object.totalConfirmed ?? "";
    message.totalUnconfirmed = object.totalUnconfirmed ?? "";
    message.availableConfirmed = object.availableConfirmed ?? "";
    message.availableUnconfirmed = object.availableUnconfirmed ?? "";
    message.reservedConfirmed = object.reservedConfirmed ?? "";
    message.reservedUnconfirmed = object.reservedUnconfirmed ?? "";
    return message;
  },
};

function createBaseBalanceHistoryPoint(): BalanceHistoryPoint {
  return { pointDate: undefined, balance: undefined };
}

export const BalanceHistoryPoint = {
  encode(message: BalanceHistoryPoint, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.pointDate !== undefined) {
      Timestamp.encode(toTimestamp(message.pointDate), writer.uint32(10).fork()).ldelim();
    }
    if (message.balance !== undefined) {
      Balance.encode(message.balance, writer.uint32(18).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): BalanceHistoryPoint {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseBalanceHistoryPoint();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.pointDate = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.balance = Balance.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): BalanceHistoryPoint {
    return {
      pointDate: isSet(object.pointDate) ? fromJsonTimestamp(object.pointDate) : undefined,
      balance: isSet(object.balance) ? Balance.fromJSON(object.balance) : undefined,
    };
  },

  toJSON(message: BalanceHistoryPoint): unknown {
    const obj: any = {};
    if (message.pointDate !== undefined) {
      obj.pointDate = message.pointDate.toISOString();
    }
    if (message.balance !== undefined) {
      obj.balance = Balance.toJSON(message.balance);
    }
    return obj;
  },

  create(base?: DeepPartial<BalanceHistoryPoint>): BalanceHistoryPoint {
    return BalanceHistoryPoint.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<BalanceHistoryPoint>): BalanceHistoryPoint {
    const message = createBaseBalanceHistoryPoint();
    message.pointDate = object.pointDate ?? undefined;
    message.balance = (object.balance !== undefined && object.balance !== null)
      ? Balance.fromPartial(object.balance)
      : undefined;
    return message;
  },
};

function createBaseWallet(): Wallet {
  return {
    id: 0,
    balance: undefined,
    currency: "",
    coin: "",
    name: "",
    container: "",
    seed: "",
    accountPath: "",
    addresses: [],
    isOmnibus: false,
    creationDate: undefined,
    updateDate: undefined,
    customerId: "",
    comment: "",
    disabled: false,
    blockchain: "",
    addressesCount: 0,
    attributes: [],
    currencyInfo: undefined,
    externalWalletId: "",
  };
}

export const Wallet = {
  encode(message: Wallet, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.id !== 0) {
      writer.uint32(8).uint64(message.id);
    }
    if (message.balance !== undefined) {
      Balance.encode(message.balance, writer.uint32(18).fork()).ldelim();
    }
    if (message.currency !== "") {
      writer.uint32(26).string(message.currency);
    }
    if (message.coin !== "") {
      writer.uint32(34).string(message.coin);
    }
    if (message.name !== "") {
      writer.uint32(42).string(message.name);
    }
    if (message.container !== "") {
      writer.uint32(50).string(message.container);
    }
    if (message.seed !== "") {
      writer.uint32(58).string(message.seed);
    }
    if (message.accountPath !== "") {
      writer.uint32(66).string(message.accountPath);
    }
    for (const v of message.addresses) {
      Address.encode(v!, writer.uint32(74).fork()).ldelim();
    }
    if (message.isOmnibus !== false) {
      writer.uint32(80).bool(message.isOmnibus);
    }
    if (message.creationDate !== undefined) {
      Timestamp.encode(toTimestamp(message.creationDate), writer.uint32(90).fork()).ldelim();
    }
    if (message.updateDate !== undefined) {
      Timestamp.encode(toTimestamp(message.updateDate), writer.uint32(98).fork()).ldelim();
    }
    if (message.customerId !== "") {
      writer.uint32(106).string(message.customerId);
    }
    if (message.comment !== "") {
      writer.uint32(114).string(message.comment);
    }
    if (message.disabled !== false) {
      writer.uint32(120).bool(message.disabled);
    }
    if (message.blockchain !== "") {
      writer.uint32(130).string(message.blockchain);
    }
    if (message.addressesCount !== 0) {
      writer.uint32(136).uint64(message.addressesCount);
    }
    for (const v of message.attributes) {
      WalletAttribute.encode(v!, writer.uint32(146).fork()).ldelim();
    }
    if (message.currencyInfo !== undefined) {
      Currency.encode(message.currencyInfo, writer.uint32(154).fork()).ldelim();
    }
    if (message.externalWalletId !== "") {
      writer.uint32(162).string(message.externalWalletId);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): Wallet {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseWallet();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.id = longToNumber(reader.uint64() as Long);
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.balance = Balance.decode(reader, reader.uint32());
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.currency = reader.string();
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.coin = reader.string();
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.name = reader.string();
          continue;
        case 6:
          if (tag !== 50) {
            break;
          }

          message.container = reader.string();
          continue;
        case 7:
          if (tag !== 58) {
            break;
          }

          message.seed = reader.string();
          continue;
        case 8:
          if (tag !== 66) {
            break;
          }

          message.accountPath = reader.string();
          continue;
        case 9:
          if (tag !== 74) {
            break;
          }

          message.addresses.push(Address.decode(reader, reader.uint32()));
          continue;
        case 10:
          if (tag !== 80) {
            break;
          }

          message.isOmnibus = reader.bool();
          continue;
        case 11:
          if (tag !== 90) {
            break;
          }

          message.creationDate = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        case 12:
          if (tag !== 98) {
            break;
          }

          message.updateDate = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        case 13:
          if (tag !== 106) {
            break;
          }

          message.customerId = reader.string();
          continue;
        case 14:
          if (tag !== 114) {
            break;
          }

          message.comment = reader.string();
          continue;
        case 15:
          if (tag !== 120) {
            break;
          }

          message.disabled = reader.bool();
          continue;
        case 16:
          if (tag !== 130) {
            break;
          }

          message.blockchain = reader.string();
          continue;
        case 17:
          if (tag !== 136) {
            break;
          }

          message.addressesCount = longToNumber(reader.uint64() as Long);
          continue;
        case 18:
          if (tag !== 146) {
            break;
          }

          message.attributes.push(WalletAttribute.decode(reader, reader.uint32()));
          continue;
        case 19:
          if (tag !== 154) {
            break;
          }

          message.currencyInfo = Currency.decode(reader, reader.uint32());
          continue;
        case 20:
          if (tag !== 162) {
            break;
          }

          message.externalWalletId = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Wallet {
    return {
      id: isSet(object.id) ? globalThis.Number(object.id) : 0,
      balance: isSet(object.balance) ? Balance.fromJSON(object.balance) : undefined,
      currency: isSet(object.currency) ? globalThis.String(object.currency) : "",
      coin: isSet(object.coin) ? globalThis.String(object.coin) : "",
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      container: isSet(object.container) ? globalThis.String(object.container) : "",
      seed: isSet(object.seed) ? globalThis.String(object.seed) : "",
      accountPath: isSet(object.accountPath) ? globalThis.String(object.accountPath) : "",
      addresses: globalThis.Array.isArray(object?.addresses)
        ? object.addresses.map((e: any) => Address.fromJSON(e))
        : [],
      isOmnibus: isSet(object.isOmnibus) ? globalThis.Boolean(object.isOmnibus) : false,
      creationDate: isSet(object.creationDate) ? fromJsonTimestamp(object.creationDate) : undefined,
      updateDate: isSet(object.updateDate) ? fromJsonTimestamp(object.updateDate) : undefined,
      customerId: isSet(object.customerId) ? globalThis.String(object.customerId) : "",
      comment: isSet(object.comment) ? globalThis.String(object.comment) : "",
      disabled: isSet(object.disabled) ? globalThis.Boolean(object.disabled) : false,
      blockchain: isSet(object.blockchain) ? globalThis.String(object.blockchain) : "",
      addressesCount: isSet(object.addressesCount) ? globalThis.Number(object.addressesCount) : 0,
      attributes: globalThis.Array.isArray(object?.attributes)
        ? object.attributes.map((e: any) => WalletAttribute.fromJSON(e))
        : [],
      currencyInfo: isSet(object.currencyInfo) ? Currency.fromJSON(object.currencyInfo) : undefined,
      externalWalletId: isSet(object.externalWalletId) ? globalThis.String(object.externalWalletId) : "",
    };
  },

  toJSON(message: Wallet): unknown {
    const obj: any = {};
    if (message.id !== 0) {
      obj.id = Math.round(message.id);
    }
    if (message.balance !== undefined) {
      obj.balance = Balance.toJSON(message.balance);
    }
    if (message.currency !== "") {
      obj.currency = message.currency;
    }
    if (message.coin !== "") {
      obj.coin = message.coin;
    }
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.container !== "") {
      obj.container = message.container;
    }
    if (message.seed !== "") {
      obj.seed = message.seed;
    }
    if (message.accountPath !== "") {
      obj.accountPath = message.accountPath;
    }
    if (message.addresses?.length) {
      obj.addresses = message.addresses.map((e) => Address.toJSON(e));
    }
    if (message.isOmnibus !== false) {
      obj.isOmnibus = message.isOmnibus;
    }
    if (message.creationDate !== undefined) {
      obj.creationDate = message.creationDate.toISOString();
    }
    if (message.updateDate !== undefined) {
      obj.updateDate = message.updateDate.toISOString();
    }
    if (message.customerId !== "") {
      obj.customerId = message.customerId;
    }
    if (message.comment !== "") {
      obj.comment = message.comment;
    }
    if (message.disabled !== false) {
      obj.disabled = message.disabled;
    }
    if (message.blockchain !== "") {
      obj.blockchain = message.blockchain;
    }
    if (message.addressesCount !== 0) {
      obj.addressesCount = Math.round(message.addressesCount);
    }
    if (message.attributes?.length) {
      obj.attributes = message.attributes.map((e) => WalletAttribute.toJSON(e));
    }
    if (message.currencyInfo !== undefined) {
      obj.currencyInfo = Currency.toJSON(message.currencyInfo);
    }
    if (message.externalWalletId !== "") {
      obj.externalWalletId = message.externalWalletId;
    }
    return obj;
  },

  create(base?: DeepPartial<Wallet>): Wallet {
    return Wallet.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<Wallet>): Wallet {
    const message = createBaseWallet();
    message.id = object.id ?? 0;
    message.balance = (object.balance !== undefined && object.balance !== null)
      ? Balance.fromPartial(object.balance)
      : undefined;
    message.currency = object.currency ?? "";
    message.coin = object.coin ?? "";
    message.name = object.name ?? "";
    message.container = object.container ?? "";
    message.seed = object.seed ?? "";
    message.accountPath = object.accountPath ?? "";
    message.addresses = object.addresses?.map((e) => Address.fromPartial(e)) || [];
    message.isOmnibus = object.isOmnibus ?? false;
    message.creationDate = object.creationDate ?? undefined;
    message.updateDate = object.updateDate ?? undefined;
    message.customerId = object.customerId ?? "";
    message.comment = object.comment ?? "";
    message.disabled = object.disabled ?? false;
    message.blockchain = object.blockchain ?? "";
    message.addressesCount = object.addressesCount ?? 0;
    message.attributes = object.attributes?.map((e) => WalletAttribute.fromPartial(e)) || [];
    message.currencyInfo = (object.currencyInfo !== undefined && object.currencyInfo !== null)
      ? Currency.fromPartial(object.currencyInfo)
      : undefined;
    message.externalWalletId = object.externalWalletId ?? "";
    return message;
  },
};

function createBaseWalletAttribute(): WalletAttribute {
  return { key: "", value: "", id: 0, contentType: "", owner: "", type: "", subtype: "", isfile: false };
}

export const WalletAttribute = {
  encode(message: WalletAttribute, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.key !== "") {
      writer.uint32(10).string(message.key);
    }
    if (message.value !== "") {
      writer.uint32(18).string(message.value);
    }
    if (message.id !== 0) {
      writer.uint32(24).uint64(message.id);
    }
    if (message.contentType !== "") {
      writer.uint32(34).string(message.contentType);
    }
    if (message.owner !== "") {
      writer.uint32(42).string(message.owner);
    }
    if (message.type !== "") {
      writer.uint32(50).string(message.type);
    }
    if (message.subtype !== "") {
      writer.uint32(58).string(message.subtype);
    }
    if (message.isfile !== false) {
      writer.uint32(64).bool(message.isfile);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): WalletAttribute {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseWalletAttribute();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.key = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.value = reader.string();
          continue;
        case 3:
          if (tag !== 24) {
            break;
          }

          message.id = longToNumber(reader.uint64() as Long);
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.contentType = reader.string();
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.owner = reader.string();
          continue;
        case 6:
          if (tag !== 50) {
            break;
          }

          message.type = reader.string();
          continue;
        case 7:
          if (tag !== 58) {
            break;
          }

          message.subtype = reader.string();
          continue;
        case 8:
          if (tag !== 64) {
            break;
          }

          message.isfile = reader.bool();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): WalletAttribute {
    return {
      key: isSet(object.key) ? globalThis.String(object.key) : "",
      value: isSet(object.value) ? globalThis.String(object.value) : "",
      id: isSet(object.id) ? globalThis.Number(object.id) : 0,
      contentType: isSet(object.contentType) ? globalThis.String(object.contentType) : "",
      owner: isSet(object.owner) ? globalThis.String(object.owner) : "",
      type: isSet(object.type) ? globalThis.String(object.type) : "",
      subtype: isSet(object.subtype) ? globalThis.String(object.subtype) : "",
      isfile: isSet(object.isfile) ? globalThis.Boolean(object.isfile) : false,
    };
  },

  toJSON(message: WalletAttribute): unknown {
    const obj: any = {};
    if (message.key !== "") {
      obj.key = message.key;
    }
    if (message.value !== "") {
      obj.value = message.value;
    }
    if (message.id !== 0) {
      obj.id = Math.round(message.id);
    }
    if (message.contentType !== "") {
      obj.contentType = message.contentType;
    }
    if (message.owner !== "") {
      obj.owner = message.owner;
    }
    if (message.type !== "") {
      obj.type = message.type;
    }
    if (message.subtype !== "") {
      obj.subtype = message.subtype;
    }
    if (message.isfile !== false) {
      obj.isfile = message.isfile;
    }
    return obj;
  },

  create(base?: DeepPartial<WalletAttribute>): WalletAttribute {
    return WalletAttribute.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<WalletAttribute>): WalletAttribute {
    const message = createBaseWalletAttribute();
    message.key = object.key ?? "";
    message.value = object.value ?? "";
    message.id = object.id ?? 0;
    message.contentType = object.contentType ?? "";
    message.owner = object.owner ?? "";
    message.type = object.type ?? "";
    message.subtype = object.subtype ?? "";
    message.isfile = object.isfile ?? false;
    return message;
  },
};

function createBaseWalletInfo(): WalletInfo {
  return {
    id: 0,
    balance: undefined,
    currency: "",
    coin: "",
    name: "",
    container: "",
    seed: "",
    accountPath: "",
    isOmnibus: false,
    creationDate: undefined,
    updateDate: undefined,
    customerId: "",
    comment: "",
    disabled: false,
    blockchain: "",
    addressesCount: 0,
    currencyInfo: undefined,
    attributes: [],
    network: "",
    visibilityGroupID: "",
    externalWalletId: "",
  };
}

export const WalletInfo = {
  encode(message: WalletInfo, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.id !== 0) {
      writer.uint32(8).uint64(message.id);
    }
    if (message.balance !== undefined) {
      Balance.encode(message.balance, writer.uint32(18).fork()).ldelim();
    }
    if (message.currency !== "") {
      writer.uint32(26).string(message.currency);
    }
    if (message.coin !== "") {
      writer.uint32(34).string(message.coin);
    }
    if (message.name !== "") {
      writer.uint32(42).string(message.name);
    }
    if (message.container !== "") {
      writer.uint32(50).string(message.container);
    }
    if (message.seed !== "") {
      writer.uint32(58).string(message.seed);
    }
    if (message.accountPath !== "") {
      writer.uint32(66).string(message.accountPath);
    }
    if (message.isOmnibus !== false) {
      writer.uint32(72).bool(message.isOmnibus);
    }
    if (message.creationDate !== undefined) {
      Timestamp.encode(toTimestamp(message.creationDate), writer.uint32(82).fork()).ldelim();
    }
    if (message.updateDate !== undefined) {
      Timestamp.encode(toTimestamp(message.updateDate), writer.uint32(90).fork()).ldelim();
    }
    if (message.customerId !== "") {
      writer.uint32(98).string(message.customerId);
    }
    if (message.comment !== "") {
      writer.uint32(106).string(message.comment);
    }
    if (message.disabled !== false) {
      writer.uint32(112).bool(message.disabled);
    }
    if (message.blockchain !== "") {
      writer.uint32(122).string(message.blockchain);
    }
    if (message.addressesCount !== 0) {
      writer.uint32(128).uint64(message.addressesCount);
    }
    if (message.currencyInfo !== undefined) {
      Currency.encode(message.currencyInfo, writer.uint32(138).fork()).ldelim();
    }
    for (const v of message.attributes) {
      WalletAttribute.encode(v!, writer.uint32(146).fork()).ldelim();
    }
    if (message.network !== "") {
      writer.uint32(154).string(message.network);
    }
    if (message.visibilityGroupID !== "") {
      writer.uint32(162).string(message.visibilityGroupID);
    }
    if (message.externalWalletId !== "") {
      writer.uint32(170).string(message.externalWalletId);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): WalletInfo {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseWalletInfo();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.id = longToNumber(reader.uint64() as Long);
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.balance = Balance.decode(reader, reader.uint32());
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.currency = reader.string();
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.coin = reader.string();
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.name = reader.string();
          continue;
        case 6:
          if (tag !== 50) {
            break;
          }

          message.container = reader.string();
          continue;
        case 7:
          if (tag !== 58) {
            break;
          }

          message.seed = reader.string();
          continue;
        case 8:
          if (tag !== 66) {
            break;
          }

          message.accountPath = reader.string();
          continue;
        case 9:
          if (tag !== 72) {
            break;
          }

          message.isOmnibus = reader.bool();
          continue;
        case 10:
          if (tag !== 82) {
            break;
          }

          message.creationDate = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        case 11:
          if (tag !== 90) {
            break;
          }

          message.updateDate = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        case 12:
          if (tag !== 98) {
            break;
          }

          message.customerId = reader.string();
          continue;
        case 13:
          if (tag !== 106) {
            break;
          }

          message.comment = reader.string();
          continue;
        case 14:
          if (tag !== 112) {
            break;
          }

          message.disabled = reader.bool();
          continue;
        case 15:
          if (tag !== 122) {
            break;
          }

          message.blockchain = reader.string();
          continue;
        case 16:
          if (tag !== 128) {
            break;
          }

          message.addressesCount = longToNumber(reader.uint64() as Long);
          continue;
        case 17:
          if (tag !== 138) {
            break;
          }

          message.currencyInfo = Currency.decode(reader, reader.uint32());
          continue;
        case 18:
          if (tag !== 146) {
            break;
          }

          message.attributes.push(WalletAttribute.decode(reader, reader.uint32()));
          continue;
        case 19:
          if (tag !== 154) {
            break;
          }

          message.network = reader.string();
          continue;
        case 20:
          if (tag !== 162) {
            break;
          }

          message.visibilityGroupID = reader.string();
          continue;
        case 21:
          if (tag !== 170) {
            break;
          }

          message.externalWalletId = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): WalletInfo {
    return {
      id: isSet(object.id) ? globalThis.Number(object.id) : 0,
      balance: isSet(object.balance) ? Balance.fromJSON(object.balance) : undefined,
      currency: isSet(object.currency) ? globalThis.String(object.currency) : "",
      coin: isSet(object.coin) ? globalThis.String(object.coin) : "",
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      container: isSet(object.container) ? globalThis.String(object.container) : "",
      seed: isSet(object.seed) ? globalThis.String(object.seed) : "",
      accountPath: isSet(object.accountPath) ? globalThis.String(object.accountPath) : "",
      isOmnibus: isSet(object.isOmnibus) ? globalThis.Boolean(object.isOmnibus) : false,
      creationDate: isSet(object.creationDate) ? fromJsonTimestamp(object.creationDate) : undefined,
      updateDate: isSet(object.updateDate) ? fromJsonTimestamp(object.updateDate) : undefined,
      customerId: isSet(object.customerId) ? globalThis.String(object.customerId) : "",
      comment: isSet(object.comment) ? globalThis.String(object.comment) : "",
      disabled: isSet(object.disabled) ? globalThis.Boolean(object.disabled) : false,
      blockchain: isSet(object.blockchain) ? globalThis.String(object.blockchain) : "",
      addressesCount: isSet(object.addressesCount) ? globalThis.Number(object.addressesCount) : 0,
      currencyInfo: isSet(object.currencyInfo) ? Currency.fromJSON(object.currencyInfo) : undefined,
      attributes: globalThis.Array.isArray(object?.attributes)
        ? object.attributes.map((e: any) => WalletAttribute.fromJSON(e))
        : [],
      network: isSet(object.network) ? globalThis.String(object.network) : "",
      visibilityGroupID: isSet(object.visibilityGroupID) ? globalThis.String(object.visibilityGroupID) : "",
      externalWalletId: isSet(object.externalWalletId) ? globalThis.String(object.externalWalletId) : "",
    };
  },

  toJSON(message: WalletInfo): unknown {
    const obj: any = {};
    if (message.id !== 0) {
      obj.id = Math.round(message.id);
    }
    if (message.balance !== undefined) {
      obj.balance = Balance.toJSON(message.balance);
    }
    if (message.currency !== "") {
      obj.currency = message.currency;
    }
    if (message.coin !== "") {
      obj.coin = message.coin;
    }
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.container !== "") {
      obj.container = message.container;
    }
    if (message.seed !== "") {
      obj.seed = message.seed;
    }
    if (message.accountPath !== "") {
      obj.accountPath = message.accountPath;
    }
    if (message.isOmnibus !== false) {
      obj.isOmnibus = message.isOmnibus;
    }
    if (message.creationDate !== undefined) {
      obj.creationDate = message.creationDate.toISOString();
    }
    if (message.updateDate !== undefined) {
      obj.updateDate = message.updateDate.toISOString();
    }
    if (message.customerId !== "") {
      obj.customerId = message.customerId;
    }
    if (message.comment !== "") {
      obj.comment = message.comment;
    }
    if (message.disabled !== false) {
      obj.disabled = message.disabled;
    }
    if (message.blockchain !== "") {
      obj.blockchain = message.blockchain;
    }
    if (message.addressesCount !== 0) {
      obj.addressesCount = Math.round(message.addressesCount);
    }
    if (message.currencyInfo !== undefined) {
      obj.currencyInfo = Currency.toJSON(message.currencyInfo);
    }
    if (message.attributes?.length) {
      obj.attributes = message.attributes.map((e) => WalletAttribute.toJSON(e));
    }
    if (message.network !== "") {
      obj.network = message.network;
    }
    if (message.visibilityGroupID !== "") {
      obj.visibilityGroupID = message.visibilityGroupID;
    }
    if (message.externalWalletId !== "") {
      obj.externalWalletId = message.externalWalletId;
    }
    return obj;
  },

  create(base?: DeepPartial<WalletInfo>): WalletInfo {
    return WalletInfo.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<WalletInfo>): WalletInfo {
    const message = createBaseWalletInfo();
    message.id = object.id ?? 0;
    message.balance = (object.balance !== undefined && object.balance !== null)
      ? Balance.fromPartial(object.balance)
      : undefined;
    message.currency = object.currency ?? "";
    message.coin = object.coin ?? "";
    message.name = object.name ?? "";
    message.container = object.container ?? "";
    message.seed = object.seed ?? "";
    message.accountPath = object.accountPath ?? "";
    message.isOmnibus = object.isOmnibus ?? false;
    message.creationDate = object.creationDate ?? undefined;
    message.updateDate = object.updateDate ?? undefined;
    message.customerId = object.customerId ?? "";
    message.comment = object.comment ?? "";
    message.disabled = object.disabled ?? false;
    message.blockchain = object.blockchain ?? "";
    message.addressesCount = object.addressesCount ?? 0;
    message.currencyInfo = (object.currencyInfo !== undefined && object.currencyInfo !== null)
      ? Currency.fromPartial(object.currencyInfo)
      : undefined;
    message.attributes = object.attributes?.map((e) => WalletAttribute.fromPartial(e)) || [];
    message.network = object.network ?? "";
    message.visibilityGroupID = object.visibilityGroupID ?? "";
    message.externalWalletId = object.externalWalletId ?? "";
    return message;
  },
};

function createBaseAddress(): Address {
  return {
    id: 0,
    walletId: 0,
    seed: "",
    currency: "",
    addressPath: "",
    addressIndex: 0,
    address: "",
    alternateAddress: "",
    comment: "",
    label: "",
    customerId: "",
    nonce: 0,
    balance: undefined,
    signature: "",
    scores: [],
    attributes: [],
    linkedWhitelistedAddressIds: [],
    creationDate: undefined,
    updateDate: undefined,
    walletInfo: undefined,
    disabled: false,
    currencyInfo: undefined,
    canUseAllFunds: false,
    externalAddressId: "",
    status: "",
  };
}

export const Address = {
  encode(message: Address, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.id !== 0) {
      writer.uint32(8).uint64(message.id);
    }
    if (message.walletId !== 0) {
      writer.uint32(16).uint64(message.walletId);
    }
    if (message.seed !== "") {
      writer.uint32(26).string(message.seed);
    }
    if (message.currency !== "") {
      writer.uint32(34).string(message.currency);
    }
    if (message.addressPath !== "") {
      writer.uint32(42).string(message.addressPath);
    }
    if (message.addressIndex !== 0) {
      writer.uint32(48).uint64(message.addressIndex);
    }
    if (message.address !== "") {
      writer.uint32(58).string(message.address);
    }
    if (message.alternateAddress !== "") {
      writer.uint32(66).string(message.alternateAddress);
    }
    if (message.comment !== "") {
      writer.uint32(74).string(message.comment);
    }
    if (message.label !== "") {
      writer.uint32(82).string(message.label);
    }
    if (message.customerId !== "") {
      writer.uint32(90).string(message.customerId);
    }
    if (message.nonce !== 0) {
      writer.uint32(96).uint64(message.nonce);
    }
    if (message.balance !== undefined) {
      Balance.encode(message.balance, writer.uint32(106).fork()).ldelim();
    }
    if (message.signature !== "") {
      writer.uint32(114).string(message.signature);
    }
    for (const v of message.scores) {
      Score.encode(v!, writer.uint32(122).fork()).ldelim();
    }
    for (const v of message.attributes) {
      AddressAttribute.encode(v!, writer.uint32(130).fork()).ldelim();
    }
    writer.uint32(138).fork();
    for (const v of message.linkedWhitelistedAddressIds) {
      writer.uint64(v);
    }
    writer.ldelim();
    if (message.creationDate !== undefined) {
      Timestamp.encode(toTimestamp(message.creationDate), writer.uint32(146).fork()).ldelim();
    }
    if (message.updateDate !== undefined) {
      Timestamp.encode(toTimestamp(message.updateDate), writer.uint32(154).fork()).ldelim();
    }
    if (message.walletInfo !== undefined) {
      WalletInfo.encode(message.walletInfo, writer.uint32(162).fork()).ldelim();
    }
    if (message.disabled !== false) {
      writer.uint32(168).bool(message.disabled);
    }
    if (message.currencyInfo !== undefined) {
      Currency.encode(message.currencyInfo, writer.uint32(178).fork()).ldelim();
    }
    if (message.canUseAllFunds !== false) {
      writer.uint32(184).bool(message.canUseAllFunds);
    }
    if (message.externalAddressId !== "") {
      writer.uint32(194).string(message.externalAddressId);
    }
    if (message.status !== "") {
      writer.uint32(202).string(message.status);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): Address {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseAddress();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.id = longToNumber(reader.uint64() as Long);
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.walletId = longToNumber(reader.uint64() as Long);
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.seed = reader.string();
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.currency = reader.string();
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.addressPath = reader.string();
          continue;
        case 6:
          if (tag !== 48) {
            break;
          }

          message.addressIndex = longToNumber(reader.uint64() as Long);
          continue;
        case 7:
          if (tag !== 58) {
            break;
          }

          message.address = reader.string();
          continue;
        case 8:
          if (tag !== 66) {
            break;
          }

          message.alternateAddress = reader.string();
          continue;
        case 9:
          if (tag !== 74) {
            break;
          }

          message.comment = reader.string();
          continue;
        case 10:
          if (tag !== 82) {
            break;
          }

          message.label = reader.string();
          continue;
        case 11:
          if (tag !== 90) {
            break;
          }

          message.customerId = reader.string();
          continue;
        case 12:
          if (tag !== 96) {
            break;
          }

          message.nonce = longToNumber(reader.uint64() as Long);
          continue;
        case 13:
          if (tag !== 106) {
            break;
          }

          message.balance = Balance.decode(reader, reader.uint32());
          continue;
        case 14:
          if (tag !== 114) {
            break;
          }

          message.signature = reader.string();
          continue;
        case 15:
          if (tag !== 122) {
            break;
          }

          message.scores.push(Score.decode(reader, reader.uint32()));
          continue;
        case 16:
          if (tag !== 130) {
            break;
          }

          message.attributes.push(AddressAttribute.decode(reader, reader.uint32()));
          continue;
        case 17:
          if (tag === 136) {
            message.linkedWhitelistedAddressIds.push(longToNumber(reader.uint64() as Long));

            continue;
          }

          if (tag === 138) {
            const end2 = reader.uint32() + reader.pos;
            while (reader.pos < end2) {
              message.linkedWhitelistedAddressIds.push(longToNumber(reader.uint64() as Long));
            }

            continue;
          }

          break;
        case 18:
          if (tag !== 146) {
            break;
          }

          message.creationDate = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        case 19:
          if (tag !== 154) {
            break;
          }

          message.updateDate = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        case 20:
          if (tag !== 162) {
            break;
          }

          message.walletInfo = WalletInfo.decode(reader, reader.uint32());
          continue;
        case 21:
          if (tag !== 168) {
            break;
          }

          message.disabled = reader.bool();
          continue;
        case 22:
          if (tag !== 178) {
            break;
          }

          message.currencyInfo = Currency.decode(reader, reader.uint32());
          continue;
        case 23:
          if (tag !== 184) {
            break;
          }

          message.canUseAllFunds = reader.bool();
          continue;
        case 24:
          if (tag !== 194) {
            break;
          }

          message.externalAddressId = reader.string();
          continue;
        case 25:
          if (tag !== 202) {
            break;
          }

          message.status = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Address {
    return {
      id: isSet(object.id) ? globalThis.Number(object.id) : 0,
      walletId: isSet(object.walletId) ? globalThis.Number(object.walletId) : 0,
      seed: isSet(object.seed) ? globalThis.String(object.seed) : "",
      currency: isSet(object.currency) ? globalThis.String(object.currency) : "",
      addressPath: isSet(object.addressPath) ? globalThis.String(object.addressPath) : "",
      addressIndex: isSet(object.addressIndex) ? globalThis.Number(object.addressIndex) : 0,
      address: isSet(object.address) ? globalThis.String(object.address) : "",
      alternateAddress: isSet(object.alternateAddress) ? globalThis.String(object.alternateAddress) : "",
      comment: isSet(object.comment) ? globalThis.String(object.comment) : "",
      label: isSet(object.label) ? globalThis.String(object.label) : "",
      customerId: isSet(object.customerId) ? globalThis.String(object.customerId) : "",
      nonce: isSet(object.nonce) ? globalThis.Number(object.nonce) : 0,
      balance: isSet(object.balance) ? Balance.fromJSON(object.balance) : undefined,
      signature: isSet(object.signature) ? globalThis.String(object.signature) : "",
      scores: globalThis.Array.isArray(object?.scores) ? object.scores.map((e: any) => Score.fromJSON(e)) : [],
      attributes: globalThis.Array.isArray(object?.attributes)
        ? object.attributes.map((e: any) => AddressAttribute.fromJSON(e))
        : [],
      linkedWhitelistedAddressIds: globalThis.Array.isArray(object?.linkedWhitelistedAddressIds)
        ? object.linkedWhitelistedAddressIds.map((e: any) => globalThis.Number(e))
        : [],
      creationDate: isSet(object.creationDate) ? fromJsonTimestamp(object.creationDate) : undefined,
      updateDate: isSet(object.updateDate) ? fromJsonTimestamp(object.updateDate) : undefined,
      walletInfo: isSet(object.walletInfo) ? WalletInfo.fromJSON(object.walletInfo) : undefined,
      disabled: isSet(object.disabled) ? globalThis.Boolean(object.disabled) : false,
      currencyInfo: isSet(object.currencyInfo) ? Currency.fromJSON(object.currencyInfo) : undefined,
      canUseAllFunds: isSet(object.canUseAllFunds) ? globalThis.Boolean(object.canUseAllFunds) : false,
      externalAddressId: isSet(object.externalAddressId) ? globalThis.String(object.externalAddressId) : "",
      status: isSet(object.status) ? globalThis.String(object.status) : "",
    };
  },

  toJSON(message: Address): unknown {
    const obj: any = {};
    if (message.id !== 0) {
      obj.id = Math.round(message.id);
    }
    if (message.walletId !== 0) {
      obj.walletId = Math.round(message.walletId);
    }
    if (message.seed !== "") {
      obj.seed = message.seed;
    }
    if (message.currency !== "") {
      obj.currency = message.currency;
    }
    if (message.addressPath !== "") {
      obj.addressPath = message.addressPath;
    }
    if (message.addressIndex !== 0) {
      obj.addressIndex = Math.round(message.addressIndex);
    }
    if (message.address !== "") {
      obj.address = message.address;
    }
    if (message.alternateAddress !== "") {
      obj.alternateAddress = message.alternateAddress;
    }
    if (message.comment !== "") {
      obj.comment = message.comment;
    }
    if (message.label !== "") {
      obj.label = message.label;
    }
    if (message.customerId !== "") {
      obj.customerId = message.customerId;
    }
    if (message.nonce !== 0) {
      obj.nonce = Math.round(message.nonce);
    }
    if (message.balance !== undefined) {
      obj.balance = Balance.toJSON(message.balance);
    }
    if (message.signature !== "") {
      obj.signature = message.signature;
    }
    if (message.scores?.length) {
      obj.scores = message.scores.map((e) => Score.toJSON(e));
    }
    if (message.attributes?.length) {
      obj.attributes = message.attributes.map((e) => AddressAttribute.toJSON(e));
    }
    if (message.linkedWhitelistedAddressIds?.length) {
      obj.linkedWhitelistedAddressIds = message.linkedWhitelistedAddressIds.map((e) => Math.round(e));
    }
    if (message.creationDate !== undefined) {
      obj.creationDate = message.creationDate.toISOString();
    }
    if (message.updateDate !== undefined) {
      obj.updateDate = message.updateDate.toISOString();
    }
    if (message.walletInfo !== undefined) {
      obj.walletInfo = WalletInfo.toJSON(message.walletInfo);
    }
    if (message.disabled !== false) {
      obj.disabled = message.disabled;
    }
    if (message.currencyInfo !== undefined) {
      obj.currencyInfo = Currency.toJSON(message.currencyInfo);
    }
    if (message.canUseAllFunds !== false) {
      obj.canUseAllFunds = message.canUseAllFunds;
    }
    if (message.externalAddressId !== "") {
      obj.externalAddressId = message.externalAddressId;
    }
    if (message.status !== "") {
      obj.status = message.status;
    }
    return obj;
  },

  create(base?: DeepPartial<Address>): Address {
    return Address.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<Address>): Address {
    const message = createBaseAddress();
    message.id = object.id ?? 0;
    message.walletId = object.walletId ?? 0;
    message.seed = object.seed ?? "";
    message.currency = object.currency ?? "";
    message.addressPath = object.addressPath ?? "";
    message.addressIndex = object.addressIndex ?? 0;
    message.address = object.address ?? "";
    message.alternateAddress = object.alternateAddress ?? "";
    message.comment = object.comment ?? "";
    message.label = object.label ?? "";
    message.customerId = object.customerId ?? "";
    message.nonce = object.nonce ?? 0;
    message.balance = (object.balance !== undefined && object.balance !== null)
      ? Balance.fromPartial(object.balance)
      : undefined;
    message.signature = object.signature ?? "";
    message.scores = object.scores?.map((e) => Score.fromPartial(e)) || [];
    message.attributes = object.attributes?.map((e) => AddressAttribute.fromPartial(e)) || [];
    message.linkedWhitelistedAddressIds = object.linkedWhitelistedAddressIds?.map((e) => e) || [];
    message.creationDate = object.creationDate ?? undefined;
    message.updateDate = object.updateDate ?? undefined;
    message.walletInfo = (object.walletInfo !== undefined && object.walletInfo !== null)
      ? WalletInfo.fromPartial(object.walletInfo)
      : undefined;
    message.disabled = object.disabled ?? false;
    message.currencyInfo = (object.currencyInfo !== undefined && object.currencyInfo !== null)
      ? Currency.fromPartial(object.currencyInfo)
      : undefined;
    message.canUseAllFunds = object.canUseAllFunds ?? false;
    message.externalAddressId = object.externalAddressId ?? "";
    message.status = object.status ?? "";
    return message;
  },
};

function createBaseAddressAttribute(): AddressAttribute {
  return { key: "", value: "", id: 0, contentType: "", owner: "", type: "", subtype: "", isfile: false };
}

export const AddressAttribute = {
  encode(message: AddressAttribute, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.key !== "") {
      writer.uint32(10).string(message.key);
    }
    if (message.value !== "") {
      writer.uint32(18).string(message.value);
    }
    if (message.id !== 0) {
      writer.uint32(24).uint64(message.id);
    }
    if (message.contentType !== "") {
      writer.uint32(34).string(message.contentType);
    }
    if (message.owner !== "") {
      writer.uint32(42).string(message.owner);
    }
    if (message.type !== "") {
      writer.uint32(50).string(message.type);
    }
    if (message.subtype !== "") {
      writer.uint32(58).string(message.subtype);
    }
    if (message.isfile !== false) {
      writer.uint32(64).bool(message.isfile);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): AddressAttribute {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseAddressAttribute();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.key = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.value = reader.string();
          continue;
        case 3:
          if (tag !== 24) {
            break;
          }

          message.id = longToNumber(reader.uint64() as Long);
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.contentType = reader.string();
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.owner = reader.string();
          continue;
        case 6:
          if (tag !== 50) {
            break;
          }

          message.type = reader.string();
          continue;
        case 7:
          if (tag !== 58) {
            break;
          }

          message.subtype = reader.string();
          continue;
        case 8:
          if (tag !== 64) {
            break;
          }

          message.isfile = reader.bool();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): AddressAttribute {
    return {
      key: isSet(object.key) ? globalThis.String(object.key) : "",
      value: isSet(object.value) ? globalThis.String(object.value) : "",
      id: isSet(object.id) ? globalThis.Number(object.id) : 0,
      contentType: isSet(object.contentType) ? globalThis.String(object.contentType) : "",
      owner: isSet(object.owner) ? globalThis.String(object.owner) : "",
      type: isSet(object.type) ? globalThis.String(object.type) : "",
      subtype: isSet(object.subtype) ? globalThis.String(object.subtype) : "",
      isfile: isSet(object.isfile) ? globalThis.Boolean(object.isfile) : false,
    };
  },

  toJSON(message: AddressAttribute): unknown {
    const obj: any = {};
    if (message.key !== "") {
      obj.key = message.key;
    }
    if (message.value !== "") {
      obj.value = message.value;
    }
    if (message.id !== 0) {
      obj.id = Math.round(message.id);
    }
    if (message.contentType !== "") {
      obj.contentType = message.contentType;
    }
    if (message.owner !== "") {
      obj.owner = message.owner;
    }
    if (message.type !== "") {
      obj.type = message.type;
    }
    if (message.subtype !== "") {
      obj.subtype = message.subtype;
    }
    if (message.isfile !== false) {
      obj.isfile = message.isfile;
    }
    return obj;
  },

  create(base?: DeepPartial<AddressAttribute>): AddressAttribute {
    return AddressAttribute.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<AddressAttribute>): AddressAttribute {
    const message = createBaseAddressAttribute();
    message.key = object.key ?? "";
    message.value = object.value ?? "";
    message.id = object.id ?? 0;
    message.contentType = object.contentType ?? "";
    message.owner = object.owner ?? "";
    message.type = object.type ?? "";
    message.subtype = object.subtype ?? "";
    message.isfile = object.isfile ?? false;
    return message;
  },
};

function createBaseUTXO(): UTXO {
  return {
    id: 0,
    hash: "",
    outputIndex: 0,
    script: "",
    value: 0,
    blockHeight: 0,
    reservedByRequestId: 0,
    reservationId: 0,
    valueString: "",
  };
}

export const UTXO = {
  encode(message: UTXO, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.id !== 0) {
      writer.uint32(8).uint64(message.id);
    }
    if (message.hash !== "") {
      writer.uint32(18).string(message.hash);
    }
    if (message.outputIndex !== 0) {
      writer.uint32(24).uint32(message.outputIndex);
    }
    if (message.script !== "") {
      writer.uint32(34).string(message.script);
    }
    if (message.value !== 0) {
      writer.uint32(40).uint64(message.value);
    }
    if (message.blockHeight !== 0) {
      writer.uint32(48).uint64(message.blockHeight);
    }
    if (message.reservedByRequestId !== 0) {
      writer.uint32(56).uint64(message.reservedByRequestId);
    }
    if (message.reservationId !== 0) {
      writer.uint32(64).uint64(message.reservationId);
    }
    if (message.valueString !== "") {
      writer.uint32(74).string(message.valueString);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): UTXO {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseUTXO();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.id = longToNumber(reader.uint64() as Long);
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.hash = reader.string();
          continue;
        case 3:
          if (tag !== 24) {
            break;
          }

          message.outputIndex = reader.uint32();
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.script = reader.string();
          continue;
        case 5:
          if (tag !== 40) {
            break;
          }

          message.value = longToNumber(reader.uint64() as Long);
          continue;
        case 6:
          if (tag !== 48) {
            break;
          }

          message.blockHeight = longToNumber(reader.uint64() as Long);
          continue;
        case 7:
          if (tag !== 56) {
            break;
          }

          message.reservedByRequestId = longToNumber(reader.uint64() as Long);
          continue;
        case 8:
          if (tag !== 64) {
            break;
          }

          message.reservationId = longToNumber(reader.uint64() as Long);
          continue;
        case 9:
          if (tag !== 74) {
            break;
          }

          message.valueString = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): UTXO {
    return {
      id: isSet(object.id) ? globalThis.Number(object.id) : 0,
      hash: isSet(object.hash) ? globalThis.String(object.hash) : "",
      outputIndex: isSet(object.outputIndex) ? globalThis.Number(object.outputIndex) : 0,
      script: isSet(object.script) ? globalThis.String(object.script) : "",
      value: isSet(object.value) ? globalThis.Number(object.value) : 0,
      blockHeight: isSet(object.blockHeight) ? globalThis.Number(object.blockHeight) : 0,
      reservedByRequestId: isSet(object.reservedByRequestId) ? globalThis.Number(object.reservedByRequestId) : 0,
      reservationId: isSet(object.reservationId) ? globalThis.Number(object.reservationId) : 0,
      valueString: isSet(object.valueString) ? globalThis.String(object.valueString) : "",
    };
  },

  toJSON(message: UTXO): unknown {
    const obj: any = {};
    if (message.id !== 0) {
      obj.id = Math.round(message.id);
    }
    if (message.hash !== "") {
      obj.hash = message.hash;
    }
    if (message.outputIndex !== 0) {
      obj.outputIndex = Math.round(message.outputIndex);
    }
    if (message.script !== "") {
      obj.script = message.script;
    }
    if (message.value !== 0) {
      obj.value = Math.round(message.value);
    }
    if (message.blockHeight !== 0) {
      obj.blockHeight = Math.round(message.blockHeight);
    }
    if (message.reservedByRequestId !== 0) {
      obj.reservedByRequestId = Math.round(message.reservedByRequestId);
    }
    if (message.reservationId !== 0) {
      obj.reservationId = Math.round(message.reservationId);
    }
    if (message.valueString !== "") {
      obj.valueString = message.valueString;
    }
    return obj;
  },

  create(base?: DeepPartial<UTXO>): UTXO {
    return UTXO.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<UTXO>): UTXO {
    const message = createBaseUTXO();
    message.id = object.id ?? 0;
    message.hash = object.hash ?? "";
    message.outputIndex = object.outputIndex ?? 0;
    message.script = object.script ?? "";
    message.value = object.value ?? 0;
    message.blockHeight = object.blockHeight ?? 0;
    message.reservedByRequestId = object.reservedByRequestId ?? 0;
    message.reservationId = object.reservationId ?? 0;
    message.valueString = object.valueString ?? "";
    return message;
  },
};

function createBaseProofOfReserve(): ProofOfReserve {
  return {
    curve: 0,
    cipher: 0,
    path: "",
    address: "",
    publicKey: new Uint8Array(0),
    challenge: "",
    challengeResponse: new Uint8Array(0),
    type: 0,
    stakePublicKey: new Uint8Array(0),
    stakeChallengeResponse: new Uint8Array(0),
  };
}

export const ProofOfReserve = {
  encode(message: ProofOfReserve, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.curve !== 0) {
      writer.uint32(8).int32(message.curve);
    }
    if (message.cipher !== 0) {
      writer.uint32(16).int32(message.cipher);
    }
    if (message.path !== "") {
      writer.uint32(26).string(message.path);
    }
    if (message.address !== "") {
      writer.uint32(34).string(message.address);
    }
    if (message.publicKey.length !== 0) {
      writer.uint32(42).bytes(message.publicKey);
    }
    if (message.challenge !== "") {
      writer.uint32(50).string(message.challenge);
    }
    if (message.challengeResponse.length !== 0) {
      writer.uint32(58).bytes(message.challengeResponse);
    }
    if (message.type !== 0) {
      writer.uint32(64).int32(message.type);
    }
    if (message.stakePublicKey.length !== 0) {
      writer.uint32(74).bytes(message.stakePublicKey);
    }
    if (message.stakeChallengeResponse.length !== 0) {
      writer.uint32(82).bytes(message.stakeChallengeResponse);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): ProofOfReserve {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseProofOfReserve();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.curve = reader.int32() as any;
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.cipher = reader.int32() as any;
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.path = reader.string();
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.address = reader.string();
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.publicKey = reader.bytes();
          continue;
        case 6:
          if (tag !== 50) {
            break;
          }

          message.challenge = reader.string();
          continue;
        case 7:
          if (tag !== 58) {
            break;
          }

          message.challengeResponse = reader.bytes();
          continue;
        case 8:
          if (tag !== 64) {
            break;
          }

          message.type = reader.int32() as any;
          continue;
        case 9:
          if (tag !== 74) {
            break;
          }

          message.stakePublicKey = reader.bytes();
          continue;
        case 10:
          if (tag !== 82) {
            break;
          }

          message.stakeChallengeResponse = reader.bytes();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ProofOfReserve {
    return {
      curve: isSet(object.curve) ? proofOfReserve_CurveFromJSON(object.curve) : 0,
      cipher: isSet(object.cipher) ? proofOfReserve_CipherFromJSON(object.cipher) : 0,
      path: isSet(object.path) ? globalThis.String(object.path) : "",
      address: isSet(object.address) ? globalThis.String(object.address) : "",
      publicKey: isSet(object.publicKey) ? bytesFromBase64(object.publicKey) : new Uint8Array(0),
      challenge: isSet(object.challenge) ? globalThis.String(object.challenge) : "",
      challengeResponse: isSet(object.challengeResponse)
        ? bytesFromBase64(object.challengeResponse)
        : new Uint8Array(0),
      type: isSet(object.type) ? proofOfReserve_ReserveTypeFromJSON(object.type) : 0,
      stakePublicKey: isSet(object.stakePublicKey) ? bytesFromBase64(object.stakePublicKey) : new Uint8Array(0),
      stakeChallengeResponse: isSet(object.stakeChallengeResponse)
        ? bytesFromBase64(object.stakeChallengeResponse)
        : new Uint8Array(0),
    };
  },

  toJSON(message: ProofOfReserve): unknown {
    const obj: any = {};
    if (message.curve !== 0) {
      obj.curve = proofOfReserve_CurveToJSON(message.curve);
    }
    if (message.cipher !== 0) {
      obj.cipher = proofOfReserve_CipherToJSON(message.cipher);
    }
    if (message.path !== "") {
      obj.path = message.path;
    }
    if (message.address !== "") {
      obj.address = message.address;
    }
    if (message.publicKey.length !== 0) {
      obj.publicKey = base64FromBytes(message.publicKey);
    }
    if (message.challenge !== "") {
      obj.challenge = message.challenge;
    }
    if (message.challengeResponse.length !== 0) {
      obj.challengeResponse = base64FromBytes(message.challengeResponse);
    }
    if (message.type !== 0) {
      obj.type = proofOfReserve_ReserveTypeToJSON(message.type);
    }
    if (message.stakePublicKey.length !== 0) {
      obj.stakePublicKey = base64FromBytes(message.stakePublicKey);
    }
    if (message.stakeChallengeResponse.length !== 0) {
      obj.stakeChallengeResponse = base64FromBytes(message.stakeChallengeResponse);
    }
    return obj;
  },

  create(base?: DeepPartial<ProofOfReserve>): ProofOfReserve {
    return ProofOfReserve.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ProofOfReserve>): ProofOfReserve {
    const message = createBaseProofOfReserve();
    message.curve = object.curve ?? 0;
    message.cipher = object.cipher ?? 0;
    message.path = object.path ?? "";
    message.address = object.address ?? "";
    message.publicKey = object.publicKey ?? new Uint8Array(0);
    message.challenge = object.challenge ?? "";
    message.challengeResponse = object.challengeResponse ?? new Uint8Array(0);
    message.type = object.type ?? 0;
    message.stakePublicKey = object.stakePublicKey ?? new Uint8Array(0);
    message.stakeChallengeResponse = object.stakeChallengeResponse ?? new Uint8Array(0);
    return message;
  },
};

function createBaseLightAddressInfo(): LightAddressInfo {
  return {
    id: 0,
    walletId: 0,
    address: "",
    customerId: "",
    network: "",
    label: "",
    comment: "",
    addressPath: "",
    status: "",
    currencyId: "",
    creationDate: undefined,
    updateDate: undefined,
    externalAddressId: "",
  };
}

export const LightAddressInfo = {
  encode(message: LightAddressInfo, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.id !== 0) {
      writer.uint32(8).uint64(message.id);
    }
    if (message.walletId !== 0) {
      writer.uint32(16).uint64(message.walletId);
    }
    if (message.address !== "") {
      writer.uint32(26).string(message.address);
    }
    if (message.customerId !== "") {
      writer.uint32(34).string(message.customerId);
    }
    if (message.network !== "") {
      writer.uint32(42).string(message.network);
    }
    if (message.label !== "") {
      writer.uint32(50).string(message.label);
    }
    if (message.comment !== "") {
      writer.uint32(58).string(message.comment);
    }
    if (message.addressPath !== "") {
      writer.uint32(66).string(message.addressPath);
    }
    if (message.status !== "") {
      writer.uint32(74).string(message.status);
    }
    if (message.currencyId !== "") {
      writer.uint32(82).string(message.currencyId);
    }
    if (message.creationDate !== undefined) {
      Timestamp.encode(toTimestamp(message.creationDate), writer.uint32(90).fork()).ldelim();
    }
    if (message.updateDate !== undefined) {
      Timestamp.encode(toTimestamp(message.updateDate), writer.uint32(98).fork()).ldelim();
    }
    if (message.externalAddressId !== "") {
      writer.uint32(106).string(message.externalAddressId);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): LightAddressInfo {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseLightAddressInfo();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.id = longToNumber(reader.uint64() as Long);
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.walletId = longToNumber(reader.uint64() as Long);
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.address = reader.string();
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.customerId = reader.string();
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.network = reader.string();
          continue;
        case 6:
          if (tag !== 50) {
            break;
          }

          message.label = reader.string();
          continue;
        case 7:
          if (tag !== 58) {
            break;
          }

          message.comment = reader.string();
          continue;
        case 8:
          if (tag !== 66) {
            break;
          }

          message.addressPath = reader.string();
          continue;
        case 9:
          if (tag !== 74) {
            break;
          }

          message.status = reader.string();
          continue;
        case 10:
          if (tag !== 82) {
            break;
          }

          message.currencyId = reader.string();
          continue;
        case 11:
          if (tag !== 90) {
            break;
          }

          message.creationDate = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        case 12:
          if (tag !== 98) {
            break;
          }

          message.updateDate = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        case 13:
          if (tag !== 106) {
            break;
          }

          message.externalAddressId = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): LightAddressInfo {
    return {
      id: isSet(object.id) ? globalThis.Number(object.id) : 0,
      walletId: isSet(object.walletId) ? globalThis.Number(object.walletId) : 0,
      address: isSet(object.address) ? globalThis.String(object.address) : "",
      customerId: isSet(object.customerId) ? globalThis.String(object.customerId) : "",
      network: isSet(object.network) ? globalThis.String(object.network) : "",
      label: isSet(object.label) ? globalThis.String(object.label) : "",
      comment: isSet(object.comment) ? globalThis.String(object.comment) : "",
      addressPath: isSet(object.addressPath) ? globalThis.String(object.addressPath) : "",
      status: isSet(object.status) ? globalThis.String(object.status) : "",
      currencyId: isSet(object.currencyId) ? globalThis.String(object.currencyId) : "",
      creationDate: isSet(object.creationDate) ? fromJsonTimestamp(object.creationDate) : undefined,
      updateDate: isSet(object.updateDate) ? fromJsonTimestamp(object.updateDate) : undefined,
      externalAddressId: isSet(object.externalAddressId) ? globalThis.String(object.externalAddressId) : "",
    };
  },

  toJSON(message: LightAddressInfo): unknown {
    const obj: any = {};
    if (message.id !== 0) {
      obj.id = Math.round(message.id);
    }
    if (message.walletId !== 0) {
      obj.walletId = Math.round(message.walletId);
    }
    if (message.address !== "") {
      obj.address = message.address;
    }
    if (message.customerId !== "") {
      obj.customerId = message.customerId;
    }
    if (message.network !== "") {
      obj.network = message.network;
    }
    if (message.label !== "") {
      obj.label = message.label;
    }
    if (message.comment !== "") {
      obj.comment = message.comment;
    }
    if (message.addressPath !== "") {
      obj.addressPath = message.addressPath;
    }
    if (message.status !== "") {
      obj.status = message.status;
    }
    if (message.currencyId !== "") {
      obj.currencyId = message.currencyId;
    }
    if (message.creationDate !== undefined) {
      obj.creationDate = message.creationDate.toISOString();
    }
    if (message.updateDate !== undefined) {
      obj.updateDate = message.updateDate.toISOString();
    }
    if (message.externalAddressId !== "") {
      obj.externalAddressId = message.externalAddressId;
    }
    return obj;
  },

  create(base?: DeepPartial<LightAddressInfo>): LightAddressInfo {
    return LightAddressInfo.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<LightAddressInfo>): LightAddressInfo {
    const message = createBaseLightAddressInfo();
    message.id = object.id ?? 0;
    message.walletId = object.walletId ?? 0;
    message.address = object.address ?? "";
    message.customerId = object.customerId ?? "";
    message.network = object.network ?? "";
    message.label = object.label ?? "";
    message.comment = object.comment ?? "";
    message.addressPath = object.addressPath ?? "";
    message.status = object.status ?? "";
    message.currencyId = object.currencyId ?? "";
    message.creationDate = object.creationDate ?? undefined;
    message.updateDate = object.updateDate ?? undefined;
    message.externalAddressId = object.externalAddressId ?? "";
    return message;
  },
};

function bytesFromBase64(b64: string): Uint8Array {
  const bin = globalThis.atob(b64);
  const arr = new Uint8Array(bin.length);
  for (let i = 0; i < bin.length; ++i) {
    arr[i] = bin.charCodeAt(i);
  }
  return arr;
}

function base64FromBytes(arr: Uint8Array): string {
  const bin: string[] = [];
  arr.forEach((byte) => {
    bin.push(globalThis.String.fromCharCode(byte));
  });
  return globalThis.btoa(bin.join(""));
}

type Builtin = Date | Function | Uint8Array | string | number | boolean | undefined;

export type DeepPartial<T> = T extends Builtin ? T
  : T extends globalThis.Array<infer U> ? globalThis.Array<DeepPartial<U>>
  : T extends ReadonlyArray<infer U> ? ReadonlyArray<DeepPartial<U>>
  : T extends {} ? { [K in keyof T]?: DeepPartial<T[K]> }
  : Partial<T>;

function toTimestamp(date: Date): Timestamp {
  const seconds = Math.trunc(date.getTime() / 1_000);
  const nanos = (date.getTime() % 1_000) * 1_000_000;
  return { seconds, nanos };
}

function fromTimestamp(t: Timestamp): Date {
  let millis = (t.seconds || 0) * 1_000;
  millis += (t.nanos || 0) / 1_000_000;
  return new globalThis.Date(millis);
}

function fromJsonTimestamp(o: any): Date {
  if (o instanceof globalThis.Date) {
    return o;
  } else if (typeof o === "string") {
    return new globalThis.Date(o);
  } else {
    return fromTimestamp(Timestamp.fromJSON(o));
  }
}

function longToNumber(long: Long): number {
  if (long.gt(globalThis.Number.MAX_SAFE_INTEGER)) {
    throw new globalThis.Error("Value is larger than Number.MAX_SAFE_INTEGER");
  }
  if (long.lt(globalThis.Number.MIN_SAFE_INTEGER)) {
    throw new globalThis.Error("Value is smaller than Number.MIN_SAFE_INTEGER");
  }
  return long.toNumber();
}

if (_m0.util.Long !== Long) {
  _m0.util.Long = Long as any;
  _m0.configure();
}

function isSet(value: any): boolean {
  return value !== null && value !== undefined;
}
