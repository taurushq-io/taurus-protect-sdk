// Code generated by protoc-gen-ts_proto. DO NOT EDIT.
// versions:
//   protoc-gen-ts_proto  v1.181.2
//   protoc               v6.33.4
// source: whitelist.proto

/* eslint-disable */
import Long from "long";
import _m0 from "protobufjs/minimal";
import { Approvers } from "./approvers";
import { Timestamp } from "./google/protobuf/timestamp";
import { Metadata } from "./metadata";
import { Score } from "./score";

export const protobufPackage = "tgvalidatord";

export enum WhitelistedContractAddressKind {
  /** _default_ - Default has an empty string as a representation */
  _default_ = 0,
  /** NFT_AUTO - Generic representation for NFTs. Upon receiving this, the backend will try to find the best match, and fill it with one of the types below. */
  NFT_AUTO = 1,
  NFT_XTZ_FA2 = 2,
  /**
   * NFT_ETH_ERC721 - Use NFT_EVM_ERC721 or NFT_AUTO instead.
   *
   * @deprecated
   */
  NFT_ETH_ERC721 = 3,
  /**
   * NFT_ETH_ERC1155 - Use NFT_EVM_ERC1155 or NFT_AUTO instead.
   *
   * @deprecated
   */
  NFT_ETH_ERC1155 = 4,
  NFT_EVM_ERC721 = 5,
  NFT_EVM_ERC1155 = 6,
  SOL_TOKEN = 7,
  SOL_TOKEN2022 = 8,
  NFT_EVM_CRYPTOPUNKS = 9,
  HEDERA_NATIVE_TOKEN = 10,
  HEDERA_NATIVE_NFT = 11,
  UNRECOGNIZED = -1,
}

export function whitelistedContractAddressKindFromJSON(object: any): WhitelistedContractAddressKind {
  switch (object) {
    case 0:
    case "_default_":
      return WhitelistedContractAddressKind._default_;
    case 1:
    case "NFT_AUTO":
      return WhitelistedContractAddressKind.NFT_AUTO;
    case 2:
    case "NFT_XTZ_FA2":
      return WhitelistedContractAddressKind.NFT_XTZ_FA2;
    case 3:
    case "NFT_ETH_ERC721":
      return WhitelistedContractAddressKind.NFT_ETH_ERC721;
    case 4:
    case "NFT_ETH_ERC1155":
      return WhitelistedContractAddressKind.NFT_ETH_ERC1155;
    case 5:
    case "NFT_EVM_ERC721":
      return WhitelistedContractAddressKind.NFT_EVM_ERC721;
    case 6:
    case "NFT_EVM_ERC1155":
      return WhitelistedContractAddressKind.NFT_EVM_ERC1155;
    case 7:
    case "SOL_TOKEN":
      return WhitelistedContractAddressKind.SOL_TOKEN;
    case 8:
    case "SOL_TOKEN2022":
      return WhitelistedContractAddressKind.SOL_TOKEN2022;
    case 9:
    case "NFT_EVM_CRYPTOPUNKS":
      return WhitelistedContractAddressKind.NFT_EVM_CRYPTOPUNKS;
    case 10:
    case "HEDERA_NATIVE_TOKEN":
      return WhitelistedContractAddressKind.HEDERA_NATIVE_TOKEN;
    case 11:
    case "HEDERA_NATIVE_NFT":
      return WhitelistedContractAddressKind.HEDERA_NATIVE_NFT;
    case -1:
    case "UNRECOGNIZED":
    default:
      return WhitelistedContractAddressKind.UNRECOGNIZED;
  }
}

export function whitelistedContractAddressKindToJSON(object: WhitelistedContractAddressKind): string {
  switch (object) {
    case WhitelistedContractAddressKind._default_:
      return "_default_";
    case WhitelistedContractAddressKind.NFT_AUTO:
      return "NFT_AUTO";
    case WhitelistedContractAddressKind.NFT_XTZ_FA2:
      return "NFT_XTZ_FA2";
    case WhitelistedContractAddressKind.NFT_ETH_ERC721:
      return "NFT_ETH_ERC721";
    case WhitelistedContractAddressKind.NFT_ETH_ERC1155:
      return "NFT_ETH_ERC1155";
    case WhitelistedContractAddressKind.NFT_EVM_ERC721:
      return "NFT_EVM_ERC721";
    case WhitelistedContractAddressKind.NFT_EVM_ERC1155:
      return "NFT_EVM_ERC1155";
    case WhitelistedContractAddressKind.SOL_TOKEN:
      return "SOL_TOKEN";
    case WhitelistedContractAddressKind.SOL_TOKEN2022:
      return "SOL_TOKEN2022";
    case WhitelistedContractAddressKind.NFT_EVM_CRYPTOPUNKS:
      return "NFT_EVM_CRYPTOPUNKS";
    case WhitelistedContractAddressKind.HEDERA_NATIVE_TOKEN:
      return "HEDERA_NATIVE_TOKEN";
    case WhitelistedContractAddressKind.HEDERA_NATIVE_NFT:
      return "HEDERA_NATIVE_NFT";
    case WhitelistedContractAddressKind.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

export interface WhitelistedAddressBatchSignature {
  ID: number;
  TenantID: number;
  UserID: number;
  Signature: string;
  Comment: string;
  Status: string;
  CreationDate: Date | undefined;
  UpdateDate: Date | undefined;
  signatures: WhitelistedAddressBatchSignature_WhitelistedAddressSignature[];
}

export interface WhitelistedAddressBatchSignature_WhitelistedAddressSignature {
  ID: number;
  TenantID: number;
  BatchSignatureID: number;
  WhitelistedAddressID: number;
  MetadataHash: string;
  Status: string;
  Message: string;
  CreationDate: Date | undefined;
  UpdateDate: Date | undefined;
}

export interface Trail {
  id: number;
  userId: number;
  externalUserId: string;
  action: string;
  comment: string;
  date: Date | undefined;
}

export interface SignedWhitelistedAddressEnvelope {
  id: number;
  tenantId: number;
  signedAddress: SignedWhitelistedAddress | undefined;
  metadata: Metadata | undefined;
  action: string;
  scores: Score[];
  trails: Trail[];
  rulesContainer: string;
  rule: string;
  approvers: Approvers | undefined;
  attributes: WhitelistedAddressAttribute[];
  rulesContainerHash: string;
  /** Currency currencyInfo = 13; */
  blockchain: string;
  status: string;
  network: string;
  visibilityGroupID: string;
  tnParticipantID: string;
  rulesSignatures: string;
}

export interface SignedWhitelistedContractAddressEnvelope {
  id: number;
  tenantId: number;
  signedContractAddress: SignedWhitelistedContractAddress | undefined;
  metadata: Metadata | undefined;
  action: string;
  trails: Trail[];
  rulesContainer: string;
  rule: string;
  approvers: Approvers | undefined;
  attributes: WhitelistedContractAddressAttribute[];
  status: string;
  blockchain: string;
  network: string;
  businessRuleEnabled: boolean;
  rulesSignatures: string;
}

export interface WhitelistUserSignature {
  userId: string;
  signature: Uint8Array;
  comment: string;
}

export interface WhitelistSignature {
  signature: WhitelistUserSignature | undefined;
  hashes: string[];
}

export interface SignedWhitelistedAddress {
  signatures: WhitelistSignature[];
  payload: Uint8Array;
}

/** This proto is used only to serialize an address into an envelope. It's not used in a JSON serialization */
export interface WhitelistedAddress {
  blockchain: string;
  addressType: WhitelistedAddress_AddressType;
  address: string;
  /** stellar memo, ripple tag */
  memo: string;
  /** description of the whitelisted address */
  label: string;
  /** customer ID for external reconciliation */
  customerId: string;
  exchangeAccountId: number;
  linkedInternalAddresses: InternalAddress[];
  /** CMTA20, ERC20 ... */
  contractType: string;
  attributes: WhitelistedAddressAttribute[];
  linkedWallets: InternalWallet[];
  /** Currency currencyInfo = 12; */
  network: string;
  tnParticipantID: string;
}

export enum WhitelistedAddress_AddressType {
  individual = 0,
  exchange = 1,
  baker = 2,
  contract = 3,
  stakepool = 4,
  validator = 5,
  node = 6,
  fiatprovider = 7,
  UNRECOGNIZED = -1,
}

export function whitelistedAddress_AddressTypeFromJSON(object: any): WhitelistedAddress_AddressType {
  switch (object) {
    case 0:
    case "individual":
      return WhitelistedAddress_AddressType.individual;
    case 1:
    case "exchange":
      return WhitelistedAddress_AddressType.exchange;
    case 2:
    case "baker":
      return WhitelistedAddress_AddressType.baker;
    case 3:
    case "contract":
      return WhitelistedAddress_AddressType.contract;
    case 4:
    case "stakepool":
      return WhitelistedAddress_AddressType.stakepool;
    case 5:
    case "validator":
      return WhitelistedAddress_AddressType.validator;
    case 6:
    case "node":
      return WhitelistedAddress_AddressType.node;
    case 7:
    case "fiatprovider":
      return WhitelistedAddress_AddressType.fiatprovider;
    case -1:
    case "UNRECOGNIZED":
    default:
      return WhitelistedAddress_AddressType.UNRECOGNIZED;
  }
}

export function whitelistedAddress_AddressTypeToJSON(object: WhitelistedAddress_AddressType): string {
  switch (object) {
    case WhitelistedAddress_AddressType.individual:
      return "individual";
    case WhitelistedAddress_AddressType.exchange:
      return "exchange";
    case WhitelistedAddress_AddressType.baker:
      return "baker";
    case WhitelistedAddress_AddressType.contract:
      return "contract";
    case WhitelistedAddress_AddressType.stakepool:
      return "stakepool";
    case WhitelistedAddress_AddressType.validator:
      return "validator";
    case WhitelistedAddress_AddressType.node:
      return "node";
    case WhitelistedAddress_AddressType.fiatprovider:
      return "fiatprovider";
    case WhitelistedAddress_AddressType.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

export interface WhitelistedAddressAttribute {
  id: number;
  key: string;
  value: string;
  contentType: string;
  owner: string;
  type: string;
  subtype: string;
  isfile: boolean;
}

export interface WhitelistedContractAddressAttribute {
  id: number;
  key: string;
  value: string;
  contentType: string;
  owner: string;
  type: string;
  subtype: string;
  isfile: boolean;
}

export interface InternalAddress {
  id: number;
  address: string;
  label: string;
}

export interface InternalWallet {
  id: number;
  name: string;
  path: string;
}

export interface SignedWhitelistedContractAddress {
  signatures: WhitelistSignature[];
  payload: Uint8Array;
}

export interface WhitelistedContractAddress {
  blockchain: string;
  name: string;
  symbol: string;
  decimals: number;
  contractAddress: string;
  /** XTZ FA2, ERC721, ERC1155 */
  tokenId: string;
  kind: string;
  network: string;
}

function createBaseWhitelistedAddressBatchSignature(): WhitelistedAddressBatchSignature {
  return {
    ID: 0,
    TenantID: 0,
    UserID: 0,
    Signature: "",
    Comment: "",
    Status: "",
    CreationDate: undefined,
    UpdateDate: undefined,
    signatures: [],
  };
}

export const WhitelistedAddressBatchSignature = {
  encode(message: WhitelistedAddressBatchSignature, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.ID !== 0) {
      writer.uint32(8).uint64(message.ID);
    }
    if (message.TenantID !== 0) {
      writer.uint32(16).uint64(message.TenantID);
    }
    if (message.UserID !== 0) {
      writer.uint32(24).uint64(message.UserID);
    }
    if (message.Signature !== "") {
      writer.uint32(34).string(message.Signature);
    }
    if (message.Comment !== "") {
      writer.uint32(42).string(message.Comment);
    }
    if (message.Status !== "") {
      writer.uint32(50).string(message.Status);
    }
    if (message.CreationDate !== undefined) {
      Timestamp.encode(toTimestamp(message.CreationDate), writer.uint32(58).fork()).ldelim();
    }
    if (message.UpdateDate !== undefined) {
      Timestamp.encode(toTimestamp(message.UpdateDate), writer.uint32(66).fork()).ldelim();
    }
    for (const v of message.signatures) {
      WhitelistedAddressBatchSignature_WhitelistedAddressSignature.encode(v!, writer.uint32(74).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): WhitelistedAddressBatchSignature {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseWhitelistedAddressBatchSignature();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.ID = longToNumber(reader.uint64() as Long);
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.TenantID = longToNumber(reader.uint64() as Long);
          continue;
        case 3:
          if (tag !== 24) {
            break;
          }

          message.UserID = longToNumber(reader.uint64() as Long);
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.Signature = reader.string();
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.Comment = reader.string();
          continue;
        case 6:
          if (tag !== 50) {
            break;
          }

          message.Status = reader.string();
          continue;
        case 7:
          if (tag !== 58) {
            break;
          }

          message.CreationDate = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        case 8:
          if (tag !== 66) {
            break;
          }

          message.UpdateDate = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        case 9:
          if (tag !== 74) {
            break;
          }

          message.signatures.push(
            WhitelistedAddressBatchSignature_WhitelistedAddressSignature.decode(reader, reader.uint32()),
          );
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): WhitelistedAddressBatchSignature {
    return {
      ID: isSet(object.ID) ? globalThis.Number(object.ID) : 0,
      TenantID: isSet(object.TenantID) ? globalThis.Number(object.TenantID) : 0,
      UserID: isSet(object.UserID) ? globalThis.Number(object.UserID) : 0,
      Signature: isSet(object.Signature) ? globalThis.String(object.Signature) : "",
      Comment: isSet(object.Comment) ? globalThis.String(object.Comment) : "",
      Status: isSet(object.Status) ? globalThis.String(object.Status) : "",
      CreationDate: isSet(object.CreationDate) ? fromJsonTimestamp(object.CreationDate) : undefined,
      UpdateDate: isSet(object.UpdateDate) ? fromJsonTimestamp(object.UpdateDate) : undefined,
      signatures: globalThis.Array.isArray(object?.signatures)
        ? object.signatures.map((e: any) => WhitelistedAddressBatchSignature_WhitelistedAddressSignature.fromJSON(e))
        : [],
    };
  },

  toJSON(message: WhitelistedAddressBatchSignature): unknown {
    const obj: any = {};
    if (message.ID !== 0) {
      obj.ID = Math.round(message.ID);
    }
    if (message.TenantID !== 0) {
      obj.TenantID = Math.round(message.TenantID);
    }
    if (message.UserID !== 0) {
      obj.UserID = Math.round(message.UserID);
    }
    if (message.Signature !== "") {
      obj.Signature = message.Signature;
    }
    if (message.Comment !== "") {
      obj.Comment = message.Comment;
    }
    if (message.Status !== "") {
      obj.Status = message.Status;
    }
    if (message.CreationDate !== undefined) {
      obj.CreationDate = message.CreationDate.toISOString();
    }
    if (message.UpdateDate !== undefined) {
      obj.UpdateDate = message.UpdateDate.toISOString();
    }
    if (message.signatures?.length) {
      obj.signatures = message.signatures.map((e) =>
        WhitelistedAddressBatchSignature_WhitelistedAddressSignature.toJSON(e)
      );
    }
    return obj;
  },

  create(base?: DeepPartial<WhitelistedAddressBatchSignature>): WhitelistedAddressBatchSignature {
    return WhitelistedAddressBatchSignature.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<WhitelistedAddressBatchSignature>): WhitelistedAddressBatchSignature {
    const message = createBaseWhitelistedAddressBatchSignature();
    message.ID = object.ID ?? 0;
    message.TenantID = object.TenantID ?? 0;
    message.UserID = object.UserID ?? 0;
    message.Signature = object.Signature ?? "";
    message.Comment = object.Comment ?? "";
    message.Status = object.Status ?? "";
    message.CreationDate = object.CreationDate ?? undefined;
    message.UpdateDate = object.UpdateDate ?? undefined;
    message.signatures =
      object.signatures?.map((e) => WhitelistedAddressBatchSignature_WhitelistedAddressSignature.fromPartial(e)) || [];
    return message;
  },
};

function createBaseWhitelistedAddressBatchSignature_WhitelistedAddressSignature(): WhitelistedAddressBatchSignature_WhitelistedAddressSignature {
  return {
    ID: 0,
    TenantID: 0,
    BatchSignatureID: 0,
    WhitelistedAddressID: 0,
    MetadataHash: "",
    Status: "",
    Message: "",
    CreationDate: undefined,
    UpdateDate: undefined,
  };
}

export const WhitelistedAddressBatchSignature_WhitelistedAddressSignature = {
  encode(
    message: WhitelistedAddressBatchSignature_WhitelistedAddressSignature,
    writer: _m0.Writer = _m0.Writer.create(),
  ): _m0.Writer {
    if (message.ID !== 0) {
      writer.uint32(8).uint64(message.ID);
    }
    if (message.TenantID !== 0) {
      writer.uint32(16).uint64(message.TenantID);
    }
    if (message.BatchSignatureID !== 0) {
      writer.uint32(24).uint64(message.BatchSignatureID);
    }
    if (message.WhitelistedAddressID !== 0) {
      writer.uint32(32).uint64(message.WhitelistedAddressID);
    }
    if (message.MetadataHash !== "") {
      writer.uint32(42).string(message.MetadataHash);
    }
    if (message.Status !== "") {
      writer.uint32(50).string(message.Status);
    }
    if (message.Message !== "") {
      writer.uint32(58).string(message.Message);
    }
    if (message.CreationDate !== undefined) {
      Timestamp.encode(toTimestamp(message.CreationDate), writer.uint32(66).fork()).ldelim();
    }
    if (message.UpdateDate !== undefined) {
      Timestamp.encode(toTimestamp(message.UpdateDate), writer.uint32(74).fork()).ldelim();
    }
    return writer;
  },

  decode(
    input: _m0.Reader | Uint8Array,
    length?: number,
  ): WhitelistedAddressBatchSignature_WhitelistedAddressSignature {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseWhitelistedAddressBatchSignature_WhitelistedAddressSignature();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.ID = longToNumber(reader.uint64() as Long);
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.TenantID = longToNumber(reader.uint64() as Long);
          continue;
        case 3:
          if (tag !== 24) {
            break;
          }

          message.BatchSignatureID = longToNumber(reader.uint64() as Long);
          continue;
        case 4:
          if (tag !== 32) {
            break;
          }

          message.WhitelistedAddressID = longToNumber(reader.uint64() as Long);
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.MetadataHash = reader.string();
          continue;
        case 6:
          if (tag !== 50) {
            break;
          }

          message.Status = reader.string();
          continue;
        case 7:
          if (tag !== 58) {
            break;
          }

          message.Message = reader.string();
          continue;
        case 8:
          if (tag !== 66) {
            break;
          }

          message.CreationDate = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        case 9:
          if (tag !== 74) {
            break;
          }

          message.UpdateDate = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): WhitelistedAddressBatchSignature_WhitelistedAddressSignature {
    return {
      ID: isSet(object.ID) ? globalThis.Number(object.ID) : 0,
      TenantID: isSet(object.TenantID) ? globalThis.Number(object.TenantID) : 0,
      BatchSignatureID: isSet(object.BatchSignatureID) ? globalThis.Number(object.BatchSignatureID) : 0,
      WhitelistedAddressID: isSet(object.WhitelistedAddressID) ? globalThis.Number(object.WhitelistedAddressID) : 0,
      MetadataHash: isSet(object.MetadataHash) ? globalThis.String(object.MetadataHash) : "",
      Status: isSet(object.Status) ? globalThis.String(object.Status) : "",
      Message: isSet(object.Message) ? globalThis.String(object.Message) : "",
      CreationDate: isSet(object.CreationDate) ? fromJsonTimestamp(object.CreationDate) : undefined,
      UpdateDate: isSet(object.UpdateDate) ? fromJsonTimestamp(object.UpdateDate) : undefined,
    };
  },

  toJSON(message: WhitelistedAddressBatchSignature_WhitelistedAddressSignature): unknown {
    const obj: any = {};
    if (message.ID !== 0) {
      obj.ID = Math.round(message.ID);
    }
    if (message.TenantID !== 0) {
      obj.TenantID = Math.round(message.TenantID);
    }
    if (message.BatchSignatureID !== 0) {
      obj.BatchSignatureID = Math.round(message.BatchSignatureID);
    }
    if (message.WhitelistedAddressID !== 0) {
      obj.WhitelistedAddressID = Math.round(message.WhitelistedAddressID);
    }
    if (message.MetadataHash !== "") {
      obj.MetadataHash = message.MetadataHash;
    }
    if (message.Status !== "") {
      obj.Status = message.Status;
    }
    if (message.Message !== "") {
      obj.Message = message.Message;
    }
    if (message.CreationDate !== undefined) {
      obj.CreationDate = message.CreationDate.toISOString();
    }
    if (message.UpdateDate !== undefined) {
      obj.UpdateDate = message.UpdateDate.toISOString();
    }
    return obj;
  },

  create(
    base?: DeepPartial<WhitelistedAddressBatchSignature_WhitelistedAddressSignature>,
  ): WhitelistedAddressBatchSignature_WhitelistedAddressSignature {
    return WhitelistedAddressBatchSignature_WhitelistedAddressSignature.fromPartial(base ?? {});
  },
  fromPartial(
    object: DeepPartial<WhitelistedAddressBatchSignature_WhitelistedAddressSignature>,
  ): WhitelistedAddressBatchSignature_WhitelistedAddressSignature {
    const message = createBaseWhitelistedAddressBatchSignature_WhitelistedAddressSignature();
    message.ID = object.ID ?? 0;
    message.TenantID = object.TenantID ?? 0;
    message.BatchSignatureID = object.BatchSignatureID ?? 0;
    message.WhitelistedAddressID = object.WhitelistedAddressID ?? 0;
    message.MetadataHash = object.MetadataHash ?? "";
    message.Status = object.Status ?? "";
    message.Message = object.Message ?? "";
    message.CreationDate = object.CreationDate ?? undefined;
    message.UpdateDate = object.UpdateDate ?? undefined;
    return message;
  },
};

function createBaseTrail(): Trail {
  return { id: 0, userId: 0, externalUserId: "", action: "", comment: "", date: undefined };
}

export const Trail = {
  encode(message: Trail, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.id !== 0) {
      writer.uint32(8).uint64(message.id);
    }
    if (message.userId !== 0) {
      writer.uint32(16).uint64(message.userId);
    }
    if (message.externalUserId !== "") {
      writer.uint32(26).string(message.externalUserId);
    }
    if (message.action !== "") {
      writer.uint32(34).string(message.action);
    }
    if (message.comment !== "") {
      writer.uint32(42).string(message.comment);
    }
    if (message.date !== undefined) {
      Timestamp.encode(toTimestamp(message.date), writer.uint32(50).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): Trail {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseTrail();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.id = longToNumber(reader.uint64() as Long);
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.userId = longToNumber(reader.uint64() as Long);
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.externalUserId = reader.string();
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.action = reader.string();
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.comment = reader.string();
          continue;
        case 6:
          if (tag !== 50) {
            break;
          }

          message.date = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Trail {
    return {
      id: isSet(object.id) ? globalThis.Number(object.id) : 0,
      userId: isSet(object.userId) ? globalThis.Number(object.userId) : 0,
      externalUserId: isSet(object.externalUserId) ? globalThis.String(object.externalUserId) : "",
      action: isSet(object.action) ? globalThis.String(object.action) : "",
      comment: isSet(object.comment) ? globalThis.String(object.comment) : "",
      date: isSet(object.date) ? fromJsonTimestamp(object.date) : undefined,
    };
  },

  toJSON(message: Trail): unknown {
    const obj: any = {};
    if (message.id !== 0) {
      obj.id = Math.round(message.id);
    }
    if (message.userId !== 0) {
      obj.userId = Math.round(message.userId);
    }
    if (message.externalUserId !== "") {
      obj.externalUserId = message.externalUserId;
    }
    if (message.action !== "") {
      obj.action = message.action;
    }
    if (message.comment !== "") {
      obj.comment = message.comment;
    }
    if (message.date !== undefined) {
      obj.date = message.date.toISOString();
    }
    return obj;
  },

  create(base?: DeepPartial<Trail>): Trail {
    return Trail.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<Trail>): Trail {
    const message = createBaseTrail();
    message.id = object.id ?? 0;
    message.userId = object.userId ?? 0;
    message.externalUserId = object.externalUserId ?? "";
    message.action = object.action ?? "";
    message.comment = object.comment ?? "";
    message.date = object.date ?? undefined;
    return message;
  },
};

function createBaseSignedWhitelistedAddressEnvelope(): SignedWhitelistedAddressEnvelope {
  return {
    id: 0,
    tenantId: 0,
    signedAddress: undefined,
    metadata: undefined,
    action: "",
    scores: [],
    trails: [],
    rulesContainer: "",
    rule: "",
    approvers: undefined,
    attributes: [],
    rulesContainerHash: "",
    blockchain: "",
    status: "",
    network: "",
    visibilityGroupID: "",
    tnParticipantID: "",
    rulesSignatures: "",
  };
}

export const SignedWhitelistedAddressEnvelope = {
  encode(message: SignedWhitelistedAddressEnvelope, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.id !== 0) {
      writer.uint32(8).uint64(message.id);
    }
    if (message.tenantId !== 0) {
      writer.uint32(16).uint64(message.tenantId);
    }
    if (message.signedAddress !== undefined) {
      SignedWhitelistedAddress.encode(message.signedAddress, writer.uint32(26).fork()).ldelim();
    }
    if (message.metadata !== undefined) {
      Metadata.encode(message.metadata, writer.uint32(34).fork()).ldelim();
    }
    if (message.action !== "") {
      writer.uint32(42).string(message.action);
    }
    for (const v of message.scores) {
      Score.encode(v!, writer.uint32(50).fork()).ldelim();
    }
    for (const v of message.trails) {
      Trail.encode(v!, writer.uint32(58).fork()).ldelim();
    }
    if (message.rulesContainer !== "") {
      writer.uint32(66).string(message.rulesContainer);
    }
    if (message.rule !== "") {
      writer.uint32(74).string(message.rule);
    }
    if (message.approvers !== undefined) {
      Approvers.encode(message.approvers, writer.uint32(82).fork()).ldelim();
    }
    for (const v of message.attributes) {
      WhitelistedAddressAttribute.encode(v!, writer.uint32(90).fork()).ldelim();
    }
    if (message.rulesContainerHash !== "") {
      writer.uint32(98).string(message.rulesContainerHash);
    }
    if (message.blockchain !== "") {
      writer.uint32(114).string(message.blockchain);
    }
    if (message.status !== "") {
      writer.uint32(122).string(message.status);
    }
    if (message.network !== "") {
      writer.uint32(130).string(message.network);
    }
    if (message.visibilityGroupID !== "") {
      writer.uint32(138).string(message.visibilityGroupID);
    }
    if (message.tnParticipantID !== "") {
      writer.uint32(146).string(message.tnParticipantID);
    }
    if (message.rulesSignatures !== "") {
      writer.uint32(154).string(message.rulesSignatures);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): SignedWhitelistedAddressEnvelope {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSignedWhitelistedAddressEnvelope();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.id = longToNumber(reader.uint64() as Long);
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.tenantId = longToNumber(reader.uint64() as Long);
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.signedAddress = SignedWhitelistedAddress.decode(reader, reader.uint32());
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.metadata = Metadata.decode(reader, reader.uint32());
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.action = reader.string();
          continue;
        case 6:
          if (tag !== 50) {
            break;
          }

          message.scores.push(Score.decode(reader, reader.uint32()));
          continue;
        case 7:
          if (tag !== 58) {
            break;
          }

          message.trails.push(Trail.decode(reader, reader.uint32()));
          continue;
        case 8:
          if (tag !== 66) {
            break;
          }

          message.rulesContainer = reader.string();
          continue;
        case 9:
          if (tag !== 74) {
            break;
          }

          message.rule = reader.string();
          continue;
        case 10:
          if (tag !== 82) {
            break;
          }

          message.approvers = Approvers.decode(reader, reader.uint32());
          continue;
        case 11:
          if (tag !== 90) {
            break;
          }

          message.attributes.push(WhitelistedAddressAttribute.decode(reader, reader.uint32()));
          continue;
        case 12:
          if (tag !== 98) {
            break;
          }

          message.rulesContainerHash = reader.string();
          continue;
        case 14:
          if (tag !== 114) {
            break;
          }

          message.blockchain = reader.string();
          continue;
        case 15:
          if (tag !== 122) {
            break;
          }

          message.status = reader.string();
          continue;
        case 16:
          if (tag !== 130) {
            break;
          }

          message.network = reader.string();
          continue;
        case 17:
          if (tag !== 138) {
            break;
          }

          message.visibilityGroupID = reader.string();
          continue;
        case 18:
          if (tag !== 146) {
            break;
          }

          message.tnParticipantID = reader.string();
          continue;
        case 19:
          if (tag !== 154) {
            break;
          }

          message.rulesSignatures = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): SignedWhitelistedAddressEnvelope {
    return {
      id: isSet(object.id) ? globalThis.Number(object.id) : 0,
      tenantId: isSet(object.tenantId) ? globalThis.Number(object.tenantId) : 0,
      signedAddress: isSet(object.signedAddress) ? SignedWhitelistedAddress.fromJSON(object.signedAddress) : undefined,
      metadata: isSet(object.metadata) ? Metadata.fromJSON(object.metadata) : undefined,
      action: isSet(object.action) ? globalThis.String(object.action) : "",
      scores: globalThis.Array.isArray(object?.scores) ? object.scores.map((e: any) => Score.fromJSON(e)) : [],
      trails: globalThis.Array.isArray(object?.trails) ? object.trails.map((e: any) => Trail.fromJSON(e)) : [],
      rulesContainer: isSet(object.rulesContainer) ? globalThis.String(object.rulesContainer) : "",
      rule: isSet(object.rule) ? globalThis.String(object.rule) : "",
      approvers: isSet(object.approvers) ? Approvers.fromJSON(object.approvers) : undefined,
      attributes: globalThis.Array.isArray(object?.attributes)
        ? object.attributes.map((e: any) => WhitelistedAddressAttribute.fromJSON(e))
        : [],
      rulesContainerHash: isSet(object.rulesContainerHash) ? globalThis.String(object.rulesContainerHash) : "",
      blockchain: isSet(object.blockchain) ? globalThis.String(object.blockchain) : "",
      status: isSet(object.status) ? globalThis.String(object.status) : "",
      network: isSet(object.network) ? globalThis.String(object.network) : "",
      visibilityGroupID: isSet(object.visibilityGroupID) ? globalThis.String(object.visibilityGroupID) : "",
      tnParticipantID: isSet(object.tnParticipantID) ? globalThis.String(object.tnParticipantID) : "",
      rulesSignatures: isSet(object.rulesSignatures) ? globalThis.String(object.rulesSignatures) : "",
    };
  },

  toJSON(message: SignedWhitelistedAddressEnvelope): unknown {
    const obj: any = {};
    if (message.id !== 0) {
      obj.id = Math.round(message.id);
    }
    if (message.tenantId !== 0) {
      obj.tenantId = Math.round(message.tenantId);
    }
    if (message.signedAddress !== undefined) {
      obj.signedAddress = SignedWhitelistedAddress.toJSON(message.signedAddress);
    }
    if (message.metadata !== undefined) {
      obj.metadata = Metadata.toJSON(message.metadata);
    }
    if (message.action !== "") {
      obj.action = message.action;
    }
    if (message.scores?.length) {
      obj.scores = message.scores.map((e) => Score.toJSON(e));
    }
    if (message.trails?.length) {
      obj.trails = message.trails.map((e) => Trail.toJSON(e));
    }
    if (message.rulesContainer !== "") {
      obj.rulesContainer = message.rulesContainer;
    }
    if (message.rule !== "") {
      obj.rule = message.rule;
    }
    if (message.approvers !== undefined) {
      obj.approvers = Approvers.toJSON(message.approvers);
    }
    if (message.attributes?.length) {
      obj.attributes = message.attributes.map((e) => WhitelistedAddressAttribute.toJSON(e));
    }
    if (message.rulesContainerHash !== "") {
      obj.rulesContainerHash = message.rulesContainerHash;
    }
    if (message.blockchain !== "") {
      obj.blockchain = message.blockchain;
    }
    if (message.status !== "") {
      obj.status = message.status;
    }
    if (message.network !== "") {
      obj.network = message.network;
    }
    if (message.visibilityGroupID !== "") {
      obj.visibilityGroupID = message.visibilityGroupID;
    }
    if (message.tnParticipantID !== "") {
      obj.tnParticipantID = message.tnParticipantID;
    }
    if (message.rulesSignatures !== "") {
      obj.rulesSignatures = message.rulesSignatures;
    }
    return obj;
  },

  create(base?: DeepPartial<SignedWhitelistedAddressEnvelope>): SignedWhitelistedAddressEnvelope {
    return SignedWhitelistedAddressEnvelope.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<SignedWhitelistedAddressEnvelope>): SignedWhitelistedAddressEnvelope {
    const message = createBaseSignedWhitelistedAddressEnvelope();
    message.id = object.id ?? 0;
    message.tenantId = object.tenantId ?? 0;
    message.signedAddress = (object.signedAddress !== undefined && object.signedAddress !== null)
      ? SignedWhitelistedAddress.fromPartial(object.signedAddress)
      : undefined;
    message.metadata = (object.metadata !== undefined && object.metadata !== null)
      ? Metadata.fromPartial(object.metadata)
      : undefined;
    message.action = object.action ?? "";
    message.scores = object.scores?.map((e) => Score.fromPartial(e)) || [];
    message.trails = object.trails?.map((e) => Trail.fromPartial(e)) || [];
    message.rulesContainer = object.rulesContainer ?? "";
    message.rule = object.rule ?? "";
    message.approvers = (object.approvers !== undefined && object.approvers !== null)
      ? Approvers.fromPartial(object.approvers)
      : undefined;
    message.attributes = object.attributes?.map((e) => WhitelistedAddressAttribute.fromPartial(e)) || [];
    message.rulesContainerHash = object.rulesContainerHash ?? "";
    message.blockchain = object.blockchain ?? "";
    message.status = object.status ?? "";
    message.network = object.network ?? "";
    message.visibilityGroupID = object.visibilityGroupID ?? "";
    message.tnParticipantID = object.tnParticipantID ?? "";
    message.rulesSignatures = object.rulesSignatures ?? "";
    return message;
  },
};

function createBaseSignedWhitelistedContractAddressEnvelope(): SignedWhitelistedContractAddressEnvelope {
  return {
    id: 0,
    tenantId: 0,
    signedContractAddress: undefined,
    metadata: undefined,
    action: "",
    trails: [],
    rulesContainer: "",
    rule: "",
    approvers: undefined,
    attributes: [],
    status: "",
    blockchain: "",
    network: "",
    businessRuleEnabled: false,
    rulesSignatures: "",
  };
}

export const SignedWhitelistedContractAddressEnvelope = {
  encode(message: SignedWhitelistedContractAddressEnvelope, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.id !== 0) {
      writer.uint32(8).uint64(message.id);
    }
    if (message.tenantId !== 0) {
      writer.uint32(16).uint64(message.tenantId);
    }
    if (message.signedContractAddress !== undefined) {
      SignedWhitelistedContractAddress.encode(message.signedContractAddress, writer.uint32(26).fork()).ldelim();
    }
    if (message.metadata !== undefined) {
      Metadata.encode(message.metadata, writer.uint32(34).fork()).ldelim();
    }
    if (message.action !== "") {
      writer.uint32(42).string(message.action);
    }
    for (const v of message.trails) {
      Trail.encode(v!, writer.uint32(50).fork()).ldelim();
    }
    if (message.rulesContainer !== "") {
      writer.uint32(66).string(message.rulesContainer);
    }
    if (message.rule !== "") {
      writer.uint32(74).string(message.rule);
    }
    if (message.approvers !== undefined) {
      Approvers.encode(message.approvers, writer.uint32(82).fork()).ldelim();
    }
    for (const v of message.attributes) {
      WhitelistedContractAddressAttribute.encode(v!, writer.uint32(90).fork()).ldelim();
    }
    if (message.status !== "") {
      writer.uint32(98).string(message.status);
    }
    if (message.blockchain !== "") {
      writer.uint32(106).string(message.blockchain);
    }
    if (message.network !== "") {
      writer.uint32(114).string(message.network);
    }
    if (message.businessRuleEnabled !== false) {
      writer.uint32(120).bool(message.businessRuleEnabled);
    }
    if (message.rulesSignatures !== "") {
      writer.uint32(130).string(message.rulesSignatures);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): SignedWhitelistedContractAddressEnvelope {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSignedWhitelistedContractAddressEnvelope();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.id = longToNumber(reader.uint64() as Long);
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.tenantId = longToNumber(reader.uint64() as Long);
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.signedContractAddress = SignedWhitelistedContractAddress.decode(reader, reader.uint32());
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.metadata = Metadata.decode(reader, reader.uint32());
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.action = reader.string();
          continue;
        case 6:
          if (tag !== 50) {
            break;
          }

          message.trails.push(Trail.decode(reader, reader.uint32()));
          continue;
        case 8:
          if (tag !== 66) {
            break;
          }

          message.rulesContainer = reader.string();
          continue;
        case 9:
          if (tag !== 74) {
            break;
          }

          message.rule = reader.string();
          continue;
        case 10:
          if (tag !== 82) {
            break;
          }

          message.approvers = Approvers.decode(reader, reader.uint32());
          continue;
        case 11:
          if (tag !== 90) {
            break;
          }

          message.attributes.push(WhitelistedContractAddressAttribute.decode(reader, reader.uint32()));
          continue;
        case 12:
          if (tag !== 98) {
            break;
          }

          message.status = reader.string();
          continue;
        case 13:
          if (tag !== 106) {
            break;
          }

          message.blockchain = reader.string();
          continue;
        case 14:
          if (tag !== 114) {
            break;
          }

          message.network = reader.string();
          continue;
        case 15:
          if (tag !== 120) {
            break;
          }

          message.businessRuleEnabled = reader.bool();
          continue;
        case 16:
          if (tag !== 130) {
            break;
          }

          message.rulesSignatures = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): SignedWhitelistedContractAddressEnvelope {
    return {
      id: isSet(object.id) ? globalThis.Number(object.id) : 0,
      tenantId: isSet(object.tenantId) ? globalThis.Number(object.tenantId) : 0,
      signedContractAddress: isSet(object.signedContractAddress)
        ? SignedWhitelistedContractAddress.fromJSON(object.signedContractAddress)
        : undefined,
      metadata: isSet(object.metadata) ? Metadata.fromJSON(object.metadata) : undefined,
      action: isSet(object.action) ? globalThis.String(object.action) : "",
      trails: globalThis.Array.isArray(object?.trails) ? object.trails.map((e: any) => Trail.fromJSON(e)) : [],
      rulesContainer: isSet(object.rulesContainer) ? globalThis.String(object.rulesContainer) : "",
      rule: isSet(object.rule) ? globalThis.String(object.rule) : "",
      approvers: isSet(object.approvers) ? Approvers.fromJSON(object.approvers) : undefined,
      attributes: globalThis.Array.isArray(object?.attributes)
        ? object.attributes.map((e: any) => WhitelistedContractAddressAttribute.fromJSON(e))
        : [],
      status: isSet(object.status) ? globalThis.String(object.status) : "",
      blockchain: isSet(object.blockchain) ? globalThis.String(object.blockchain) : "",
      network: isSet(object.network) ? globalThis.String(object.network) : "",
      businessRuleEnabled: isSet(object.businessRuleEnabled) ? globalThis.Boolean(object.businessRuleEnabled) : false,
      rulesSignatures: isSet(object.rulesSignatures) ? globalThis.String(object.rulesSignatures) : "",
    };
  },

  toJSON(message: SignedWhitelistedContractAddressEnvelope): unknown {
    const obj: any = {};
    if (message.id !== 0) {
      obj.id = Math.round(message.id);
    }
    if (message.tenantId !== 0) {
      obj.tenantId = Math.round(message.tenantId);
    }
    if (message.signedContractAddress !== undefined) {
      obj.signedContractAddress = SignedWhitelistedContractAddress.toJSON(message.signedContractAddress);
    }
    if (message.metadata !== undefined) {
      obj.metadata = Metadata.toJSON(message.metadata);
    }
    if (message.action !== "") {
      obj.action = message.action;
    }
    if (message.trails?.length) {
      obj.trails = message.trails.map((e) => Trail.toJSON(e));
    }
    if (message.rulesContainer !== "") {
      obj.rulesContainer = message.rulesContainer;
    }
    if (message.rule !== "") {
      obj.rule = message.rule;
    }
    if (message.approvers !== undefined) {
      obj.approvers = Approvers.toJSON(message.approvers);
    }
    if (message.attributes?.length) {
      obj.attributes = message.attributes.map((e) => WhitelistedContractAddressAttribute.toJSON(e));
    }
    if (message.status !== "") {
      obj.status = message.status;
    }
    if (message.blockchain !== "") {
      obj.blockchain = message.blockchain;
    }
    if (message.network !== "") {
      obj.network = message.network;
    }
    if (message.businessRuleEnabled !== false) {
      obj.businessRuleEnabled = message.businessRuleEnabled;
    }
    if (message.rulesSignatures !== "") {
      obj.rulesSignatures = message.rulesSignatures;
    }
    return obj;
  },

  create(base?: DeepPartial<SignedWhitelistedContractAddressEnvelope>): SignedWhitelistedContractAddressEnvelope {
    return SignedWhitelistedContractAddressEnvelope.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<SignedWhitelistedContractAddressEnvelope>): SignedWhitelistedContractAddressEnvelope {
    const message = createBaseSignedWhitelistedContractAddressEnvelope();
    message.id = object.id ?? 0;
    message.tenantId = object.tenantId ?? 0;
    message.signedContractAddress =
      (object.signedContractAddress !== undefined && object.signedContractAddress !== null)
        ? SignedWhitelistedContractAddress.fromPartial(object.signedContractAddress)
        : undefined;
    message.metadata = (object.metadata !== undefined && object.metadata !== null)
      ? Metadata.fromPartial(object.metadata)
      : undefined;
    message.action = object.action ?? "";
    message.trails = object.trails?.map((e) => Trail.fromPartial(e)) || [];
    message.rulesContainer = object.rulesContainer ?? "";
    message.rule = object.rule ?? "";
    message.approvers = (object.approvers !== undefined && object.approvers !== null)
      ? Approvers.fromPartial(object.approvers)
      : undefined;
    message.attributes = object.attributes?.map((e) => WhitelistedContractAddressAttribute.fromPartial(e)) || [];
    message.status = object.status ?? "";
    message.blockchain = object.blockchain ?? "";
    message.network = object.network ?? "";
    message.businessRuleEnabled = object.businessRuleEnabled ?? false;
    message.rulesSignatures = object.rulesSignatures ?? "";
    return message;
  },
};

function createBaseWhitelistUserSignature(): WhitelistUserSignature {
  return { userId: "", signature: new Uint8Array(0), comment: "" };
}

export const WhitelistUserSignature = {
  encode(message: WhitelistUserSignature, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.userId !== "") {
      writer.uint32(10).string(message.userId);
    }
    if (message.signature.length !== 0) {
      writer.uint32(18).bytes(message.signature);
    }
    if (message.comment !== "") {
      writer.uint32(26).string(message.comment);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): WhitelistUserSignature {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseWhitelistUserSignature();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.userId = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.signature = reader.bytes();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.comment = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): WhitelistUserSignature {
    return {
      userId: isSet(object.userId) ? globalThis.String(object.userId) : "",
      signature: isSet(object.signature) ? bytesFromBase64(object.signature) : new Uint8Array(0),
      comment: isSet(object.comment) ? globalThis.String(object.comment) : "",
    };
  },

  toJSON(message: WhitelistUserSignature): unknown {
    const obj: any = {};
    if (message.userId !== "") {
      obj.userId = message.userId;
    }
    if (message.signature.length !== 0) {
      obj.signature = base64FromBytes(message.signature);
    }
    if (message.comment !== "") {
      obj.comment = message.comment;
    }
    return obj;
  },

  create(base?: DeepPartial<WhitelistUserSignature>): WhitelistUserSignature {
    return WhitelistUserSignature.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<WhitelistUserSignature>): WhitelistUserSignature {
    const message = createBaseWhitelistUserSignature();
    message.userId = object.userId ?? "";
    message.signature = object.signature ?? new Uint8Array(0);
    message.comment = object.comment ?? "";
    return message;
  },
};

function createBaseWhitelistSignature(): WhitelistSignature {
  return { signature: undefined, hashes: [] };
}

export const WhitelistSignature = {
  encode(message: WhitelistSignature, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.signature !== undefined) {
      WhitelistUserSignature.encode(message.signature, writer.uint32(10).fork()).ldelim();
    }
    for (const v of message.hashes) {
      writer.uint32(18).string(v!);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): WhitelistSignature {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseWhitelistSignature();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.signature = WhitelistUserSignature.decode(reader, reader.uint32());
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.hashes.push(reader.string());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): WhitelistSignature {
    return {
      signature: isSet(object.signature) ? WhitelistUserSignature.fromJSON(object.signature) : undefined,
      hashes: globalThis.Array.isArray(object?.hashes) ? object.hashes.map((e: any) => globalThis.String(e)) : [],
    };
  },

  toJSON(message: WhitelistSignature): unknown {
    const obj: any = {};
    if (message.signature !== undefined) {
      obj.signature = WhitelistUserSignature.toJSON(message.signature);
    }
    if (message.hashes?.length) {
      obj.hashes = message.hashes;
    }
    return obj;
  },

  create(base?: DeepPartial<WhitelistSignature>): WhitelistSignature {
    return WhitelistSignature.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<WhitelistSignature>): WhitelistSignature {
    const message = createBaseWhitelistSignature();
    message.signature = (object.signature !== undefined && object.signature !== null)
      ? WhitelistUserSignature.fromPartial(object.signature)
      : undefined;
    message.hashes = object.hashes?.map((e) => e) || [];
    return message;
  },
};

function createBaseSignedWhitelistedAddress(): SignedWhitelistedAddress {
  return { signatures: [], payload: new Uint8Array(0) };
}

export const SignedWhitelistedAddress = {
  encode(message: SignedWhitelistedAddress, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    for (const v of message.signatures) {
      WhitelistSignature.encode(v!, writer.uint32(10).fork()).ldelim();
    }
    if (message.payload.length !== 0) {
      writer.uint32(18).bytes(message.payload);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): SignedWhitelistedAddress {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSignedWhitelistedAddress();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.signatures.push(WhitelistSignature.decode(reader, reader.uint32()));
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.payload = reader.bytes();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): SignedWhitelistedAddress {
    return {
      signatures: globalThis.Array.isArray(object?.signatures)
        ? object.signatures.map((e: any) => WhitelistSignature.fromJSON(e))
        : [],
      payload: isSet(object.payload) ? bytesFromBase64(object.payload) : new Uint8Array(0),
    };
  },

  toJSON(message: SignedWhitelistedAddress): unknown {
    const obj: any = {};
    if (message.signatures?.length) {
      obj.signatures = message.signatures.map((e) => WhitelistSignature.toJSON(e));
    }
    if (message.payload.length !== 0) {
      obj.payload = base64FromBytes(message.payload);
    }
    return obj;
  },

  create(base?: DeepPartial<SignedWhitelistedAddress>): SignedWhitelistedAddress {
    return SignedWhitelistedAddress.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<SignedWhitelistedAddress>): SignedWhitelistedAddress {
    const message = createBaseSignedWhitelistedAddress();
    message.signatures = object.signatures?.map((e) => WhitelistSignature.fromPartial(e)) || [];
    message.payload = object.payload ?? new Uint8Array(0);
    return message;
  },
};

function createBaseWhitelistedAddress(): WhitelistedAddress {
  return {
    blockchain: "",
    addressType: 0,
    address: "",
    memo: "",
    label: "",
    customerId: "",
    exchangeAccountId: 0,
    linkedInternalAddresses: [],
    contractType: "",
    attributes: [],
    linkedWallets: [],
    network: "",
    tnParticipantID: "",
  };
}

export const WhitelistedAddress = {
  encode(message: WhitelistedAddress, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.blockchain !== "") {
      writer.uint32(10).string(message.blockchain);
    }
    if (message.addressType !== 0) {
      writer.uint32(16).int32(message.addressType);
    }
    if (message.address !== "") {
      writer.uint32(26).string(message.address);
    }
    if (message.memo !== "") {
      writer.uint32(34).string(message.memo);
    }
    if (message.label !== "") {
      writer.uint32(42).string(message.label);
    }
    if (message.customerId !== "") {
      writer.uint32(50).string(message.customerId);
    }
    if (message.exchangeAccountId !== 0) {
      writer.uint32(56).uint64(message.exchangeAccountId);
    }
    for (const v of message.linkedInternalAddresses) {
      InternalAddress.encode(v!, writer.uint32(66).fork()).ldelim();
    }
    if (message.contractType !== "") {
      writer.uint32(74).string(message.contractType);
    }
    for (const v of message.attributes) {
      WhitelistedAddressAttribute.encode(v!, writer.uint32(82).fork()).ldelim();
    }
    for (const v of message.linkedWallets) {
      InternalWallet.encode(v!, writer.uint32(90).fork()).ldelim();
    }
    if (message.network !== "") {
      writer.uint32(106).string(message.network);
    }
    if (message.tnParticipantID !== "") {
      writer.uint32(114).string(message.tnParticipantID);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): WhitelistedAddress {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseWhitelistedAddress();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.blockchain = reader.string();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.addressType = reader.int32() as any;
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.address = reader.string();
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.memo = reader.string();
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.label = reader.string();
          continue;
        case 6:
          if (tag !== 50) {
            break;
          }

          message.customerId = reader.string();
          continue;
        case 7:
          if (tag !== 56) {
            break;
          }

          message.exchangeAccountId = longToNumber(reader.uint64() as Long);
          continue;
        case 8:
          if (tag !== 66) {
            break;
          }

          message.linkedInternalAddresses.push(InternalAddress.decode(reader, reader.uint32()));
          continue;
        case 9:
          if (tag !== 74) {
            break;
          }

          message.contractType = reader.string();
          continue;
        case 10:
          if (tag !== 82) {
            break;
          }

          message.attributes.push(WhitelistedAddressAttribute.decode(reader, reader.uint32()));
          continue;
        case 11:
          if (tag !== 90) {
            break;
          }

          message.linkedWallets.push(InternalWallet.decode(reader, reader.uint32()));
          continue;
        case 13:
          if (tag !== 106) {
            break;
          }

          message.network = reader.string();
          continue;
        case 14:
          if (tag !== 114) {
            break;
          }

          message.tnParticipantID = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): WhitelistedAddress {
    return {
      blockchain: isSet(object.blockchain) ? globalThis.String(object.blockchain) : "",
      addressType: isSet(object.addressType) ? whitelistedAddress_AddressTypeFromJSON(object.addressType) : 0,
      address: isSet(object.address) ? globalThis.String(object.address) : "",
      memo: isSet(object.memo) ? globalThis.String(object.memo) : "",
      label: isSet(object.label) ? globalThis.String(object.label) : "",
      customerId: isSet(object.customerId) ? globalThis.String(object.customerId) : "",
      exchangeAccountId: isSet(object.exchangeAccountId) ? globalThis.Number(object.exchangeAccountId) : 0,
      linkedInternalAddresses: globalThis.Array.isArray(object?.linkedInternalAddresses)
        ? object.linkedInternalAddresses.map((e: any) => InternalAddress.fromJSON(e))
        : [],
      contractType: isSet(object.contractType) ? globalThis.String(object.contractType) : "",
      attributes: globalThis.Array.isArray(object?.attributes)
        ? object.attributes.map((e: any) => WhitelistedAddressAttribute.fromJSON(e))
        : [],
      linkedWallets: globalThis.Array.isArray(object?.linkedWallets)
        ? object.linkedWallets.map((e: any) => InternalWallet.fromJSON(e))
        : [],
      network: isSet(object.network) ? globalThis.String(object.network) : "",
      tnParticipantID: isSet(object.tnParticipantID) ? globalThis.String(object.tnParticipantID) : "",
    };
  },

  toJSON(message: WhitelistedAddress): unknown {
    const obj: any = {};
    if (message.blockchain !== "") {
      obj.blockchain = message.blockchain;
    }
    if (message.addressType !== 0) {
      obj.addressType = whitelistedAddress_AddressTypeToJSON(message.addressType);
    }
    if (message.address !== "") {
      obj.address = message.address;
    }
    if (message.memo !== "") {
      obj.memo = message.memo;
    }
    if (message.label !== "") {
      obj.label = message.label;
    }
    if (message.customerId !== "") {
      obj.customerId = message.customerId;
    }
    if (message.exchangeAccountId !== 0) {
      obj.exchangeAccountId = Math.round(message.exchangeAccountId);
    }
    if (message.linkedInternalAddresses?.length) {
      obj.linkedInternalAddresses = message.linkedInternalAddresses.map((e) => InternalAddress.toJSON(e));
    }
    if (message.contractType !== "") {
      obj.contractType = message.contractType;
    }
    if (message.attributes?.length) {
      obj.attributes = message.attributes.map((e) => WhitelistedAddressAttribute.toJSON(e));
    }
    if (message.linkedWallets?.length) {
      obj.linkedWallets = message.linkedWallets.map((e) => InternalWallet.toJSON(e));
    }
    if (message.network !== "") {
      obj.network = message.network;
    }
    if (message.tnParticipantID !== "") {
      obj.tnParticipantID = message.tnParticipantID;
    }
    return obj;
  },

  create(base?: DeepPartial<WhitelistedAddress>): WhitelistedAddress {
    return WhitelistedAddress.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<WhitelistedAddress>): WhitelistedAddress {
    const message = createBaseWhitelistedAddress();
    message.blockchain = object.blockchain ?? "";
    message.addressType = object.addressType ?? 0;
    message.address = object.address ?? "";
    message.memo = object.memo ?? "";
    message.label = object.label ?? "";
    message.customerId = object.customerId ?? "";
    message.exchangeAccountId = object.exchangeAccountId ?? 0;
    message.linkedInternalAddresses = object.linkedInternalAddresses?.map((e) => InternalAddress.fromPartial(e)) || [];
    message.contractType = object.contractType ?? "";
    message.attributes = object.attributes?.map((e) => WhitelistedAddressAttribute.fromPartial(e)) || [];
    message.linkedWallets = object.linkedWallets?.map((e) => InternalWallet.fromPartial(e)) || [];
    message.network = object.network ?? "";
    message.tnParticipantID = object.tnParticipantID ?? "";
    return message;
  },
};

function createBaseWhitelistedAddressAttribute(): WhitelistedAddressAttribute {
  return { id: 0, key: "", value: "", contentType: "", owner: "", type: "", subtype: "", isfile: false };
}

export const WhitelistedAddressAttribute = {
  encode(message: WhitelistedAddressAttribute, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.id !== 0) {
      writer.uint32(8).uint64(message.id);
    }
    if (message.key !== "") {
      writer.uint32(18).string(message.key);
    }
    if (message.value !== "") {
      writer.uint32(26).string(message.value);
    }
    if (message.contentType !== "") {
      writer.uint32(34).string(message.contentType);
    }
    if (message.owner !== "") {
      writer.uint32(42).string(message.owner);
    }
    if (message.type !== "") {
      writer.uint32(50).string(message.type);
    }
    if (message.subtype !== "") {
      writer.uint32(58).string(message.subtype);
    }
    if (message.isfile !== false) {
      writer.uint32(64).bool(message.isfile);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): WhitelistedAddressAttribute {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseWhitelistedAddressAttribute();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.id = longToNumber(reader.uint64() as Long);
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.key = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.value = reader.string();
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.contentType = reader.string();
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.owner = reader.string();
          continue;
        case 6:
          if (tag !== 50) {
            break;
          }

          message.type = reader.string();
          continue;
        case 7:
          if (tag !== 58) {
            break;
          }

          message.subtype = reader.string();
          continue;
        case 8:
          if (tag !== 64) {
            break;
          }

          message.isfile = reader.bool();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): WhitelistedAddressAttribute {
    return {
      id: isSet(object.id) ? globalThis.Number(object.id) : 0,
      key: isSet(object.key) ? globalThis.String(object.key) : "",
      value: isSet(object.value) ? globalThis.String(object.value) : "",
      contentType: isSet(object.contentType) ? globalThis.String(object.contentType) : "",
      owner: isSet(object.owner) ? globalThis.String(object.owner) : "",
      type: isSet(object.type) ? globalThis.String(object.type) : "",
      subtype: isSet(object.subtype) ? globalThis.String(object.subtype) : "",
      isfile: isSet(object.isfile) ? globalThis.Boolean(object.isfile) : false,
    };
  },

  toJSON(message: WhitelistedAddressAttribute): unknown {
    const obj: any = {};
    if (message.id !== 0) {
      obj.id = Math.round(message.id);
    }
    if (message.key !== "") {
      obj.key = message.key;
    }
    if (message.value !== "") {
      obj.value = message.value;
    }
    if (message.contentType !== "") {
      obj.contentType = message.contentType;
    }
    if (message.owner !== "") {
      obj.owner = message.owner;
    }
    if (message.type !== "") {
      obj.type = message.type;
    }
    if (message.subtype !== "") {
      obj.subtype = message.subtype;
    }
    if (message.isfile !== false) {
      obj.isfile = message.isfile;
    }
    return obj;
  },

  create(base?: DeepPartial<WhitelistedAddressAttribute>): WhitelistedAddressAttribute {
    return WhitelistedAddressAttribute.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<WhitelistedAddressAttribute>): WhitelistedAddressAttribute {
    const message = createBaseWhitelistedAddressAttribute();
    message.id = object.id ?? 0;
    message.key = object.key ?? "";
    message.value = object.value ?? "";
    message.contentType = object.contentType ?? "";
    message.owner = object.owner ?? "";
    message.type = object.type ?? "";
    message.subtype = object.subtype ?? "";
    message.isfile = object.isfile ?? false;
    return message;
  },
};

function createBaseWhitelistedContractAddressAttribute(): WhitelistedContractAddressAttribute {
  return { id: 0, key: "", value: "", contentType: "", owner: "", type: "", subtype: "", isfile: false };
}

export const WhitelistedContractAddressAttribute = {
  encode(message: WhitelistedContractAddressAttribute, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.id !== 0) {
      writer.uint32(8).uint64(message.id);
    }
    if (message.key !== "") {
      writer.uint32(18).string(message.key);
    }
    if (message.value !== "") {
      writer.uint32(26).string(message.value);
    }
    if (message.contentType !== "") {
      writer.uint32(34).string(message.contentType);
    }
    if (message.owner !== "") {
      writer.uint32(42).string(message.owner);
    }
    if (message.type !== "") {
      writer.uint32(50).string(message.type);
    }
    if (message.subtype !== "") {
      writer.uint32(58).string(message.subtype);
    }
    if (message.isfile !== false) {
      writer.uint32(64).bool(message.isfile);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): WhitelistedContractAddressAttribute {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseWhitelistedContractAddressAttribute();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.id = longToNumber(reader.uint64() as Long);
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.key = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.value = reader.string();
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.contentType = reader.string();
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.owner = reader.string();
          continue;
        case 6:
          if (tag !== 50) {
            break;
          }

          message.type = reader.string();
          continue;
        case 7:
          if (tag !== 58) {
            break;
          }

          message.subtype = reader.string();
          continue;
        case 8:
          if (tag !== 64) {
            break;
          }

          message.isfile = reader.bool();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): WhitelistedContractAddressAttribute {
    return {
      id: isSet(object.id) ? globalThis.Number(object.id) : 0,
      key: isSet(object.key) ? globalThis.String(object.key) : "",
      value: isSet(object.value) ? globalThis.String(object.value) : "",
      contentType: isSet(object.contentType) ? globalThis.String(object.contentType) : "",
      owner: isSet(object.owner) ? globalThis.String(object.owner) : "",
      type: isSet(object.type) ? globalThis.String(object.type) : "",
      subtype: isSet(object.subtype) ? globalThis.String(object.subtype) : "",
      isfile: isSet(object.isfile) ? globalThis.Boolean(object.isfile) : false,
    };
  },

  toJSON(message: WhitelistedContractAddressAttribute): unknown {
    const obj: any = {};
    if (message.id !== 0) {
      obj.id = Math.round(message.id);
    }
    if (message.key !== "") {
      obj.key = message.key;
    }
    if (message.value !== "") {
      obj.value = message.value;
    }
    if (message.contentType !== "") {
      obj.contentType = message.contentType;
    }
    if (message.owner !== "") {
      obj.owner = message.owner;
    }
    if (message.type !== "") {
      obj.type = message.type;
    }
    if (message.subtype !== "") {
      obj.subtype = message.subtype;
    }
    if (message.isfile !== false) {
      obj.isfile = message.isfile;
    }
    return obj;
  },

  create(base?: DeepPartial<WhitelistedContractAddressAttribute>): WhitelistedContractAddressAttribute {
    return WhitelistedContractAddressAttribute.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<WhitelistedContractAddressAttribute>): WhitelistedContractAddressAttribute {
    const message = createBaseWhitelistedContractAddressAttribute();
    message.id = object.id ?? 0;
    message.key = object.key ?? "";
    message.value = object.value ?? "";
    message.contentType = object.contentType ?? "";
    message.owner = object.owner ?? "";
    message.type = object.type ?? "";
    message.subtype = object.subtype ?? "";
    message.isfile = object.isfile ?? false;
    return message;
  },
};

function createBaseInternalAddress(): InternalAddress {
  return { id: 0, address: "", label: "" };
}

export const InternalAddress = {
  encode(message: InternalAddress, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.id !== 0) {
      writer.uint32(8).uint64(message.id);
    }
    if (message.address !== "") {
      writer.uint32(18).string(message.address);
    }
    if (message.label !== "") {
      writer.uint32(26).string(message.label);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): InternalAddress {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseInternalAddress();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.id = longToNumber(reader.uint64() as Long);
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.address = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.label = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): InternalAddress {
    return {
      id: isSet(object.id) ? globalThis.Number(object.id) : 0,
      address: isSet(object.address) ? globalThis.String(object.address) : "",
      label: isSet(object.label) ? globalThis.String(object.label) : "",
    };
  },

  toJSON(message: InternalAddress): unknown {
    const obj: any = {};
    if (message.id !== 0) {
      obj.id = Math.round(message.id);
    }
    if (message.address !== "") {
      obj.address = message.address;
    }
    if (message.label !== "") {
      obj.label = message.label;
    }
    return obj;
  },

  create(base?: DeepPartial<InternalAddress>): InternalAddress {
    return InternalAddress.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<InternalAddress>): InternalAddress {
    const message = createBaseInternalAddress();
    message.id = object.id ?? 0;
    message.address = object.address ?? "";
    message.label = object.label ?? "";
    return message;
  },
};

function createBaseInternalWallet(): InternalWallet {
  return { id: 0, name: "", path: "" };
}

export const InternalWallet = {
  encode(message: InternalWallet, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.id !== 0) {
      writer.uint32(8).uint64(message.id);
    }
    if (message.name !== "") {
      writer.uint32(18).string(message.name);
    }
    if (message.path !== "") {
      writer.uint32(26).string(message.path);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): InternalWallet {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseInternalWallet();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.id = longToNumber(reader.uint64() as Long);
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.name = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.path = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): InternalWallet {
    return {
      id: isSet(object.id) ? globalThis.Number(object.id) : 0,
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      path: isSet(object.path) ? globalThis.String(object.path) : "",
    };
  },

  toJSON(message: InternalWallet): unknown {
    const obj: any = {};
    if (message.id !== 0) {
      obj.id = Math.round(message.id);
    }
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.path !== "") {
      obj.path = message.path;
    }
    return obj;
  },

  create(base?: DeepPartial<InternalWallet>): InternalWallet {
    return InternalWallet.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<InternalWallet>): InternalWallet {
    const message = createBaseInternalWallet();
    message.id = object.id ?? 0;
    message.name = object.name ?? "";
    message.path = object.path ?? "";
    return message;
  },
};

function createBaseSignedWhitelistedContractAddress(): SignedWhitelistedContractAddress {
  return { signatures: [], payload: new Uint8Array(0) };
}

export const SignedWhitelistedContractAddress = {
  encode(message: SignedWhitelistedContractAddress, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    for (const v of message.signatures) {
      WhitelistSignature.encode(v!, writer.uint32(10).fork()).ldelim();
    }
    if (message.payload.length !== 0) {
      writer.uint32(18).bytes(message.payload);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): SignedWhitelistedContractAddress {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSignedWhitelistedContractAddress();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.signatures.push(WhitelistSignature.decode(reader, reader.uint32()));
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.payload = reader.bytes();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): SignedWhitelistedContractAddress {
    return {
      signatures: globalThis.Array.isArray(object?.signatures)
        ? object.signatures.map((e: any) => WhitelistSignature.fromJSON(e))
        : [],
      payload: isSet(object.payload) ? bytesFromBase64(object.payload) : new Uint8Array(0),
    };
  },

  toJSON(message: SignedWhitelistedContractAddress): unknown {
    const obj: any = {};
    if (message.signatures?.length) {
      obj.signatures = message.signatures.map((e) => WhitelistSignature.toJSON(e));
    }
    if (message.payload.length !== 0) {
      obj.payload = base64FromBytes(message.payload);
    }
    return obj;
  },

  create(base?: DeepPartial<SignedWhitelistedContractAddress>): SignedWhitelistedContractAddress {
    return SignedWhitelistedContractAddress.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<SignedWhitelistedContractAddress>): SignedWhitelistedContractAddress {
    const message = createBaseSignedWhitelistedContractAddress();
    message.signatures = object.signatures?.map((e) => WhitelistSignature.fromPartial(e)) || [];
    message.payload = object.payload ?? new Uint8Array(0);
    return message;
  },
};

function createBaseWhitelistedContractAddress(): WhitelistedContractAddress {
  return { blockchain: "", name: "", symbol: "", decimals: 0, contractAddress: "", tokenId: "", kind: "", network: "" };
}

export const WhitelistedContractAddress = {
  encode(message: WhitelistedContractAddress, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.blockchain !== "") {
      writer.uint32(10).string(message.blockchain);
    }
    if (message.name !== "") {
      writer.uint32(18).string(message.name);
    }
    if (message.symbol !== "") {
      writer.uint32(26).string(message.symbol);
    }
    if (message.decimals !== 0) {
      writer.uint32(32).uint64(message.decimals);
    }
    if (message.contractAddress !== "") {
      writer.uint32(42).string(message.contractAddress);
    }
    if (message.tokenId !== "") {
      writer.uint32(50).string(message.tokenId);
    }
    if (message.kind !== "") {
      writer.uint32(58).string(message.kind);
    }
    if (message.network !== "") {
      writer.uint32(66).string(message.network);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): WhitelistedContractAddress {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseWhitelistedContractAddress();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.blockchain = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.name = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.symbol = reader.string();
          continue;
        case 4:
          if (tag !== 32) {
            break;
          }

          message.decimals = longToNumber(reader.uint64() as Long);
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.contractAddress = reader.string();
          continue;
        case 6:
          if (tag !== 50) {
            break;
          }

          message.tokenId = reader.string();
          continue;
        case 7:
          if (tag !== 58) {
            break;
          }

          message.kind = reader.string();
          continue;
        case 8:
          if (tag !== 66) {
            break;
          }

          message.network = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): WhitelistedContractAddress {
    return {
      blockchain: isSet(object.blockchain) ? globalThis.String(object.blockchain) : "",
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      symbol: isSet(object.symbol) ? globalThis.String(object.symbol) : "",
      decimals: isSet(object.decimals) ? globalThis.Number(object.decimals) : 0,
      contractAddress: isSet(object.contractAddress) ? globalThis.String(object.contractAddress) : "",
      tokenId: isSet(object.tokenId) ? globalThis.String(object.tokenId) : "",
      kind: isSet(object.kind) ? globalThis.String(object.kind) : "",
      network: isSet(object.network) ? globalThis.String(object.network) : "",
    };
  },

  toJSON(message: WhitelistedContractAddress): unknown {
    const obj: any = {};
    if (message.blockchain !== "") {
      obj.blockchain = message.blockchain;
    }
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.symbol !== "") {
      obj.symbol = message.symbol;
    }
    if (message.decimals !== 0) {
      obj.decimals = Math.round(message.decimals);
    }
    if (message.contractAddress !== "") {
      obj.contractAddress = message.contractAddress;
    }
    if (message.tokenId !== "") {
      obj.tokenId = message.tokenId;
    }
    if (message.kind !== "") {
      obj.kind = message.kind;
    }
    if (message.network !== "") {
      obj.network = message.network;
    }
    return obj;
  },

  create(base?: DeepPartial<WhitelistedContractAddress>): WhitelistedContractAddress {
    return WhitelistedContractAddress.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<WhitelistedContractAddress>): WhitelistedContractAddress {
    const message = createBaseWhitelistedContractAddress();
    message.blockchain = object.blockchain ?? "";
    message.name = object.name ?? "";
    message.symbol = object.symbol ?? "";
    message.decimals = object.decimals ?? 0;
    message.contractAddress = object.contractAddress ?? "";
    message.tokenId = object.tokenId ?? "";
    message.kind = object.kind ?? "";
    message.network = object.network ?? "";
    return message;
  },
};

function bytesFromBase64(b64: string): Uint8Array {
  const bin = globalThis.atob(b64);
  const arr = new Uint8Array(bin.length);
  for (let i = 0; i < bin.length; ++i) {
    arr[i] = bin.charCodeAt(i);
  }
  return arr;
}

function base64FromBytes(arr: Uint8Array): string {
  const bin: string[] = [];
  arr.forEach((byte) => {
    bin.push(globalThis.String.fromCharCode(byte));
  });
  return globalThis.btoa(bin.join(""));
}

type Builtin = Date | Function | Uint8Array | string | number | boolean | undefined;

export type DeepPartial<T> = T extends Builtin ? T
  : T extends globalThis.Array<infer U> ? globalThis.Array<DeepPartial<U>>
  : T extends ReadonlyArray<infer U> ? ReadonlyArray<DeepPartial<U>>
  : T extends {} ? { [K in keyof T]?: DeepPartial<T[K]> }
  : Partial<T>;

function toTimestamp(date: Date): Timestamp {
  const seconds = Math.trunc(date.getTime() / 1_000);
  const nanos = (date.getTime() % 1_000) * 1_000_000;
  return { seconds, nanos };
}

function fromTimestamp(t: Timestamp): Date {
  let millis = (t.seconds || 0) * 1_000;
  millis += (t.nanos || 0) / 1_000_000;
  return new globalThis.Date(millis);
}

function fromJsonTimestamp(o: any): Date {
  if (o instanceof globalThis.Date) {
    return o;
  } else if (typeof o === "string") {
    return new globalThis.Date(o);
  } else {
    return fromTimestamp(Timestamp.fromJSON(o));
  }
}

function longToNumber(long: Long): number {
  if (long.gt(globalThis.Number.MAX_SAFE_INTEGER)) {
    throw new globalThis.Error("Value is larger than Number.MAX_SAFE_INTEGER");
  }
  if (long.lt(globalThis.Number.MIN_SAFE_INTEGER)) {
    throw new globalThis.Error("Value is smaller than Number.MIN_SAFE_INTEGER");
  }
  return long.toNumber();
}

if (_m0.util.Long !== Long) {
  _m0.util.Long = Long as any;
  _m0.configure();
}

function isSet(value: any): boolean {
  return value !== null && value !== undefined;
}
