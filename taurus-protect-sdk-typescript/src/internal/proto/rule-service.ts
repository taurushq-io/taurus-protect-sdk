// Code generated by protoc-gen-ts_proto. DO NOT EDIT.
// versions:
//   protoc-gen-ts_proto  v1.181.2
//   protoc               v6.33.4
// source: rule-service.proto

/* eslint-disable */
import Long from "long";
import _m0 from "protobufjs/minimal";
import { RequestCursor, ResponseCursor } from "./cursor";
import { Empty } from "./google/protobuf/empty";
import { BusinessRule, Rules } from "./rule";

export const protobufPackage = "tgvalidatord";

export interface GetBusinessRulesRequest {
  limit: number;
  offset: number;
  ids: number[];
  ruleKeys: string[];
  ruleGroups: string[];
  walletIds: number[];
  currencies: string[];
  addressIds: number[];
  level: string;
}

export interface GetBusinessRulesV2Request {
  ids: number[];
  ruleKeys: string[];
  ruleGroups: string[];
  /**
   * Deprecated - Use EntityType and EntityID instead
   *
   * @deprecated
   */
  walletIds: number[];
  currencyIds: string[];
  /**
   * Deprecated - Use EntityType and EntityID instead
   *
   * @deprecated
   */
  addressIds: number[];
  /**
   * Deprecated - Use EntityType instead
   *
   * @deprecated
   */
  level: string;
  cursor:
    | RequestCursor
    | undefined;
  /** Filters rules by what they apply to. This can be one of `global`, `currency`, `wallet`, `address`, `exchange`, `exchange_account`, `tn_participant`. */
  entityType: string;
  /** Filters rules by the identifier of the affected entity. For wallets, addresses, and currencies this is their ID. For exchanges this is the exchange label. Leave this field blank for global rules. */
  entityIDs: string[];
}

export interface GetBusinessRulesV2Reply {
  result: BusinessRule[];
  cursor: ResponseCursor | undefined;
}

export interface GetBusinessRulesReply {
  result: BusinessRule[];
  totalItems: number;
}

export interface GetRulesReply {
  result: Rules | undefined;
}

export interface GetRulesByIDRequest {
  id: number;
}

export interface GetRulesHistoryRequest {
  limit: number;
  cursor: Uint8Array;
}

export interface GetRulesHistoryReply {
  result: Rules[];
  totalItems: number;
  cursor: Uint8Array;
}

export interface UpdateRulesProposalRequest {
  rulesContainer: string;
}

export interface ApproveRulesProposalRequest {
  /** base64(ecdsa_sign(sha256(rules_proposal))) */
  signature: string;
  comment: string;
}

export interface RejectRulesProposalRequest {
  comment: string;
}

export interface UpdateTransactionsEnabledBusinessRuleRequest {
  enabled: boolean;
}

export interface GetPublicKeysReply {
  publicKeys: GetPublicKeysReply_PublicKey[];
}

export interface GetPublicKeysReply_PublicKey {
  userID: string;
  publicKey: string;
}

function createBaseGetBusinessRulesRequest(): GetBusinessRulesRequest {
  return {
    limit: 0,
    offset: 0,
    ids: [],
    ruleKeys: [],
    ruleGroups: [],
    walletIds: [],
    currencies: [],
    addressIds: [],
    level: "",
  };
}

export const GetBusinessRulesRequest = {
  encode(message: GetBusinessRulesRequest, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.limit !== 0) {
      writer.uint32(8).uint64(message.limit);
    }
    if (message.offset !== 0) {
      writer.uint32(16).uint64(message.offset);
    }
    writer.uint32(26).fork();
    for (const v of message.ids) {
      writer.uint64(v);
    }
    writer.ldelim();
    for (const v of message.ruleKeys) {
      writer.uint32(34).string(v!);
    }
    for (const v of message.ruleGroups) {
      writer.uint32(42).string(v!);
    }
    writer.uint32(50).fork();
    for (const v of message.walletIds) {
      writer.uint64(v);
    }
    writer.ldelim();
    for (const v of message.currencies) {
      writer.uint32(58).string(v!);
    }
    writer.uint32(66).fork();
    for (const v of message.addressIds) {
      writer.uint64(v);
    }
    writer.ldelim();
    if (message.level !== "") {
      writer.uint32(74).string(message.level);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): GetBusinessRulesRequest {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetBusinessRulesRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.limit = longToNumber(reader.uint64() as Long);
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.offset = longToNumber(reader.uint64() as Long);
          continue;
        case 3:
          if (tag === 24) {
            message.ids.push(longToNumber(reader.uint64() as Long));

            continue;
          }

          if (tag === 26) {
            const end2 = reader.uint32() + reader.pos;
            while (reader.pos < end2) {
              message.ids.push(longToNumber(reader.uint64() as Long));
            }

            continue;
          }

          break;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.ruleKeys.push(reader.string());
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.ruleGroups.push(reader.string());
          continue;
        case 6:
          if (tag === 48) {
            message.walletIds.push(longToNumber(reader.uint64() as Long));

            continue;
          }

          if (tag === 50) {
            const end2 = reader.uint32() + reader.pos;
            while (reader.pos < end2) {
              message.walletIds.push(longToNumber(reader.uint64() as Long));
            }

            continue;
          }

          break;
        case 7:
          if (tag !== 58) {
            break;
          }

          message.currencies.push(reader.string());
          continue;
        case 8:
          if (tag === 64) {
            message.addressIds.push(longToNumber(reader.uint64() as Long));

            continue;
          }

          if (tag === 66) {
            const end2 = reader.uint32() + reader.pos;
            while (reader.pos < end2) {
              message.addressIds.push(longToNumber(reader.uint64() as Long));
            }

            continue;
          }

          break;
        case 9:
          if (tag !== 74) {
            break;
          }

          message.level = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetBusinessRulesRequest {
    return {
      limit: isSet(object.limit) ? globalThis.Number(object.limit) : 0,
      offset: isSet(object.offset) ? globalThis.Number(object.offset) : 0,
      ids: globalThis.Array.isArray(object?.ids) ? object.ids.map((e: any) => globalThis.Number(e)) : [],
      ruleKeys: globalThis.Array.isArray(object?.ruleKeys) ? object.ruleKeys.map((e: any) => globalThis.String(e)) : [],
      ruleGroups: globalThis.Array.isArray(object?.ruleGroups)
        ? object.ruleGroups.map((e: any) => globalThis.String(e))
        : [],
      walletIds: globalThis.Array.isArray(object?.walletIds)
        ? object.walletIds.map((e: any) => globalThis.Number(e))
        : [],
      currencies: globalThis.Array.isArray(object?.currencies)
        ? object.currencies.map((e: any) => globalThis.String(e))
        : [],
      addressIds: globalThis.Array.isArray(object?.addressIds)
        ? object.addressIds.map((e: any) => globalThis.Number(e))
        : [],
      level: isSet(object.level) ? globalThis.String(object.level) : "",
    };
  },

  toJSON(message: GetBusinessRulesRequest): unknown {
    const obj: any = {};
    if (message.limit !== 0) {
      obj.limit = Math.round(message.limit);
    }
    if (message.offset !== 0) {
      obj.offset = Math.round(message.offset);
    }
    if (message.ids?.length) {
      obj.ids = message.ids.map((e) => Math.round(e));
    }
    if (message.ruleKeys?.length) {
      obj.ruleKeys = message.ruleKeys;
    }
    if (message.ruleGroups?.length) {
      obj.ruleGroups = message.ruleGroups;
    }
    if (message.walletIds?.length) {
      obj.walletIds = message.walletIds.map((e) => Math.round(e));
    }
    if (message.currencies?.length) {
      obj.currencies = message.currencies;
    }
    if (message.addressIds?.length) {
      obj.addressIds = message.addressIds.map((e) => Math.round(e));
    }
    if (message.level !== "") {
      obj.level = message.level;
    }
    return obj;
  },

  create(base?: DeepPartial<GetBusinessRulesRequest>): GetBusinessRulesRequest {
    return GetBusinessRulesRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<GetBusinessRulesRequest>): GetBusinessRulesRequest {
    const message = createBaseGetBusinessRulesRequest();
    message.limit = object.limit ?? 0;
    message.offset = object.offset ?? 0;
    message.ids = object.ids?.map((e) => e) || [];
    message.ruleKeys = object.ruleKeys?.map((e) => e) || [];
    message.ruleGroups = object.ruleGroups?.map((e) => e) || [];
    message.walletIds = object.walletIds?.map((e) => e) || [];
    message.currencies = object.currencies?.map((e) => e) || [];
    message.addressIds = object.addressIds?.map((e) => e) || [];
    message.level = object.level ?? "";
    return message;
  },
};

function createBaseGetBusinessRulesV2Request(): GetBusinessRulesV2Request {
  return {
    ids: [],
    ruleKeys: [],
    ruleGroups: [],
    walletIds: [],
    currencyIds: [],
    addressIds: [],
    level: "",
    cursor: undefined,
    entityType: "",
    entityIDs: [],
  };
}

export const GetBusinessRulesV2Request = {
  encode(message: GetBusinessRulesV2Request, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    writer.uint32(10).fork();
    for (const v of message.ids) {
      writer.uint64(v);
    }
    writer.ldelim();
    for (const v of message.ruleKeys) {
      writer.uint32(18).string(v!);
    }
    for (const v of message.ruleGroups) {
      writer.uint32(26).string(v!);
    }
    writer.uint32(34).fork();
    for (const v of message.walletIds) {
      writer.uint64(v);
    }
    writer.ldelim();
    for (const v of message.currencyIds) {
      writer.uint32(42).string(v!);
    }
    writer.uint32(50).fork();
    for (const v of message.addressIds) {
      writer.uint64(v);
    }
    writer.ldelim();
    if (message.level !== "") {
      writer.uint32(58).string(message.level);
    }
    if (message.cursor !== undefined) {
      RequestCursor.encode(message.cursor, writer.uint32(66).fork()).ldelim();
    }
    if (message.entityType !== "") {
      writer.uint32(74).string(message.entityType);
    }
    for (const v of message.entityIDs) {
      writer.uint32(82).string(v!);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): GetBusinessRulesV2Request {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetBusinessRulesV2Request();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag === 8) {
            message.ids.push(longToNumber(reader.uint64() as Long));

            continue;
          }

          if (tag === 10) {
            const end2 = reader.uint32() + reader.pos;
            while (reader.pos < end2) {
              message.ids.push(longToNumber(reader.uint64() as Long));
            }

            continue;
          }

          break;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.ruleKeys.push(reader.string());
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.ruleGroups.push(reader.string());
          continue;
        case 4:
          if (tag === 32) {
            message.walletIds.push(longToNumber(reader.uint64() as Long));

            continue;
          }

          if (tag === 34) {
            const end2 = reader.uint32() + reader.pos;
            while (reader.pos < end2) {
              message.walletIds.push(longToNumber(reader.uint64() as Long));
            }

            continue;
          }

          break;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.currencyIds.push(reader.string());
          continue;
        case 6:
          if (tag === 48) {
            message.addressIds.push(longToNumber(reader.uint64() as Long));

            continue;
          }

          if (tag === 50) {
            const end2 = reader.uint32() + reader.pos;
            while (reader.pos < end2) {
              message.addressIds.push(longToNumber(reader.uint64() as Long));
            }

            continue;
          }

          break;
        case 7:
          if (tag !== 58) {
            break;
          }

          message.level = reader.string();
          continue;
        case 8:
          if (tag !== 66) {
            break;
          }

          message.cursor = RequestCursor.decode(reader, reader.uint32());
          continue;
        case 9:
          if (tag !== 74) {
            break;
          }

          message.entityType = reader.string();
          continue;
        case 10:
          if (tag !== 82) {
            break;
          }

          message.entityIDs.push(reader.string());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetBusinessRulesV2Request {
    return {
      ids: globalThis.Array.isArray(object?.ids) ? object.ids.map((e: any) => globalThis.Number(e)) : [],
      ruleKeys: globalThis.Array.isArray(object?.ruleKeys) ? object.ruleKeys.map((e: any) => globalThis.String(e)) : [],
      ruleGroups: globalThis.Array.isArray(object?.ruleGroups)
        ? object.ruleGroups.map((e: any) => globalThis.String(e))
        : [],
      walletIds: globalThis.Array.isArray(object?.walletIds)
        ? object.walletIds.map((e: any) => globalThis.Number(e))
        : [],
      currencyIds: globalThis.Array.isArray(object?.currencyIds)
        ? object.currencyIds.map((e: any) => globalThis.String(e))
        : [],
      addressIds: globalThis.Array.isArray(object?.addressIds)
        ? object.addressIds.map((e: any) => globalThis.Number(e))
        : [],
      level: isSet(object.level) ? globalThis.String(object.level) : "",
      cursor: isSet(object.cursor) ? RequestCursor.fromJSON(object.cursor) : undefined,
      entityType: isSet(object.entityType) ? globalThis.String(object.entityType) : "",
      entityIDs: globalThis.Array.isArray(object?.entityIDs)
        ? object.entityIDs.map((e: any) => globalThis.String(e))
        : [],
    };
  },

  toJSON(message: GetBusinessRulesV2Request): unknown {
    const obj: any = {};
    if (message.ids?.length) {
      obj.ids = message.ids.map((e) => Math.round(e));
    }
    if (message.ruleKeys?.length) {
      obj.ruleKeys = message.ruleKeys;
    }
    if (message.ruleGroups?.length) {
      obj.ruleGroups = message.ruleGroups;
    }
    if (message.walletIds?.length) {
      obj.walletIds = message.walletIds.map((e) => Math.round(e));
    }
    if (message.currencyIds?.length) {
      obj.currencyIds = message.currencyIds;
    }
    if (message.addressIds?.length) {
      obj.addressIds = message.addressIds.map((e) => Math.round(e));
    }
    if (message.level !== "") {
      obj.level = message.level;
    }
    if (message.cursor !== undefined) {
      obj.cursor = RequestCursor.toJSON(message.cursor);
    }
    if (message.entityType !== "") {
      obj.entityType = message.entityType;
    }
    if (message.entityIDs?.length) {
      obj.entityIDs = message.entityIDs;
    }
    return obj;
  },

  create(base?: DeepPartial<GetBusinessRulesV2Request>): GetBusinessRulesV2Request {
    return GetBusinessRulesV2Request.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<GetBusinessRulesV2Request>): GetBusinessRulesV2Request {
    const message = createBaseGetBusinessRulesV2Request();
    message.ids = object.ids?.map((e) => e) || [];
    message.ruleKeys = object.ruleKeys?.map((e) => e) || [];
    message.ruleGroups = object.ruleGroups?.map((e) => e) || [];
    message.walletIds = object.walletIds?.map((e) => e) || [];
    message.currencyIds = object.currencyIds?.map((e) => e) || [];
    message.addressIds = object.addressIds?.map((e) => e) || [];
    message.level = object.level ?? "";
    message.cursor = (object.cursor !== undefined && object.cursor !== null)
      ? RequestCursor.fromPartial(object.cursor)
      : undefined;
    message.entityType = object.entityType ?? "";
    message.entityIDs = object.entityIDs?.map((e) => e) || [];
    return message;
  },
};

function createBaseGetBusinessRulesV2Reply(): GetBusinessRulesV2Reply {
  return { result: [], cursor: undefined };
}

export const GetBusinessRulesV2Reply = {
  encode(message: GetBusinessRulesV2Reply, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    for (const v of message.result) {
      BusinessRule.encode(v!, writer.uint32(10).fork()).ldelim();
    }
    if (message.cursor !== undefined) {
      ResponseCursor.encode(message.cursor, writer.uint32(18).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): GetBusinessRulesV2Reply {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetBusinessRulesV2Reply();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.result.push(BusinessRule.decode(reader, reader.uint32()));
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.cursor = ResponseCursor.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetBusinessRulesV2Reply {
    return {
      result: globalThis.Array.isArray(object?.result) ? object.result.map((e: any) => BusinessRule.fromJSON(e)) : [],
      cursor: isSet(object.cursor) ? ResponseCursor.fromJSON(object.cursor) : undefined,
    };
  },

  toJSON(message: GetBusinessRulesV2Reply): unknown {
    const obj: any = {};
    if (message.result?.length) {
      obj.result = message.result.map((e) => BusinessRule.toJSON(e));
    }
    if (message.cursor !== undefined) {
      obj.cursor = ResponseCursor.toJSON(message.cursor);
    }
    return obj;
  },

  create(base?: DeepPartial<GetBusinessRulesV2Reply>): GetBusinessRulesV2Reply {
    return GetBusinessRulesV2Reply.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<GetBusinessRulesV2Reply>): GetBusinessRulesV2Reply {
    const message = createBaseGetBusinessRulesV2Reply();
    message.result = object.result?.map((e) => BusinessRule.fromPartial(e)) || [];
    message.cursor = (object.cursor !== undefined && object.cursor !== null)
      ? ResponseCursor.fromPartial(object.cursor)
      : undefined;
    return message;
  },
};

function createBaseGetBusinessRulesReply(): GetBusinessRulesReply {
  return { result: [], totalItems: 0 };
}

export const GetBusinessRulesReply = {
  encode(message: GetBusinessRulesReply, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    for (const v of message.result) {
      BusinessRule.encode(v!, writer.uint32(10).fork()).ldelim();
    }
    if (message.totalItems !== 0) {
      writer.uint32(16).uint64(message.totalItems);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): GetBusinessRulesReply {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetBusinessRulesReply();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.result.push(BusinessRule.decode(reader, reader.uint32()));
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.totalItems = longToNumber(reader.uint64() as Long);
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetBusinessRulesReply {
    return {
      result: globalThis.Array.isArray(object?.result) ? object.result.map((e: any) => BusinessRule.fromJSON(e)) : [],
      totalItems: isSet(object.totalItems) ? globalThis.Number(object.totalItems) : 0,
    };
  },

  toJSON(message: GetBusinessRulesReply): unknown {
    const obj: any = {};
    if (message.result?.length) {
      obj.result = message.result.map((e) => BusinessRule.toJSON(e));
    }
    if (message.totalItems !== 0) {
      obj.totalItems = Math.round(message.totalItems);
    }
    return obj;
  },

  create(base?: DeepPartial<GetBusinessRulesReply>): GetBusinessRulesReply {
    return GetBusinessRulesReply.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<GetBusinessRulesReply>): GetBusinessRulesReply {
    const message = createBaseGetBusinessRulesReply();
    message.result = object.result?.map((e) => BusinessRule.fromPartial(e)) || [];
    message.totalItems = object.totalItems ?? 0;
    return message;
  },
};

function createBaseGetRulesReply(): GetRulesReply {
  return { result: undefined };
}

export const GetRulesReply = {
  encode(message: GetRulesReply, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.result !== undefined) {
      Rules.encode(message.result, writer.uint32(10).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): GetRulesReply {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetRulesReply();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.result = Rules.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetRulesReply {
    return { result: isSet(object.result) ? Rules.fromJSON(object.result) : undefined };
  },

  toJSON(message: GetRulesReply): unknown {
    const obj: any = {};
    if (message.result !== undefined) {
      obj.result = Rules.toJSON(message.result);
    }
    return obj;
  },

  create(base?: DeepPartial<GetRulesReply>): GetRulesReply {
    return GetRulesReply.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<GetRulesReply>): GetRulesReply {
    const message = createBaseGetRulesReply();
    message.result = (object.result !== undefined && object.result !== null)
      ? Rules.fromPartial(object.result)
      : undefined;
    return message;
  },
};

function createBaseGetRulesByIDRequest(): GetRulesByIDRequest {
  return { id: 0 };
}

export const GetRulesByIDRequest = {
  encode(message: GetRulesByIDRequest, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.id !== 0) {
      writer.uint32(8).uint64(message.id);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): GetRulesByIDRequest {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetRulesByIDRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.id = longToNumber(reader.uint64() as Long);
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetRulesByIDRequest {
    return { id: isSet(object.id) ? globalThis.Number(object.id) : 0 };
  },

  toJSON(message: GetRulesByIDRequest): unknown {
    const obj: any = {};
    if (message.id !== 0) {
      obj.id = Math.round(message.id);
    }
    return obj;
  },

  create(base?: DeepPartial<GetRulesByIDRequest>): GetRulesByIDRequest {
    return GetRulesByIDRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<GetRulesByIDRequest>): GetRulesByIDRequest {
    const message = createBaseGetRulesByIDRequest();
    message.id = object.id ?? 0;
    return message;
  },
};

function createBaseGetRulesHistoryRequest(): GetRulesHistoryRequest {
  return { limit: 0, cursor: new Uint8Array(0) };
}

export const GetRulesHistoryRequest = {
  encode(message: GetRulesHistoryRequest, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.limit !== 0) {
      writer.uint32(8).uint64(message.limit);
    }
    if (message.cursor.length !== 0) {
      writer.uint32(18).bytes(message.cursor);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): GetRulesHistoryRequest {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetRulesHistoryRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.limit = longToNumber(reader.uint64() as Long);
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.cursor = reader.bytes();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetRulesHistoryRequest {
    return {
      limit: isSet(object.limit) ? globalThis.Number(object.limit) : 0,
      cursor: isSet(object.cursor) ? bytesFromBase64(object.cursor) : new Uint8Array(0),
    };
  },

  toJSON(message: GetRulesHistoryRequest): unknown {
    const obj: any = {};
    if (message.limit !== 0) {
      obj.limit = Math.round(message.limit);
    }
    if (message.cursor.length !== 0) {
      obj.cursor = base64FromBytes(message.cursor);
    }
    return obj;
  },

  create(base?: DeepPartial<GetRulesHistoryRequest>): GetRulesHistoryRequest {
    return GetRulesHistoryRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<GetRulesHistoryRequest>): GetRulesHistoryRequest {
    const message = createBaseGetRulesHistoryRequest();
    message.limit = object.limit ?? 0;
    message.cursor = object.cursor ?? new Uint8Array(0);
    return message;
  },
};

function createBaseGetRulesHistoryReply(): GetRulesHistoryReply {
  return { result: [], totalItems: 0, cursor: new Uint8Array(0) };
}

export const GetRulesHistoryReply = {
  encode(message: GetRulesHistoryReply, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    for (const v of message.result) {
      Rules.encode(v!, writer.uint32(10).fork()).ldelim();
    }
    if (message.totalItems !== 0) {
      writer.uint32(16).uint64(message.totalItems);
    }
    if (message.cursor.length !== 0) {
      writer.uint32(26).bytes(message.cursor);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): GetRulesHistoryReply {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetRulesHistoryReply();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.result.push(Rules.decode(reader, reader.uint32()));
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.totalItems = longToNumber(reader.uint64() as Long);
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.cursor = reader.bytes();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetRulesHistoryReply {
    return {
      result: globalThis.Array.isArray(object?.result) ? object.result.map((e: any) => Rules.fromJSON(e)) : [],
      totalItems: isSet(object.totalItems) ? globalThis.Number(object.totalItems) : 0,
      cursor: isSet(object.cursor) ? bytesFromBase64(object.cursor) : new Uint8Array(0),
    };
  },

  toJSON(message: GetRulesHistoryReply): unknown {
    const obj: any = {};
    if (message.result?.length) {
      obj.result = message.result.map((e) => Rules.toJSON(e));
    }
    if (message.totalItems !== 0) {
      obj.totalItems = Math.round(message.totalItems);
    }
    if (message.cursor.length !== 0) {
      obj.cursor = base64FromBytes(message.cursor);
    }
    return obj;
  },

  create(base?: DeepPartial<GetRulesHistoryReply>): GetRulesHistoryReply {
    return GetRulesHistoryReply.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<GetRulesHistoryReply>): GetRulesHistoryReply {
    const message = createBaseGetRulesHistoryReply();
    message.result = object.result?.map((e) => Rules.fromPartial(e)) || [];
    message.totalItems = object.totalItems ?? 0;
    message.cursor = object.cursor ?? new Uint8Array(0);
    return message;
  },
};

function createBaseUpdateRulesProposalRequest(): UpdateRulesProposalRequest {
  return { rulesContainer: "" };
}

export const UpdateRulesProposalRequest = {
  encode(message: UpdateRulesProposalRequest, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.rulesContainer !== "") {
      writer.uint32(10).string(message.rulesContainer);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): UpdateRulesProposalRequest {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseUpdateRulesProposalRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.rulesContainer = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): UpdateRulesProposalRequest {
    return { rulesContainer: isSet(object.rulesContainer) ? globalThis.String(object.rulesContainer) : "" };
  },

  toJSON(message: UpdateRulesProposalRequest): unknown {
    const obj: any = {};
    if (message.rulesContainer !== "") {
      obj.rulesContainer = message.rulesContainer;
    }
    return obj;
  },

  create(base?: DeepPartial<UpdateRulesProposalRequest>): UpdateRulesProposalRequest {
    return UpdateRulesProposalRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<UpdateRulesProposalRequest>): UpdateRulesProposalRequest {
    const message = createBaseUpdateRulesProposalRequest();
    message.rulesContainer = object.rulesContainer ?? "";
    return message;
  },
};

function createBaseApproveRulesProposalRequest(): ApproveRulesProposalRequest {
  return { signature: "", comment: "" };
}

export const ApproveRulesProposalRequest = {
  encode(message: ApproveRulesProposalRequest, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.signature !== "") {
      writer.uint32(10).string(message.signature);
    }
    if (message.comment !== "") {
      writer.uint32(18).string(message.comment);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): ApproveRulesProposalRequest {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseApproveRulesProposalRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.signature = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.comment = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ApproveRulesProposalRequest {
    return {
      signature: isSet(object.signature) ? globalThis.String(object.signature) : "",
      comment: isSet(object.comment) ? globalThis.String(object.comment) : "",
    };
  },

  toJSON(message: ApproveRulesProposalRequest): unknown {
    const obj: any = {};
    if (message.signature !== "") {
      obj.signature = message.signature;
    }
    if (message.comment !== "") {
      obj.comment = message.comment;
    }
    return obj;
  },

  create(base?: DeepPartial<ApproveRulesProposalRequest>): ApproveRulesProposalRequest {
    return ApproveRulesProposalRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ApproveRulesProposalRequest>): ApproveRulesProposalRequest {
    const message = createBaseApproveRulesProposalRequest();
    message.signature = object.signature ?? "";
    message.comment = object.comment ?? "";
    return message;
  },
};

function createBaseRejectRulesProposalRequest(): RejectRulesProposalRequest {
  return { comment: "" };
}

export const RejectRulesProposalRequest = {
  encode(message: RejectRulesProposalRequest, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.comment !== "") {
      writer.uint32(10).string(message.comment);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): RejectRulesProposalRequest {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseRejectRulesProposalRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.comment = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): RejectRulesProposalRequest {
    return { comment: isSet(object.comment) ? globalThis.String(object.comment) : "" };
  },

  toJSON(message: RejectRulesProposalRequest): unknown {
    const obj: any = {};
    if (message.comment !== "") {
      obj.comment = message.comment;
    }
    return obj;
  },

  create(base?: DeepPartial<RejectRulesProposalRequest>): RejectRulesProposalRequest {
    return RejectRulesProposalRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<RejectRulesProposalRequest>): RejectRulesProposalRequest {
    const message = createBaseRejectRulesProposalRequest();
    message.comment = object.comment ?? "";
    return message;
  },
};

function createBaseUpdateTransactionsEnabledBusinessRuleRequest(): UpdateTransactionsEnabledBusinessRuleRequest {
  return { enabled: false };
}

export const UpdateTransactionsEnabledBusinessRuleRequest = {
  encode(message: UpdateTransactionsEnabledBusinessRuleRequest, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.enabled !== false) {
      writer.uint32(8).bool(message.enabled);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): UpdateTransactionsEnabledBusinessRuleRequest {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseUpdateTransactionsEnabledBusinessRuleRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.enabled = reader.bool();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): UpdateTransactionsEnabledBusinessRuleRequest {
    return { enabled: isSet(object.enabled) ? globalThis.Boolean(object.enabled) : false };
  },

  toJSON(message: UpdateTransactionsEnabledBusinessRuleRequest): unknown {
    const obj: any = {};
    if (message.enabled !== false) {
      obj.enabled = message.enabled;
    }
    return obj;
  },

  create(
    base?: DeepPartial<UpdateTransactionsEnabledBusinessRuleRequest>,
  ): UpdateTransactionsEnabledBusinessRuleRequest {
    return UpdateTransactionsEnabledBusinessRuleRequest.fromPartial(base ?? {});
  },
  fromPartial(
    object: DeepPartial<UpdateTransactionsEnabledBusinessRuleRequest>,
  ): UpdateTransactionsEnabledBusinessRuleRequest {
    const message = createBaseUpdateTransactionsEnabledBusinessRuleRequest();
    message.enabled = object.enabled ?? false;
    return message;
  },
};

function createBaseGetPublicKeysReply(): GetPublicKeysReply {
  return { publicKeys: [] };
}

export const GetPublicKeysReply = {
  encode(message: GetPublicKeysReply, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    for (const v of message.publicKeys) {
      GetPublicKeysReply_PublicKey.encode(v!, writer.uint32(10).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): GetPublicKeysReply {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetPublicKeysReply();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.publicKeys.push(GetPublicKeysReply_PublicKey.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetPublicKeysReply {
    return {
      publicKeys: globalThis.Array.isArray(object?.publicKeys)
        ? object.publicKeys.map((e: any) => GetPublicKeysReply_PublicKey.fromJSON(e))
        : [],
    };
  },

  toJSON(message: GetPublicKeysReply): unknown {
    const obj: any = {};
    if (message.publicKeys?.length) {
      obj.publicKeys = message.publicKeys.map((e) => GetPublicKeysReply_PublicKey.toJSON(e));
    }
    return obj;
  },

  create(base?: DeepPartial<GetPublicKeysReply>): GetPublicKeysReply {
    return GetPublicKeysReply.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<GetPublicKeysReply>): GetPublicKeysReply {
    const message = createBaseGetPublicKeysReply();
    message.publicKeys = object.publicKeys?.map((e) => GetPublicKeysReply_PublicKey.fromPartial(e)) || [];
    return message;
  },
};

function createBaseGetPublicKeysReply_PublicKey(): GetPublicKeysReply_PublicKey {
  return { userID: "", publicKey: "" };
}

export const GetPublicKeysReply_PublicKey = {
  encode(message: GetPublicKeysReply_PublicKey, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.userID !== "") {
      writer.uint32(10).string(message.userID);
    }
    if (message.publicKey !== "") {
      writer.uint32(18).string(message.publicKey);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): GetPublicKeysReply_PublicKey {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetPublicKeysReply_PublicKey();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.userID = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.publicKey = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetPublicKeysReply_PublicKey {
    return {
      userID: isSet(object.userID) ? globalThis.String(object.userID) : "",
      publicKey: isSet(object.publicKey) ? globalThis.String(object.publicKey) : "",
    };
  },

  toJSON(message: GetPublicKeysReply_PublicKey): unknown {
    const obj: any = {};
    if (message.userID !== "") {
      obj.userID = message.userID;
    }
    if (message.publicKey !== "") {
      obj.publicKey = message.publicKey;
    }
    return obj;
  },

  create(base?: DeepPartial<GetPublicKeysReply_PublicKey>): GetPublicKeysReply_PublicKey {
    return GetPublicKeysReply_PublicKey.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<GetPublicKeysReply_PublicKey>): GetPublicKeysReply_PublicKey {
    const message = createBaseGetPublicKeysReply_PublicKey();
    message.userID = object.userID ?? "";
    message.publicKey = object.publicKey ?? "";
    return message;
  },
};

export interface RuleService {
  /**
   * ///////////////////////////
   * //   Business Rules   /////
   * ///////////////////////////
   * Deprecated - do not use anymore, use /api/rest/v2/businessrules instead
   */
  GetBusinessRules(request: GetBusinessRulesRequest): Promise<GetBusinessRulesReply>;
  GetBusinessRulesV2(request: GetBusinessRulesV2Request): Promise<GetBusinessRulesV2Reply>;
  UpdateTransactionsEnabledBusinessRule(request: UpdateTransactionsEnabledBusinessRuleRequest): Promise<Empty>;
  /**
   * /////////////////////////////
   * //   Governance Rules   /////
   * /////////////////////////////
   */
  GetRulesByID(request: GetRulesByIDRequest): Promise<GetRulesReply>;
  /** It is important that this is defined AFTER the more generic /api/rest/v1/rules/{id} routes */
  GetRules(request: Empty): Promise<GetRulesReply>;
  GetRulesHistory(request: GetRulesHistoryRequest): Promise<GetRulesHistoryReply>;
  GetRulesProposal(request: Empty): Promise<GetRulesReply>;
  UpdateRulesProposal(request: UpdateRulesProposalRequest): Promise<Empty>;
  ApproveRulesProposal(request: ApproveRulesProposalRequest): Promise<Empty>;
  RejectRulesProposal(request: RejectRulesProposalRequest): Promise<Empty>;
  GetPublicKeys(request: Empty): Promise<GetPublicKeysReply>;
}

export const RuleServiceServiceName = "tgvalidatord.RuleService";
export class RuleServiceClientImpl implements RuleService {
  private readonly rpc: Rpc;
  private readonly service: string;
  constructor(rpc: Rpc, opts?: { service?: string }) {
    this.service = opts?.service || RuleServiceServiceName;
    this.rpc = rpc;
    this.GetBusinessRules = this.GetBusinessRules.bind(this);
    this.GetBusinessRulesV2 = this.GetBusinessRulesV2.bind(this);
    this.UpdateTransactionsEnabledBusinessRule = this.UpdateTransactionsEnabledBusinessRule.bind(this);
    this.GetRulesByID = this.GetRulesByID.bind(this);
    this.GetRules = this.GetRules.bind(this);
    this.GetRulesHistory = this.GetRulesHistory.bind(this);
    this.GetRulesProposal = this.GetRulesProposal.bind(this);
    this.UpdateRulesProposal = this.UpdateRulesProposal.bind(this);
    this.ApproveRulesProposal = this.ApproveRulesProposal.bind(this);
    this.RejectRulesProposal = this.RejectRulesProposal.bind(this);
    this.GetPublicKeys = this.GetPublicKeys.bind(this);
  }
  GetBusinessRules(request: GetBusinessRulesRequest): Promise<GetBusinessRulesReply> {
    const data = GetBusinessRulesRequest.encode(request).finish();
    const promise = this.rpc.request(this.service, "GetBusinessRules", data);
    return promise.then((data) => GetBusinessRulesReply.decode(_m0.Reader.create(data)));
  }

  GetBusinessRulesV2(request: GetBusinessRulesV2Request): Promise<GetBusinessRulesV2Reply> {
    const data = GetBusinessRulesV2Request.encode(request).finish();
    const promise = this.rpc.request(this.service, "GetBusinessRulesV2", data);
    return promise.then((data) => GetBusinessRulesV2Reply.decode(_m0.Reader.create(data)));
  }

  UpdateTransactionsEnabledBusinessRule(request: UpdateTransactionsEnabledBusinessRuleRequest): Promise<Empty> {
    const data = UpdateTransactionsEnabledBusinessRuleRequest.encode(request).finish();
    const promise = this.rpc.request(this.service, "UpdateTransactionsEnabledBusinessRule", data);
    return promise.then((data) => Empty.decode(_m0.Reader.create(data)));
  }

  GetRulesByID(request: GetRulesByIDRequest): Promise<GetRulesReply> {
    const data = GetRulesByIDRequest.encode(request).finish();
    const promise = this.rpc.request(this.service, "GetRulesByID", data);
    return promise.then((data) => GetRulesReply.decode(_m0.Reader.create(data)));
  }

  GetRules(request: Empty): Promise<GetRulesReply> {
    const data = Empty.encode(request).finish();
    const promise = this.rpc.request(this.service, "GetRules", data);
    return promise.then((data) => GetRulesReply.decode(_m0.Reader.create(data)));
  }

  GetRulesHistory(request: GetRulesHistoryRequest): Promise<GetRulesHistoryReply> {
    const data = GetRulesHistoryRequest.encode(request).finish();
    const promise = this.rpc.request(this.service, "GetRulesHistory", data);
    return promise.then((data) => GetRulesHistoryReply.decode(_m0.Reader.create(data)));
  }

  GetRulesProposal(request: Empty): Promise<GetRulesReply> {
    const data = Empty.encode(request).finish();
    const promise = this.rpc.request(this.service, "GetRulesProposal", data);
    return promise.then((data) => GetRulesReply.decode(_m0.Reader.create(data)));
  }

  UpdateRulesProposal(request: UpdateRulesProposalRequest): Promise<Empty> {
    const data = UpdateRulesProposalRequest.encode(request).finish();
    const promise = this.rpc.request(this.service, "UpdateRulesProposal", data);
    return promise.then((data) => Empty.decode(_m0.Reader.create(data)));
  }

  ApproveRulesProposal(request: ApproveRulesProposalRequest): Promise<Empty> {
    const data = ApproveRulesProposalRequest.encode(request).finish();
    const promise = this.rpc.request(this.service, "ApproveRulesProposal", data);
    return promise.then((data) => Empty.decode(_m0.Reader.create(data)));
  }

  RejectRulesProposal(request: RejectRulesProposalRequest): Promise<Empty> {
    const data = RejectRulesProposalRequest.encode(request).finish();
    const promise = this.rpc.request(this.service, "RejectRulesProposal", data);
    return promise.then((data) => Empty.decode(_m0.Reader.create(data)));
  }

  GetPublicKeys(request: Empty): Promise<GetPublicKeysReply> {
    const data = Empty.encode(request).finish();
    const promise = this.rpc.request(this.service, "GetPublicKeys", data);
    return promise.then((data) => GetPublicKeysReply.decode(_m0.Reader.create(data)));
  }
}

interface Rpc {
  request(service: string, method: string, data: Uint8Array): Promise<Uint8Array>;
}

function bytesFromBase64(b64: string): Uint8Array {
  const bin = globalThis.atob(b64);
  const arr = new Uint8Array(bin.length);
  for (let i = 0; i < bin.length; ++i) {
    arr[i] = bin.charCodeAt(i);
  }
  return arr;
}

function base64FromBytes(arr: Uint8Array): string {
  const bin: string[] = [];
  arr.forEach((byte) => {
    bin.push(globalThis.String.fromCharCode(byte));
  });
  return globalThis.btoa(bin.join(""));
}

type Builtin = Date | Function | Uint8Array | string | number | boolean | undefined;

export type DeepPartial<T> = T extends Builtin ? T
  : T extends globalThis.Array<infer U> ? globalThis.Array<DeepPartial<U>>
  : T extends ReadonlyArray<infer U> ? ReadonlyArray<DeepPartial<U>>
  : T extends {} ? { [K in keyof T]?: DeepPartial<T[K]> }
  : Partial<T>;

function longToNumber(long: Long): number {
  if (long.gt(globalThis.Number.MAX_SAFE_INTEGER)) {
    throw new globalThis.Error("Value is larger than Number.MAX_SAFE_INTEGER");
  }
  if (long.lt(globalThis.Number.MIN_SAFE_INTEGER)) {
    throw new globalThis.Error("Value is smaller than Number.MIN_SAFE_INTEGER");
  }
  return long.toNumber();
}

if (_m0.util.Long !== Long) {
  _m0.util.Long = Long as any;
  _m0.configure();
}

function isSet(value: any): boolean {
  return value !== null && value !== undefined;
}
