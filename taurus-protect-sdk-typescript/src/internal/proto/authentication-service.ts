// Code generated by protoc-gen-ts_proto. DO NOT EDIT.
// versions:
//   protoc-gen-ts_proto  v1.181.2
//   protoc               v6.33.4
// source: authentication-service.proto

/* eslint-disable */
import _m0 from "protobufjs/minimal";
import { ApiRequestToValidate } from "./auth_proxy/api_request_to_validate";
import { Credentials, OIDCLocation, OIDCSession, SAMLAuthRedirect, SAMLAuthRequest, SAMLSession } from "./credentials";
import { SecurityDomain_Mode, securityDomain_ModeFromJSON, securityDomain_ModeToJSON } from "./sso";

export const protobufPackage = "tgvalidatord";

export interface AuthenticationReply {
  result: string;
}

export interface StartLoginRequest {
  email: string;
}

export interface StartLoginReply {
  result: SecurityDomain_Mode;
}

export interface SAMLInitiateRequest {
  email: string;
  redirectUri: string;
}

export interface SAMLInitiateReply {
  result: SAMLAuthRequest | undefined;
}

export interface SAMLCheckAssertionRequest {
  SAMLResponse: string;
  RelayState: string;
}

export interface SAMLCheckAssertionReply {
  result: SAMLAuthRedirect | undefined;
}

export interface SAMLSessionRequest {
}

export interface SAMLSessionReply {
  result: SAMLSession | undefined;
}

export interface OIDCInitiateRequest {
  email: string;
  redirectUri: string;
}

export interface OIDCInitiateReply {
  result: OIDCLocation | undefined;
}

export interface OIDCSessionRequest {
  code: string;
  state: string;
}

export interface OIDCSessionReply {
  result: OIDCSession | undefined;
}

export interface ValidateAuthenticationReq {
  apiRequestToValidate: ApiRequestToValidate | undefined;
  signature: Uint8Array;
}

export interface ValidateAuthenticationReply {
  jwt: string;
}

function createBaseAuthenticationReply(): AuthenticationReply {
  return { result: "" };
}

export const AuthenticationReply = {
  encode(message: AuthenticationReply, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.result !== "") {
      writer.uint32(10).string(message.result);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): AuthenticationReply {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseAuthenticationReply();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.result = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): AuthenticationReply {
    return { result: isSet(object.result) ? globalThis.String(object.result) : "" };
  },

  toJSON(message: AuthenticationReply): unknown {
    const obj: any = {};
    if (message.result !== "") {
      obj.result = message.result;
    }
    return obj;
  },

  create(base?: DeepPartial<AuthenticationReply>): AuthenticationReply {
    return AuthenticationReply.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<AuthenticationReply>): AuthenticationReply {
    const message = createBaseAuthenticationReply();
    message.result = object.result ?? "";
    return message;
  },
};

function createBaseStartLoginRequest(): StartLoginRequest {
  return { email: "" };
}

export const StartLoginRequest = {
  encode(message: StartLoginRequest, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.email !== "") {
      writer.uint32(10).string(message.email);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): StartLoginRequest {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseStartLoginRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.email = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): StartLoginRequest {
    return { email: isSet(object.email) ? globalThis.String(object.email) : "" };
  },

  toJSON(message: StartLoginRequest): unknown {
    const obj: any = {};
    if (message.email !== "") {
      obj.email = message.email;
    }
    return obj;
  },

  create(base?: DeepPartial<StartLoginRequest>): StartLoginRequest {
    return StartLoginRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<StartLoginRequest>): StartLoginRequest {
    const message = createBaseStartLoginRequest();
    message.email = object.email ?? "";
    return message;
  },
};

function createBaseStartLoginReply(): StartLoginReply {
  return { result: 0 };
}

export const StartLoginReply = {
  encode(message: StartLoginReply, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.result !== 0) {
      writer.uint32(8).int32(message.result);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): StartLoginReply {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseStartLoginReply();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.result = reader.int32() as any;
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): StartLoginReply {
    return { result: isSet(object.result) ? securityDomain_ModeFromJSON(object.result) : 0 };
  },

  toJSON(message: StartLoginReply): unknown {
    const obj: any = {};
    if (message.result !== 0) {
      obj.result = securityDomain_ModeToJSON(message.result);
    }
    return obj;
  },

  create(base?: DeepPartial<StartLoginReply>): StartLoginReply {
    return StartLoginReply.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<StartLoginReply>): StartLoginReply {
    const message = createBaseStartLoginReply();
    message.result = object.result ?? 0;
    return message;
  },
};

function createBaseSAMLInitiateRequest(): SAMLInitiateRequest {
  return { email: "", redirectUri: "" };
}

export const SAMLInitiateRequest = {
  encode(message: SAMLInitiateRequest, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.email !== "") {
      writer.uint32(10).string(message.email);
    }
    if (message.redirectUri !== "") {
      writer.uint32(18).string(message.redirectUri);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): SAMLInitiateRequest {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSAMLInitiateRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.email = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.redirectUri = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): SAMLInitiateRequest {
    return {
      email: isSet(object.email) ? globalThis.String(object.email) : "",
      redirectUri: isSet(object.redirectUri) ? globalThis.String(object.redirectUri) : "",
    };
  },

  toJSON(message: SAMLInitiateRequest): unknown {
    const obj: any = {};
    if (message.email !== "") {
      obj.email = message.email;
    }
    if (message.redirectUri !== "") {
      obj.redirectUri = message.redirectUri;
    }
    return obj;
  },

  create(base?: DeepPartial<SAMLInitiateRequest>): SAMLInitiateRequest {
    return SAMLInitiateRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<SAMLInitiateRequest>): SAMLInitiateRequest {
    const message = createBaseSAMLInitiateRequest();
    message.email = object.email ?? "";
    message.redirectUri = object.redirectUri ?? "";
    return message;
  },
};

function createBaseSAMLInitiateReply(): SAMLInitiateReply {
  return { result: undefined };
}

export const SAMLInitiateReply = {
  encode(message: SAMLInitiateReply, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.result !== undefined) {
      SAMLAuthRequest.encode(message.result, writer.uint32(10).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): SAMLInitiateReply {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSAMLInitiateReply();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.result = SAMLAuthRequest.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): SAMLInitiateReply {
    return { result: isSet(object.result) ? SAMLAuthRequest.fromJSON(object.result) : undefined };
  },

  toJSON(message: SAMLInitiateReply): unknown {
    const obj: any = {};
    if (message.result !== undefined) {
      obj.result = SAMLAuthRequest.toJSON(message.result);
    }
    return obj;
  },

  create(base?: DeepPartial<SAMLInitiateReply>): SAMLInitiateReply {
    return SAMLInitiateReply.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<SAMLInitiateReply>): SAMLInitiateReply {
    const message = createBaseSAMLInitiateReply();
    message.result = (object.result !== undefined && object.result !== null)
      ? SAMLAuthRequest.fromPartial(object.result)
      : undefined;
    return message;
  },
};

function createBaseSAMLCheckAssertionRequest(): SAMLCheckAssertionRequest {
  return { SAMLResponse: "", RelayState: "" };
}

export const SAMLCheckAssertionRequest = {
  encode(message: SAMLCheckAssertionRequest, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.SAMLResponse !== "") {
      writer.uint32(10).string(message.SAMLResponse);
    }
    if (message.RelayState !== "") {
      writer.uint32(18).string(message.RelayState);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): SAMLCheckAssertionRequest {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSAMLCheckAssertionRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.SAMLResponse = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.RelayState = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): SAMLCheckAssertionRequest {
    return {
      SAMLResponse: isSet(object.SAMLResponse) ? globalThis.String(object.SAMLResponse) : "",
      RelayState: isSet(object.RelayState) ? globalThis.String(object.RelayState) : "",
    };
  },

  toJSON(message: SAMLCheckAssertionRequest): unknown {
    const obj: any = {};
    if (message.SAMLResponse !== "") {
      obj.SAMLResponse = message.SAMLResponse;
    }
    if (message.RelayState !== "") {
      obj.RelayState = message.RelayState;
    }
    return obj;
  },

  create(base?: DeepPartial<SAMLCheckAssertionRequest>): SAMLCheckAssertionRequest {
    return SAMLCheckAssertionRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<SAMLCheckAssertionRequest>): SAMLCheckAssertionRequest {
    const message = createBaseSAMLCheckAssertionRequest();
    message.SAMLResponse = object.SAMLResponse ?? "";
    message.RelayState = object.RelayState ?? "";
    return message;
  },
};

function createBaseSAMLCheckAssertionReply(): SAMLCheckAssertionReply {
  return { result: undefined };
}

export const SAMLCheckAssertionReply = {
  encode(message: SAMLCheckAssertionReply, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.result !== undefined) {
      SAMLAuthRedirect.encode(message.result, writer.uint32(10).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): SAMLCheckAssertionReply {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSAMLCheckAssertionReply();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.result = SAMLAuthRedirect.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): SAMLCheckAssertionReply {
    return { result: isSet(object.result) ? SAMLAuthRedirect.fromJSON(object.result) : undefined };
  },

  toJSON(message: SAMLCheckAssertionReply): unknown {
    const obj: any = {};
    if (message.result !== undefined) {
      obj.result = SAMLAuthRedirect.toJSON(message.result);
    }
    return obj;
  },

  create(base?: DeepPartial<SAMLCheckAssertionReply>): SAMLCheckAssertionReply {
    return SAMLCheckAssertionReply.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<SAMLCheckAssertionReply>): SAMLCheckAssertionReply {
    const message = createBaseSAMLCheckAssertionReply();
    message.result = (object.result !== undefined && object.result !== null)
      ? SAMLAuthRedirect.fromPartial(object.result)
      : undefined;
    return message;
  },
};

function createBaseSAMLSessionRequest(): SAMLSessionRequest {
  return {};
}

export const SAMLSessionRequest = {
  encode(_: SAMLSessionRequest, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): SAMLSessionRequest {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSAMLSessionRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(_: any): SAMLSessionRequest {
    return {};
  },

  toJSON(_: SAMLSessionRequest): unknown {
    const obj: any = {};
    return obj;
  },

  create(base?: DeepPartial<SAMLSessionRequest>): SAMLSessionRequest {
    return SAMLSessionRequest.fromPartial(base ?? {});
  },
  fromPartial(_: DeepPartial<SAMLSessionRequest>): SAMLSessionRequest {
    const message = createBaseSAMLSessionRequest();
    return message;
  },
};

function createBaseSAMLSessionReply(): SAMLSessionReply {
  return { result: undefined };
}

export const SAMLSessionReply = {
  encode(message: SAMLSessionReply, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.result !== undefined) {
      SAMLSession.encode(message.result, writer.uint32(10).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): SAMLSessionReply {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSAMLSessionReply();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.result = SAMLSession.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): SAMLSessionReply {
    return { result: isSet(object.result) ? SAMLSession.fromJSON(object.result) : undefined };
  },

  toJSON(message: SAMLSessionReply): unknown {
    const obj: any = {};
    if (message.result !== undefined) {
      obj.result = SAMLSession.toJSON(message.result);
    }
    return obj;
  },

  create(base?: DeepPartial<SAMLSessionReply>): SAMLSessionReply {
    return SAMLSessionReply.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<SAMLSessionReply>): SAMLSessionReply {
    const message = createBaseSAMLSessionReply();
    message.result = (object.result !== undefined && object.result !== null)
      ? SAMLSession.fromPartial(object.result)
      : undefined;
    return message;
  },
};

function createBaseOIDCInitiateRequest(): OIDCInitiateRequest {
  return { email: "", redirectUri: "" };
}

export const OIDCInitiateRequest = {
  encode(message: OIDCInitiateRequest, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.email !== "") {
      writer.uint32(10).string(message.email);
    }
    if (message.redirectUri !== "") {
      writer.uint32(18).string(message.redirectUri);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): OIDCInitiateRequest {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseOIDCInitiateRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.email = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.redirectUri = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): OIDCInitiateRequest {
    return {
      email: isSet(object.email) ? globalThis.String(object.email) : "",
      redirectUri: isSet(object.redirectUri) ? globalThis.String(object.redirectUri) : "",
    };
  },

  toJSON(message: OIDCInitiateRequest): unknown {
    const obj: any = {};
    if (message.email !== "") {
      obj.email = message.email;
    }
    if (message.redirectUri !== "") {
      obj.redirectUri = message.redirectUri;
    }
    return obj;
  },

  create(base?: DeepPartial<OIDCInitiateRequest>): OIDCInitiateRequest {
    return OIDCInitiateRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<OIDCInitiateRequest>): OIDCInitiateRequest {
    const message = createBaseOIDCInitiateRequest();
    message.email = object.email ?? "";
    message.redirectUri = object.redirectUri ?? "";
    return message;
  },
};

function createBaseOIDCInitiateReply(): OIDCInitiateReply {
  return { result: undefined };
}

export const OIDCInitiateReply = {
  encode(message: OIDCInitiateReply, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.result !== undefined) {
      OIDCLocation.encode(message.result, writer.uint32(10).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): OIDCInitiateReply {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseOIDCInitiateReply();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.result = OIDCLocation.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): OIDCInitiateReply {
    return { result: isSet(object.result) ? OIDCLocation.fromJSON(object.result) : undefined };
  },

  toJSON(message: OIDCInitiateReply): unknown {
    const obj: any = {};
    if (message.result !== undefined) {
      obj.result = OIDCLocation.toJSON(message.result);
    }
    return obj;
  },

  create(base?: DeepPartial<OIDCInitiateReply>): OIDCInitiateReply {
    return OIDCInitiateReply.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<OIDCInitiateReply>): OIDCInitiateReply {
    const message = createBaseOIDCInitiateReply();
    message.result = (object.result !== undefined && object.result !== null)
      ? OIDCLocation.fromPartial(object.result)
      : undefined;
    return message;
  },
};

function createBaseOIDCSessionRequest(): OIDCSessionRequest {
  return { code: "", state: "" };
}

export const OIDCSessionRequest = {
  encode(message: OIDCSessionRequest, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.code !== "") {
      writer.uint32(10).string(message.code);
    }
    if (message.state !== "") {
      writer.uint32(26).string(message.state);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): OIDCSessionRequest {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseOIDCSessionRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.code = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.state = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): OIDCSessionRequest {
    return {
      code: isSet(object.code) ? globalThis.String(object.code) : "",
      state: isSet(object.state) ? globalThis.String(object.state) : "",
    };
  },

  toJSON(message: OIDCSessionRequest): unknown {
    const obj: any = {};
    if (message.code !== "") {
      obj.code = message.code;
    }
    if (message.state !== "") {
      obj.state = message.state;
    }
    return obj;
  },

  create(base?: DeepPartial<OIDCSessionRequest>): OIDCSessionRequest {
    return OIDCSessionRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<OIDCSessionRequest>): OIDCSessionRequest {
    const message = createBaseOIDCSessionRequest();
    message.code = object.code ?? "";
    message.state = object.state ?? "";
    return message;
  },
};

function createBaseOIDCSessionReply(): OIDCSessionReply {
  return { result: undefined };
}

export const OIDCSessionReply = {
  encode(message: OIDCSessionReply, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.result !== undefined) {
      OIDCSession.encode(message.result, writer.uint32(10).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): OIDCSessionReply {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseOIDCSessionReply();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.result = OIDCSession.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): OIDCSessionReply {
    return { result: isSet(object.result) ? OIDCSession.fromJSON(object.result) : undefined };
  },

  toJSON(message: OIDCSessionReply): unknown {
    const obj: any = {};
    if (message.result !== undefined) {
      obj.result = OIDCSession.toJSON(message.result);
    }
    return obj;
  },

  create(base?: DeepPartial<OIDCSessionReply>): OIDCSessionReply {
    return OIDCSessionReply.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<OIDCSessionReply>): OIDCSessionReply {
    const message = createBaseOIDCSessionReply();
    message.result = (object.result !== undefined && object.result !== null)
      ? OIDCSession.fromPartial(object.result)
      : undefined;
    return message;
  },
};

function createBaseValidateAuthenticationReq(): ValidateAuthenticationReq {
  return { apiRequestToValidate: undefined, signature: new Uint8Array(0) };
}

export const ValidateAuthenticationReq = {
  encode(message: ValidateAuthenticationReq, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.apiRequestToValidate !== undefined) {
      ApiRequestToValidate.encode(message.apiRequestToValidate, writer.uint32(10).fork()).ldelim();
    }
    if (message.signature.length !== 0) {
      writer.uint32(18).bytes(message.signature);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): ValidateAuthenticationReq {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseValidateAuthenticationReq();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.apiRequestToValidate = ApiRequestToValidate.decode(reader, reader.uint32());
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.signature = reader.bytes();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ValidateAuthenticationReq {
    return {
      apiRequestToValidate: isSet(object.apiRequestToValidate)
        ? ApiRequestToValidate.fromJSON(object.apiRequestToValidate)
        : undefined,
      signature: isSet(object.signature) ? bytesFromBase64(object.signature) : new Uint8Array(0),
    };
  },

  toJSON(message: ValidateAuthenticationReq): unknown {
    const obj: any = {};
    if (message.apiRequestToValidate !== undefined) {
      obj.apiRequestToValidate = ApiRequestToValidate.toJSON(message.apiRequestToValidate);
    }
    if (message.signature.length !== 0) {
      obj.signature = base64FromBytes(message.signature);
    }
    return obj;
  },

  create(base?: DeepPartial<ValidateAuthenticationReq>): ValidateAuthenticationReq {
    return ValidateAuthenticationReq.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ValidateAuthenticationReq>): ValidateAuthenticationReq {
    const message = createBaseValidateAuthenticationReq();
    message.apiRequestToValidate = (object.apiRequestToValidate !== undefined && object.apiRequestToValidate !== null)
      ? ApiRequestToValidate.fromPartial(object.apiRequestToValidate)
      : undefined;
    message.signature = object.signature ?? new Uint8Array(0);
    return message;
  },
};

function createBaseValidateAuthenticationReply(): ValidateAuthenticationReply {
  return { jwt: "" };
}

export const ValidateAuthenticationReply = {
  encode(message: ValidateAuthenticationReply, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.jwt !== "") {
      writer.uint32(10).string(message.jwt);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): ValidateAuthenticationReply {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseValidateAuthenticationReply();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.jwt = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ValidateAuthenticationReply {
    return { jwt: isSet(object.jwt) ? globalThis.String(object.jwt) : "" };
  },

  toJSON(message: ValidateAuthenticationReply): unknown {
    const obj: any = {};
    if (message.jwt !== "") {
      obj.jwt = message.jwt;
    }
    return obj;
  },

  create(base?: DeepPartial<ValidateAuthenticationReply>): ValidateAuthenticationReply {
    return ValidateAuthenticationReply.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ValidateAuthenticationReply>): ValidateAuthenticationReply {
    const message = createBaseValidateAuthenticationReply();
    message.jwt = object.jwt ?? "";
    return message;
  },
};

export interface AuthenticationService {
  Authenticate(request: Credentials): Promise<AuthenticationReply>;
  StartLogin(request: StartLoginRequest): Promise<StartLoginReply>;
  SAMLInitiate(request: SAMLInitiateRequest): Promise<SAMLInitiateReply>;
  SAMLCheckAssertion(request: SAMLCheckAssertionRequest): Promise<SAMLCheckAssertionReply>;
  SAMLSession(request: SAMLSessionRequest): Promise<SAMLSessionReply>;
  OIDCInitiate(request: OIDCInitiateRequest): Promise<OIDCInitiateReply>;
  OIDCSession(request: OIDCSessionRequest): Promise<OIDCSessionReply>;
  ValidateAuthentication(request: ValidateAuthenticationReq): Promise<ValidateAuthenticationReply>;
}

export const AuthenticationServiceServiceName = "tgvalidatord.AuthenticationService";
export class AuthenticationServiceClientImpl implements AuthenticationService {
  private readonly rpc: Rpc;
  private readonly service: string;
  constructor(rpc: Rpc, opts?: { service?: string }) {
    this.service = opts?.service || AuthenticationServiceServiceName;
    this.rpc = rpc;
    this.Authenticate = this.Authenticate.bind(this);
    this.StartLogin = this.StartLogin.bind(this);
    this.SAMLInitiate = this.SAMLInitiate.bind(this);
    this.SAMLCheckAssertion = this.SAMLCheckAssertion.bind(this);
    this.SAMLSession = this.SAMLSession.bind(this);
    this.OIDCInitiate = this.OIDCInitiate.bind(this);
    this.OIDCSession = this.OIDCSession.bind(this);
    this.ValidateAuthentication = this.ValidateAuthentication.bind(this);
  }
  Authenticate(request: Credentials): Promise<AuthenticationReply> {
    const data = Credentials.encode(request).finish();
    const promise = this.rpc.request(this.service, "Authenticate", data);
    return promise.then((data) => AuthenticationReply.decode(_m0.Reader.create(data)));
  }

  StartLogin(request: StartLoginRequest): Promise<StartLoginReply> {
    const data = StartLoginRequest.encode(request).finish();
    const promise = this.rpc.request(this.service, "StartLogin", data);
    return promise.then((data) => StartLoginReply.decode(_m0.Reader.create(data)));
  }

  SAMLInitiate(request: SAMLInitiateRequest): Promise<SAMLInitiateReply> {
    const data = SAMLInitiateRequest.encode(request).finish();
    const promise = this.rpc.request(this.service, "SAMLInitiate", data);
    return promise.then((data) => SAMLInitiateReply.decode(_m0.Reader.create(data)));
  }

  SAMLCheckAssertion(request: SAMLCheckAssertionRequest): Promise<SAMLCheckAssertionReply> {
    const data = SAMLCheckAssertionRequest.encode(request).finish();
    const promise = this.rpc.request(this.service, "SAMLCheckAssertion", data);
    return promise.then((data) => SAMLCheckAssertionReply.decode(_m0.Reader.create(data)));
  }

  SAMLSession(request: SAMLSessionRequest): Promise<SAMLSessionReply> {
    const data = SAMLSessionRequest.encode(request).finish();
    const promise = this.rpc.request(this.service, "SAMLSession", data);
    return promise.then((data) => SAMLSessionReply.decode(_m0.Reader.create(data)));
  }

  OIDCInitiate(request: OIDCInitiateRequest): Promise<OIDCInitiateReply> {
    const data = OIDCInitiateRequest.encode(request).finish();
    const promise = this.rpc.request(this.service, "OIDCInitiate", data);
    return promise.then((data) => OIDCInitiateReply.decode(_m0.Reader.create(data)));
  }

  OIDCSession(request: OIDCSessionRequest): Promise<OIDCSessionReply> {
    const data = OIDCSessionRequest.encode(request).finish();
    const promise = this.rpc.request(this.service, "OIDCSession", data);
    return promise.then((data) => OIDCSessionReply.decode(_m0.Reader.create(data)));
  }

  ValidateAuthentication(request: ValidateAuthenticationReq): Promise<ValidateAuthenticationReply> {
    const data = ValidateAuthenticationReq.encode(request).finish();
    const promise = this.rpc.request(this.service, "ValidateAuthentication", data);
    return promise.then((data) => ValidateAuthenticationReply.decode(_m0.Reader.create(data)));
  }
}

interface Rpc {
  request(service: string, method: string, data: Uint8Array): Promise<Uint8Array>;
}

function bytesFromBase64(b64: string): Uint8Array {
  const bin = globalThis.atob(b64);
  const arr = new Uint8Array(bin.length);
  for (let i = 0; i < bin.length; ++i) {
    arr[i] = bin.charCodeAt(i);
  }
  return arr;
}

function base64FromBytes(arr: Uint8Array): string {
  const bin: string[] = [];
  arr.forEach((byte) => {
    bin.push(globalThis.String.fromCharCode(byte));
  });
  return globalThis.btoa(bin.join(""));
}

type Builtin = Date | Function | Uint8Array | string | number | boolean | undefined;

export type DeepPartial<T> = T extends Builtin ? T
  : T extends globalThis.Array<infer U> ? globalThis.Array<DeepPartial<U>>
  : T extends ReadonlyArray<infer U> ? ReadonlyArray<DeepPartial<U>>
  : T extends {} ? { [K in keyof T]?: DeepPartial<T[K]> }
  : Partial<T>;

function isSet(value: any): boolean {
  return value !== null && value !== undefined;
}
