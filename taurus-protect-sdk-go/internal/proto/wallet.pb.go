// Code generated by protoc-gen-go. DO NOT EDIT.
// versions:
// 	protoc-gen-go v1.36.11
// 	protoc        v5.29.3
// source: wallet.proto

package proto

import (
	_ "github.com/grpc-ecosystem/grpc-gateway/v2/protoc-gen-openapiv2/options"
	protoreflect "google.golang.org/protobuf/reflect/protoreflect"
	protoimpl "google.golang.org/protobuf/runtime/protoimpl"
	timestamppb "google.golang.org/protobuf/types/known/timestamppb"
	reflect "reflect"
	sync "sync"
	unsafe "unsafe"
)

const (
	// Verify that this generated code is sufficiently up-to-date.
	_ = protoimpl.EnforceVersion(20 - protoimpl.MinVersion)
	// Verify that runtime/protoimpl is sufficiently up-to-date.
	_ = protoimpl.EnforceVersion(protoimpl.MaxVersion - 20)
)

type Asset_Kind int32

const (
	Asset__default_ Asset_Kind = 0
	Asset_Unknown   Asset_Kind = 1
	Asset_NFT       Asset_Kind = 2
)

// Enum value maps for Asset_Kind.
var (
	Asset_Kind_name = map[int32]string{
		0: "_default_",
		1: "Unknown",
		2: "NFT",
	}
	Asset_Kind_value = map[string]int32{
		"_default_": 0,
		"Unknown":   1,
		"NFT":       2,
	}
)

func (x Asset_Kind) Enum() *Asset_Kind {
	p := new(Asset_Kind)
	*p = x
	return p
}

func (x Asset_Kind) String() string {
	return protoimpl.X.EnumStringOf(x.Descriptor(), protoreflect.EnumNumber(x))
}

func (Asset_Kind) Descriptor() protoreflect.EnumDescriptor {
	return file_wallet_proto_enumTypes[0].Descriptor()
}

func (Asset_Kind) Type() protoreflect.EnumType {
	return &file_wallet_proto_enumTypes[0]
}

func (x Asset_Kind) Number() protoreflect.EnumNumber {
	return protoreflect.EnumNumber(x)
}

// Deprecated: Use Asset_Kind.Descriptor instead.
func (Asset_Kind) EnumDescriptor() ([]byte, []int) {
	return file_wallet_proto_rawDescGZIP(), []int{0, 0}
}

// _X because with grpc gateway 0 field of enum are not returned in JSON
//
//	can use "runtime.WithMarshalerOption(runtime.MIMEWildcard, &runtime.JSONPb{OrigName: true, EmitDefaults: true})"
//	but this will break other endpoints (e.g. without this option empty repeated message are display as null, with they are returned as empty array)
type ProofOfReserve_Curve int32

const (
	ProofOfReserve__curve    ProofOfReserve_Curve = 0
	ProofOfReserve_Secp256k1 ProofOfReserve_Curve = 1
	ProofOfReserve_Ed25519   ProofOfReserve_Curve = 2
	ProofOfReserve_Secp256r1 ProofOfReserve_Curve = 3
	ProofOfReserve_Pallas    ProofOfReserve_Curve = 4
)

// Enum value maps for ProofOfReserve_Curve.
var (
	ProofOfReserve_Curve_name = map[int32]string{
		0: "_curve",
		1: "Secp256k1",
		2: "Ed25519",
		3: "Secp256r1",
		4: "Pallas",
	}
	ProofOfReserve_Curve_value = map[string]int32{
		"_curve":    0,
		"Secp256k1": 1,
		"Ed25519":   2,
		"Secp256r1": 3,
		"Pallas":    4,
	}
)

func (x ProofOfReserve_Curve) Enum() *ProofOfReserve_Curve {
	p := new(ProofOfReserve_Curve)
	*p = x
	return p
}

func (x ProofOfReserve_Curve) String() string {
	return protoimpl.X.EnumStringOf(x.Descriptor(), protoreflect.EnumNumber(x))
}

func (ProofOfReserve_Curve) Descriptor() protoreflect.EnumDescriptor {
	return file_wallet_proto_enumTypes[1].Descriptor()
}

func (ProofOfReserve_Curve) Type() protoreflect.EnumType {
	return &file_wallet_proto_enumTypes[1]
}

func (x ProofOfReserve_Curve) Number() protoreflect.EnumNumber {
	return protoreflect.EnumNumber(x)
}

// Deprecated: Use ProofOfReserve_Curve.Descriptor instead.
func (ProofOfReserve_Curve) EnumDescriptor() ([]byte, []int) {
	return file_wallet_proto_rawDescGZIP(), []int{11, 0}
}

type ProofOfReserve_Cipher int32

const (
	ProofOfReserve__cipher      ProofOfReserve_Cipher = 0
	ProofOfReserve_ECDSA_SHA256 ProofOfReserve_Cipher = 1
	ProofOfReserve_ECDSA_SHA512 ProofOfReserve_Cipher = 2
	ProofOfReserve_EDDSA        ProofOfReserve_Cipher = 3
	ProofOfReserve_Schnorr      ProofOfReserve_Cipher = 4
)

// Enum value maps for ProofOfReserve_Cipher.
var (
	ProofOfReserve_Cipher_name = map[int32]string{
		0: "_cipher",
		1: "ECDSA_SHA256",
		2: "ECDSA_SHA512",
		3: "EDDSA",
		4: "Schnorr",
	}
	ProofOfReserve_Cipher_value = map[string]int32{
		"_cipher":      0,
		"ECDSA_SHA256": 1,
		"ECDSA_SHA512": 2,
		"EDDSA":        3,
		"Schnorr":      4,
	}
)

func (x ProofOfReserve_Cipher) Enum() *ProofOfReserve_Cipher {
	p := new(ProofOfReserve_Cipher)
	*p = x
	return p
}

func (x ProofOfReserve_Cipher) String() string {
	return protoimpl.X.EnumStringOf(x.Descriptor(), protoreflect.EnumNumber(x))
}

func (ProofOfReserve_Cipher) Descriptor() protoreflect.EnumDescriptor {
	return file_wallet_proto_enumTypes[2].Descriptor()
}

func (ProofOfReserve_Cipher) Type() protoreflect.EnumType {
	return &file_wallet_proto_enumTypes[2]
}

func (x ProofOfReserve_Cipher) Number() protoreflect.EnumNumber {
	return protoreflect.EnumNumber(x)
}

// Deprecated: Use ProofOfReserve_Cipher.Descriptor instead.
func (ProofOfReserve_Cipher) EnumDescriptor() ([]byte, []int) {
	return file_wallet_proto_rawDescGZIP(), []int{11, 1}
}

type ProofOfReserve_ReserveType int32

const (
	ProofOfReserve_Generic ProofOfReserve_ReserveType = 0
	ProofOfReserve_ADA     ProofOfReserve_ReserveType = 1
)

// Enum value maps for ProofOfReserve_ReserveType.
var (
	ProofOfReserve_ReserveType_name = map[int32]string{
		0: "Generic",
		1: "ADA",
	}
	ProofOfReserve_ReserveType_value = map[string]int32{
		"Generic": 0,
		"ADA":     1,
	}
)

func (x ProofOfReserve_ReserveType) Enum() *ProofOfReserve_ReserveType {
	p := new(ProofOfReserve_ReserveType)
	*p = x
	return p
}

func (x ProofOfReserve_ReserveType) String() string {
	return protoimpl.X.EnumStringOf(x.Descriptor(), protoreflect.EnumNumber(x))
}

func (ProofOfReserve_ReserveType) Descriptor() protoreflect.EnumDescriptor {
	return file_wallet_proto_enumTypes[3].Descriptor()
}

func (ProofOfReserve_ReserveType) Type() protoreflect.EnumType {
	return &file_wallet_proto_enumTypes[3]
}

func (x ProofOfReserve_ReserveType) Number() protoreflect.EnumNumber {
	return protoreflect.EnumNumber(x)
}

// Deprecated: Use ProofOfReserve_ReserveType.Descriptor instead.
func (ProofOfReserve_ReserveType) EnumDescriptor() ([]byte, []int) {
	return file_wallet_proto_rawDescGZIP(), []int{11, 2}
}

type Asset struct {
	state         protoimpl.MessageState `protogen:"open.v1"`
	Currency      string                 `protobuf:"bytes,1,opt,name=currency,proto3" json:"currency,omitempty"`
	Kind          string                 `protobuf:"bytes,2,opt,name=kind,proto3" json:"kind,omitempty"`
	Nft           *Asset_XNFT            `protobuf:"bytes,3,opt,name=nft,proto3" json:"nft,omitempty"`
	Unknown       *Asset_XUnknown        `protobuf:"bytes,4,opt,name=unknown,proto3" json:"unknown,omitempty"`
	CurrencyInfo  *Currency              `protobuf:"bytes,5,opt,name=currencyInfo,proto3" json:"currencyInfo,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *Asset) Reset() {
	*x = Asset{}
	mi := &file_wallet_proto_msgTypes[0]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *Asset) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*Asset) ProtoMessage() {}

func (x *Asset) ProtoReflect() protoreflect.Message {
	mi := &file_wallet_proto_msgTypes[0]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use Asset.ProtoReflect.Descriptor instead.
func (*Asset) Descriptor() ([]byte, []int) {
	return file_wallet_proto_rawDescGZIP(), []int{0}
}

func (x *Asset) GetCurrency() string {
	if x != nil {
		return x.Currency
	}
	return ""
}

func (x *Asset) GetKind() string {
	if x != nil {
		return x.Kind
	}
	return ""
}

func (x *Asset) GetNft() *Asset_XNFT {
	if x != nil {
		return x.Nft
	}
	return nil
}

func (x *Asset) GetUnknown() *Asset_XUnknown {
	if x != nil {
		return x.Unknown
	}
	return nil
}

func (x *Asset) GetCurrencyInfo() *Currency {
	if x != nil {
		return x.CurrencyInfo
	}
	return nil
}

type AssetBalance struct {
	state         protoimpl.MessageState `protogen:"open.v1"`
	Asset         *Asset                 `protobuf:"bytes,1,opt,name=asset,proto3" json:"asset,omitempty"`
	Balance       *Balance               `protobuf:"bytes,2,opt,name=balance,proto3" json:"balance,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *AssetBalance) Reset() {
	*x = AssetBalance{}
	mi := &file_wallet_proto_msgTypes[1]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *AssetBalance) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*AssetBalance) ProtoMessage() {}

func (x *AssetBalance) ProtoReflect() protoreflect.Message {
	mi := &file_wallet_proto_msgTypes[1]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use AssetBalance.ProtoReflect.Descriptor instead.
func (*AssetBalance) Descriptor() ([]byte, []int) {
	return file_wallet_proto_rawDescGZIP(), []int{1}
}

func (x *AssetBalance) GetAsset() *Asset {
	if x != nil {
		return x.Asset
	}
	return nil
}

func (x *AssetBalance) GetBalance() *Balance {
	if x != nil {
		return x.Balance
	}
	return nil
}

type NFTCollectionBalance struct {
	state         protoimpl.MessageState `protogen:"open.v1"`
	CurrencyInfo  *Currency              `protobuf:"bytes,1,opt,name=currencyInfo,proto3" json:"currencyInfo,omitempty"`
	Balance       *Balance               `protobuf:"bytes,2,opt,name=balance,proto3" json:"balance,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *NFTCollectionBalance) Reset() {
	*x = NFTCollectionBalance{}
	mi := &file_wallet_proto_msgTypes[2]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *NFTCollectionBalance) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*NFTCollectionBalance) ProtoMessage() {}

func (x *NFTCollectionBalance) ProtoReflect() protoreflect.Message {
	mi := &file_wallet_proto_msgTypes[2]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use NFTCollectionBalance.ProtoReflect.Descriptor instead.
func (*NFTCollectionBalance) Descriptor() ([]byte, []int) {
	return file_wallet_proto_rawDescGZIP(), []int{2}
}

func (x *NFTCollectionBalance) GetCurrencyInfo() *Currency {
	if x != nil {
		return x.CurrencyInfo
	}
	return nil
}

func (x *NFTCollectionBalance) GetBalance() *Balance {
	if x != nil {
		return x.Balance
	}
	return nil
}

type Balance struct {
	state                protoimpl.MessageState `protogen:"open.v1"`
	TotalConfirmed       string                 `protobuf:"bytes,1,opt,name=totalConfirmed,proto3" json:"totalConfirmed,omitempty"`
	TotalUnconfirmed     string                 `protobuf:"bytes,2,opt,name=totalUnconfirmed,proto3" json:"totalUnconfirmed,omitempty"`
	AvailableConfirmed   string                 `protobuf:"bytes,3,opt,name=availableConfirmed,proto3" json:"availableConfirmed,omitempty"`
	AvailableUnconfirmed string                 `protobuf:"bytes,4,opt,name=availableUnconfirmed,proto3" json:"availableUnconfirmed,omitempty"`
	ReservedConfirmed    string                 `protobuf:"bytes,5,opt,name=reservedConfirmed,proto3" json:"reservedConfirmed,omitempty"`
	ReservedUnconfirmed  string                 `protobuf:"bytes,6,opt,name=reservedUnconfirmed,proto3" json:"reservedUnconfirmed,omitempty"`
	unknownFields        protoimpl.UnknownFields
	sizeCache            protoimpl.SizeCache
}

func (x *Balance) Reset() {
	*x = Balance{}
	mi := &file_wallet_proto_msgTypes[3]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *Balance) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*Balance) ProtoMessage() {}

func (x *Balance) ProtoReflect() protoreflect.Message {
	mi := &file_wallet_proto_msgTypes[3]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use Balance.ProtoReflect.Descriptor instead.
func (*Balance) Descriptor() ([]byte, []int) {
	return file_wallet_proto_rawDescGZIP(), []int{3}
}

func (x *Balance) GetTotalConfirmed() string {
	if x != nil {
		return x.TotalConfirmed
	}
	return ""
}

func (x *Balance) GetTotalUnconfirmed() string {
	if x != nil {
		return x.TotalUnconfirmed
	}
	return ""
}

func (x *Balance) GetAvailableConfirmed() string {
	if x != nil {
		return x.AvailableConfirmed
	}
	return ""
}

func (x *Balance) GetAvailableUnconfirmed() string {
	if x != nil {
		return x.AvailableUnconfirmed
	}
	return ""
}

func (x *Balance) GetReservedConfirmed() string {
	if x != nil {
		return x.ReservedConfirmed
	}
	return ""
}

func (x *Balance) GetReservedUnconfirmed() string {
	if x != nil {
		return x.ReservedUnconfirmed
	}
	return ""
}

type BalanceHistoryPoint struct {
	state         protoimpl.MessageState `protogen:"open.v1"`
	PointDate     *timestamppb.Timestamp `protobuf:"bytes,1,opt,name=pointDate,proto3" json:"pointDate,omitempty"`
	Balance       *Balance               `protobuf:"bytes,2,opt,name=balance,proto3" json:"balance,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *BalanceHistoryPoint) Reset() {
	*x = BalanceHistoryPoint{}
	mi := &file_wallet_proto_msgTypes[4]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *BalanceHistoryPoint) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*BalanceHistoryPoint) ProtoMessage() {}

func (x *BalanceHistoryPoint) ProtoReflect() protoreflect.Message {
	mi := &file_wallet_proto_msgTypes[4]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use BalanceHistoryPoint.ProtoReflect.Descriptor instead.
func (*BalanceHistoryPoint) Descriptor() ([]byte, []int) {
	return file_wallet_proto_rawDescGZIP(), []int{4}
}

func (x *BalanceHistoryPoint) GetPointDate() *timestamppb.Timestamp {
	if x != nil {
		return x.PointDate
	}
	return nil
}

func (x *BalanceHistoryPoint) GetBalance() *Balance {
	if x != nil {
		return x.Balance
	}
	return nil
}

// Deprecated: Wallets can have thousands of addresses. It is not a good idea to serialize a wallet with all its addresses.
// Generally, WalletInfo should be used instead
type Wallet struct {
	state            protoimpl.MessageState `protogen:"open.v1"`
	Id               uint64                 `protobuf:"varint,1,opt,name=id,proto3" json:"id,omitempty"`
	Balance          *Balance               `protobuf:"bytes,2,opt,name=balance,proto3" json:"balance,omitempty"`
	Currency         string                 `protobuf:"bytes,3,opt,name=currency,proto3" json:"currency,omitempty"`
	Coin             string                 `protobuf:"bytes,4,opt,name=coin,proto3" json:"coin,omitempty"`
	Name             string                 `protobuf:"bytes,5,opt,name=name,proto3" json:"name,omitempty"`
	Container        string                 `protobuf:"bytes,6,opt,name=container,proto3" json:"container,omitempty"`
	Seed             string                 `protobuf:"bytes,7,opt,name=seed,proto3" json:"seed,omitempty"`
	AccountPath      string                 `protobuf:"bytes,8,opt,name=accountPath,proto3" json:"accountPath,omitempty"`
	Addresses        []*Address             `protobuf:"bytes,9,rep,name=addresses,proto3" json:"addresses,omitempty"`
	IsOmnibus        bool                   `protobuf:"varint,10,opt,name=isOmnibus,proto3" json:"isOmnibus,omitempty"`
	CreationDate     *timestamppb.Timestamp `protobuf:"bytes,11,opt,name=creationDate,proto3" json:"creationDate,omitempty"`
	UpdateDate       *timestamppb.Timestamp `protobuf:"bytes,12,opt,name=updateDate,proto3" json:"updateDate,omitempty"`
	CustomerId       string                 `protobuf:"bytes,13,opt,name=customerId,proto3" json:"customerId,omitempty"`
	Comment          string                 `protobuf:"bytes,14,opt,name=comment,proto3" json:"comment,omitempty"`
	Disabled         bool                   `protobuf:"varint,15,opt,name=disabled,proto3" json:"disabled,omitempty"`
	Blockchain       string                 `protobuf:"bytes,16,opt,name=blockchain,proto3" json:"blockchain,omitempty"`
	AddressesCount   uint64                 `protobuf:"varint,17,opt,name=addressesCount,proto3" json:"addressesCount,omitempty"`
	Attributes       []*WalletAttribute     `protobuf:"bytes,18,rep,name=attributes,proto3" json:"attributes,omitempty"`
	CurrencyInfo     *Currency              `protobuf:"bytes,19,opt,name=currencyInfo,proto3" json:"currencyInfo,omitempty"`
	ExternalWalletId string                 `protobuf:"bytes,20,opt,name=externalWalletId,proto3" json:"externalWalletId,omitempty"`
	unknownFields    protoimpl.UnknownFields
	sizeCache        protoimpl.SizeCache
}

func (x *Wallet) Reset() {
	*x = Wallet{}
	mi := &file_wallet_proto_msgTypes[5]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *Wallet) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*Wallet) ProtoMessage() {}

func (x *Wallet) ProtoReflect() protoreflect.Message {
	mi := &file_wallet_proto_msgTypes[5]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use Wallet.ProtoReflect.Descriptor instead.
func (*Wallet) Descriptor() ([]byte, []int) {
	return file_wallet_proto_rawDescGZIP(), []int{5}
}

func (x *Wallet) GetId() uint64 {
	if x != nil {
		return x.Id
	}
	return 0
}

func (x *Wallet) GetBalance() *Balance {
	if x != nil {
		return x.Balance
	}
	return nil
}

func (x *Wallet) GetCurrency() string {
	if x != nil {
		return x.Currency
	}
	return ""
}

func (x *Wallet) GetCoin() string {
	if x != nil {
		return x.Coin
	}
	return ""
}

func (x *Wallet) GetName() string {
	if x != nil {
		return x.Name
	}
	return ""
}

func (x *Wallet) GetContainer() string {
	if x != nil {
		return x.Container
	}
	return ""
}

func (x *Wallet) GetSeed() string {
	if x != nil {
		return x.Seed
	}
	return ""
}

func (x *Wallet) GetAccountPath() string {
	if x != nil {
		return x.AccountPath
	}
	return ""
}

func (x *Wallet) GetAddresses() []*Address {
	if x != nil {
		return x.Addresses
	}
	return nil
}

func (x *Wallet) GetIsOmnibus() bool {
	if x != nil {
		return x.IsOmnibus
	}
	return false
}

func (x *Wallet) GetCreationDate() *timestamppb.Timestamp {
	if x != nil {
		return x.CreationDate
	}
	return nil
}

func (x *Wallet) GetUpdateDate() *timestamppb.Timestamp {
	if x != nil {
		return x.UpdateDate
	}
	return nil
}

func (x *Wallet) GetCustomerId() string {
	if x != nil {
		return x.CustomerId
	}
	return ""
}

func (x *Wallet) GetComment() string {
	if x != nil {
		return x.Comment
	}
	return ""
}

func (x *Wallet) GetDisabled() bool {
	if x != nil {
		return x.Disabled
	}
	return false
}

func (x *Wallet) GetBlockchain() string {
	if x != nil {
		return x.Blockchain
	}
	return ""
}

func (x *Wallet) GetAddressesCount() uint64 {
	if x != nil {
		return x.AddressesCount
	}
	return 0
}

func (x *Wallet) GetAttributes() []*WalletAttribute {
	if x != nil {
		return x.Attributes
	}
	return nil
}

func (x *Wallet) GetCurrencyInfo() *Currency {
	if x != nil {
		return x.CurrencyInfo
	}
	return nil
}

func (x *Wallet) GetExternalWalletId() string {
	if x != nil {
		return x.ExternalWalletId
	}
	return ""
}

type WalletAttribute struct {
	state         protoimpl.MessageState `protogen:"open.v1"`
	Key           string                 `protobuf:"bytes,1,opt,name=key,proto3" json:"key,omitempty"`
	Value         string                 `protobuf:"bytes,2,opt,name=value,proto3" json:"value,omitempty"`
	Id            uint64                 `protobuf:"varint,3,opt,name=id,proto3" json:"id,omitempty"`
	ContentType   string                 `protobuf:"bytes,4,opt,name=contentType,proto3" json:"contentType,omitempty"`
	Owner         string                 `protobuf:"bytes,5,opt,name=owner,proto3" json:"owner,omitempty"`
	Type          string                 `protobuf:"bytes,6,opt,name=type,proto3" json:"type,omitempty"`
	Subtype       string                 `protobuf:"bytes,7,opt,name=subtype,proto3" json:"subtype,omitempty"`
	Isfile        bool                   `protobuf:"varint,8,opt,name=isfile,proto3" json:"isfile,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *WalletAttribute) Reset() {
	*x = WalletAttribute{}
	mi := &file_wallet_proto_msgTypes[6]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *WalletAttribute) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*WalletAttribute) ProtoMessage() {}

func (x *WalletAttribute) ProtoReflect() protoreflect.Message {
	mi := &file_wallet_proto_msgTypes[6]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use WalletAttribute.ProtoReflect.Descriptor instead.
func (*WalletAttribute) Descriptor() ([]byte, []int) {
	return file_wallet_proto_rawDescGZIP(), []int{6}
}

func (x *WalletAttribute) GetKey() string {
	if x != nil {
		return x.Key
	}
	return ""
}

func (x *WalletAttribute) GetValue() string {
	if x != nil {
		return x.Value
	}
	return ""
}

func (x *WalletAttribute) GetId() uint64 {
	if x != nil {
		return x.Id
	}
	return 0
}

func (x *WalletAttribute) GetContentType() string {
	if x != nil {
		return x.ContentType
	}
	return ""
}

func (x *WalletAttribute) GetOwner() string {
	if x != nil {
		return x.Owner
	}
	return ""
}

func (x *WalletAttribute) GetType() string {
	if x != nil {
		return x.Type
	}
	return ""
}

func (x *WalletAttribute) GetSubtype() string {
	if x != nil {
		return x.Subtype
	}
	return ""
}

func (x *WalletAttribute) GetIsfile() bool {
	if x != nil {
		return x.Isfile
	}
	return false
}

type WalletInfo struct {
	state             protoimpl.MessageState `protogen:"open.v1"`
	Id                uint64                 `protobuf:"varint,1,opt,name=id,proto3" json:"id,omitempty"`
	Balance           *Balance               `protobuf:"bytes,2,opt,name=balance,proto3" json:"balance,omitempty"`
	Currency          string                 `protobuf:"bytes,3,opt,name=currency,proto3" json:"currency,omitempty"`
	Coin              string                 `protobuf:"bytes,4,opt,name=coin,proto3" json:"coin,omitempty"`
	Name              string                 `protobuf:"bytes,5,opt,name=name,proto3" json:"name,omitempty"`
	Container         string                 `protobuf:"bytes,6,opt,name=container,proto3" json:"container,omitempty"`
	Seed              string                 `protobuf:"bytes,7,opt,name=seed,proto3" json:"seed,omitempty"`
	AccountPath       string                 `protobuf:"bytes,8,opt,name=accountPath,proto3" json:"accountPath,omitempty"`
	IsOmnibus         bool                   `protobuf:"varint,9,opt,name=isOmnibus,proto3" json:"isOmnibus,omitempty"`
	CreationDate      *timestamppb.Timestamp `protobuf:"bytes,10,opt,name=creationDate,proto3" json:"creationDate,omitempty"`
	UpdateDate        *timestamppb.Timestamp `protobuf:"bytes,11,opt,name=updateDate,proto3" json:"updateDate,omitempty"`
	CustomerId        string                 `protobuf:"bytes,12,opt,name=customerId,proto3" json:"customerId,omitempty"`
	Comment           string                 `protobuf:"bytes,13,opt,name=comment,proto3" json:"comment,omitempty"`
	Disabled          bool                   `protobuf:"varint,14,opt,name=disabled,proto3" json:"disabled,omitempty"`
	Blockchain        string                 `protobuf:"bytes,15,opt,name=blockchain,proto3" json:"blockchain,omitempty"`
	AddressesCount    uint64                 `protobuf:"varint,16,opt,name=addressesCount,proto3" json:"addressesCount,omitempty"`
	CurrencyInfo      *Currency              `protobuf:"bytes,17,opt,name=currencyInfo,proto3" json:"currencyInfo,omitempty"`
	Attributes        []*WalletAttribute     `protobuf:"bytes,18,rep,name=attributes,proto3" json:"attributes,omitempty"`
	Network           string                 `protobuf:"bytes,19,opt,name=network,proto3" json:"network,omitempty"`
	VisibilityGroupID string                 `protobuf:"bytes,20,opt,name=visibilityGroupID,proto3" json:"visibilityGroupID,omitempty"`
	ExternalWalletId  string                 `protobuf:"bytes,21,opt,name=externalWalletId,proto3" json:"externalWalletId,omitempty"`
	unknownFields     protoimpl.UnknownFields
	sizeCache         protoimpl.SizeCache
}

func (x *WalletInfo) Reset() {
	*x = WalletInfo{}
	mi := &file_wallet_proto_msgTypes[7]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *WalletInfo) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*WalletInfo) ProtoMessage() {}

func (x *WalletInfo) ProtoReflect() protoreflect.Message {
	mi := &file_wallet_proto_msgTypes[7]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use WalletInfo.ProtoReflect.Descriptor instead.
func (*WalletInfo) Descriptor() ([]byte, []int) {
	return file_wallet_proto_rawDescGZIP(), []int{7}
}

func (x *WalletInfo) GetId() uint64 {
	if x != nil {
		return x.Id
	}
	return 0
}

func (x *WalletInfo) GetBalance() *Balance {
	if x != nil {
		return x.Balance
	}
	return nil
}

func (x *WalletInfo) GetCurrency() string {
	if x != nil {
		return x.Currency
	}
	return ""
}

func (x *WalletInfo) GetCoin() string {
	if x != nil {
		return x.Coin
	}
	return ""
}

func (x *WalletInfo) GetName() string {
	if x != nil {
		return x.Name
	}
	return ""
}

func (x *WalletInfo) GetContainer() string {
	if x != nil {
		return x.Container
	}
	return ""
}

func (x *WalletInfo) GetSeed() string {
	if x != nil {
		return x.Seed
	}
	return ""
}

func (x *WalletInfo) GetAccountPath() string {
	if x != nil {
		return x.AccountPath
	}
	return ""
}

func (x *WalletInfo) GetIsOmnibus() bool {
	if x != nil {
		return x.IsOmnibus
	}
	return false
}

func (x *WalletInfo) GetCreationDate() *timestamppb.Timestamp {
	if x != nil {
		return x.CreationDate
	}
	return nil
}

func (x *WalletInfo) GetUpdateDate() *timestamppb.Timestamp {
	if x != nil {
		return x.UpdateDate
	}
	return nil
}

func (x *WalletInfo) GetCustomerId() string {
	if x != nil {
		return x.CustomerId
	}
	return ""
}

func (x *WalletInfo) GetComment() string {
	if x != nil {
		return x.Comment
	}
	return ""
}

func (x *WalletInfo) GetDisabled() bool {
	if x != nil {
		return x.Disabled
	}
	return false
}

func (x *WalletInfo) GetBlockchain() string {
	if x != nil {
		return x.Blockchain
	}
	return ""
}

func (x *WalletInfo) GetAddressesCount() uint64 {
	if x != nil {
		return x.AddressesCount
	}
	return 0
}

func (x *WalletInfo) GetCurrencyInfo() *Currency {
	if x != nil {
		return x.CurrencyInfo
	}
	return nil
}

func (x *WalletInfo) GetAttributes() []*WalletAttribute {
	if x != nil {
		return x.Attributes
	}
	return nil
}

func (x *WalletInfo) GetNetwork() string {
	if x != nil {
		return x.Network
	}
	return ""
}

func (x *WalletInfo) GetVisibilityGroupID() string {
	if x != nil {
		return x.VisibilityGroupID
	}
	return ""
}

func (x *WalletInfo) GetExternalWalletId() string {
	if x != nil {
		return x.ExternalWalletId
	}
	return ""
}

type Address struct {
	state                       protoimpl.MessageState `protogen:"open.v1"`
	Id                          uint64                 `protobuf:"varint,1,opt,name=id,proto3" json:"id,omitempty"`
	WalletId                    uint64                 `protobuf:"varint,2,opt,name=walletId,proto3" json:"walletId,omitempty"`
	Seed                        string                 `protobuf:"bytes,3,opt,name=seed,proto3" json:"seed,omitempty"`
	Currency                    string                 `protobuf:"bytes,4,opt,name=currency,proto3" json:"currency,omitempty"`
	AddressPath                 string                 `protobuf:"bytes,5,opt,name=addressPath,proto3" json:"addressPath,omitempty"`
	AddressIndex                uint64                 `protobuf:"varint,6,opt,name=addressIndex,proto3" json:"addressIndex,omitempty"`
	Address                     string                 `protobuf:"bytes,7,opt,name=address,proto3" json:"address,omitempty"`
	AlternateAddress            string                 `protobuf:"bytes,8,opt,name=alternateAddress,proto3" json:"alternateAddress,omitempty"`
	Comment                     string                 `protobuf:"bytes,9,opt,name=comment,proto3" json:"comment,omitempty"`
	Label                       string                 `protobuf:"bytes,10,opt,name=label,proto3" json:"label,omitempty"`
	CustomerId                  string                 `protobuf:"bytes,11,opt,name=customerId,proto3" json:"customerId,omitempty"`
	Nonce                       uint64                 `protobuf:"varint,12,opt,name=nonce,proto3" json:"nonce,omitempty"`
	Balance                     *Balance               `protobuf:"bytes,13,opt,name=balance,proto3" json:"balance,omitempty"`
	Signature                   string                 `protobuf:"bytes,14,opt,name=signature,proto3" json:"signature,omitempty"`
	Scores                      []*Score               `protobuf:"bytes,15,rep,name=scores,proto3" json:"scores,omitempty"`
	Attributes                  []*AddressAttribute    `protobuf:"bytes,16,rep,name=attributes,proto3" json:"attributes,omitempty"`
	LinkedWhitelistedAddressIds []uint64               `protobuf:"varint,17,rep,packed,name=linkedWhitelistedAddressIds,proto3" json:"linkedWhitelistedAddressIds,omitempty"`
	CreationDate                *timestamppb.Timestamp `protobuf:"bytes,18,opt,name=creationDate,proto3" json:"creationDate,omitempty"`
	UpdateDate                  *timestamppb.Timestamp `protobuf:"bytes,19,opt,name=updateDate,proto3" json:"updateDate,omitempty"`
	WalletInfo                  *WalletInfo            `protobuf:"bytes,20,opt,name=walletInfo,proto3" json:"walletInfo,omitempty"`
	Disabled                    bool                   `protobuf:"varint,21,opt,name=disabled,proto3" json:"disabled,omitempty"`
	CurrencyInfo                *Currency              `protobuf:"bytes,22,opt,name=currencyInfo,proto3" json:"currencyInfo,omitempty"`
	CanUseAllFunds              bool                   `protobuf:"varint,23,opt,name=canUseAllFunds,proto3" json:"canUseAllFunds,omitempty"`
	ExternalAddressId           string                 `protobuf:"bytes,24,opt,name=externalAddressId,proto3" json:"externalAddressId,omitempty"`
	Status                      string                 `protobuf:"bytes,25,opt,name=status,proto3" json:"status,omitempty"`
	unknownFields               protoimpl.UnknownFields
	sizeCache                   protoimpl.SizeCache
}

func (x *Address) Reset() {
	*x = Address{}
	mi := &file_wallet_proto_msgTypes[8]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *Address) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*Address) ProtoMessage() {}

func (x *Address) ProtoReflect() protoreflect.Message {
	mi := &file_wallet_proto_msgTypes[8]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use Address.ProtoReflect.Descriptor instead.
func (*Address) Descriptor() ([]byte, []int) {
	return file_wallet_proto_rawDescGZIP(), []int{8}
}

func (x *Address) GetId() uint64 {
	if x != nil {
		return x.Id
	}
	return 0
}

func (x *Address) GetWalletId() uint64 {
	if x != nil {
		return x.WalletId
	}
	return 0
}

func (x *Address) GetSeed() string {
	if x != nil {
		return x.Seed
	}
	return ""
}

func (x *Address) GetCurrency() string {
	if x != nil {
		return x.Currency
	}
	return ""
}

func (x *Address) GetAddressPath() string {
	if x != nil {
		return x.AddressPath
	}
	return ""
}

func (x *Address) GetAddressIndex() uint64 {
	if x != nil {
		return x.AddressIndex
	}
	return 0
}

func (x *Address) GetAddress() string {
	if x != nil {
		return x.Address
	}
	return ""
}

func (x *Address) GetAlternateAddress() string {
	if x != nil {
		return x.AlternateAddress
	}
	return ""
}

func (x *Address) GetComment() string {
	if x != nil {
		return x.Comment
	}
	return ""
}

func (x *Address) GetLabel() string {
	if x != nil {
		return x.Label
	}
	return ""
}

func (x *Address) GetCustomerId() string {
	if x != nil {
		return x.CustomerId
	}
	return ""
}

func (x *Address) GetNonce() uint64 {
	if x != nil {
		return x.Nonce
	}
	return 0
}

func (x *Address) GetBalance() *Balance {
	if x != nil {
		return x.Balance
	}
	return nil
}

func (x *Address) GetSignature() string {
	if x != nil {
		return x.Signature
	}
	return ""
}

func (x *Address) GetScores() []*Score {
	if x != nil {
		return x.Scores
	}
	return nil
}

func (x *Address) GetAttributes() []*AddressAttribute {
	if x != nil {
		return x.Attributes
	}
	return nil
}

func (x *Address) GetLinkedWhitelistedAddressIds() []uint64 {
	if x != nil {
		return x.LinkedWhitelistedAddressIds
	}
	return nil
}

func (x *Address) GetCreationDate() *timestamppb.Timestamp {
	if x != nil {
		return x.CreationDate
	}
	return nil
}

func (x *Address) GetUpdateDate() *timestamppb.Timestamp {
	if x != nil {
		return x.UpdateDate
	}
	return nil
}

func (x *Address) GetWalletInfo() *WalletInfo {
	if x != nil {
		return x.WalletInfo
	}
	return nil
}

func (x *Address) GetDisabled() bool {
	if x != nil {
		return x.Disabled
	}
	return false
}

func (x *Address) GetCurrencyInfo() *Currency {
	if x != nil {
		return x.CurrencyInfo
	}
	return nil
}

func (x *Address) GetCanUseAllFunds() bool {
	if x != nil {
		return x.CanUseAllFunds
	}
	return false
}

func (x *Address) GetExternalAddressId() string {
	if x != nil {
		return x.ExternalAddressId
	}
	return ""
}

func (x *Address) GetStatus() string {
	if x != nil {
		return x.Status
	}
	return ""
}

type AddressAttribute struct {
	state         protoimpl.MessageState `protogen:"open.v1"`
	Key           string                 `protobuf:"bytes,1,opt,name=key,proto3" json:"key,omitempty"`
	Value         string                 `protobuf:"bytes,2,opt,name=value,proto3" json:"value,omitempty"`
	Id            uint64                 `protobuf:"varint,3,opt,name=id,proto3" json:"id,omitempty"`
	ContentType   string                 `protobuf:"bytes,4,opt,name=contentType,proto3" json:"contentType,omitempty"`
	Owner         string                 `protobuf:"bytes,5,opt,name=owner,proto3" json:"owner,omitempty"`
	Type          string                 `protobuf:"bytes,6,opt,name=type,proto3" json:"type,omitempty"`
	Subtype       string                 `protobuf:"bytes,7,opt,name=subtype,proto3" json:"subtype,omitempty"`
	Isfile        bool                   `protobuf:"varint,8,opt,name=isfile,proto3" json:"isfile,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *AddressAttribute) Reset() {
	*x = AddressAttribute{}
	mi := &file_wallet_proto_msgTypes[9]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *AddressAttribute) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*AddressAttribute) ProtoMessage() {}

func (x *AddressAttribute) ProtoReflect() protoreflect.Message {
	mi := &file_wallet_proto_msgTypes[9]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use AddressAttribute.ProtoReflect.Descriptor instead.
func (*AddressAttribute) Descriptor() ([]byte, []int) {
	return file_wallet_proto_rawDescGZIP(), []int{9}
}

func (x *AddressAttribute) GetKey() string {
	if x != nil {
		return x.Key
	}
	return ""
}

func (x *AddressAttribute) GetValue() string {
	if x != nil {
		return x.Value
	}
	return ""
}

func (x *AddressAttribute) GetId() uint64 {
	if x != nil {
		return x.Id
	}
	return 0
}

func (x *AddressAttribute) GetContentType() string {
	if x != nil {
		return x.ContentType
	}
	return ""
}

func (x *AddressAttribute) GetOwner() string {
	if x != nil {
		return x.Owner
	}
	return ""
}

func (x *AddressAttribute) GetType() string {
	if x != nil {
		return x.Type
	}
	return ""
}

func (x *AddressAttribute) GetSubtype() string {
	if x != nil {
		return x.Subtype
	}
	return ""
}

func (x *AddressAttribute) GetIsfile() bool {
	if x != nil {
		return x.Isfile
	}
	return false
}

type UTXO struct {
	state               protoimpl.MessageState `protogen:"open.v1"`
	Id                  uint64                 `protobuf:"varint,1,opt,name=id,proto3" json:"id,omitempty"`
	Hash                string                 `protobuf:"bytes,2,opt,name=hash,proto3" json:"hash,omitempty"`
	OutputIndex         uint32                 `protobuf:"varint,3,opt,name=outputIndex,proto3" json:"outputIndex,omitempty"`
	Script              string                 `protobuf:"bytes,4,opt,name=script,proto3" json:"script,omitempty"`
	Value               uint64                 `protobuf:"varint,5,opt,name=value,proto3" json:"value,omitempty"`
	BlockHeight         uint64                 `protobuf:"varint,6,opt,name=blockHeight,proto3" json:"blockHeight,omitempty"`
	ReservedByRequestId uint64                 `protobuf:"varint,7,opt,name=reservedByRequestId,proto3" json:"reservedByRequestId,omitempty"`
	ReservationId       uint64                 `protobuf:"varint,8,opt,name=reservationId,proto3" json:"reservationId,omitempty"`
	ValueString         string                 `protobuf:"bytes,9,opt,name=valueString,proto3" json:"valueString,omitempty"`
	unknownFields       protoimpl.UnknownFields
	sizeCache           protoimpl.SizeCache
}

func (x *UTXO) Reset() {
	*x = UTXO{}
	mi := &file_wallet_proto_msgTypes[10]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *UTXO) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*UTXO) ProtoMessage() {}

func (x *UTXO) ProtoReflect() protoreflect.Message {
	mi := &file_wallet_proto_msgTypes[10]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use UTXO.ProtoReflect.Descriptor instead.
func (*UTXO) Descriptor() ([]byte, []int) {
	return file_wallet_proto_rawDescGZIP(), []int{10}
}

func (x *UTXO) GetId() uint64 {
	if x != nil {
		return x.Id
	}
	return 0
}

func (x *UTXO) GetHash() string {
	if x != nil {
		return x.Hash
	}
	return ""
}

func (x *UTXO) GetOutputIndex() uint32 {
	if x != nil {
		return x.OutputIndex
	}
	return 0
}

func (x *UTXO) GetScript() string {
	if x != nil {
		return x.Script
	}
	return ""
}

func (x *UTXO) GetValue() uint64 {
	if x != nil {
		return x.Value
	}
	return 0
}

func (x *UTXO) GetBlockHeight() uint64 {
	if x != nil {
		return x.BlockHeight
	}
	return 0
}

func (x *UTXO) GetReservedByRequestId() uint64 {
	if x != nil {
		return x.ReservedByRequestId
	}
	return 0
}

func (x *UTXO) GetReservationId() uint64 {
	if x != nil {
		return x.ReservationId
	}
	return 0
}

func (x *UTXO) GetValueString() string {
	if x != nil {
		return x.ValueString
	}
	return ""
}

type ProofOfReserve struct {
	state                  protoimpl.MessageState     `protogen:"open.v1"`
	Curve                  ProofOfReserve_Curve       `protobuf:"varint,1,opt,name=curve,proto3,enum=tgvalidatord.ProofOfReserve_Curve" json:"curve,omitempty"`
	Cipher                 ProofOfReserve_Cipher      `protobuf:"varint,2,opt,name=cipher,proto3,enum=tgvalidatord.ProofOfReserve_Cipher" json:"cipher,omitempty"`
	Path                   string                     `protobuf:"bytes,3,opt,name=path,proto3" json:"path,omitempty"`
	Address                string                     `protobuf:"bytes,4,opt,name=address,proto3" json:"address,omitempty"`
	PublicKey              []byte                     `protobuf:"bytes,5,opt,name=publicKey,proto3" json:"publicKey,omitempty"`
	Challenge              string                     `protobuf:"bytes,6,opt,name=challenge,proto3" json:"challenge,omitempty"`
	ChallengeResponse      []byte                     `protobuf:"bytes,7,opt,name=challengeResponse,proto3" json:"challengeResponse,omitempty"`
	Type                   ProofOfReserve_ReserveType `protobuf:"varint,8,opt,name=type,proto3,enum=tgvalidatord.ProofOfReserve_ReserveType" json:"type,omitempty"`
	StakePublicKey         []byte                     `protobuf:"bytes,9,opt,name=stakePublicKey,proto3" json:"stakePublicKey,omitempty"`
	StakeChallengeResponse []byte                     `protobuf:"bytes,10,opt,name=stakeChallengeResponse,proto3" json:"stakeChallengeResponse,omitempty"`
	unknownFields          protoimpl.UnknownFields
	sizeCache              protoimpl.SizeCache
}

func (x *ProofOfReserve) Reset() {
	*x = ProofOfReserve{}
	mi := &file_wallet_proto_msgTypes[11]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *ProofOfReserve) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*ProofOfReserve) ProtoMessage() {}

func (x *ProofOfReserve) ProtoReflect() protoreflect.Message {
	mi := &file_wallet_proto_msgTypes[11]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use ProofOfReserve.ProtoReflect.Descriptor instead.
func (*ProofOfReserve) Descriptor() ([]byte, []int) {
	return file_wallet_proto_rawDescGZIP(), []int{11}
}

func (x *ProofOfReserve) GetCurve() ProofOfReserve_Curve {
	if x != nil {
		return x.Curve
	}
	return ProofOfReserve__curve
}

func (x *ProofOfReserve) GetCipher() ProofOfReserve_Cipher {
	if x != nil {
		return x.Cipher
	}
	return ProofOfReserve__cipher
}

func (x *ProofOfReserve) GetPath() string {
	if x != nil {
		return x.Path
	}
	return ""
}

func (x *ProofOfReserve) GetAddress() string {
	if x != nil {
		return x.Address
	}
	return ""
}

func (x *ProofOfReserve) GetPublicKey() []byte {
	if x != nil {
		return x.PublicKey
	}
	return nil
}

func (x *ProofOfReserve) GetChallenge() string {
	if x != nil {
		return x.Challenge
	}
	return ""
}

func (x *ProofOfReserve) GetChallengeResponse() []byte {
	if x != nil {
		return x.ChallengeResponse
	}
	return nil
}

func (x *ProofOfReserve) GetType() ProofOfReserve_ReserveType {
	if x != nil {
		return x.Type
	}
	return ProofOfReserve_Generic
}

func (x *ProofOfReserve) GetStakePublicKey() []byte {
	if x != nil {
		return x.StakePublicKey
	}
	return nil
}

func (x *ProofOfReserve) GetStakeChallengeResponse() []byte {
	if x != nil {
		return x.StakeChallengeResponse
	}
	return nil
}

type LightAddressInfo struct {
	state             protoimpl.MessageState `protogen:"open.v1"`
	Id                uint64                 `protobuf:"varint,1,opt,name=id,proto3" json:"id,omitempty"`
	WalletId          uint64                 `protobuf:"varint,2,opt,name=walletId,proto3" json:"walletId,omitempty"`
	Address           string                 `protobuf:"bytes,3,opt,name=address,proto3" json:"address,omitempty"`
	CustomerId        string                 `protobuf:"bytes,4,opt,name=customerId,proto3" json:"customerId,omitempty"`
	Network           string                 `protobuf:"bytes,5,opt,name=network,proto3" json:"network,omitempty"`
	Label             string                 `protobuf:"bytes,6,opt,name=label,proto3" json:"label,omitempty"`
	Comment           string                 `protobuf:"bytes,7,opt,name=comment,proto3" json:"comment,omitempty"`
	AddressPath       string                 `protobuf:"bytes,8,opt,name=addressPath,proto3" json:"addressPath,omitempty"`
	Status            string                 `protobuf:"bytes,9,opt,name=status,proto3" json:"status,omitempty"`
	CurrencyId        string                 `protobuf:"bytes,10,opt,name=currencyId,proto3" json:"currencyId,omitempty"`
	CreationDate      *timestamppb.Timestamp `protobuf:"bytes,11,opt,name=creationDate,proto3" json:"creationDate,omitempty"`
	UpdateDate        *timestamppb.Timestamp `protobuf:"bytes,12,opt,name=updateDate,proto3" json:"updateDate,omitempty"`
	ExternalAddressId string                 `protobuf:"bytes,13,opt,name=externalAddressId,proto3" json:"externalAddressId,omitempty"`
	unknownFields     protoimpl.UnknownFields
	sizeCache         protoimpl.SizeCache
}

func (x *LightAddressInfo) Reset() {
	*x = LightAddressInfo{}
	mi := &file_wallet_proto_msgTypes[12]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *LightAddressInfo) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*LightAddressInfo) ProtoMessage() {}

func (x *LightAddressInfo) ProtoReflect() protoreflect.Message {
	mi := &file_wallet_proto_msgTypes[12]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use LightAddressInfo.ProtoReflect.Descriptor instead.
func (*LightAddressInfo) Descriptor() ([]byte, []int) {
	return file_wallet_proto_rawDescGZIP(), []int{12}
}

func (x *LightAddressInfo) GetId() uint64 {
	if x != nil {
		return x.Id
	}
	return 0
}

func (x *LightAddressInfo) GetWalletId() uint64 {
	if x != nil {
		return x.WalletId
	}
	return 0
}

func (x *LightAddressInfo) GetAddress() string {
	if x != nil {
		return x.Address
	}
	return ""
}

func (x *LightAddressInfo) GetCustomerId() string {
	if x != nil {
		return x.CustomerId
	}
	return ""
}

func (x *LightAddressInfo) GetNetwork() string {
	if x != nil {
		return x.Network
	}
	return ""
}

func (x *LightAddressInfo) GetLabel() string {
	if x != nil {
		return x.Label
	}
	return ""
}

func (x *LightAddressInfo) GetComment() string {
	if x != nil {
		return x.Comment
	}
	return ""
}

func (x *LightAddressInfo) GetAddressPath() string {
	if x != nil {
		return x.AddressPath
	}
	return ""
}

func (x *LightAddressInfo) GetStatus() string {
	if x != nil {
		return x.Status
	}
	return ""
}

func (x *LightAddressInfo) GetCurrencyId() string {
	if x != nil {
		return x.CurrencyId
	}
	return ""
}

func (x *LightAddressInfo) GetCreationDate() *timestamppb.Timestamp {
	if x != nil {
		return x.CreationDate
	}
	return nil
}

func (x *LightAddressInfo) GetUpdateDate() *timestamppb.Timestamp {
	if x != nil {
		return x.UpdateDate
	}
	return nil
}

func (x *LightAddressInfo) GetExternalAddressId() string {
	if x != nil {
		return x.ExternalAddressId
	}
	return ""
}

type Asset_XNFT struct {
	state         protoimpl.MessageState `protogen:"open.v1"`
	Tokenid       string                 `protobuf:"bytes,1,opt,name=tokenid,proto3" json:"tokenid,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *Asset_XNFT) Reset() {
	*x = Asset_XNFT{}
	mi := &file_wallet_proto_msgTypes[13]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *Asset_XNFT) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*Asset_XNFT) ProtoMessage() {}

func (x *Asset_XNFT) ProtoReflect() protoreflect.Message {
	mi := &file_wallet_proto_msgTypes[13]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use Asset_XNFT.ProtoReflect.Descriptor instead.
func (*Asset_XNFT) Descriptor() ([]byte, []int) {
	return file_wallet_proto_rawDescGZIP(), []int{0, 0}
}

func (x *Asset_XNFT) GetTokenid() string {
	if x != nil {
		return x.Tokenid
	}
	return ""
}

type Asset_XUnknown struct {
	state         protoimpl.MessageState `protogen:"open.v1"`
	Blockchain    string                 `protobuf:"bytes,1,opt,name=blockchain,proto3" json:"blockchain,omitempty"`
	Arg1          string                 `protobuf:"bytes,2,opt,name=arg1,proto3" json:"arg1,omitempty"`
	Arg2          string                 `protobuf:"bytes,3,opt,name=arg2,proto3" json:"arg2,omitempty"`
	Network       string                 `protobuf:"bytes,4,opt,name=network,proto3" json:"network,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *Asset_XUnknown) Reset() {
	*x = Asset_XUnknown{}
	mi := &file_wallet_proto_msgTypes[14]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *Asset_XUnknown) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*Asset_XUnknown) ProtoMessage() {}

func (x *Asset_XUnknown) ProtoReflect() protoreflect.Message {
	mi := &file_wallet_proto_msgTypes[14]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use Asset_XUnknown.ProtoReflect.Descriptor instead.
func (*Asset_XUnknown) Descriptor() ([]byte, []int) {
	return file_wallet_proto_rawDescGZIP(), []int{0, 1}
}

func (x *Asset_XUnknown) GetBlockchain() string {
	if x != nil {
		return x.Blockchain
	}
	return ""
}

func (x *Asset_XUnknown) GetArg1() string {
	if x != nil {
		return x.Arg1
	}
	return ""
}

func (x *Asset_XUnknown) GetArg2() string {
	if x != nil {
		return x.Arg2
	}
	return ""
}

func (x *Asset_XUnknown) GetNetwork() string {
	if x != nil {
		return x.Network
	}
	return ""
}

var File_wallet_proto protoreflect.FileDescriptor

const file_wallet_proto_rawDesc = "" +
	"\n" +
	"\fwallet.proto\x12\ftgvalidatord\x1a\x0ecurrency.proto\x1a\vscore.proto\x1a\x1fgoogle/protobuf/timestamp.proto\x1a.protoc-gen-openapiv2/options/annotations.proto\"\xa6\x04\n" +
	"\x05Asset\x12\x99\x01\n" +
	"\bcurrency\x18\x01 \x01(\tB}\x92Az2xThe currency name, e.g. 'ALGO', 'AVAX', 'USDt'. Set to 'Unknown' when the currency is unknown (as for the 'kind' field).R\bcurrency\x12\x12\n" +
	"\x04kind\x18\x02 \x01(\tR\x04kind\x12*\n" +
	"\x03nft\x18\x03 \x01(\v2\x18.tgvalidatord.Asset._NFTR\x03nft\x126\n" +
	"\aunknown\x18\x04 \x01(\v2\x1c.tgvalidatord.Asset._UnknownR\aunknown\x12:\n" +
	"\fcurrencyInfo\x18\x05 \x01(\v2\x16.tgvalidatord.CurrencyR\fcurrencyInfo\x1a \n" +
	"\x04_NFT\x12\x18\n" +
	"\atokenid\x18\x01 \x01(\tR\atokenid\x1al\n" +
	"\b_Unknown\x12\x1e\n" +
	"\n" +
	"blockchain\x18\x01 \x01(\tR\n" +
	"blockchain\x12\x12\n" +
	"\x04arg1\x18\x02 \x01(\tR\x04arg1\x12\x12\n" +
	"\x04arg2\x18\x03 \x01(\tR\x04arg2\x12\x18\n" +
	"\anetwork\x18\x04 \x01(\tR\anetwork\"+\n" +
	"\x04Kind\x12\r\n" +
	"\t_default_\x10\x00\x12\v\n" +
	"\aUnknown\x10\x01\x12\a\n" +
	"\x03NFT\x10\x02:\x10\x92A\r\n" +
	"\v\xd2\x01\bcurrency\"j\n" +
	"\fAssetBalance\x12)\n" +
	"\x05asset\x18\x01 \x01(\v2\x13.tgvalidatord.AssetR\x05asset\x12/\n" +
	"\abalance\x18\x02 \x01(\v2\x15.tgvalidatord.BalanceR\abalance\"\x83\x01\n" +
	"\x14NFTCollectionBalance\x12:\n" +
	"\fcurrencyInfo\x18\x01 \x01(\v2\x16.tgvalidatord.CurrencyR\fcurrencyInfo\x12/\n" +
	"\abalance\x18\x02 \x01(\v2\x15.tgvalidatord.BalanceR\abalance\"\x8b\a\n" +
	"\aBalance\x12w\n" +
	"\x0etotalConfirmed\x18\x01 \x01(\tBO\x92AL2JTotal confirmed balance in the smallest currency unit (e.g., WEI for ETH).R\x0etotalConfirmed\x12\x87\x02\n" +
	"\x10totalUnconfirmed\x18\x02 \x01(\tB\xda\x01\x92A\xd6\x012\xd3\x01Total balance including unconfirmed transactions in smallest currency unit (e.g., WEI). Exceeds totalConfirmed when transactions are pending confirmation. Equal to confirmed balance when all funds are confirmed.R\x10totalUnconfirmed\x12s\n" +
	"\x12availableConfirmed\x18\x03 \x01(\tBC\x92A@2>Available confirmed balance that is ready to be spent or used.R\x12availableConfirmed\x12n\n" +
	"\x14availableUnconfirmed\x18\x04 \x01(\tB:\x92A725Available balance including unconfirmed transactions.R\x14availableUnconfirmed\x12\xa1\x01\n" +
	"\x11reservedConfirmed\x18\x05 \x01(\tBs\x92Ap2nConfirmed reserved balance that is set being held for specific purposes, such as another pending transactions.R\x11reservedConfirmed\x12t\n" +
	"\x13reservedUnconfirmed\x18\x06 \x01(\tBB\x92A?2=Reserved unconfirmed balance that is not yet fully validated.R\x13reservedUnconfirmed\"\x80\x01\n" +
	"\x13BalanceHistoryPoint\x128\n" +
	"\tpointDate\x18\x01 \x01(\v2\x1a.google.protobuf.TimestampR\tpointDate\x12/\n" +
	"\abalance\x18\x02 \x01(\v2\x15.tgvalidatord.BalanceR\abalance\"\xf6\x06\n" +
	"\x06Wallet\x12\x0e\n" +
	"\x02id\x18\x01 \x01(\x04R\x02id\x12/\n" +
	"\abalance\x18\x02 \x01(\v2\x15.tgvalidatord.BalanceR\abalance\x12\x1a\n" +
	"\bcurrency\x18\x03 \x01(\tR\bcurrency\x12\x12\n" +
	"\x04coin\x18\x04 \x01(\tR\x04coin\x12\x12\n" +
	"\x04name\x18\x05 \x01(\tR\x04name\x12\x1c\n" +
	"\tcontainer\x18\x06 \x01(\tR\tcontainer\x12\x12\n" +
	"\x04seed\x18\a \x01(\tR\x04seed\x12 \n" +
	"\vaccountPath\x18\b \x01(\tR\vaccountPath\x123\n" +
	"\taddresses\x18\t \x03(\v2\x15.tgvalidatord.AddressR\taddresses\x12\x1c\n" +
	"\tisOmnibus\x18\n" +
	" \x01(\bR\tisOmnibus\x12>\n" +
	"\fcreationDate\x18\v \x01(\v2\x1a.google.protobuf.TimestampR\fcreationDate\x12:\n" +
	"\n" +
	"updateDate\x18\f \x01(\v2\x1a.google.protobuf.TimestampR\n" +
	"updateDate\x12\x1e\n" +
	"\n" +
	"customerId\x18\r \x01(\tR\n" +
	"customerId\x12\x18\n" +
	"\acomment\x18\x0e \x01(\tR\acomment\x12\x1a\n" +
	"\bdisabled\x18\x0f \x01(\bR\bdisabled\x12\x1e\n" +
	"\n" +
	"blockchain\x18\x10 \x01(\tR\n" +
	"blockchain\x12&\n" +
	"\x0eaddressesCount\x18\x11 \x01(\x04R\x0eaddressesCount\x12=\n" +
	"\n" +
	"attributes\x18\x12 \x03(\v2\x1d.tgvalidatord.WalletAttributeR\n" +
	"attributes\x12:\n" +
	"\fcurrencyInfo\x18\x13 \x01(\v2\x16.tgvalidatord.CurrencyR\fcurrencyInfo\x12`\n" +
	"\x10externalWalletId\x18\x14 \x01(\tB4\x92A12/An optional external identifier for the wallet.R\x10externalWalletId:I\x92AF2D{ \"id\": 42, \"currency\": \"ETH\", \"name\":\"Nostro wallet\", \"coin\":\"ETH\"}\"\xc7\x01\n" +
	"\x0fWalletAttribute\x12\x10\n" +
	"\x03key\x18\x01 \x01(\tR\x03key\x12\x14\n" +
	"\x05value\x18\x02 \x01(\tR\x05value\x12\x0e\n" +
	"\x02id\x18\x03 \x01(\x04R\x02id\x12 \n" +
	"\vcontentType\x18\x04 \x01(\tR\vcontentType\x12\x14\n" +
	"\x05owner\x18\x05 \x01(\tR\x05owner\x12\x12\n" +
	"\x04type\x18\x06 \x01(\tR\x04type\x12\x18\n" +
	"\asubtype\x18\a \x01(\tR\asubtype\x12\x16\n" +
	"\x06isfile\x18\b \x01(\bR\x06isfile\"\xc2\x06\n" +
	"\n" +
	"WalletInfo\x12\x0e\n" +
	"\x02id\x18\x01 \x01(\x04R\x02id\x12/\n" +
	"\abalance\x18\x02 \x01(\v2\x15.tgvalidatord.BalanceR\abalance\x12\x1a\n" +
	"\bcurrency\x18\x03 \x01(\tR\bcurrency\x12\x12\n" +
	"\x04coin\x18\x04 \x01(\tR\x04coin\x12\x12\n" +
	"\x04name\x18\x05 \x01(\tR\x04name\x12\x1c\n" +
	"\tcontainer\x18\x06 \x01(\tR\tcontainer\x12\x12\n" +
	"\x04seed\x18\a \x01(\tR\x04seed\x12 \n" +
	"\vaccountPath\x18\b \x01(\tR\vaccountPath\x12\x1c\n" +
	"\tisOmnibus\x18\t \x01(\bR\tisOmnibus\x12>\n" +
	"\fcreationDate\x18\n" +
	" \x01(\v2\x1a.google.protobuf.TimestampR\fcreationDate\x12:\n" +
	"\n" +
	"updateDate\x18\v \x01(\v2\x1a.google.protobuf.TimestampR\n" +
	"updateDate\x12\x1e\n" +
	"\n" +
	"customerId\x18\f \x01(\tR\n" +
	"customerId\x12\x18\n" +
	"\acomment\x18\r \x01(\tR\acomment\x12\x1a\n" +
	"\bdisabled\x18\x0e \x01(\bR\bdisabled\x12\x1e\n" +
	"\n" +
	"blockchain\x18\x0f \x01(\tR\n" +
	"blockchain\x12&\n" +
	"\x0eaddressesCount\x18\x10 \x01(\x04R\x0eaddressesCount\x12:\n" +
	"\fcurrencyInfo\x18\x11 \x01(\v2\x16.tgvalidatord.CurrencyR\fcurrencyInfo\x12=\n" +
	"\n" +
	"attributes\x18\x12 \x03(\v2\x1d.tgvalidatord.WalletAttributeR\n" +
	"attributes\x12\x18\n" +
	"\anetwork\x18\x13 \x01(\tR\anetwork\x12,\n" +
	"\x11visibilityGroupID\x18\x14 \x01(\tR\x11visibilityGroupID\x12`\n" +
	"\x10externalWalletId\x18\x15 \x01(\tB4\x92A12/An optional external identifier for the wallet.R\x10externalWalletId\"\xab\x17\n" +
	"\aAddress\x12?\n" +
	"\x02id\x18\x01 \x01(\x04B/\x92A,2*uint64; Unique identifier for the address.R\x02id\x12u\n" +
	"\bwalletId\x18\x02 \x01(\x04BY\x92AV2Tuint64; Unique identifier for the wallet associated with the address (parent wallet)R\bwalletId\x12N\n" +
	"\x04seed\x18\x03 \x01(\tB:\x92A725Which seed in the HSM to use for address generation..R\x04seed\x12\xee\x01\n" +
	"\bcurrency\x18\x04 \x01(\tB\xd1\x01\x92A\xcd\x012\xca\x01Currency associated with the address (e.g., ETH, BTC). For a list of enabled currencies, query the [currencies endpoint](https://docs.taurushq.com/protect-capital/reference/walletservice_getcurrencies).R\bcurrency\x12w\n" +
	"\vaddressPath\x18\x05 \x01(\tBU\x92AR2PThe derivation path for the address, used to generate the address from the seed.R\vaddressPath\x12r\n" +
	"\faddressIndex\x18\x06 \x01(\x04BN\x92AK2Iuint64; Index used for address generation. Required for derivation paths.R\faddressIndex\x12K\n" +
	"\aaddress\x18\a \x01(\tB1\x92A.2,The actual address generated for the wallet.R\aaddress\x12v\n" +
	"\x10alternateAddress\x18\b \x01(\tBJ\x92AG2EAn alternate address that can be used for transactions, if available.R\x10alternateAddress\x12O\n" +
	"\acomment\x18\t \x01(\tB5\x92A220An optional comment associated with the address.R\acomment\x12z\n" +
	"\x05label\x18\n" +
	" \x01(\tBd\x92Aa2_A user-friendly label for the address (e.g., 'Deposit Address'). Displayed as `Name` in the UI.R\x05label\x12]\n" +
	"\n" +
	"customerId\x18\v \x01(\tB=\x92A:28Identifier for the customer associated with the address.R\n" +
	"customerId\x12\x8b\x01\n" +
	"\x05nonce\x18\f \x01(\x04Bu\x92Ar2puint64; The current nonce of the address. A nonce is a 32-bit (or 4-byte) number used to prevent replay attacks.R\x05nonce\x12\x87\x01\n" +
	"\abalance\x18\r \x01(\v2\x15.tgvalidatord.BalanceBV\x92AS2QBalance associated with the address, including confirmed and unconfirmed amounts.R\abalance\x12I\n" +
	"\tsignature\x18\x0e \x01(\tB+\x92A(2&Signature associated with the address.R\tsignature\x12\xa7\x01\n" +
	"\x06scores\x18\x0f \x03(\v2\x13.tgvalidatord.ScoreBz\x92Aw2uRisk score related to the address, pulled from external reputation services. (e.g., Scorechain, Chainalysis, etc...).R\x06scores\x12\x84\x01\n" +
	"\n" +
	"attributes\x18\x10 \x03(\v2\x1e.tgvalidatord.AddressAttributeBD\x92AA2?Additional attributes and metadata associated with the address.R\n" +
	"attributes\x12\x87\x01\n" +
	"\x1blinkedWhitelistedAddressIds\x18\x11 \x03(\x04BE\x92AB2@List of whitelisted address IDs that are linked to this address.R\x1blinkedWhitelistedAddressIds\x12t\n" +
	"\fcreationDate\x18\x12 \x01(\v2\x1a.google.protobuf.TimestampB4\x92A12/The date and time when the address was created.R\fcreationDate\x12u\n" +
	"\n" +
	"updateDate\x18\x13 \x01(\v2\x1a.google.protobuf.TimestampB9\x92A624The date and time when the address was last updated.R\n" +
	"updateDate\x12c\n" +
	"\n" +
	"walletInfo\x18\x14 \x01(\v2\x18.tgvalidatord.WalletInfoB)\x92A&2$Information about the parent wallet.R\n" +
	"walletInfo\x12K\n" +
	"\bdisabled\x18\x15 \x01(\bB/\x92A,2*Indicates whether the address is disabled.R\bdisabled\x12|\n" +
	"\fcurrencyInfo\x18\x16 \x01(\v2\x16.tgvalidatord.CurrencyB@\x92A=2;Information about the currency associated with the address.R\fcurrencyInfo\x12d\n" +
	"\x0ecanUseAllFunds\x18\x17 \x01(\bB<\x92A927Indicates whether all funds in the address can be used.R\x0ecanUseAllFunds\x12c\n" +
	"\x11externalAddressId\x18\x18 \x01(\tB5\x92A220An optional external identifier for the address.R\x11externalAddressId\x12\xc2\x01\n" +
	"\x06status\x18\x19 \x01(\tB\xa9\x01\x92A\xa5\x012\xa2\x01Status of address creation. Creating status is used for asynchronous address creation. Value is one of `created`, `creating, `signed`, `observed`, or `confirmed`.R\x06status\"\xeb\x05\n" +
	"\x10AddressAttribute\x12y\n" +
	"\x03key\x18\x01 \x01(\tBg\x92Ad2bA key that Protect assigns to the attribute. E.g., `legacyAddress` `has_any_transactions`, etc... R\x03key\x126\n" +
	"\x05value\x18\x02 \x01(\tB \x92A\x1d2\x1bThe value of the attribute.R\x05value\x129\n" +
	"\x02id\x18\x03 \x01(\x04B)\x92A&2$Unique identifier for the attribute.R\x02id\x12a\n" +
	"\vcontentType\x18\x04 \x01(\tB?\x92A<2:Content type of the attribute value. Usually `text/plain.`R\vcontentType\x12T\n" +
	"\x05owner\x18\x05 \x01(\tB>\x92A;29Owner of the attribute. Most commonly `system` or `user`.R\x05owner\x12d\n" +
	"\x04type\x18\x06 \x01(\tBP\x92AM2KA Protect generated attribute type. E.g., `transaction_info`, `tag`, etc...R\x04type\x12\x80\x01\n" +
	"\asubtype\x18\a \x01(\tBf\x92Ac2aA Protect generated subtype. Not commonly used but can be used to further classify the attribute.R\asubtype\x12G\n" +
	"\x06isfile\x18\b \x01(\bB/\x92A,2*Indicates whether the attribute is a file.R\x06isfile\"\x84\x03\n" +
	"\x04UTXO\x12\x0e\n" +
	"\x02id\x18\x01 \x01(\x04R\x02id\x12\x12\n" +
	"\x04hash\x18\x02 \x01(\tR\x04hash\x12 \n" +
	"\voutputIndex\x18\x03 \x01(\rR\voutputIndex\x12\x16\n" +
	"\x06script\x18\x04 \x01(\tR\x06script\x12\x14\n" +
	"\x05value\x18\x05 \x01(\x04R\x05value\x12 \n" +
	"\vblockHeight\x18\x06 \x01(\x04R\vblockHeight\x12\x9d\x01\n" +
	"\x13reservedByRequestId\x18\a \x01(\x04Bk\x92Ah2freservedByRequestId has been replaced by reservationId since 3.22. It will always be empty since 3.22.R\x13reservedByRequestId\x12$\n" +
	"\rreservationId\x18\b \x01(\x04R\rreservationId\x12 \n" +
	"\vvalueString\x18\t \x01(\tR\vvalueString\"\x90\x06\n" +
	"\x0eProofOfReserve\x128\n" +
	"\x05curve\x18\x01 \x01(\x0e2\".tgvalidatord.ProofOfReserve.CurveR\x05curve\x12;\n" +
	"\x06cipher\x18\x02 \x01(\x0e2#.tgvalidatord.ProofOfReserve.CipherR\x06cipher\x12\x12\n" +
	"\x04path\x18\x03 \x01(\tR\x04path\x12\x18\n" +
	"\aaddress\x18\x04 \x01(\tR\aaddress\x12\x1c\n" +
	"\tpublicKey\x18\x05 \x01(\fR\tpublicKey\x12\x1c\n" +
	"\tchallenge\x18\x06 \x01(\tR\tchallenge\x12,\n" +
	"\x11challengeResponse\x18\a \x01(\fR\x11challengeResponse\x12\xca\x01\n" +
	"\x04type\x18\b \x01(\x0e2(.tgvalidatord.ProofOfReserve.ReserveTypeB\x8b\x01\x92A\x87\x012\x84\x01Indicates the type of PoR. The 'stake' fields are only relevant when the type is 'ADA'. For the 'Generic' case they must be ignored.R\x04type\x12&\n" +
	"\x0estakePublicKey\x18\t \x01(\fR\x0estakePublicKey\x126\n" +
	"\x16stakeChallengeResponse\x18\n" +
	" \x01(\fR\x16stakeChallengeResponse\"J\n" +
	"\x05Curve\x12\n" +
	"\n" +
	"\x06_curve\x10\x00\x12\r\n" +
	"\tSecp256k1\x10\x01\x12\v\n" +
	"\aEd25519\x10\x02\x12\r\n" +
	"\tSecp256r1\x10\x03\x12\n" +
	"\n" +
	"\x06Pallas\x10\x04\"Q\n" +
	"\x06Cipher\x12\v\n" +
	"\a_cipher\x10\x00\x12\x10\n" +
	"\fECDSA_SHA256\x10\x01\x12\x10\n" +
	"\fECDSA_SHA512\x10\x02\x12\t\n" +
	"\x05EDDSA\x10\x03\x12\v\n" +
	"\aSchnorr\x10\x04\"#\n" +
	"\vReserveType\x12\v\n" +
	"\aGeneric\x10\x00\x12\a\n" +
	"\x03ADA\x10\x01\"\xa5\v\n" +
	"\x10LightAddressInfo\x127\n" +
	"\x02id\x18\x01 \x01(\x04B'\x92A$2\"Unique identifier for the address.R\x02id\x12m\n" +
	"\bwalletId\x18\x02 \x01(\x04BQ\x92AN2LUnique identifier for the wallet associated with the address (parent wallet)R\bwalletId\x12K\n" +
	"\aaddress\x18\x03 \x01(\tB1\x92A.2,The actual address generated for the wallet.R\aaddress\x12]\n" +
	"\n" +
	"customerId\x18\x04 \x01(\tB=\x92A:28Identifier for the customer associated with the address.R\n" +
	"customerId\x12\\\n" +
	"\anetwork\x18\x05 \x01(\tBB\x92A?2=Network associated with the address (e.g., mainnet, testnet).R\anetwork\x12z\n" +
	"\x05label\x18\x06 \x01(\tBd\x92Aa2_A user-friendly label for the address (e.g., 'Deposit Address'). Displayed as `Name` in the UI.R\x05label\x12O\n" +
	"\acomment\x18\a \x01(\tB5\x92A220An optional comment associated with the address.R\acomment\x12w\n" +
	"\vaddressPath\x18\b \x01(\tBU\x92AR2PThe derivation path for the address, used to generate the address from the seed.R\vaddressPath\x12\xc2\x01\n" +
	"\x06status\x18\t \x01(\tB\xa9\x01\x92A\xa5\x012\xa2\x01Status of address creation. Creating status is used for asynchronous address creation. Value is one of `created`, `creating, `signed`, `observed`, or `confirmed`.R\x06status\x12\xf2\x01\n" +
	"\n" +
	"currencyId\x18\n" +
	" \x01(\tB\xd1\x01\x92A\xcd\x012\xca\x01Currency associated with the address (e.g., ETH, BTC). For a list of enabled currencies, query the [currencies endpoint](https://docs.taurushq.com/protect-capital/reference/walletservice_getcurrencies).R\n" +
	"currencyId\x12>\n" +
	"\fcreationDate\x18\v \x01(\v2\x1a.google.protobuf.TimestampR\fcreationDate\x12:\n" +
	"\n" +
	"updateDate\x18\f \x01(\v2\x1a.google.protobuf.TimestampR\n" +
	"updateDate\x12c\n" +
	"\x11externalAddressId\x18\r \x01(\tB5\x92A220An optional external identifier for the address.R\x11externalAddressIdB#\n" +
	"!com.taurushq.sdk.protect.proto.v1b\x06proto3"

var (
	file_wallet_proto_rawDescOnce sync.Once
	file_wallet_proto_rawDescData []byte
)

func file_wallet_proto_rawDescGZIP() []byte {
	file_wallet_proto_rawDescOnce.Do(func() {
		file_wallet_proto_rawDescData = protoimpl.X.CompressGZIP(unsafe.Slice(unsafe.StringData(file_wallet_proto_rawDesc), len(file_wallet_proto_rawDesc)))
	})
	return file_wallet_proto_rawDescData
}

var file_wallet_proto_enumTypes = make([]protoimpl.EnumInfo, 4)
var file_wallet_proto_msgTypes = make([]protoimpl.MessageInfo, 15)
var file_wallet_proto_goTypes = []any{
	(Asset_Kind)(0),                 // 0: tgvalidatord.Asset.Kind
	(ProofOfReserve_Curve)(0),       // 1: tgvalidatord.ProofOfReserve.Curve
	(ProofOfReserve_Cipher)(0),      // 2: tgvalidatord.ProofOfReserve.Cipher
	(ProofOfReserve_ReserveType)(0), // 3: tgvalidatord.ProofOfReserve.ReserveType
	(*Asset)(nil),                   // 4: tgvalidatord.Asset
	(*AssetBalance)(nil),            // 5: tgvalidatord.AssetBalance
	(*NFTCollectionBalance)(nil),    // 6: tgvalidatord.NFTCollectionBalance
	(*Balance)(nil),                 // 7: tgvalidatord.Balance
	(*BalanceHistoryPoint)(nil),     // 8: tgvalidatord.BalanceHistoryPoint
	(*Wallet)(nil),                  // 9: tgvalidatord.Wallet
	(*WalletAttribute)(nil),         // 10: tgvalidatord.WalletAttribute
	(*WalletInfo)(nil),              // 11: tgvalidatord.WalletInfo
	(*Address)(nil),                 // 12: tgvalidatord.Address
	(*AddressAttribute)(nil),        // 13: tgvalidatord.AddressAttribute
	(*UTXO)(nil),                    // 14: tgvalidatord.UTXO
	(*ProofOfReserve)(nil),          // 15: tgvalidatord.ProofOfReserve
	(*LightAddressInfo)(nil),        // 16: tgvalidatord.LightAddressInfo
	(*Asset_XNFT)(nil),              // 17: tgvalidatord.Asset._NFT
	(*Asset_XUnknown)(nil),          // 18: tgvalidatord.Asset._Unknown
	(*Currency)(nil),                // 19: tgvalidatord.Currency
	(*timestamppb.Timestamp)(nil),   // 20: google.protobuf.Timestamp
	(*Score)(nil),                   // 21: tgvalidatord.Score
}
var file_wallet_proto_depIdxs = []int32{
	17, // 0: tgvalidatord.Asset.nft:type_name -> tgvalidatord.Asset._NFT
	18, // 1: tgvalidatord.Asset.unknown:type_name -> tgvalidatord.Asset._Unknown
	19, // 2: tgvalidatord.Asset.currencyInfo:type_name -> tgvalidatord.Currency
	4,  // 3: tgvalidatord.AssetBalance.asset:type_name -> tgvalidatord.Asset
	7,  // 4: tgvalidatord.AssetBalance.balance:type_name -> tgvalidatord.Balance
	19, // 5: tgvalidatord.NFTCollectionBalance.currencyInfo:type_name -> tgvalidatord.Currency
	7,  // 6: tgvalidatord.NFTCollectionBalance.balance:type_name -> tgvalidatord.Balance
	20, // 7: tgvalidatord.BalanceHistoryPoint.pointDate:type_name -> google.protobuf.Timestamp
	7,  // 8: tgvalidatord.BalanceHistoryPoint.balance:type_name -> tgvalidatord.Balance
	7,  // 9: tgvalidatord.Wallet.balance:type_name -> tgvalidatord.Balance
	12, // 10: tgvalidatord.Wallet.addresses:type_name -> tgvalidatord.Address
	20, // 11: tgvalidatord.Wallet.creationDate:type_name -> google.protobuf.Timestamp
	20, // 12: tgvalidatord.Wallet.updateDate:type_name -> google.protobuf.Timestamp
	10, // 13: tgvalidatord.Wallet.attributes:type_name -> tgvalidatord.WalletAttribute
	19, // 14: tgvalidatord.Wallet.currencyInfo:type_name -> tgvalidatord.Currency
	7,  // 15: tgvalidatord.WalletInfo.balance:type_name -> tgvalidatord.Balance
	20, // 16: tgvalidatord.WalletInfo.creationDate:type_name -> google.protobuf.Timestamp
	20, // 17: tgvalidatord.WalletInfo.updateDate:type_name -> google.protobuf.Timestamp
	19, // 18: tgvalidatord.WalletInfo.currencyInfo:type_name -> tgvalidatord.Currency
	10, // 19: tgvalidatord.WalletInfo.attributes:type_name -> tgvalidatord.WalletAttribute
	7,  // 20: tgvalidatord.Address.balance:type_name -> tgvalidatord.Balance
	21, // 21: tgvalidatord.Address.scores:type_name -> tgvalidatord.Score
	13, // 22: tgvalidatord.Address.attributes:type_name -> tgvalidatord.AddressAttribute
	20, // 23: tgvalidatord.Address.creationDate:type_name -> google.protobuf.Timestamp
	20, // 24: tgvalidatord.Address.updateDate:type_name -> google.protobuf.Timestamp
	11, // 25: tgvalidatord.Address.walletInfo:type_name -> tgvalidatord.WalletInfo
	19, // 26: tgvalidatord.Address.currencyInfo:type_name -> tgvalidatord.Currency
	1,  // 27: tgvalidatord.ProofOfReserve.curve:type_name -> tgvalidatord.ProofOfReserve.Curve
	2,  // 28: tgvalidatord.ProofOfReserve.cipher:type_name -> tgvalidatord.ProofOfReserve.Cipher
	3,  // 29: tgvalidatord.ProofOfReserve.type:type_name -> tgvalidatord.ProofOfReserve.ReserveType
	20, // 30: tgvalidatord.LightAddressInfo.creationDate:type_name -> google.protobuf.Timestamp
	20, // 31: tgvalidatord.LightAddressInfo.updateDate:type_name -> google.protobuf.Timestamp
	32, // [32:32] is the sub-list for method output_type
	32, // [32:32] is the sub-list for method input_type
	32, // [32:32] is the sub-list for extension type_name
	32, // [32:32] is the sub-list for extension extendee
	0,  // [0:32] is the sub-list for field type_name
}

func init() { file_wallet_proto_init() }
func file_wallet_proto_init() {
	if File_wallet_proto != nil {
		return
	}
	file_currency_proto_init()
	file_score_proto_init()
	type x struct{}
	out := protoimpl.TypeBuilder{
		File: protoimpl.DescBuilder{
			GoPackagePath: reflect.TypeOf(x{}).PkgPath(),
			RawDescriptor: unsafe.Slice(unsafe.StringData(file_wallet_proto_rawDesc), len(file_wallet_proto_rawDesc)),
			NumEnums:      4,
			NumMessages:   15,
			NumExtensions: 0,
			NumServices:   0,
		},
		GoTypes:           file_wallet_proto_goTypes,
		DependencyIndexes: file_wallet_proto_depIdxs,
		EnumInfos:         file_wallet_proto_enumTypes,
		MessageInfos:      file_wallet_proto_msgTypes,
	}.Build()
	File_wallet_proto = out.File
	file_wallet_proto_goTypes = nil
	file_wallet_proto_depIdxs = nil
}
