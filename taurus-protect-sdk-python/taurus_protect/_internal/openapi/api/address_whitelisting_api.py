# coding: utf-8

"""
    Taurus-PROTECT APIs

    Taurus-PROTECT APIs description

    The version of the OpenAPI document: 1.0
    Generated by OpenAPI Generator (https://openapi-generator.tech)

    Do not edit the class manually.
"""  # noqa: E501

import warnings
from pydantic import validate_call, Field, StrictFloat, StrictStr, StrictInt
from typing import Any, Dict, List, Optional, Tuple, Union
from typing_extensions import Annotated

from datetime import datetime
from pydantic import Field, StrictBool, StrictStr
from typing import Any, Dict, List, Optional
from typing_extensions import Annotated
from taurus_protect._internal.openapi.models.tgvalidatord_approve_whitelisted_address_request import TgvalidatordApproveWhitelistedAddressRequest
from taurus_protect._internal.openapi.models.tgvalidatord_approve_whitelisting_reply import TgvalidatordApproveWhitelistingReply
from taurus_protect._internal.openapi.models.tgvalidatord_create_reply import TgvalidatordCreateReply
from taurus_protect._internal.openapi.models.tgvalidatord_create_whitelisted_address_attributes_reply import TgvalidatordCreateWhitelistedAddressAttributesReply
from taurus_protect._internal.openapi.models.tgvalidatord_create_whitelisted_address_request import TgvalidatordCreateWhitelistedAddressRequest
from taurus_protect._internal.openapi.models.tgvalidatord_delete_whitelisted_address_request import TgvalidatordDeleteWhitelistedAddressRequest
from taurus_protect._internal.openapi.models.tgvalidatord_export_whitelisted_addresses_reply import TgvalidatordExportWhitelistedAddressesReply
from taurus_protect._internal.openapi.models.tgvalidatord_get_signed_whitelisted_address_envelope_reply import TgvalidatordGetSignedWhitelistedAddressEnvelopeReply
from taurus_protect._internal.openapi.models.tgvalidatord_get_signed_whitelisted_address_envelopes_reply import TgvalidatordGetSignedWhitelistedAddressEnvelopesReply
from taurus_protect._internal.openapi.models.tgvalidatord_get_whitelisted_address_attribute_reply import TgvalidatordGetWhitelistedAddressAttributeReply
from taurus_protect._internal.openapi.models.tgvalidatord_reject_whitelisted_address_request import TgvalidatordRejectWhitelistedAddressRequest
from taurus_protect._internal.openapi.models.whitelist_service_create_whitelisted_address_attributes_body import WhitelistServiceCreateWhitelistedAddressAttributesBody

from taurus_protect._internal.openapi.api_client import ApiClient, RequestSerialized
from taurus_protect._internal.openapi.api_response import ApiResponse
from taurus_protect._internal.openapi.rest import RESTResponseType


class AddressWhitelistingApi:
    """NOTE: This class is auto generated by OpenAPI Generator
    Ref: https://openapi-generator.tech

    Do not edit the class manually.
    """

    def __init__(self, api_client=None) -> None:
        if api_client is None:
            api_client = ApiClient.get_default()
        self.api_client = api_client


    @validate_call
    def whitelist_service_approve_whitelisted_address(
        self,
        body: TgvalidatordApproveWhitelistedAddressRequest,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> TgvalidatordApproveWhitelistingReply:
        """Approve a whitelisted address

        This endpoint approves a whitelisted address.  Required role: **WhitelistedAddressApprover**.

        :param body: (required)
        :type body: TgvalidatordApproveWhitelistedAddressRequest
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._whitelist_service_approve_whitelisted_address_serialize(
            body=body,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "TgvalidatordApproveWhitelistingReply",
            '400': "object",
            '401': "object",
            '403': "object",
            '404': "object",
            '500': "object",
            '503': "object",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def whitelist_service_approve_whitelisted_address_with_http_info(
        self,
        body: TgvalidatordApproveWhitelistedAddressRequest,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[TgvalidatordApproveWhitelistingReply]:
        """Approve a whitelisted address

        This endpoint approves a whitelisted address.  Required role: **WhitelistedAddressApprover**.

        :param body: (required)
        :type body: TgvalidatordApproveWhitelistedAddressRequest
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._whitelist_service_approve_whitelisted_address_serialize(
            body=body,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "TgvalidatordApproveWhitelistingReply",
            '400': "object",
            '401': "object",
            '403': "object",
            '404': "object",
            '500': "object",
            '503': "object",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def whitelist_service_approve_whitelisted_address_without_preload_content(
        self,
        body: TgvalidatordApproveWhitelistedAddressRequest,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """Approve a whitelisted address

        This endpoint approves a whitelisted address.  Required role: **WhitelistedAddressApprover**.

        :param body: (required)
        :type body: TgvalidatordApproveWhitelistedAddressRequest
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._whitelist_service_approve_whitelisted_address_serialize(
            body=body,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "TgvalidatordApproveWhitelistingReply",
            '400': "object",
            '401': "object",
            '403': "object",
            '404': "object",
            '500': "object",
            '503': "object",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _whitelist_service_approve_whitelisted_address_serialize(
        self,
        body,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        # process the query parameters
        # process the header parameters
        # process the form parameters
        # process the body parameter
        if body is not None:
            _body_params = body


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json'
                ]
            )

        # set the HTTP header `Content-Type`
        if _content_type:
            _header_params['Content-Type'] = _content_type
        else:
            _default_content_type = (
                self.api_client.select_header_content_type(
                    [
                        'application/json'
                    ]
                )
            )
            if _default_content_type is not None:
                _header_params['Content-Type'] = _default_content_type

        # authentication setting
        _auth_settings: List[str] = [
            'ApiKeyTPV1'
        ]

        return self.api_client.param_serialize(
            method='POST',
            resource_path='/api/rest/v1/whitelists/addresses/approve',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def whitelist_service_create_whitelisted_address(
        self,
        body: TgvalidatordCreateWhitelistedAddressRequest,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> TgvalidatordCreateReply:
        """Create a whitelisted address

        This endpoint creates a new whitelisted address.  Required role: **WhitelistedAddressCreator**.

        :param body: (required)
        :type body: TgvalidatordCreateWhitelistedAddressRequest
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._whitelist_service_create_whitelisted_address_serialize(
            body=body,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "TgvalidatordCreateReply",
            '400': "object",
            '401': "object",
            '403': "object",
            '404': "object",
            '500': "object",
            '503': "object",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def whitelist_service_create_whitelisted_address_with_http_info(
        self,
        body: TgvalidatordCreateWhitelistedAddressRequest,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[TgvalidatordCreateReply]:
        """Create a whitelisted address

        This endpoint creates a new whitelisted address.  Required role: **WhitelistedAddressCreator**.

        :param body: (required)
        :type body: TgvalidatordCreateWhitelistedAddressRequest
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._whitelist_service_create_whitelisted_address_serialize(
            body=body,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "TgvalidatordCreateReply",
            '400': "object",
            '401': "object",
            '403': "object",
            '404': "object",
            '500': "object",
            '503': "object",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def whitelist_service_create_whitelisted_address_without_preload_content(
        self,
        body: TgvalidatordCreateWhitelistedAddressRequest,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """Create a whitelisted address

        This endpoint creates a new whitelisted address.  Required role: **WhitelistedAddressCreator**.

        :param body: (required)
        :type body: TgvalidatordCreateWhitelistedAddressRequest
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._whitelist_service_create_whitelisted_address_serialize(
            body=body,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "TgvalidatordCreateReply",
            '400': "object",
            '401': "object",
            '403': "object",
            '404': "object",
            '500': "object",
            '503': "object",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _whitelist_service_create_whitelisted_address_serialize(
        self,
        body,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        # process the query parameters
        # process the header parameters
        # process the form parameters
        # process the body parameter
        if body is not None:
            _body_params = body


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json'
                ]
            )

        # set the HTTP header `Content-Type`
        if _content_type:
            _header_params['Content-Type'] = _content_type
        else:
            _default_content_type = (
                self.api_client.select_header_content_type(
                    [
                        'application/json'
                    ]
                )
            )
            if _default_content_type is not None:
                _header_params['Content-Type'] = _default_content_type

        # authentication setting
        _auth_settings: List[str] = [
            'ApiKeyTPV1'
        ]

        return self.api_client.param_serialize(
            method='POST',
            resource_path='/api/rest/v1/whitelists/addresses',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def whitelist_service_create_whitelisted_address_attributes(
        self,
        whitelisted_address_id: Annotated[StrictStr, Field(description="uint64; The ID of the whitelisted address for the attribute")],
        body: WhitelistServiceCreateWhitelistedAddressAttributesBody,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> TgvalidatordCreateWhitelistedAddressAttributesReply:
        """Create attributes

        This endpoint creates attributes of a given whitelisted address.  Required role: **WhitelistedAddressCreator**.

        :param whitelisted_address_id: uint64; The ID of the whitelisted address for the attribute (required)
        :type whitelisted_address_id: str
        :param body: (required)
        :type body: WhitelistServiceCreateWhitelistedAddressAttributesBody
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._whitelist_service_create_whitelisted_address_attributes_serialize(
            whitelisted_address_id=whitelisted_address_id,
            body=body,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "TgvalidatordCreateWhitelistedAddressAttributesReply",
            '400': "object",
            '401': "object",
            '403': "object",
            '404': "object",
            '500': "object",
            '503': "object",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def whitelist_service_create_whitelisted_address_attributes_with_http_info(
        self,
        whitelisted_address_id: Annotated[StrictStr, Field(description="uint64; The ID of the whitelisted address for the attribute")],
        body: WhitelistServiceCreateWhitelistedAddressAttributesBody,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[TgvalidatordCreateWhitelistedAddressAttributesReply]:
        """Create attributes

        This endpoint creates attributes of a given whitelisted address.  Required role: **WhitelistedAddressCreator**.

        :param whitelisted_address_id: uint64; The ID of the whitelisted address for the attribute (required)
        :type whitelisted_address_id: str
        :param body: (required)
        :type body: WhitelistServiceCreateWhitelistedAddressAttributesBody
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._whitelist_service_create_whitelisted_address_attributes_serialize(
            whitelisted_address_id=whitelisted_address_id,
            body=body,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "TgvalidatordCreateWhitelistedAddressAttributesReply",
            '400': "object",
            '401': "object",
            '403': "object",
            '404': "object",
            '500': "object",
            '503': "object",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def whitelist_service_create_whitelisted_address_attributes_without_preload_content(
        self,
        whitelisted_address_id: Annotated[StrictStr, Field(description="uint64; The ID of the whitelisted address for the attribute")],
        body: WhitelistServiceCreateWhitelistedAddressAttributesBody,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """Create attributes

        This endpoint creates attributes of a given whitelisted address.  Required role: **WhitelistedAddressCreator**.

        :param whitelisted_address_id: uint64; The ID of the whitelisted address for the attribute (required)
        :type whitelisted_address_id: str
        :param body: (required)
        :type body: WhitelistServiceCreateWhitelistedAddressAttributesBody
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._whitelist_service_create_whitelisted_address_attributes_serialize(
            whitelisted_address_id=whitelisted_address_id,
            body=body,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "TgvalidatordCreateWhitelistedAddressAttributesReply",
            '400': "object",
            '401': "object",
            '403': "object",
            '404': "object",
            '500': "object",
            '503': "object",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _whitelist_service_create_whitelisted_address_attributes_serialize(
        self,
        whitelisted_address_id,
        body,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        if whitelisted_address_id is not None:
            _path_params['whitelistedAddressId'] = whitelisted_address_id
        # process the query parameters
        # process the header parameters
        # process the form parameters
        # process the body parameter
        if body is not None:
            _body_params = body


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json'
                ]
            )

        # set the HTTP header `Content-Type`
        if _content_type:
            _header_params['Content-Type'] = _content_type
        else:
            _default_content_type = (
                self.api_client.select_header_content_type(
                    [
                        'application/json'
                    ]
                )
            )
            if _default_content_type is not None:
                _header_params['Content-Type'] = _default_content_type

        # authentication setting
        _auth_settings: List[str] = [
            'ApiKeyTPV1'
        ]

        return self.api_client.param_serialize(
            method='POST',
            resource_path='/api/rest/v1/whitelists/addresses/{whitelistedAddressId}/attributes',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def whitelist_service_delete_whitelisted_address(
        self,
        body: TgvalidatordDeleteWhitelistedAddressRequest,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> TgvalidatordCreateReply:
        """Delete a whitelisted address

        This endpoint deletes a whitelisted address.  Required role: **WhitelistedAddressCreator**.

        :param body: (required)
        :type body: TgvalidatordDeleteWhitelistedAddressRequest
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._whitelist_service_delete_whitelisted_address_serialize(
            body=body,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "TgvalidatordCreateReply",
            '400': "object",
            '401': "object",
            '403': "object",
            '404': "object",
            '500': "object",
            '503': "object",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def whitelist_service_delete_whitelisted_address_with_http_info(
        self,
        body: TgvalidatordDeleteWhitelistedAddressRequest,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[TgvalidatordCreateReply]:
        """Delete a whitelisted address

        This endpoint deletes a whitelisted address.  Required role: **WhitelistedAddressCreator**.

        :param body: (required)
        :type body: TgvalidatordDeleteWhitelistedAddressRequest
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._whitelist_service_delete_whitelisted_address_serialize(
            body=body,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "TgvalidatordCreateReply",
            '400': "object",
            '401': "object",
            '403': "object",
            '404': "object",
            '500': "object",
            '503': "object",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def whitelist_service_delete_whitelisted_address_without_preload_content(
        self,
        body: TgvalidatordDeleteWhitelistedAddressRequest,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """Delete a whitelisted address

        This endpoint deletes a whitelisted address.  Required role: **WhitelistedAddressCreator**.

        :param body: (required)
        :type body: TgvalidatordDeleteWhitelistedAddressRequest
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._whitelist_service_delete_whitelisted_address_serialize(
            body=body,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "TgvalidatordCreateReply",
            '400': "object",
            '401': "object",
            '403': "object",
            '404': "object",
            '500': "object",
            '503': "object",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _whitelist_service_delete_whitelisted_address_serialize(
        self,
        body,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        # process the query parameters
        # process the header parameters
        # process the form parameters
        # process the body parameter
        if body is not None:
            _body_params = body


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json'
                ]
            )

        # set the HTTP header `Content-Type`
        if _content_type:
            _header_params['Content-Type'] = _content_type
        else:
            _default_content_type = (
                self.api_client.select_header_content_type(
                    [
                        'application/json'
                    ]
                )
            )
            if _default_content_type is not None:
                _header_params['Content-Type'] = _default_content_type

        # authentication setting
        _auth_settings: List[str] = [
            'ApiKeyTPV1'
        ]

        return self.api_client.param_serialize(
            method='POST',
            resource_path='/api/rest/v1/whitelists/addresses/delete',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def whitelist_service_delete_whitelisted_address_attribute(
        self,
        whitelisted_address_id: Annotated[StrictStr, Field(description="uint64; The whitelisted address ID for the attribute")],
        id: Annotated[StrictStr, Field(description="uint64; The attribute ID to delete")],
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> object:
        """Delete an attribute

        This endpoint deletes an attribute of a given whitelisted address.  Required role: **WhitelistedAddressCreator**.

        :param whitelisted_address_id: uint64; The whitelisted address ID for the attribute (required)
        :type whitelisted_address_id: str
        :param id: uint64; The attribute ID to delete (required)
        :type id: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._whitelist_service_delete_whitelisted_address_attribute_serialize(
            whitelisted_address_id=whitelisted_address_id,
            id=id,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "object",
            '400': "object",
            '401': "object",
            '403': "object",
            '404': "object",
            '500': "object",
            '503': "object",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def whitelist_service_delete_whitelisted_address_attribute_with_http_info(
        self,
        whitelisted_address_id: Annotated[StrictStr, Field(description="uint64; The whitelisted address ID for the attribute")],
        id: Annotated[StrictStr, Field(description="uint64; The attribute ID to delete")],
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[object]:
        """Delete an attribute

        This endpoint deletes an attribute of a given whitelisted address.  Required role: **WhitelistedAddressCreator**.

        :param whitelisted_address_id: uint64; The whitelisted address ID for the attribute (required)
        :type whitelisted_address_id: str
        :param id: uint64; The attribute ID to delete (required)
        :type id: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._whitelist_service_delete_whitelisted_address_attribute_serialize(
            whitelisted_address_id=whitelisted_address_id,
            id=id,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "object",
            '400': "object",
            '401': "object",
            '403': "object",
            '404': "object",
            '500': "object",
            '503': "object",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def whitelist_service_delete_whitelisted_address_attribute_without_preload_content(
        self,
        whitelisted_address_id: Annotated[StrictStr, Field(description="uint64; The whitelisted address ID for the attribute")],
        id: Annotated[StrictStr, Field(description="uint64; The attribute ID to delete")],
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """Delete an attribute

        This endpoint deletes an attribute of a given whitelisted address.  Required role: **WhitelistedAddressCreator**.

        :param whitelisted_address_id: uint64; The whitelisted address ID for the attribute (required)
        :type whitelisted_address_id: str
        :param id: uint64; The attribute ID to delete (required)
        :type id: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._whitelist_service_delete_whitelisted_address_attribute_serialize(
            whitelisted_address_id=whitelisted_address_id,
            id=id,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "object",
            '400': "object",
            '401': "object",
            '403': "object",
            '404': "object",
            '500': "object",
            '503': "object",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _whitelist_service_delete_whitelisted_address_attribute_serialize(
        self,
        whitelisted_address_id,
        id,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        if whitelisted_address_id is not None:
            _path_params['whitelistedAddressId'] = whitelisted_address_id
        if id is not None:
            _path_params['id'] = id
        # process the query parameters
        # process the header parameters
        # process the form parameters
        # process the body parameter


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json'
                ]
            )


        # authentication setting
        _auth_settings: List[str] = [
            'ApiKeyTPV1'
        ]

        return self.api_client.param_serialize(
            method='DELETE',
            resource_path='/api/rest/v1/whitelists/addresses/{whitelistedAddressId}/attributes/{id}',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def whitelist_service_export_whitelisted_addresses(
        self,
        format: Annotated[Optional[StrictStr], Field(description="defaults to `json`; can be `csv` or `json`")] = None,
        exchange_account_id: Annotated[Optional[StrictStr], Field(description="**Deprecated:** Use exchangeAccountIds instead")] = None,
        address_type: Annotated[Optional[StrictStr], Field(description="Can be one of the following: `individual`, `exchange`, `baker`, `stakepool`, `contract`, `validator`, node, `fiatprovider`")] = None,
        query: Annotated[Optional[StrictStr], Field(description="Will find a match in any part of the value. Filter applies to the following fields: `customerid`, `address`, `blockchain`, `label`, `memo`, `addresstype`")] = None,
        currency: Annotated[Optional[StrictStr], Field(description="**Deprecated:** Use `blockchain` instead")] = None,
        score_provider: Annotated[Optional[StrictStr], Field(description="**Deprecated:** Use `scoreFilter` instead. Can be either of the following: `scorechain`, `coinfirm`, `chainalysis`, `elliptic`, `trmlabs`")] = None,
        score_in_below: Annotated[Optional[StrictStr], Field(description="numeric; **Deprecated:** Use `scoreFilter` instead")] = None,
        score_out_below: Annotated[Optional[StrictStr], Field(description="numeric; **Deprecated:** Use `scoreFilter` instead")] = None,
        score_exclusive: Annotated[Optional[StrictBool], Field(description="**Deprecated:** Use `scoreFilter` instead")] = None,
        exchange_account_ids: Annotated[Optional[List[StrictStr]], Field(description="uint64; Array containing the list of IDs for exchange accounts")] = None,
        coinfirm_score_greater: Annotated[Optional[StrictStr], Field(description="uint64; **Deprecated:** Use `scoreFilter` instead")] = None,
        tags: Annotated[Optional[List[StrictStr]], Field(description="List of tags applied returned whitelisted addresses")] = None,
        chainalysis_score_greater: Annotated[Optional[StrictStr], Field(description="uint64; **Deprecated:** Use `scoreFilter` instead")] = None,
        blockchain: Annotated[Optional[StrictStr], Field(description="Filter on the blockchain of the WLA.")] = None,
        addresses: Annotated[Optional[List[StrictStr]], Field(description="Filter on the specific addresses to return. This field is using the blockchain's native address syntax")] = None,
        network: Annotated[Optional[StrictStr], Field(description="Name of the blockchain network, eg. `mainnet`, `testnet`, or `sepolia`")] = None,
        score_filter_score_provider: Annotated[Optional[StrictStr], Field(description="Specify the score provider to filter on, or empty.Each provider has associated filter parameters that can be set.Supported values: `scorechain`, `coinfirm`, `chainalysis`, `elliptic`, `trmlabs`")] = None,
        score_filter_scorechain_filters_score_in_below: Annotated[Optional[StrictStr], Field(description="Filter addresses under a Scorechain incoming score threshold.")] = None,
        score_filter_scorechain_filters_score_out_below: Annotated[Optional[StrictStr], Field(description="Filter addresses under a Scorechain outgoing score threshold.")] = None,
        score_filter_scorechain_filters_score_exclusive: Annotated[Optional[StrictBool], Field(description="By default when both Scorechain scores scoreInBelow and scoreOutBelow are provided, it returns the addresses matching (scoreInBelow AND scoreOutBelow). When scoreExclusive is set to true, it will return the addresses matching (scoreInBelow OR scoreOutBelow).")] = None,
        score_filter_coinfirm_filters_score_greater: Annotated[Optional[StrictStr], Field(description="Filter addresses with a Coinfirm C-score above threshold.")] = None,
        score_filter_chainalysis_filters_score_greater: Annotated[Optional[StrictStr], Field(description="Filter addresses with a Chainalysis risk score above threshold.")] = None,
        score_filter_elliptic_filters_score_greater: Annotated[Optional[StrictStr], Field(description="Filter addresses with an Elliptic risk score above threshold.")] = None,
        score_filter_trmlabs_filters_score_greater: Annotated[Optional[StrictStr], Field(description="Filter addresses with an TRM Labs risk score above threshold.")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> TgvalidatordExportWhitelistedAddressesReply:
        """Export whitelisted addresses

        This endpoint exports a list of whitelisted addresses

        :param format: defaults to `json`; can be `csv` or `json`
        :type format: str
        :param exchange_account_id: **Deprecated:** Use exchangeAccountIds instead
        :type exchange_account_id: str
        :param address_type: Can be one of the following: `individual`, `exchange`, `baker`, `stakepool`, `contract`, `validator`, node, `fiatprovider`
        :type address_type: str
        :param query: Will find a match in any part of the value. Filter applies to the following fields: `customerid`, `address`, `blockchain`, `label`, `memo`, `addresstype`
        :type query: str
        :param currency: **Deprecated:** Use `blockchain` instead
        :type currency: str
        :param score_provider: **Deprecated:** Use `scoreFilter` instead. Can be either of the following: `scorechain`, `coinfirm`, `chainalysis`, `elliptic`, `trmlabs`
        :type score_provider: str
        :param score_in_below: numeric; **Deprecated:** Use `scoreFilter` instead
        :type score_in_below: str
        :param score_out_below: numeric; **Deprecated:** Use `scoreFilter` instead
        :type score_out_below: str
        :param score_exclusive: **Deprecated:** Use `scoreFilter` instead
        :type score_exclusive: bool
        :param exchange_account_ids: uint64; Array containing the list of IDs for exchange accounts
        :type exchange_account_ids: List[str]
        :param coinfirm_score_greater: uint64; **Deprecated:** Use `scoreFilter` instead
        :type coinfirm_score_greater: str
        :param tags: List of tags applied returned whitelisted addresses
        :type tags: List[str]
        :param chainalysis_score_greater: uint64; **Deprecated:** Use `scoreFilter` instead
        :type chainalysis_score_greater: str
        :param blockchain: Filter on the blockchain of the WLA.
        :type blockchain: str
        :param addresses: Filter on the specific addresses to return. This field is using the blockchain's native address syntax
        :type addresses: List[str]
        :param network: Name of the blockchain network, eg. `mainnet`, `testnet`, or `sepolia`
        :type network: str
        :param score_filter_score_provider: Specify the score provider to filter on, or empty.Each provider has associated filter parameters that can be set.Supported values: `scorechain`, `coinfirm`, `chainalysis`, `elliptic`, `trmlabs`
        :type score_filter_score_provider: str
        :param score_filter_scorechain_filters_score_in_below: Filter addresses under a Scorechain incoming score threshold.
        :type score_filter_scorechain_filters_score_in_below: str
        :param score_filter_scorechain_filters_score_out_below: Filter addresses under a Scorechain outgoing score threshold.
        :type score_filter_scorechain_filters_score_out_below: str
        :param score_filter_scorechain_filters_score_exclusive: By default when both Scorechain scores scoreInBelow and scoreOutBelow are provided, it returns the addresses matching (scoreInBelow AND scoreOutBelow). When scoreExclusive is set to true, it will return the addresses matching (scoreInBelow OR scoreOutBelow).
        :type score_filter_scorechain_filters_score_exclusive: bool
        :param score_filter_coinfirm_filters_score_greater: Filter addresses with a Coinfirm C-score above threshold.
        :type score_filter_coinfirm_filters_score_greater: str
        :param score_filter_chainalysis_filters_score_greater: Filter addresses with a Chainalysis risk score above threshold.
        :type score_filter_chainalysis_filters_score_greater: str
        :param score_filter_elliptic_filters_score_greater: Filter addresses with an Elliptic risk score above threshold.
        :type score_filter_elliptic_filters_score_greater: str
        :param score_filter_trmlabs_filters_score_greater: Filter addresses with an TRM Labs risk score above threshold.
        :type score_filter_trmlabs_filters_score_greater: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._whitelist_service_export_whitelisted_addresses_serialize(
            format=format,
            exchange_account_id=exchange_account_id,
            address_type=address_type,
            query=query,
            currency=currency,
            score_provider=score_provider,
            score_in_below=score_in_below,
            score_out_below=score_out_below,
            score_exclusive=score_exclusive,
            exchange_account_ids=exchange_account_ids,
            coinfirm_score_greater=coinfirm_score_greater,
            tags=tags,
            chainalysis_score_greater=chainalysis_score_greater,
            blockchain=blockchain,
            addresses=addresses,
            network=network,
            score_filter_score_provider=score_filter_score_provider,
            score_filter_scorechain_filters_score_in_below=score_filter_scorechain_filters_score_in_below,
            score_filter_scorechain_filters_score_out_below=score_filter_scorechain_filters_score_out_below,
            score_filter_scorechain_filters_score_exclusive=score_filter_scorechain_filters_score_exclusive,
            score_filter_coinfirm_filters_score_greater=score_filter_coinfirm_filters_score_greater,
            score_filter_chainalysis_filters_score_greater=score_filter_chainalysis_filters_score_greater,
            score_filter_elliptic_filters_score_greater=score_filter_elliptic_filters_score_greater,
            score_filter_trmlabs_filters_score_greater=score_filter_trmlabs_filters_score_greater,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "TgvalidatordExportWhitelistedAddressesReply",
            '400': "object",
            '401': "object",
            '403': "object",
            '404': "object",
            '500': "object",
            '503': "object",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def whitelist_service_export_whitelisted_addresses_with_http_info(
        self,
        format: Annotated[Optional[StrictStr], Field(description="defaults to `json`; can be `csv` or `json`")] = None,
        exchange_account_id: Annotated[Optional[StrictStr], Field(description="**Deprecated:** Use exchangeAccountIds instead")] = None,
        address_type: Annotated[Optional[StrictStr], Field(description="Can be one of the following: `individual`, `exchange`, `baker`, `stakepool`, `contract`, `validator`, node, `fiatprovider`")] = None,
        query: Annotated[Optional[StrictStr], Field(description="Will find a match in any part of the value. Filter applies to the following fields: `customerid`, `address`, `blockchain`, `label`, `memo`, `addresstype`")] = None,
        currency: Annotated[Optional[StrictStr], Field(description="**Deprecated:** Use `blockchain` instead")] = None,
        score_provider: Annotated[Optional[StrictStr], Field(description="**Deprecated:** Use `scoreFilter` instead. Can be either of the following: `scorechain`, `coinfirm`, `chainalysis`, `elliptic`, `trmlabs`")] = None,
        score_in_below: Annotated[Optional[StrictStr], Field(description="numeric; **Deprecated:** Use `scoreFilter` instead")] = None,
        score_out_below: Annotated[Optional[StrictStr], Field(description="numeric; **Deprecated:** Use `scoreFilter` instead")] = None,
        score_exclusive: Annotated[Optional[StrictBool], Field(description="**Deprecated:** Use `scoreFilter` instead")] = None,
        exchange_account_ids: Annotated[Optional[List[StrictStr]], Field(description="uint64; Array containing the list of IDs for exchange accounts")] = None,
        coinfirm_score_greater: Annotated[Optional[StrictStr], Field(description="uint64; **Deprecated:** Use `scoreFilter` instead")] = None,
        tags: Annotated[Optional[List[StrictStr]], Field(description="List of tags applied returned whitelisted addresses")] = None,
        chainalysis_score_greater: Annotated[Optional[StrictStr], Field(description="uint64; **Deprecated:** Use `scoreFilter` instead")] = None,
        blockchain: Annotated[Optional[StrictStr], Field(description="Filter on the blockchain of the WLA.")] = None,
        addresses: Annotated[Optional[List[StrictStr]], Field(description="Filter on the specific addresses to return. This field is using the blockchain's native address syntax")] = None,
        network: Annotated[Optional[StrictStr], Field(description="Name of the blockchain network, eg. `mainnet`, `testnet`, or `sepolia`")] = None,
        score_filter_score_provider: Annotated[Optional[StrictStr], Field(description="Specify the score provider to filter on, or empty.Each provider has associated filter parameters that can be set.Supported values: `scorechain`, `coinfirm`, `chainalysis`, `elliptic`, `trmlabs`")] = None,
        score_filter_scorechain_filters_score_in_below: Annotated[Optional[StrictStr], Field(description="Filter addresses under a Scorechain incoming score threshold.")] = None,
        score_filter_scorechain_filters_score_out_below: Annotated[Optional[StrictStr], Field(description="Filter addresses under a Scorechain outgoing score threshold.")] = None,
        score_filter_scorechain_filters_score_exclusive: Annotated[Optional[StrictBool], Field(description="By default when both Scorechain scores scoreInBelow and scoreOutBelow are provided, it returns the addresses matching (scoreInBelow AND scoreOutBelow). When scoreExclusive is set to true, it will return the addresses matching (scoreInBelow OR scoreOutBelow).")] = None,
        score_filter_coinfirm_filters_score_greater: Annotated[Optional[StrictStr], Field(description="Filter addresses with a Coinfirm C-score above threshold.")] = None,
        score_filter_chainalysis_filters_score_greater: Annotated[Optional[StrictStr], Field(description="Filter addresses with a Chainalysis risk score above threshold.")] = None,
        score_filter_elliptic_filters_score_greater: Annotated[Optional[StrictStr], Field(description="Filter addresses with an Elliptic risk score above threshold.")] = None,
        score_filter_trmlabs_filters_score_greater: Annotated[Optional[StrictStr], Field(description="Filter addresses with an TRM Labs risk score above threshold.")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[TgvalidatordExportWhitelistedAddressesReply]:
        """Export whitelisted addresses

        This endpoint exports a list of whitelisted addresses

        :param format: defaults to `json`; can be `csv` or `json`
        :type format: str
        :param exchange_account_id: **Deprecated:** Use exchangeAccountIds instead
        :type exchange_account_id: str
        :param address_type: Can be one of the following: `individual`, `exchange`, `baker`, `stakepool`, `contract`, `validator`, node, `fiatprovider`
        :type address_type: str
        :param query: Will find a match in any part of the value. Filter applies to the following fields: `customerid`, `address`, `blockchain`, `label`, `memo`, `addresstype`
        :type query: str
        :param currency: **Deprecated:** Use `blockchain` instead
        :type currency: str
        :param score_provider: **Deprecated:** Use `scoreFilter` instead. Can be either of the following: `scorechain`, `coinfirm`, `chainalysis`, `elliptic`, `trmlabs`
        :type score_provider: str
        :param score_in_below: numeric; **Deprecated:** Use `scoreFilter` instead
        :type score_in_below: str
        :param score_out_below: numeric; **Deprecated:** Use `scoreFilter` instead
        :type score_out_below: str
        :param score_exclusive: **Deprecated:** Use `scoreFilter` instead
        :type score_exclusive: bool
        :param exchange_account_ids: uint64; Array containing the list of IDs for exchange accounts
        :type exchange_account_ids: List[str]
        :param coinfirm_score_greater: uint64; **Deprecated:** Use `scoreFilter` instead
        :type coinfirm_score_greater: str
        :param tags: List of tags applied returned whitelisted addresses
        :type tags: List[str]
        :param chainalysis_score_greater: uint64; **Deprecated:** Use `scoreFilter` instead
        :type chainalysis_score_greater: str
        :param blockchain: Filter on the blockchain of the WLA.
        :type blockchain: str
        :param addresses: Filter on the specific addresses to return. This field is using the blockchain's native address syntax
        :type addresses: List[str]
        :param network: Name of the blockchain network, eg. `mainnet`, `testnet`, or `sepolia`
        :type network: str
        :param score_filter_score_provider: Specify the score provider to filter on, or empty.Each provider has associated filter parameters that can be set.Supported values: `scorechain`, `coinfirm`, `chainalysis`, `elliptic`, `trmlabs`
        :type score_filter_score_provider: str
        :param score_filter_scorechain_filters_score_in_below: Filter addresses under a Scorechain incoming score threshold.
        :type score_filter_scorechain_filters_score_in_below: str
        :param score_filter_scorechain_filters_score_out_below: Filter addresses under a Scorechain outgoing score threshold.
        :type score_filter_scorechain_filters_score_out_below: str
        :param score_filter_scorechain_filters_score_exclusive: By default when both Scorechain scores scoreInBelow and scoreOutBelow are provided, it returns the addresses matching (scoreInBelow AND scoreOutBelow). When scoreExclusive is set to true, it will return the addresses matching (scoreInBelow OR scoreOutBelow).
        :type score_filter_scorechain_filters_score_exclusive: bool
        :param score_filter_coinfirm_filters_score_greater: Filter addresses with a Coinfirm C-score above threshold.
        :type score_filter_coinfirm_filters_score_greater: str
        :param score_filter_chainalysis_filters_score_greater: Filter addresses with a Chainalysis risk score above threshold.
        :type score_filter_chainalysis_filters_score_greater: str
        :param score_filter_elliptic_filters_score_greater: Filter addresses with an Elliptic risk score above threshold.
        :type score_filter_elliptic_filters_score_greater: str
        :param score_filter_trmlabs_filters_score_greater: Filter addresses with an TRM Labs risk score above threshold.
        :type score_filter_trmlabs_filters_score_greater: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._whitelist_service_export_whitelisted_addresses_serialize(
            format=format,
            exchange_account_id=exchange_account_id,
            address_type=address_type,
            query=query,
            currency=currency,
            score_provider=score_provider,
            score_in_below=score_in_below,
            score_out_below=score_out_below,
            score_exclusive=score_exclusive,
            exchange_account_ids=exchange_account_ids,
            coinfirm_score_greater=coinfirm_score_greater,
            tags=tags,
            chainalysis_score_greater=chainalysis_score_greater,
            blockchain=blockchain,
            addresses=addresses,
            network=network,
            score_filter_score_provider=score_filter_score_provider,
            score_filter_scorechain_filters_score_in_below=score_filter_scorechain_filters_score_in_below,
            score_filter_scorechain_filters_score_out_below=score_filter_scorechain_filters_score_out_below,
            score_filter_scorechain_filters_score_exclusive=score_filter_scorechain_filters_score_exclusive,
            score_filter_coinfirm_filters_score_greater=score_filter_coinfirm_filters_score_greater,
            score_filter_chainalysis_filters_score_greater=score_filter_chainalysis_filters_score_greater,
            score_filter_elliptic_filters_score_greater=score_filter_elliptic_filters_score_greater,
            score_filter_trmlabs_filters_score_greater=score_filter_trmlabs_filters_score_greater,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "TgvalidatordExportWhitelistedAddressesReply",
            '400': "object",
            '401': "object",
            '403': "object",
            '404': "object",
            '500': "object",
            '503': "object",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def whitelist_service_export_whitelisted_addresses_without_preload_content(
        self,
        format: Annotated[Optional[StrictStr], Field(description="defaults to `json`; can be `csv` or `json`")] = None,
        exchange_account_id: Annotated[Optional[StrictStr], Field(description="**Deprecated:** Use exchangeAccountIds instead")] = None,
        address_type: Annotated[Optional[StrictStr], Field(description="Can be one of the following: `individual`, `exchange`, `baker`, `stakepool`, `contract`, `validator`, node, `fiatprovider`")] = None,
        query: Annotated[Optional[StrictStr], Field(description="Will find a match in any part of the value. Filter applies to the following fields: `customerid`, `address`, `blockchain`, `label`, `memo`, `addresstype`")] = None,
        currency: Annotated[Optional[StrictStr], Field(description="**Deprecated:** Use `blockchain` instead")] = None,
        score_provider: Annotated[Optional[StrictStr], Field(description="**Deprecated:** Use `scoreFilter` instead. Can be either of the following: `scorechain`, `coinfirm`, `chainalysis`, `elliptic`, `trmlabs`")] = None,
        score_in_below: Annotated[Optional[StrictStr], Field(description="numeric; **Deprecated:** Use `scoreFilter` instead")] = None,
        score_out_below: Annotated[Optional[StrictStr], Field(description="numeric; **Deprecated:** Use `scoreFilter` instead")] = None,
        score_exclusive: Annotated[Optional[StrictBool], Field(description="**Deprecated:** Use `scoreFilter` instead")] = None,
        exchange_account_ids: Annotated[Optional[List[StrictStr]], Field(description="uint64; Array containing the list of IDs for exchange accounts")] = None,
        coinfirm_score_greater: Annotated[Optional[StrictStr], Field(description="uint64; **Deprecated:** Use `scoreFilter` instead")] = None,
        tags: Annotated[Optional[List[StrictStr]], Field(description="List of tags applied returned whitelisted addresses")] = None,
        chainalysis_score_greater: Annotated[Optional[StrictStr], Field(description="uint64; **Deprecated:** Use `scoreFilter` instead")] = None,
        blockchain: Annotated[Optional[StrictStr], Field(description="Filter on the blockchain of the WLA.")] = None,
        addresses: Annotated[Optional[List[StrictStr]], Field(description="Filter on the specific addresses to return. This field is using the blockchain's native address syntax")] = None,
        network: Annotated[Optional[StrictStr], Field(description="Name of the blockchain network, eg. `mainnet`, `testnet`, or `sepolia`")] = None,
        score_filter_score_provider: Annotated[Optional[StrictStr], Field(description="Specify the score provider to filter on, or empty.Each provider has associated filter parameters that can be set.Supported values: `scorechain`, `coinfirm`, `chainalysis`, `elliptic`, `trmlabs`")] = None,
        score_filter_scorechain_filters_score_in_below: Annotated[Optional[StrictStr], Field(description="Filter addresses under a Scorechain incoming score threshold.")] = None,
        score_filter_scorechain_filters_score_out_below: Annotated[Optional[StrictStr], Field(description="Filter addresses under a Scorechain outgoing score threshold.")] = None,
        score_filter_scorechain_filters_score_exclusive: Annotated[Optional[StrictBool], Field(description="By default when both Scorechain scores scoreInBelow and scoreOutBelow are provided, it returns the addresses matching (scoreInBelow AND scoreOutBelow). When scoreExclusive is set to true, it will return the addresses matching (scoreInBelow OR scoreOutBelow).")] = None,
        score_filter_coinfirm_filters_score_greater: Annotated[Optional[StrictStr], Field(description="Filter addresses with a Coinfirm C-score above threshold.")] = None,
        score_filter_chainalysis_filters_score_greater: Annotated[Optional[StrictStr], Field(description="Filter addresses with a Chainalysis risk score above threshold.")] = None,
        score_filter_elliptic_filters_score_greater: Annotated[Optional[StrictStr], Field(description="Filter addresses with an Elliptic risk score above threshold.")] = None,
        score_filter_trmlabs_filters_score_greater: Annotated[Optional[StrictStr], Field(description="Filter addresses with an TRM Labs risk score above threshold.")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """Export whitelisted addresses

        This endpoint exports a list of whitelisted addresses

        :param format: defaults to `json`; can be `csv` or `json`
        :type format: str
        :param exchange_account_id: **Deprecated:** Use exchangeAccountIds instead
        :type exchange_account_id: str
        :param address_type: Can be one of the following: `individual`, `exchange`, `baker`, `stakepool`, `contract`, `validator`, node, `fiatprovider`
        :type address_type: str
        :param query: Will find a match in any part of the value. Filter applies to the following fields: `customerid`, `address`, `blockchain`, `label`, `memo`, `addresstype`
        :type query: str
        :param currency: **Deprecated:** Use `blockchain` instead
        :type currency: str
        :param score_provider: **Deprecated:** Use `scoreFilter` instead. Can be either of the following: `scorechain`, `coinfirm`, `chainalysis`, `elliptic`, `trmlabs`
        :type score_provider: str
        :param score_in_below: numeric; **Deprecated:** Use `scoreFilter` instead
        :type score_in_below: str
        :param score_out_below: numeric; **Deprecated:** Use `scoreFilter` instead
        :type score_out_below: str
        :param score_exclusive: **Deprecated:** Use `scoreFilter` instead
        :type score_exclusive: bool
        :param exchange_account_ids: uint64; Array containing the list of IDs for exchange accounts
        :type exchange_account_ids: List[str]
        :param coinfirm_score_greater: uint64; **Deprecated:** Use `scoreFilter` instead
        :type coinfirm_score_greater: str
        :param tags: List of tags applied returned whitelisted addresses
        :type tags: List[str]
        :param chainalysis_score_greater: uint64; **Deprecated:** Use `scoreFilter` instead
        :type chainalysis_score_greater: str
        :param blockchain: Filter on the blockchain of the WLA.
        :type blockchain: str
        :param addresses: Filter on the specific addresses to return. This field is using the blockchain's native address syntax
        :type addresses: List[str]
        :param network: Name of the blockchain network, eg. `mainnet`, `testnet`, or `sepolia`
        :type network: str
        :param score_filter_score_provider: Specify the score provider to filter on, or empty.Each provider has associated filter parameters that can be set.Supported values: `scorechain`, `coinfirm`, `chainalysis`, `elliptic`, `trmlabs`
        :type score_filter_score_provider: str
        :param score_filter_scorechain_filters_score_in_below: Filter addresses under a Scorechain incoming score threshold.
        :type score_filter_scorechain_filters_score_in_below: str
        :param score_filter_scorechain_filters_score_out_below: Filter addresses under a Scorechain outgoing score threshold.
        :type score_filter_scorechain_filters_score_out_below: str
        :param score_filter_scorechain_filters_score_exclusive: By default when both Scorechain scores scoreInBelow and scoreOutBelow are provided, it returns the addresses matching (scoreInBelow AND scoreOutBelow). When scoreExclusive is set to true, it will return the addresses matching (scoreInBelow OR scoreOutBelow).
        :type score_filter_scorechain_filters_score_exclusive: bool
        :param score_filter_coinfirm_filters_score_greater: Filter addresses with a Coinfirm C-score above threshold.
        :type score_filter_coinfirm_filters_score_greater: str
        :param score_filter_chainalysis_filters_score_greater: Filter addresses with a Chainalysis risk score above threshold.
        :type score_filter_chainalysis_filters_score_greater: str
        :param score_filter_elliptic_filters_score_greater: Filter addresses with an Elliptic risk score above threshold.
        :type score_filter_elliptic_filters_score_greater: str
        :param score_filter_trmlabs_filters_score_greater: Filter addresses with an TRM Labs risk score above threshold.
        :type score_filter_trmlabs_filters_score_greater: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._whitelist_service_export_whitelisted_addresses_serialize(
            format=format,
            exchange_account_id=exchange_account_id,
            address_type=address_type,
            query=query,
            currency=currency,
            score_provider=score_provider,
            score_in_below=score_in_below,
            score_out_below=score_out_below,
            score_exclusive=score_exclusive,
            exchange_account_ids=exchange_account_ids,
            coinfirm_score_greater=coinfirm_score_greater,
            tags=tags,
            chainalysis_score_greater=chainalysis_score_greater,
            blockchain=blockchain,
            addresses=addresses,
            network=network,
            score_filter_score_provider=score_filter_score_provider,
            score_filter_scorechain_filters_score_in_below=score_filter_scorechain_filters_score_in_below,
            score_filter_scorechain_filters_score_out_below=score_filter_scorechain_filters_score_out_below,
            score_filter_scorechain_filters_score_exclusive=score_filter_scorechain_filters_score_exclusive,
            score_filter_coinfirm_filters_score_greater=score_filter_coinfirm_filters_score_greater,
            score_filter_chainalysis_filters_score_greater=score_filter_chainalysis_filters_score_greater,
            score_filter_elliptic_filters_score_greater=score_filter_elliptic_filters_score_greater,
            score_filter_trmlabs_filters_score_greater=score_filter_trmlabs_filters_score_greater,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "TgvalidatordExportWhitelistedAddressesReply",
            '400': "object",
            '401': "object",
            '403': "object",
            '404': "object",
            '500': "object",
            '503': "object",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _whitelist_service_export_whitelisted_addresses_serialize(
        self,
        format,
        exchange_account_id,
        address_type,
        query,
        currency,
        score_provider,
        score_in_below,
        score_out_below,
        score_exclusive,
        exchange_account_ids,
        coinfirm_score_greater,
        tags,
        chainalysis_score_greater,
        blockchain,
        addresses,
        network,
        score_filter_score_provider,
        score_filter_scorechain_filters_score_in_below,
        score_filter_scorechain_filters_score_out_below,
        score_filter_scorechain_filters_score_exclusive,
        score_filter_coinfirm_filters_score_greater,
        score_filter_chainalysis_filters_score_greater,
        score_filter_elliptic_filters_score_greater,
        score_filter_trmlabs_filters_score_greater,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
            'exchangeAccountIds': 'multi',
            'tags': 'multi',
            'addresses': 'multi',
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        # process the query parameters
        if format is not None:
            
            _query_params.append(('format', format))
            
        if exchange_account_id is not None:
            
            _query_params.append(('exchangeAccountId', exchange_account_id))
            
        if address_type is not None:
            
            _query_params.append(('addressType', address_type))
            
        if query is not None:
            
            _query_params.append(('query', query))
            
        if currency is not None:
            
            _query_params.append(('currency', currency))
            
        if score_provider is not None:
            
            _query_params.append(('scoreProvider', score_provider))
            
        if score_in_below is not None:
            
            _query_params.append(('scoreInBelow', score_in_below))
            
        if score_out_below is not None:
            
            _query_params.append(('scoreOutBelow', score_out_below))
            
        if score_exclusive is not None:
            
            _query_params.append(('scoreExclusive', score_exclusive))
            
        if exchange_account_ids is not None:
            
            _query_params.append(('exchangeAccountIds', exchange_account_ids))
            
        if coinfirm_score_greater is not None:
            
            _query_params.append(('coinfirmScoreGreater', coinfirm_score_greater))
            
        if tags is not None:
            
            _query_params.append(('tags', tags))
            
        if chainalysis_score_greater is not None:
            
            _query_params.append(('chainalysisScoreGreater', chainalysis_score_greater))
            
        if blockchain is not None:
            
            _query_params.append(('blockchain', blockchain))
            
        if addresses is not None:
            
            _query_params.append(('addresses', addresses))
            
        if network is not None:
            
            _query_params.append(('network', network))
            
        if score_filter_score_provider is not None:
            
            _query_params.append(('scoreFilter.scoreProvider', score_filter_score_provider))
            
        if score_filter_scorechain_filters_score_in_below is not None:
            
            _query_params.append(('scoreFilter.scorechainFilters.scoreInBelow', score_filter_scorechain_filters_score_in_below))
            
        if score_filter_scorechain_filters_score_out_below is not None:
            
            _query_params.append(('scoreFilter.scorechainFilters.scoreOutBelow', score_filter_scorechain_filters_score_out_below))
            
        if score_filter_scorechain_filters_score_exclusive is not None:
            
            _query_params.append(('scoreFilter.scorechainFilters.scoreExclusive', score_filter_scorechain_filters_score_exclusive))
            
        if score_filter_coinfirm_filters_score_greater is not None:
            
            _query_params.append(('scoreFilter.coinfirmFilters.scoreGreater', score_filter_coinfirm_filters_score_greater))
            
        if score_filter_chainalysis_filters_score_greater is not None:
            
            _query_params.append(('scoreFilter.chainalysisFilters.scoreGreater', score_filter_chainalysis_filters_score_greater))
            
        if score_filter_elliptic_filters_score_greater is not None:
            
            _query_params.append(('scoreFilter.ellipticFilters.scoreGreater', score_filter_elliptic_filters_score_greater))
            
        if score_filter_trmlabs_filters_score_greater is not None:
            
            _query_params.append(('scoreFilter.trmlabsFilters.scoreGreater', score_filter_trmlabs_filters_score_greater))
            
        # process the header parameters
        # process the form parameters
        # process the body parameter


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json'
                ]
            )


        # authentication setting
        _auth_settings: List[str] = [
            'ApiKeyTPV1'
        ]

        return self.api_client.param_serialize(
            method='GET',
            resource_path='/api/rest/v1/whitelists/addresses/export',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def whitelist_service_get_whitelisted_address(
        self,
        id: StrictStr,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> TgvalidatordGetSignedWhitelistedAddressEnvelopeReply:
        """Get a whitelisted address

        This endpoint returns a whitelisted address

        :param id: (required)
        :type id: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._whitelist_service_get_whitelisted_address_serialize(
            id=id,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "TgvalidatordGetSignedWhitelistedAddressEnvelopeReply",
            '400': "object",
            '401': "object",
            '403': "object",
            '404': "object",
            '500': "object",
            '503': "object",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def whitelist_service_get_whitelisted_address_with_http_info(
        self,
        id: StrictStr,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[TgvalidatordGetSignedWhitelistedAddressEnvelopeReply]:
        """Get a whitelisted address

        This endpoint returns a whitelisted address

        :param id: (required)
        :type id: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._whitelist_service_get_whitelisted_address_serialize(
            id=id,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "TgvalidatordGetSignedWhitelistedAddressEnvelopeReply",
            '400': "object",
            '401': "object",
            '403': "object",
            '404': "object",
            '500': "object",
            '503': "object",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def whitelist_service_get_whitelisted_address_without_preload_content(
        self,
        id: StrictStr,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """Get a whitelisted address

        This endpoint returns a whitelisted address

        :param id: (required)
        :type id: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._whitelist_service_get_whitelisted_address_serialize(
            id=id,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "TgvalidatordGetSignedWhitelistedAddressEnvelopeReply",
            '400': "object",
            '401': "object",
            '403': "object",
            '404': "object",
            '500': "object",
            '503': "object",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _whitelist_service_get_whitelisted_address_serialize(
        self,
        id,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        if id is not None:
            _path_params['id'] = id
        # process the query parameters
        # process the header parameters
        # process the form parameters
        # process the body parameter


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json'
                ]
            )


        # authentication setting
        _auth_settings: List[str] = [
            'ApiKeyTPV1'
        ]

        return self.api_client.param_serialize(
            method='GET',
            resource_path='/api/rest/v1/whitelists/addresses/{id}',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def whitelist_service_get_whitelisted_address_attribute(
        self,
        whitelisted_address_id: Annotated[StrictStr, Field(description="uint64; The ID of the whitelisted address for the attribute")],
        id: Annotated[StrictStr, Field(description="uint64; The ID of the attribute")],
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> TgvalidatordGetWhitelistedAddressAttributeReply:
        """List attributes

        This endpoint returns a list of attributes of a given whitelisted address

        :param whitelisted_address_id: uint64; The ID of the whitelisted address for the attribute (required)
        :type whitelisted_address_id: str
        :param id: uint64; The ID of the attribute (required)
        :type id: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._whitelist_service_get_whitelisted_address_attribute_serialize(
            whitelisted_address_id=whitelisted_address_id,
            id=id,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "TgvalidatordGetWhitelistedAddressAttributeReply",
            '400': "object",
            '401': "object",
            '403': "object",
            '404': "object",
            '500': "object",
            '503': "object",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def whitelist_service_get_whitelisted_address_attribute_with_http_info(
        self,
        whitelisted_address_id: Annotated[StrictStr, Field(description="uint64; The ID of the whitelisted address for the attribute")],
        id: Annotated[StrictStr, Field(description="uint64; The ID of the attribute")],
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[TgvalidatordGetWhitelistedAddressAttributeReply]:
        """List attributes

        This endpoint returns a list of attributes of a given whitelisted address

        :param whitelisted_address_id: uint64; The ID of the whitelisted address for the attribute (required)
        :type whitelisted_address_id: str
        :param id: uint64; The ID of the attribute (required)
        :type id: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._whitelist_service_get_whitelisted_address_attribute_serialize(
            whitelisted_address_id=whitelisted_address_id,
            id=id,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "TgvalidatordGetWhitelistedAddressAttributeReply",
            '400': "object",
            '401': "object",
            '403': "object",
            '404': "object",
            '500': "object",
            '503': "object",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def whitelist_service_get_whitelisted_address_attribute_without_preload_content(
        self,
        whitelisted_address_id: Annotated[StrictStr, Field(description="uint64; The ID of the whitelisted address for the attribute")],
        id: Annotated[StrictStr, Field(description="uint64; The ID of the attribute")],
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """List attributes

        This endpoint returns a list of attributes of a given whitelisted address

        :param whitelisted_address_id: uint64; The ID of the whitelisted address for the attribute (required)
        :type whitelisted_address_id: str
        :param id: uint64; The ID of the attribute (required)
        :type id: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._whitelist_service_get_whitelisted_address_attribute_serialize(
            whitelisted_address_id=whitelisted_address_id,
            id=id,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "TgvalidatordGetWhitelistedAddressAttributeReply",
            '400': "object",
            '401': "object",
            '403': "object",
            '404': "object",
            '500': "object",
            '503': "object",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _whitelist_service_get_whitelisted_address_attribute_serialize(
        self,
        whitelisted_address_id,
        id,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        if whitelisted_address_id is not None:
            _path_params['whitelistedAddressId'] = whitelisted_address_id
        if id is not None:
            _path_params['id'] = id
        # process the query parameters
        # process the header parameters
        # process the form parameters
        # process the body parameter


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json'
                ]
            )


        # authentication setting
        _auth_settings: List[str] = [
            'ApiKeyTPV1'
        ]

        return self.api_client.param_serialize(
            method='GET',
            resource_path='/api/rest/v1/whitelists/addresses/{whitelistedAddressId}/attributes/{id}',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def whitelist_service_get_whitelisted_addresses(
        self,
        limit: Annotated[Optional[StrictStr], Field(description="uint64; Return maximum `limit` items for a query; Max 100.")] = None,
        offset: Annotated[Optional[StrictStr], Field(description="uint64; Start retrieving items starting at `offset` id")] = None,
        exchange_account_id: Annotated[Optional[StrictStr], Field(description="uint64; **Deprecated:** Use exchangeAccountIds instead")] = None,
        address_type: Annotated[Optional[StrictStr], Field(description="Can be one of the following: `individual`, `exchange`, `baker`, `stakepool`, `contract`, `validator`, node, `fiatprovider`")] = None,
        query: Annotated[Optional[StrictStr], Field(description="Will find a match in any part of the value. Filter applies to the following fields: `customerid`, `address`, `blockchain`, `label`, `memo`, `addresstype`")] = None,
        currency: Annotated[Optional[StrictStr], Field(description="**Deprecated:** Use `blockchain` instead")] = None,
        score_provider: Annotated[Optional[StrictStr], Field(description="**Deprecated:** Use `scoreFilter` instead. Can be either of the following: `scorechain`, `coinfirm`, `chainalysis`, `elliptic`, `trmlabs`")] = None,
        score_in_below: Annotated[Optional[StrictStr], Field(description="numeric; **Deprecated:** Use `scoreFilter` instead")] = None,
        score_out_below: Annotated[Optional[StrictStr], Field(description="numeric; **Deprecated:** Use `scoreFilter` instead")] = None,
        score_exclusive: Annotated[Optional[StrictBool], Field(description="**Deprecated:** Use `scoreFilter` instead")] = None,
        rules_container_normalized: Annotated[Optional[StrictBool], Field(description="Normalize rules containers in its own object")] = None,
        exchange_account_ids: Annotated[Optional[List[StrictStr]], Field(description="uint64; Array containing the list of IDs for exchange accounts")] = None,
        coinfirm_score_greater: Annotated[Optional[StrictStr], Field(description="uint64; **Deprecated:** Use `scoreFilter` instead")] = None,
        tag_ids: Annotated[Optional[List[StrictStr]], Field(description="Filter addresses with a 'OR' combination of tag IDs")] = None,
        chainalysis_score_greater: Annotated[Optional[StrictStr], Field(description="uint64; **Deprecated:** Use `scoreFilter` instead")] = None,
        contract_type: Annotated[Optional[StrictStr], Field(description="**Deprecated:** Use `contractTypes` instead")] = None,
        allowed_for_address_id: Annotated[Optional[StrictStr], Field(description="uint64; Filter addresses allowed to receive funds from this address id")] = None,
        allowed_for_wallet_id: Annotated[Optional[StrictStr], Field(description="uint64; Filter addresses allowed to receive funds from this wallet id. Will be ignored if allowedForAddressId is filled")] = None,
        blockchain: Annotated[Optional[StrictStr], Field(description="Filter on the blockchain of the WLA.")] = None,
        include_for_approval: Annotated[Optional[StrictBool], Field(description="If true, include also addresses waiting for approval in the results.")] = None,
        addresses: Annotated[Optional[List[StrictStr]], Field(description="Filter on the specific addresses to return. This field is using the blockchain's native address syntax")] = None,
        network: Annotated[Optional[StrictStr], Field(description="Name of the blockchain network, eg. `mainnet`, `testnet`, or `sepolia`")] = None,
        ids: Annotated[Optional[List[StrictStr]], Field(description="uint64; List of IDs to return")] = None,
        tn_participant_id: Annotated[Optional[StrictStr], Field(description="uuid; UUID of the Taurus-NETWORK participant to whom the address belongs")] = None,
        score_filter_score_provider: Annotated[Optional[StrictStr], Field(description="Specify the score provider to filter on, or empty.Each provider has associated filter parameters that can be set.Supported values: `scorechain`, `coinfirm`, `chainalysis`, `elliptic`, `trmlabs`")] = None,
        score_filter_scorechain_filters_score_in_below: Annotated[Optional[StrictStr], Field(description="Filter addresses under a Scorechain incoming score threshold.")] = None,
        score_filter_scorechain_filters_score_out_below: Annotated[Optional[StrictStr], Field(description="Filter addresses under a Scorechain outgoing score threshold.")] = None,
        score_filter_scorechain_filters_score_exclusive: Annotated[Optional[StrictBool], Field(description="By default when both Scorechain scores scoreInBelow and scoreOutBelow are provided, it returns the addresses matching (scoreInBelow AND scoreOutBelow). When scoreExclusive is set to true, it will return the addresses matching (scoreInBelow OR scoreOutBelow).")] = None,
        score_filter_coinfirm_filters_score_greater: Annotated[Optional[StrictStr], Field(description="Filter addresses with a Coinfirm C-score above threshold.")] = None,
        score_filter_chainalysis_filters_score_greater: Annotated[Optional[StrictStr], Field(description="Filter addresses with a Chainalysis risk score above threshold.")] = None,
        score_filter_elliptic_filters_score_greater: Annotated[Optional[StrictStr], Field(description="Filter addresses with an Elliptic risk score above threshold.")] = None,
        score_filter_trmlabs_filters_score_greater: Annotated[Optional[StrictStr], Field(description="Filter addresses with an TRM Labs risk score above threshold.")] = None,
        last_incoming_tx_from_whitelisted_address: Annotated[Optional[datetime], Field(description="Filtered addresses with the last incoming transaction older than lastIncomingTransactionDate  won't appear in the result. The default value is never")] = None,
        contract_types: Annotated[Optional[List[StrictStr]], Field(description="Filter addresses by multiple Contract Types. Can be any of: `GENERIC`, `CMTA20`, `CMTA20-KYC`, `CMTA20-RULEENGINE`, `CMTAT`, `ERC20`, `DEFI`, `ERC2771-PROXY-ADMIN`, `TERC1155A`, `GSN_FORWARDER`, `OPEN_ZEPPELIN_FORWARDER`, `TAURUS_CONTRACT_CREATOR`, `SMARTPY-FA2`, `SMARTPY-FA12`, `ASA`, `FIGMENT_STAKING`")] = None,
        attribute_filters_json: Annotated[Optional[StrictStr], Field(description="A JSON representation of a list of AttributeFilter objects. The filters are combined with an attributeFiltersOperator ('OR' by default). Each AttributeFilter can use different comparison operators: `=` (default if not specified), `<>` (not equal), `>` (greater than), `>=` (greater than or equal), `<` (less than), `<=` (less than or equal)")] = None,
        attribute_filters_operator: Annotated[Optional[StrictStr], Field(description="Specifies how attribute filters are combined. Accepted values: 'OR' (default), 'AND'.")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> TgvalidatordGetSignedWhitelistedAddressEnvelopesReply:
        """List whitelisted addresses

        This endpoint returns a list of whitelisted addresses

        :param limit: uint64; Return maximum `limit` items for a query; Max 100.
        :type limit: str
        :param offset: uint64; Start retrieving items starting at `offset` id
        :type offset: str
        :param exchange_account_id: uint64; **Deprecated:** Use exchangeAccountIds instead
        :type exchange_account_id: str
        :param address_type: Can be one of the following: `individual`, `exchange`, `baker`, `stakepool`, `contract`, `validator`, node, `fiatprovider`
        :type address_type: str
        :param query: Will find a match in any part of the value. Filter applies to the following fields: `customerid`, `address`, `blockchain`, `label`, `memo`, `addresstype`
        :type query: str
        :param currency: **Deprecated:** Use `blockchain` instead
        :type currency: str
        :param score_provider: **Deprecated:** Use `scoreFilter` instead. Can be either of the following: `scorechain`, `coinfirm`, `chainalysis`, `elliptic`, `trmlabs`
        :type score_provider: str
        :param score_in_below: numeric; **Deprecated:** Use `scoreFilter` instead
        :type score_in_below: str
        :param score_out_below: numeric; **Deprecated:** Use `scoreFilter` instead
        :type score_out_below: str
        :param score_exclusive: **Deprecated:** Use `scoreFilter` instead
        :type score_exclusive: bool
        :param rules_container_normalized: Normalize rules containers in its own object
        :type rules_container_normalized: bool
        :param exchange_account_ids: uint64; Array containing the list of IDs for exchange accounts
        :type exchange_account_ids: List[str]
        :param coinfirm_score_greater: uint64; **Deprecated:** Use `scoreFilter` instead
        :type coinfirm_score_greater: str
        :param tag_ids: Filter addresses with a 'OR' combination of tag IDs
        :type tag_ids: List[str]
        :param chainalysis_score_greater: uint64; **Deprecated:** Use `scoreFilter` instead
        :type chainalysis_score_greater: str
        :param contract_type: **Deprecated:** Use `contractTypes` instead
        :type contract_type: str
        :param allowed_for_address_id: uint64; Filter addresses allowed to receive funds from this address id
        :type allowed_for_address_id: str
        :param allowed_for_wallet_id: uint64; Filter addresses allowed to receive funds from this wallet id. Will be ignored if allowedForAddressId is filled
        :type allowed_for_wallet_id: str
        :param blockchain: Filter on the blockchain of the WLA.
        :type blockchain: str
        :param include_for_approval: If true, include also addresses waiting for approval in the results.
        :type include_for_approval: bool
        :param addresses: Filter on the specific addresses to return. This field is using the blockchain's native address syntax
        :type addresses: List[str]
        :param network: Name of the blockchain network, eg. `mainnet`, `testnet`, or `sepolia`
        :type network: str
        :param ids: uint64; List of IDs to return
        :type ids: List[str]
        :param tn_participant_id: uuid; UUID of the Taurus-NETWORK participant to whom the address belongs
        :type tn_participant_id: str
        :param score_filter_score_provider: Specify the score provider to filter on, or empty.Each provider has associated filter parameters that can be set.Supported values: `scorechain`, `coinfirm`, `chainalysis`, `elliptic`, `trmlabs`
        :type score_filter_score_provider: str
        :param score_filter_scorechain_filters_score_in_below: Filter addresses under a Scorechain incoming score threshold.
        :type score_filter_scorechain_filters_score_in_below: str
        :param score_filter_scorechain_filters_score_out_below: Filter addresses under a Scorechain outgoing score threshold.
        :type score_filter_scorechain_filters_score_out_below: str
        :param score_filter_scorechain_filters_score_exclusive: By default when both Scorechain scores scoreInBelow and scoreOutBelow are provided, it returns the addresses matching (scoreInBelow AND scoreOutBelow). When scoreExclusive is set to true, it will return the addresses matching (scoreInBelow OR scoreOutBelow).
        :type score_filter_scorechain_filters_score_exclusive: bool
        :param score_filter_coinfirm_filters_score_greater: Filter addresses with a Coinfirm C-score above threshold.
        :type score_filter_coinfirm_filters_score_greater: str
        :param score_filter_chainalysis_filters_score_greater: Filter addresses with a Chainalysis risk score above threshold.
        :type score_filter_chainalysis_filters_score_greater: str
        :param score_filter_elliptic_filters_score_greater: Filter addresses with an Elliptic risk score above threshold.
        :type score_filter_elliptic_filters_score_greater: str
        :param score_filter_trmlabs_filters_score_greater: Filter addresses with an TRM Labs risk score above threshold.
        :type score_filter_trmlabs_filters_score_greater: str
        :param last_incoming_tx_from_whitelisted_address: Filtered addresses with the last incoming transaction older than lastIncomingTransactionDate  won't appear in the result. The default value is never
        :type last_incoming_tx_from_whitelisted_address: datetime
        :param contract_types: Filter addresses by multiple Contract Types. Can be any of: `GENERIC`, `CMTA20`, `CMTA20-KYC`, `CMTA20-RULEENGINE`, `CMTAT`, `ERC20`, `DEFI`, `ERC2771-PROXY-ADMIN`, `TERC1155A`, `GSN_FORWARDER`, `OPEN_ZEPPELIN_FORWARDER`, `TAURUS_CONTRACT_CREATOR`, `SMARTPY-FA2`, `SMARTPY-FA12`, `ASA`, `FIGMENT_STAKING`
        :type contract_types: List[str]
        :param attribute_filters_json: A JSON representation of a list of AttributeFilter objects. The filters are combined with an attributeFiltersOperator ('OR' by default). Each AttributeFilter can use different comparison operators: `=` (default if not specified), `<>` (not equal), `>` (greater than), `>=` (greater than or equal), `<` (less than), `<=` (less than or equal)
        :type attribute_filters_json: str
        :param attribute_filters_operator: Specifies how attribute filters are combined. Accepted values: 'OR' (default), 'AND'.
        :type attribute_filters_operator: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._whitelist_service_get_whitelisted_addresses_serialize(
            limit=limit,
            offset=offset,
            exchange_account_id=exchange_account_id,
            address_type=address_type,
            query=query,
            currency=currency,
            score_provider=score_provider,
            score_in_below=score_in_below,
            score_out_below=score_out_below,
            score_exclusive=score_exclusive,
            rules_container_normalized=rules_container_normalized,
            exchange_account_ids=exchange_account_ids,
            coinfirm_score_greater=coinfirm_score_greater,
            tag_ids=tag_ids,
            chainalysis_score_greater=chainalysis_score_greater,
            contract_type=contract_type,
            allowed_for_address_id=allowed_for_address_id,
            allowed_for_wallet_id=allowed_for_wallet_id,
            blockchain=blockchain,
            include_for_approval=include_for_approval,
            addresses=addresses,
            network=network,
            ids=ids,
            tn_participant_id=tn_participant_id,
            score_filter_score_provider=score_filter_score_provider,
            score_filter_scorechain_filters_score_in_below=score_filter_scorechain_filters_score_in_below,
            score_filter_scorechain_filters_score_out_below=score_filter_scorechain_filters_score_out_below,
            score_filter_scorechain_filters_score_exclusive=score_filter_scorechain_filters_score_exclusive,
            score_filter_coinfirm_filters_score_greater=score_filter_coinfirm_filters_score_greater,
            score_filter_chainalysis_filters_score_greater=score_filter_chainalysis_filters_score_greater,
            score_filter_elliptic_filters_score_greater=score_filter_elliptic_filters_score_greater,
            score_filter_trmlabs_filters_score_greater=score_filter_trmlabs_filters_score_greater,
            last_incoming_tx_from_whitelisted_address=last_incoming_tx_from_whitelisted_address,
            contract_types=contract_types,
            attribute_filters_json=attribute_filters_json,
            attribute_filters_operator=attribute_filters_operator,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "TgvalidatordGetSignedWhitelistedAddressEnvelopesReply",
            '400': "object",
            '401': "object",
            '403': "object",
            '404': "object",
            '500': "object",
            '503': "object",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def whitelist_service_get_whitelisted_addresses_with_http_info(
        self,
        limit: Annotated[Optional[StrictStr], Field(description="uint64; Return maximum `limit` items for a query; Max 100.")] = None,
        offset: Annotated[Optional[StrictStr], Field(description="uint64; Start retrieving items starting at `offset` id")] = None,
        exchange_account_id: Annotated[Optional[StrictStr], Field(description="uint64; **Deprecated:** Use exchangeAccountIds instead")] = None,
        address_type: Annotated[Optional[StrictStr], Field(description="Can be one of the following: `individual`, `exchange`, `baker`, `stakepool`, `contract`, `validator`, node, `fiatprovider`")] = None,
        query: Annotated[Optional[StrictStr], Field(description="Will find a match in any part of the value. Filter applies to the following fields: `customerid`, `address`, `blockchain`, `label`, `memo`, `addresstype`")] = None,
        currency: Annotated[Optional[StrictStr], Field(description="**Deprecated:** Use `blockchain` instead")] = None,
        score_provider: Annotated[Optional[StrictStr], Field(description="**Deprecated:** Use `scoreFilter` instead. Can be either of the following: `scorechain`, `coinfirm`, `chainalysis`, `elliptic`, `trmlabs`")] = None,
        score_in_below: Annotated[Optional[StrictStr], Field(description="numeric; **Deprecated:** Use `scoreFilter` instead")] = None,
        score_out_below: Annotated[Optional[StrictStr], Field(description="numeric; **Deprecated:** Use `scoreFilter` instead")] = None,
        score_exclusive: Annotated[Optional[StrictBool], Field(description="**Deprecated:** Use `scoreFilter` instead")] = None,
        rules_container_normalized: Annotated[Optional[StrictBool], Field(description="Normalize rules containers in its own object")] = None,
        exchange_account_ids: Annotated[Optional[List[StrictStr]], Field(description="uint64; Array containing the list of IDs for exchange accounts")] = None,
        coinfirm_score_greater: Annotated[Optional[StrictStr], Field(description="uint64; **Deprecated:** Use `scoreFilter` instead")] = None,
        tag_ids: Annotated[Optional[List[StrictStr]], Field(description="Filter addresses with a 'OR' combination of tag IDs")] = None,
        chainalysis_score_greater: Annotated[Optional[StrictStr], Field(description="uint64; **Deprecated:** Use `scoreFilter` instead")] = None,
        contract_type: Annotated[Optional[StrictStr], Field(description="**Deprecated:** Use `contractTypes` instead")] = None,
        allowed_for_address_id: Annotated[Optional[StrictStr], Field(description="uint64; Filter addresses allowed to receive funds from this address id")] = None,
        allowed_for_wallet_id: Annotated[Optional[StrictStr], Field(description="uint64; Filter addresses allowed to receive funds from this wallet id. Will be ignored if allowedForAddressId is filled")] = None,
        blockchain: Annotated[Optional[StrictStr], Field(description="Filter on the blockchain of the WLA.")] = None,
        include_for_approval: Annotated[Optional[StrictBool], Field(description="If true, include also addresses waiting for approval in the results.")] = None,
        addresses: Annotated[Optional[List[StrictStr]], Field(description="Filter on the specific addresses to return. This field is using the blockchain's native address syntax")] = None,
        network: Annotated[Optional[StrictStr], Field(description="Name of the blockchain network, eg. `mainnet`, `testnet`, or `sepolia`")] = None,
        ids: Annotated[Optional[List[StrictStr]], Field(description="uint64; List of IDs to return")] = None,
        tn_participant_id: Annotated[Optional[StrictStr], Field(description="uuid; UUID of the Taurus-NETWORK participant to whom the address belongs")] = None,
        score_filter_score_provider: Annotated[Optional[StrictStr], Field(description="Specify the score provider to filter on, or empty.Each provider has associated filter parameters that can be set.Supported values: `scorechain`, `coinfirm`, `chainalysis`, `elliptic`, `trmlabs`")] = None,
        score_filter_scorechain_filters_score_in_below: Annotated[Optional[StrictStr], Field(description="Filter addresses under a Scorechain incoming score threshold.")] = None,
        score_filter_scorechain_filters_score_out_below: Annotated[Optional[StrictStr], Field(description="Filter addresses under a Scorechain outgoing score threshold.")] = None,
        score_filter_scorechain_filters_score_exclusive: Annotated[Optional[StrictBool], Field(description="By default when both Scorechain scores scoreInBelow and scoreOutBelow are provided, it returns the addresses matching (scoreInBelow AND scoreOutBelow). When scoreExclusive is set to true, it will return the addresses matching (scoreInBelow OR scoreOutBelow).")] = None,
        score_filter_coinfirm_filters_score_greater: Annotated[Optional[StrictStr], Field(description="Filter addresses with a Coinfirm C-score above threshold.")] = None,
        score_filter_chainalysis_filters_score_greater: Annotated[Optional[StrictStr], Field(description="Filter addresses with a Chainalysis risk score above threshold.")] = None,
        score_filter_elliptic_filters_score_greater: Annotated[Optional[StrictStr], Field(description="Filter addresses with an Elliptic risk score above threshold.")] = None,
        score_filter_trmlabs_filters_score_greater: Annotated[Optional[StrictStr], Field(description="Filter addresses with an TRM Labs risk score above threshold.")] = None,
        last_incoming_tx_from_whitelisted_address: Annotated[Optional[datetime], Field(description="Filtered addresses with the last incoming transaction older than lastIncomingTransactionDate  won't appear in the result. The default value is never")] = None,
        contract_types: Annotated[Optional[List[StrictStr]], Field(description="Filter addresses by multiple Contract Types. Can be any of: `GENERIC`, `CMTA20`, `CMTA20-KYC`, `CMTA20-RULEENGINE`, `CMTAT`, `ERC20`, `DEFI`, `ERC2771-PROXY-ADMIN`, `TERC1155A`, `GSN_FORWARDER`, `OPEN_ZEPPELIN_FORWARDER`, `TAURUS_CONTRACT_CREATOR`, `SMARTPY-FA2`, `SMARTPY-FA12`, `ASA`, `FIGMENT_STAKING`")] = None,
        attribute_filters_json: Annotated[Optional[StrictStr], Field(description="A JSON representation of a list of AttributeFilter objects. The filters are combined with an attributeFiltersOperator ('OR' by default). Each AttributeFilter can use different comparison operators: `=` (default if not specified), `<>` (not equal), `>` (greater than), `>=` (greater than or equal), `<` (less than), `<=` (less than or equal)")] = None,
        attribute_filters_operator: Annotated[Optional[StrictStr], Field(description="Specifies how attribute filters are combined. Accepted values: 'OR' (default), 'AND'.")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[TgvalidatordGetSignedWhitelistedAddressEnvelopesReply]:
        """List whitelisted addresses

        This endpoint returns a list of whitelisted addresses

        :param limit: uint64; Return maximum `limit` items for a query; Max 100.
        :type limit: str
        :param offset: uint64; Start retrieving items starting at `offset` id
        :type offset: str
        :param exchange_account_id: uint64; **Deprecated:** Use exchangeAccountIds instead
        :type exchange_account_id: str
        :param address_type: Can be one of the following: `individual`, `exchange`, `baker`, `stakepool`, `contract`, `validator`, node, `fiatprovider`
        :type address_type: str
        :param query: Will find a match in any part of the value. Filter applies to the following fields: `customerid`, `address`, `blockchain`, `label`, `memo`, `addresstype`
        :type query: str
        :param currency: **Deprecated:** Use `blockchain` instead
        :type currency: str
        :param score_provider: **Deprecated:** Use `scoreFilter` instead. Can be either of the following: `scorechain`, `coinfirm`, `chainalysis`, `elliptic`, `trmlabs`
        :type score_provider: str
        :param score_in_below: numeric; **Deprecated:** Use `scoreFilter` instead
        :type score_in_below: str
        :param score_out_below: numeric; **Deprecated:** Use `scoreFilter` instead
        :type score_out_below: str
        :param score_exclusive: **Deprecated:** Use `scoreFilter` instead
        :type score_exclusive: bool
        :param rules_container_normalized: Normalize rules containers in its own object
        :type rules_container_normalized: bool
        :param exchange_account_ids: uint64; Array containing the list of IDs for exchange accounts
        :type exchange_account_ids: List[str]
        :param coinfirm_score_greater: uint64; **Deprecated:** Use `scoreFilter` instead
        :type coinfirm_score_greater: str
        :param tag_ids: Filter addresses with a 'OR' combination of tag IDs
        :type tag_ids: List[str]
        :param chainalysis_score_greater: uint64; **Deprecated:** Use `scoreFilter` instead
        :type chainalysis_score_greater: str
        :param contract_type: **Deprecated:** Use `contractTypes` instead
        :type contract_type: str
        :param allowed_for_address_id: uint64; Filter addresses allowed to receive funds from this address id
        :type allowed_for_address_id: str
        :param allowed_for_wallet_id: uint64; Filter addresses allowed to receive funds from this wallet id. Will be ignored if allowedForAddressId is filled
        :type allowed_for_wallet_id: str
        :param blockchain: Filter on the blockchain of the WLA.
        :type blockchain: str
        :param include_for_approval: If true, include also addresses waiting for approval in the results.
        :type include_for_approval: bool
        :param addresses: Filter on the specific addresses to return. This field is using the blockchain's native address syntax
        :type addresses: List[str]
        :param network: Name of the blockchain network, eg. `mainnet`, `testnet`, or `sepolia`
        :type network: str
        :param ids: uint64; List of IDs to return
        :type ids: List[str]
        :param tn_participant_id: uuid; UUID of the Taurus-NETWORK participant to whom the address belongs
        :type tn_participant_id: str
        :param score_filter_score_provider: Specify the score provider to filter on, or empty.Each provider has associated filter parameters that can be set.Supported values: `scorechain`, `coinfirm`, `chainalysis`, `elliptic`, `trmlabs`
        :type score_filter_score_provider: str
        :param score_filter_scorechain_filters_score_in_below: Filter addresses under a Scorechain incoming score threshold.
        :type score_filter_scorechain_filters_score_in_below: str
        :param score_filter_scorechain_filters_score_out_below: Filter addresses under a Scorechain outgoing score threshold.
        :type score_filter_scorechain_filters_score_out_below: str
        :param score_filter_scorechain_filters_score_exclusive: By default when both Scorechain scores scoreInBelow and scoreOutBelow are provided, it returns the addresses matching (scoreInBelow AND scoreOutBelow). When scoreExclusive is set to true, it will return the addresses matching (scoreInBelow OR scoreOutBelow).
        :type score_filter_scorechain_filters_score_exclusive: bool
        :param score_filter_coinfirm_filters_score_greater: Filter addresses with a Coinfirm C-score above threshold.
        :type score_filter_coinfirm_filters_score_greater: str
        :param score_filter_chainalysis_filters_score_greater: Filter addresses with a Chainalysis risk score above threshold.
        :type score_filter_chainalysis_filters_score_greater: str
        :param score_filter_elliptic_filters_score_greater: Filter addresses with an Elliptic risk score above threshold.
        :type score_filter_elliptic_filters_score_greater: str
        :param score_filter_trmlabs_filters_score_greater: Filter addresses with an TRM Labs risk score above threshold.
        :type score_filter_trmlabs_filters_score_greater: str
        :param last_incoming_tx_from_whitelisted_address: Filtered addresses with the last incoming transaction older than lastIncomingTransactionDate  won't appear in the result. The default value is never
        :type last_incoming_tx_from_whitelisted_address: datetime
        :param contract_types: Filter addresses by multiple Contract Types. Can be any of: `GENERIC`, `CMTA20`, `CMTA20-KYC`, `CMTA20-RULEENGINE`, `CMTAT`, `ERC20`, `DEFI`, `ERC2771-PROXY-ADMIN`, `TERC1155A`, `GSN_FORWARDER`, `OPEN_ZEPPELIN_FORWARDER`, `TAURUS_CONTRACT_CREATOR`, `SMARTPY-FA2`, `SMARTPY-FA12`, `ASA`, `FIGMENT_STAKING`
        :type contract_types: List[str]
        :param attribute_filters_json: A JSON representation of a list of AttributeFilter objects. The filters are combined with an attributeFiltersOperator ('OR' by default). Each AttributeFilter can use different comparison operators: `=` (default if not specified), `<>` (not equal), `>` (greater than), `>=` (greater than or equal), `<` (less than), `<=` (less than or equal)
        :type attribute_filters_json: str
        :param attribute_filters_operator: Specifies how attribute filters are combined. Accepted values: 'OR' (default), 'AND'.
        :type attribute_filters_operator: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._whitelist_service_get_whitelisted_addresses_serialize(
            limit=limit,
            offset=offset,
            exchange_account_id=exchange_account_id,
            address_type=address_type,
            query=query,
            currency=currency,
            score_provider=score_provider,
            score_in_below=score_in_below,
            score_out_below=score_out_below,
            score_exclusive=score_exclusive,
            rules_container_normalized=rules_container_normalized,
            exchange_account_ids=exchange_account_ids,
            coinfirm_score_greater=coinfirm_score_greater,
            tag_ids=tag_ids,
            chainalysis_score_greater=chainalysis_score_greater,
            contract_type=contract_type,
            allowed_for_address_id=allowed_for_address_id,
            allowed_for_wallet_id=allowed_for_wallet_id,
            blockchain=blockchain,
            include_for_approval=include_for_approval,
            addresses=addresses,
            network=network,
            ids=ids,
            tn_participant_id=tn_participant_id,
            score_filter_score_provider=score_filter_score_provider,
            score_filter_scorechain_filters_score_in_below=score_filter_scorechain_filters_score_in_below,
            score_filter_scorechain_filters_score_out_below=score_filter_scorechain_filters_score_out_below,
            score_filter_scorechain_filters_score_exclusive=score_filter_scorechain_filters_score_exclusive,
            score_filter_coinfirm_filters_score_greater=score_filter_coinfirm_filters_score_greater,
            score_filter_chainalysis_filters_score_greater=score_filter_chainalysis_filters_score_greater,
            score_filter_elliptic_filters_score_greater=score_filter_elliptic_filters_score_greater,
            score_filter_trmlabs_filters_score_greater=score_filter_trmlabs_filters_score_greater,
            last_incoming_tx_from_whitelisted_address=last_incoming_tx_from_whitelisted_address,
            contract_types=contract_types,
            attribute_filters_json=attribute_filters_json,
            attribute_filters_operator=attribute_filters_operator,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "TgvalidatordGetSignedWhitelistedAddressEnvelopesReply",
            '400': "object",
            '401': "object",
            '403': "object",
            '404': "object",
            '500': "object",
            '503': "object",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def whitelist_service_get_whitelisted_addresses_without_preload_content(
        self,
        limit: Annotated[Optional[StrictStr], Field(description="uint64; Return maximum `limit` items for a query; Max 100.")] = None,
        offset: Annotated[Optional[StrictStr], Field(description="uint64; Start retrieving items starting at `offset` id")] = None,
        exchange_account_id: Annotated[Optional[StrictStr], Field(description="uint64; **Deprecated:** Use exchangeAccountIds instead")] = None,
        address_type: Annotated[Optional[StrictStr], Field(description="Can be one of the following: `individual`, `exchange`, `baker`, `stakepool`, `contract`, `validator`, node, `fiatprovider`")] = None,
        query: Annotated[Optional[StrictStr], Field(description="Will find a match in any part of the value. Filter applies to the following fields: `customerid`, `address`, `blockchain`, `label`, `memo`, `addresstype`")] = None,
        currency: Annotated[Optional[StrictStr], Field(description="**Deprecated:** Use `blockchain` instead")] = None,
        score_provider: Annotated[Optional[StrictStr], Field(description="**Deprecated:** Use `scoreFilter` instead. Can be either of the following: `scorechain`, `coinfirm`, `chainalysis`, `elliptic`, `trmlabs`")] = None,
        score_in_below: Annotated[Optional[StrictStr], Field(description="numeric; **Deprecated:** Use `scoreFilter` instead")] = None,
        score_out_below: Annotated[Optional[StrictStr], Field(description="numeric; **Deprecated:** Use `scoreFilter` instead")] = None,
        score_exclusive: Annotated[Optional[StrictBool], Field(description="**Deprecated:** Use `scoreFilter` instead")] = None,
        rules_container_normalized: Annotated[Optional[StrictBool], Field(description="Normalize rules containers in its own object")] = None,
        exchange_account_ids: Annotated[Optional[List[StrictStr]], Field(description="uint64; Array containing the list of IDs for exchange accounts")] = None,
        coinfirm_score_greater: Annotated[Optional[StrictStr], Field(description="uint64; **Deprecated:** Use `scoreFilter` instead")] = None,
        tag_ids: Annotated[Optional[List[StrictStr]], Field(description="Filter addresses with a 'OR' combination of tag IDs")] = None,
        chainalysis_score_greater: Annotated[Optional[StrictStr], Field(description="uint64; **Deprecated:** Use `scoreFilter` instead")] = None,
        contract_type: Annotated[Optional[StrictStr], Field(description="**Deprecated:** Use `contractTypes` instead")] = None,
        allowed_for_address_id: Annotated[Optional[StrictStr], Field(description="uint64; Filter addresses allowed to receive funds from this address id")] = None,
        allowed_for_wallet_id: Annotated[Optional[StrictStr], Field(description="uint64; Filter addresses allowed to receive funds from this wallet id. Will be ignored if allowedForAddressId is filled")] = None,
        blockchain: Annotated[Optional[StrictStr], Field(description="Filter on the blockchain of the WLA.")] = None,
        include_for_approval: Annotated[Optional[StrictBool], Field(description="If true, include also addresses waiting for approval in the results.")] = None,
        addresses: Annotated[Optional[List[StrictStr]], Field(description="Filter on the specific addresses to return. This field is using the blockchain's native address syntax")] = None,
        network: Annotated[Optional[StrictStr], Field(description="Name of the blockchain network, eg. `mainnet`, `testnet`, or `sepolia`")] = None,
        ids: Annotated[Optional[List[StrictStr]], Field(description="uint64; List of IDs to return")] = None,
        tn_participant_id: Annotated[Optional[StrictStr], Field(description="uuid; UUID of the Taurus-NETWORK participant to whom the address belongs")] = None,
        score_filter_score_provider: Annotated[Optional[StrictStr], Field(description="Specify the score provider to filter on, or empty.Each provider has associated filter parameters that can be set.Supported values: `scorechain`, `coinfirm`, `chainalysis`, `elliptic`, `trmlabs`")] = None,
        score_filter_scorechain_filters_score_in_below: Annotated[Optional[StrictStr], Field(description="Filter addresses under a Scorechain incoming score threshold.")] = None,
        score_filter_scorechain_filters_score_out_below: Annotated[Optional[StrictStr], Field(description="Filter addresses under a Scorechain outgoing score threshold.")] = None,
        score_filter_scorechain_filters_score_exclusive: Annotated[Optional[StrictBool], Field(description="By default when both Scorechain scores scoreInBelow and scoreOutBelow are provided, it returns the addresses matching (scoreInBelow AND scoreOutBelow). When scoreExclusive is set to true, it will return the addresses matching (scoreInBelow OR scoreOutBelow).")] = None,
        score_filter_coinfirm_filters_score_greater: Annotated[Optional[StrictStr], Field(description="Filter addresses with a Coinfirm C-score above threshold.")] = None,
        score_filter_chainalysis_filters_score_greater: Annotated[Optional[StrictStr], Field(description="Filter addresses with a Chainalysis risk score above threshold.")] = None,
        score_filter_elliptic_filters_score_greater: Annotated[Optional[StrictStr], Field(description="Filter addresses with an Elliptic risk score above threshold.")] = None,
        score_filter_trmlabs_filters_score_greater: Annotated[Optional[StrictStr], Field(description="Filter addresses with an TRM Labs risk score above threshold.")] = None,
        last_incoming_tx_from_whitelisted_address: Annotated[Optional[datetime], Field(description="Filtered addresses with the last incoming transaction older than lastIncomingTransactionDate  won't appear in the result. The default value is never")] = None,
        contract_types: Annotated[Optional[List[StrictStr]], Field(description="Filter addresses by multiple Contract Types. Can be any of: `GENERIC`, `CMTA20`, `CMTA20-KYC`, `CMTA20-RULEENGINE`, `CMTAT`, `ERC20`, `DEFI`, `ERC2771-PROXY-ADMIN`, `TERC1155A`, `GSN_FORWARDER`, `OPEN_ZEPPELIN_FORWARDER`, `TAURUS_CONTRACT_CREATOR`, `SMARTPY-FA2`, `SMARTPY-FA12`, `ASA`, `FIGMENT_STAKING`")] = None,
        attribute_filters_json: Annotated[Optional[StrictStr], Field(description="A JSON representation of a list of AttributeFilter objects. The filters are combined with an attributeFiltersOperator ('OR' by default). Each AttributeFilter can use different comparison operators: `=` (default if not specified), `<>` (not equal), `>` (greater than), `>=` (greater than or equal), `<` (less than), `<=` (less than or equal)")] = None,
        attribute_filters_operator: Annotated[Optional[StrictStr], Field(description="Specifies how attribute filters are combined. Accepted values: 'OR' (default), 'AND'.")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """List whitelisted addresses

        This endpoint returns a list of whitelisted addresses

        :param limit: uint64; Return maximum `limit` items for a query; Max 100.
        :type limit: str
        :param offset: uint64; Start retrieving items starting at `offset` id
        :type offset: str
        :param exchange_account_id: uint64; **Deprecated:** Use exchangeAccountIds instead
        :type exchange_account_id: str
        :param address_type: Can be one of the following: `individual`, `exchange`, `baker`, `stakepool`, `contract`, `validator`, node, `fiatprovider`
        :type address_type: str
        :param query: Will find a match in any part of the value. Filter applies to the following fields: `customerid`, `address`, `blockchain`, `label`, `memo`, `addresstype`
        :type query: str
        :param currency: **Deprecated:** Use `blockchain` instead
        :type currency: str
        :param score_provider: **Deprecated:** Use `scoreFilter` instead. Can be either of the following: `scorechain`, `coinfirm`, `chainalysis`, `elliptic`, `trmlabs`
        :type score_provider: str
        :param score_in_below: numeric; **Deprecated:** Use `scoreFilter` instead
        :type score_in_below: str
        :param score_out_below: numeric; **Deprecated:** Use `scoreFilter` instead
        :type score_out_below: str
        :param score_exclusive: **Deprecated:** Use `scoreFilter` instead
        :type score_exclusive: bool
        :param rules_container_normalized: Normalize rules containers in its own object
        :type rules_container_normalized: bool
        :param exchange_account_ids: uint64; Array containing the list of IDs for exchange accounts
        :type exchange_account_ids: List[str]
        :param coinfirm_score_greater: uint64; **Deprecated:** Use `scoreFilter` instead
        :type coinfirm_score_greater: str
        :param tag_ids: Filter addresses with a 'OR' combination of tag IDs
        :type tag_ids: List[str]
        :param chainalysis_score_greater: uint64; **Deprecated:** Use `scoreFilter` instead
        :type chainalysis_score_greater: str
        :param contract_type: **Deprecated:** Use `contractTypes` instead
        :type contract_type: str
        :param allowed_for_address_id: uint64; Filter addresses allowed to receive funds from this address id
        :type allowed_for_address_id: str
        :param allowed_for_wallet_id: uint64; Filter addresses allowed to receive funds from this wallet id. Will be ignored if allowedForAddressId is filled
        :type allowed_for_wallet_id: str
        :param blockchain: Filter on the blockchain of the WLA.
        :type blockchain: str
        :param include_for_approval: If true, include also addresses waiting for approval in the results.
        :type include_for_approval: bool
        :param addresses: Filter on the specific addresses to return. This field is using the blockchain's native address syntax
        :type addresses: List[str]
        :param network: Name of the blockchain network, eg. `mainnet`, `testnet`, or `sepolia`
        :type network: str
        :param ids: uint64; List of IDs to return
        :type ids: List[str]
        :param tn_participant_id: uuid; UUID of the Taurus-NETWORK participant to whom the address belongs
        :type tn_participant_id: str
        :param score_filter_score_provider: Specify the score provider to filter on, or empty.Each provider has associated filter parameters that can be set.Supported values: `scorechain`, `coinfirm`, `chainalysis`, `elliptic`, `trmlabs`
        :type score_filter_score_provider: str
        :param score_filter_scorechain_filters_score_in_below: Filter addresses under a Scorechain incoming score threshold.
        :type score_filter_scorechain_filters_score_in_below: str
        :param score_filter_scorechain_filters_score_out_below: Filter addresses under a Scorechain outgoing score threshold.
        :type score_filter_scorechain_filters_score_out_below: str
        :param score_filter_scorechain_filters_score_exclusive: By default when both Scorechain scores scoreInBelow and scoreOutBelow are provided, it returns the addresses matching (scoreInBelow AND scoreOutBelow). When scoreExclusive is set to true, it will return the addresses matching (scoreInBelow OR scoreOutBelow).
        :type score_filter_scorechain_filters_score_exclusive: bool
        :param score_filter_coinfirm_filters_score_greater: Filter addresses with a Coinfirm C-score above threshold.
        :type score_filter_coinfirm_filters_score_greater: str
        :param score_filter_chainalysis_filters_score_greater: Filter addresses with a Chainalysis risk score above threshold.
        :type score_filter_chainalysis_filters_score_greater: str
        :param score_filter_elliptic_filters_score_greater: Filter addresses with an Elliptic risk score above threshold.
        :type score_filter_elliptic_filters_score_greater: str
        :param score_filter_trmlabs_filters_score_greater: Filter addresses with an TRM Labs risk score above threshold.
        :type score_filter_trmlabs_filters_score_greater: str
        :param last_incoming_tx_from_whitelisted_address: Filtered addresses with the last incoming transaction older than lastIncomingTransactionDate  won't appear in the result. The default value is never
        :type last_incoming_tx_from_whitelisted_address: datetime
        :param contract_types: Filter addresses by multiple Contract Types. Can be any of: `GENERIC`, `CMTA20`, `CMTA20-KYC`, `CMTA20-RULEENGINE`, `CMTAT`, `ERC20`, `DEFI`, `ERC2771-PROXY-ADMIN`, `TERC1155A`, `GSN_FORWARDER`, `OPEN_ZEPPELIN_FORWARDER`, `TAURUS_CONTRACT_CREATOR`, `SMARTPY-FA2`, `SMARTPY-FA12`, `ASA`, `FIGMENT_STAKING`
        :type contract_types: List[str]
        :param attribute_filters_json: A JSON representation of a list of AttributeFilter objects. The filters are combined with an attributeFiltersOperator ('OR' by default). Each AttributeFilter can use different comparison operators: `=` (default if not specified), `<>` (not equal), `>` (greater than), `>=` (greater than or equal), `<` (less than), `<=` (less than or equal)
        :type attribute_filters_json: str
        :param attribute_filters_operator: Specifies how attribute filters are combined. Accepted values: 'OR' (default), 'AND'.
        :type attribute_filters_operator: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._whitelist_service_get_whitelisted_addresses_serialize(
            limit=limit,
            offset=offset,
            exchange_account_id=exchange_account_id,
            address_type=address_type,
            query=query,
            currency=currency,
            score_provider=score_provider,
            score_in_below=score_in_below,
            score_out_below=score_out_below,
            score_exclusive=score_exclusive,
            rules_container_normalized=rules_container_normalized,
            exchange_account_ids=exchange_account_ids,
            coinfirm_score_greater=coinfirm_score_greater,
            tag_ids=tag_ids,
            chainalysis_score_greater=chainalysis_score_greater,
            contract_type=contract_type,
            allowed_for_address_id=allowed_for_address_id,
            allowed_for_wallet_id=allowed_for_wallet_id,
            blockchain=blockchain,
            include_for_approval=include_for_approval,
            addresses=addresses,
            network=network,
            ids=ids,
            tn_participant_id=tn_participant_id,
            score_filter_score_provider=score_filter_score_provider,
            score_filter_scorechain_filters_score_in_below=score_filter_scorechain_filters_score_in_below,
            score_filter_scorechain_filters_score_out_below=score_filter_scorechain_filters_score_out_below,
            score_filter_scorechain_filters_score_exclusive=score_filter_scorechain_filters_score_exclusive,
            score_filter_coinfirm_filters_score_greater=score_filter_coinfirm_filters_score_greater,
            score_filter_chainalysis_filters_score_greater=score_filter_chainalysis_filters_score_greater,
            score_filter_elliptic_filters_score_greater=score_filter_elliptic_filters_score_greater,
            score_filter_trmlabs_filters_score_greater=score_filter_trmlabs_filters_score_greater,
            last_incoming_tx_from_whitelisted_address=last_incoming_tx_from_whitelisted_address,
            contract_types=contract_types,
            attribute_filters_json=attribute_filters_json,
            attribute_filters_operator=attribute_filters_operator,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "TgvalidatordGetSignedWhitelistedAddressEnvelopesReply",
            '400': "object",
            '401': "object",
            '403': "object",
            '404': "object",
            '500': "object",
            '503': "object",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _whitelist_service_get_whitelisted_addresses_serialize(
        self,
        limit,
        offset,
        exchange_account_id,
        address_type,
        query,
        currency,
        score_provider,
        score_in_below,
        score_out_below,
        score_exclusive,
        rules_container_normalized,
        exchange_account_ids,
        coinfirm_score_greater,
        tag_ids,
        chainalysis_score_greater,
        contract_type,
        allowed_for_address_id,
        allowed_for_wallet_id,
        blockchain,
        include_for_approval,
        addresses,
        network,
        ids,
        tn_participant_id,
        score_filter_score_provider,
        score_filter_scorechain_filters_score_in_below,
        score_filter_scorechain_filters_score_out_below,
        score_filter_scorechain_filters_score_exclusive,
        score_filter_coinfirm_filters_score_greater,
        score_filter_chainalysis_filters_score_greater,
        score_filter_elliptic_filters_score_greater,
        score_filter_trmlabs_filters_score_greater,
        last_incoming_tx_from_whitelisted_address,
        contract_types,
        attribute_filters_json,
        attribute_filters_operator,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
            'exchangeAccountIds': 'multi',
            'tagIDs': 'multi',
            'addresses': 'multi',
            'ids': 'multi',
            'contractTypes': 'multi',
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        # process the query parameters
        if limit is not None:
            
            _query_params.append(('limit', limit))
            
        if offset is not None:
            
            _query_params.append(('offset', offset))
            
        if exchange_account_id is not None:
            
            _query_params.append(('exchangeAccountId', exchange_account_id))
            
        if address_type is not None:
            
            _query_params.append(('addressType', address_type))
            
        if query is not None:
            
            _query_params.append(('query', query))
            
        if currency is not None:
            
            _query_params.append(('currency', currency))
            
        if score_provider is not None:
            
            _query_params.append(('scoreProvider', score_provider))
            
        if score_in_below is not None:
            
            _query_params.append(('scoreInBelow', score_in_below))
            
        if score_out_below is not None:
            
            _query_params.append(('scoreOutBelow', score_out_below))
            
        if score_exclusive is not None:
            
            _query_params.append(('scoreExclusive', score_exclusive))
            
        if rules_container_normalized is not None:
            
            _query_params.append(('rulesContainerNormalized', rules_container_normalized))
            
        if exchange_account_ids is not None:
            
            _query_params.append(('exchangeAccountIds', exchange_account_ids))
            
        if coinfirm_score_greater is not None:
            
            _query_params.append(('coinfirmScoreGreater', coinfirm_score_greater))
            
        if tag_ids is not None:
            
            _query_params.append(('tagIDs', tag_ids))
            
        if chainalysis_score_greater is not None:
            
            _query_params.append(('chainalysisScoreGreater', chainalysis_score_greater))
            
        if contract_type is not None:
            
            _query_params.append(('contractType', contract_type))
            
        if allowed_for_address_id is not None:
            
            _query_params.append(('allowedForAddressId', allowed_for_address_id))
            
        if allowed_for_wallet_id is not None:
            
            _query_params.append(('allowedForWalletId', allowed_for_wallet_id))
            
        if blockchain is not None:
            
            _query_params.append(('blockchain', blockchain))
            
        if include_for_approval is not None:
            
            _query_params.append(('includeForApproval', include_for_approval))
            
        if addresses is not None:
            
            _query_params.append(('addresses', addresses))
            
        if network is not None:
            
            _query_params.append(('network', network))
            
        if ids is not None:
            
            _query_params.append(('ids', ids))
            
        if tn_participant_id is not None:
            
            _query_params.append(('tnParticipantID', tn_participant_id))
            
        if score_filter_score_provider is not None:
            
            _query_params.append(('scoreFilter.scoreProvider', score_filter_score_provider))
            
        if score_filter_scorechain_filters_score_in_below is not None:
            
            _query_params.append(('scoreFilter.scorechainFilters.scoreInBelow', score_filter_scorechain_filters_score_in_below))
            
        if score_filter_scorechain_filters_score_out_below is not None:
            
            _query_params.append(('scoreFilter.scorechainFilters.scoreOutBelow', score_filter_scorechain_filters_score_out_below))
            
        if score_filter_scorechain_filters_score_exclusive is not None:
            
            _query_params.append(('scoreFilter.scorechainFilters.scoreExclusive', score_filter_scorechain_filters_score_exclusive))
            
        if score_filter_coinfirm_filters_score_greater is not None:
            
            _query_params.append(('scoreFilter.coinfirmFilters.scoreGreater', score_filter_coinfirm_filters_score_greater))
            
        if score_filter_chainalysis_filters_score_greater is not None:
            
            _query_params.append(('scoreFilter.chainalysisFilters.scoreGreater', score_filter_chainalysis_filters_score_greater))
            
        if score_filter_elliptic_filters_score_greater is not None:
            
            _query_params.append(('scoreFilter.ellipticFilters.scoreGreater', score_filter_elliptic_filters_score_greater))
            
        if score_filter_trmlabs_filters_score_greater is not None:
            
            _query_params.append(('scoreFilter.trmlabsFilters.scoreGreater', score_filter_trmlabs_filters_score_greater))
            
        if last_incoming_tx_from_whitelisted_address is not None:
            if isinstance(last_incoming_tx_from_whitelisted_address, datetime):
                _query_params.append(
                    (
                        'lastIncomingTxFromWhitelistedAddress',
                        last_incoming_tx_from_whitelisted_address.strftime(
                            self.api_client.configuration.datetime_format
                        )
                    )
                )
            else:
                _query_params.append(('lastIncomingTxFromWhitelistedAddress', last_incoming_tx_from_whitelisted_address))
            
        if contract_types is not None:
            
            _query_params.append(('contractTypes', contract_types))
            
        if attribute_filters_json is not None:
            
            _query_params.append(('attributeFiltersJson', attribute_filters_json))
            
        if attribute_filters_operator is not None:
            
            _query_params.append(('attributeFiltersOperator', attribute_filters_operator))
            
        # process the header parameters
        # process the form parameters
        # process the body parameter


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json'
                ]
            )


        # authentication setting
        _auth_settings: List[str] = [
            'ApiKeyTPV1'
        ]

        return self.api_client.param_serialize(
            method='GET',
            resource_path='/api/rest/v1/whitelists/addresses',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def whitelist_service_get_whitelisted_addresses_for_approval(
        self,
        limit: Annotated[Optional[StrictStr], Field(description="uint64; The amount of unapproved whitelisted address returned per request. Max 100.")] = None,
        offset: Annotated[Optional[StrictStr], Field(description="uint64; The offset from which to begin selection of unapproved whitelisted addresses.")] = None,
        ids: Annotated[Optional[List[StrictStr]], Field(description="uint64 Array; The ids to filter your requests selection by.")] = None,
        blockchain: Annotated[Optional[StrictStr], Field(description="The blockchain associated with the unapproved whitelisted addresses. (ex. eth, btc)")] = None,
        address_type: Annotated[Optional[StrictStr], Field(description="The type of unapproved whitelisted address (ex. individual, exchange, baker, contract, stakepool, validator, node, fiatprovider).")] = None,
        query: Annotated[Optional[StrictStr], Field(description="A search query to filter your request with. Will search the label or address fields.")] = None,
        network: Annotated[Optional[StrictStr], Field(description="The network of the associated blockchain the address is in. (ex. mainnet, sepolia)")] = None,
        include_already_signed_by_user: Annotated[Optional[StrictBool], Field(description="Set to true to include the pending approval whitelisted addresses already signed by the user. Default: false")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> TgvalidatordGetSignedWhitelistedAddressEnvelopesReply:
        """List whitelisted addresses for approval

        This endpoint returns a list of whitelisted addresses for approval

        :param limit: uint64; The amount of unapproved whitelisted address returned per request. Max 100.
        :type limit: str
        :param offset: uint64; The offset from which to begin selection of unapproved whitelisted addresses.
        :type offset: str
        :param ids: uint64 Array; The ids to filter your requests selection by.
        :type ids: List[str]
        :param blockchain: The blockchain associated with the unapproved whitelisted addresses. (ex. eth, btc)
        :type blockchain: str
        :param address_type: The type of unapproved whitelisted address (ex. individual, exchange, baker, contract, stakepool, validator, node, fiatprovider).
        :type address_type: str
        :param query: A search query to filter your request with. Will search the label or address fields.
        :type query: str
        :param network: The network of the associated blockchain the address is in. (ex. mainnet, sepolia)
        :type network: str
        :param include_already_signed_by_user: Set to true to include the pending approval whitelisted addresses already signed by the user. Default: false
        :type include_already_signed_by_user: bool
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._whitelist_service_get_whitelisted_addresses_for_approval_serialize(
            limit=limit,
            offset=offset,
            ids=ids,
            blockchain=blockchain,
            address_type=address_type,
            query=query,
            network=network,
            include_already_signed_by_user=include_already_signed_by_user,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "TgvalidatordGetSignedWhitelistedAddressEnvelopesReply",
            '400': "object",
            '401': "object",
            '403': "object",
            '404': "object",
            '500': "object",
            '503': "object",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def whitelist_service_get_whitelisted_addresses_for_approval_with_http_info(
        self,
        limit: Annotated[Optional[StrictStr], Field(description="uint64; The amount of unapproved whitelisted address returned per request. Max 100.")] = None,
        offset: Annotated[Optional[StrictStr], Field(description="uint64; The offset from which to begin selection of unapproved whitelisted addresses.")] = None,
        ids: Annotated[Optional[List[StrictStr]], Field(description="uint64 Array; The ids to filter your requests selection by.")] = None,
        blockchain: Annotated[Optional[StrictStr], Field(description="The blockchain associated with the unapproved whitelisted addresses. (ex. eth, btc)")] = None,
        address_type: Annotated[Optional[StrictStr], Field(description="The type of unapproved whitelisted address (ex. individual, exchange, baker, contract, stakepool, validator, node, fiatprovider).")] = None,
        query: Annotated[Optional[StrictStr], Field(description="A search query to filter your request with. Will search the label or address fields.")] = None,
        network: Annotated[Optional[StrictStr], Field(description="The network of the associated blockchain the address is in. (ex. mainnet, sepolia)")] = None,
        include_already_signed_by_user: Annotated[Optional[StrictBool], Field(description="Set to true to include the pending approval whitelisted addresses already signed by the user. Default: false")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[TgvalidatordGetSignedWhitelistedAddressEnvelopesReply]:
        """List whitelisted addresses for approval

        This endpoint returns a list of whitelisted addresses for approval

        :param limit: uint64; The amount of unapproved whitelisted address returned per request. Max 100.
        :type limit: str
        :param offset: uint64; The offset from which to begin selection of unapproved whitelisted addresses.
        :type offset: str
        :param ids: uint64 Array; The ids to filter your requests selection by.
        :type ids: List[str]
        :param blockchain: The blockchain associated with the unapproved whitelisted addresses. (ex. eth, btc)
        :type blockchain: str
        :param address_type: The type of unapproved whitelisted address (ex. individual, exchange, baker, contract, stakepool, validator, node, fiatprovider).
        :type address_type: str
        :param query: A search query to filter your request with. Will search the label or address fields.
        :type query: str
        :param network: The network of the associated blockchain the address is in. (ex. mainnet, sepolia)
        :type network: str
        :param include_already_signed_by_user: Set to true to include the pending approval whitelisted addresses already signed by the user. Default: false
        :type include_already_signed_by_user: bool
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._whitelist_service_get_whitelisted_addresses_for_approval_serialize(
            limit=limit,
            offset=offset,
            ids=ids,
            blockchain=blockchain,
            address_type=address_type,
            query=query,
            network=network,
            include_already_signed_by_user=include_already_signed_by_user,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "TgvalidatordGetSignedWhitelistedAddressEnvelopesReply",
            '400': "object",
            '401': "object",
            '403': "object",
            '404': "object",
            '500': "object",
            '503': "object",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def whitelist_service_get_whitelisted_addresses_for_approval_without_preload_content(
        self,
        limit: Annotated[Optional[StrictStr], Field(description="uint64; The amount of unapproved whitelisted address returned per request. Max 100.")] = None,
        offset: Annotated[Optional[StrictStr], Field(description="uint64; The offset from which to begin selection of unapproved whitelisted addresses.")] = None,
        ids: Annotated[Optional[List[StrictStr]], Field(description="uint64 Array; The ids to filter your requests selection by.")] = None,
        blockchain: Annotated[Optional[StrictStr], Field(description="The blockchain associated with the unapproved whitelisted addresses. (ex. eth, btc)")] = None,
        address_type: Annotated[Optional[StrictStr], Field(description="The type of unapproved whitelisted address (ex. individual, exchange, baker, contract, stakepool, validator, node, fiatprovider).")] = None,
        query: Annotated[Optional[StrictStr], Field(description="A search query to filter your request with. Will search the label or address fields.")] = None,
        network: Annotated[Optional[StrictStr], Field(description="The network of the associated blockchain the address is in. (ex. mainnet, sepolia)")] = None,
        include_already_signed_by_user: Annotated[Optional[StrictBool], Field(description="Set to true to include the pending approval whitelisted addresses already signed by the user. Default: false")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """List whitelisted addresses for approval

        This endpoint returns a list of whitelisted addresses for approval

        :param limit: uint64; The amount of unapproved whitelisted address returned per request. Max 100.
        :type limit: str
        :param offset: uint64; The offset from which to begin selection of unapproved whitelisted addresses.
        :type offset: str
        :param ids: uint64 Array; The ids to filter your requests selection by.
        :type ids: List[str]
        :param blockchain: The blockchain associated with the unapproved whitelisted addresses. (ex. eth, btc)
        :type blockchain: str
        :param address_type: The type of unapproved whitelisted address (ex. individual, exchange, baker, contract, stakepool, validator, node, fiatprovider).
        :type address_type: str
        :param query: A search query to filter your request with. Will search the label or address fields.
        :type query: str
        :param network: The network of the associated blockchain the address is in. (ex. mainnet, sepolia)
        :type network: str
        :param include_already_signed_by_user: Set to true to include the pending approval whitelisted addresses already signed by the user. Default: false
        :type include_already_signed_by_user: bool
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._whitelist_service_get_whitelisted_addresses_for_approval_serialize(
            limit=limit,
            offset=offset,
            ids=ids,
            blockchain=blockchain,
            address_type=address_type,
            query=query,
            network=network,
            include_already_signed_by_user=include_already_signed_by_user,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "TgvalidatordGetSignedWhitelistedAddressEnvelopesReply",
            '400': "object",
            '401': "object",
            '403': "object",
            '404': "object",
            '500': "object",
            '503': "object",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _whitelist_service_get_whitelisted_addresses_for_approval_serialize(
        self,
        limit,
        offset,
        ids,
        blockchain,
        address_type,
        query,
        network,
        include_already_signed_by_user,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
            'ids': 'multi',
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        # process the query parameters
        if limit is not None:
            
            _query_params.append(('limit', limit))
            
        if offset is not None:
            
            _query_params.append(('offset', offset))
            
        if ids is not None:
            
            _query_params.append(('ids', ids))
            
        if blockchain is not None:
            
            _query_params.append(('blockchain', blockchain))
            
        if address_type is not None:
            
            _query_params.append(('addressType', address_type))
            
        if query is not None:
            
            _query_params.append(('query', query))
            
        if network is not None:
            
            _query_params.append(('network', network))
            
        if include_already_signed_by_user is not None:
            
            _query_params.append(('includeAlreadySignedByUser', include_already_signed_by_user))
            
        # process the header parameters
        # process the form parameters
        # process the body parameter


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json'
                ]
            )


        # authentication setting
        _auth_settings: List[str] = [
            'ApiKeyTPV1'
        ]

        return self.api_client.param_serialize(
            method='GET',
            resource_path='/api/rest/v1/whitelists/addresses/for-approval',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def whitelist_service_reject_whitelisted_address(
        self,
        body: TgvalidatordRejectWhitelistedAddressRequest,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> object:
        """Reject a whitelisted address

        This endpoint rejects a whitelisted address.  Required role: **WhitelistedAddressApprover**.

        :param body: (required)
        :type body: TgvalidatordRejectWhitelistedAddressRequest
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._whitelist_service_reject_whitelisted_address_serialize(
            body=body,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "object",
            '400': "object",
            '401': "object",
            '403': "object",
            '404': "object",
            '500': "object",
            '503': "object",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def whitelist_service_reject_whitelisted_address_with_http_info(
        self,
        body: TgvalidatordRejectWhitelistedAddressRequest,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[object]:
        """Reject a whitelisted address

        This endpoint rejects a whitelisted address.  Required role: **WhitelistedAddressApprover**.

        :param body: (required)
        :type body: TgvalidatordRejectWhitelistedAddressRequest
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._whitelist_service_reject_whitelisted_address_serialize(
            body=body,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "object",
            '400': "object",
            '401': "object",
            '403': "object",
            '404': "object",
            '500': "object",
            '503': "object",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def whitelist_service_reject_whitelisted_address_without_preload_content(
        self,
        body: TgvalidatordRejectWhitelistedAddressRequest,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """Reject a whitelisted address

        This endpoint rejects a whitelisted address.  Required role: **WhitelistedAddressApprover**.

        :param body: (required)
        :type body: TgvalidatordRejectWhitelistedAddressRequest
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._whitelist_service_reject_whitelisted_address_serialize(
            body=body,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "object",
            '400': "object",
            '401': "object",
            '403': "object",
            '404': "object",
            '500': "object",
            '503': "object",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _whitelist_service_reject_whitelisted_address_serialize(
        self,
        body,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        # process the query parameters
        # process the header parameters
        # process the form parameters
        # process the body parameter
        if body is not None:
            _body_params = body


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json'
                ]
            )

        # set the HTTP header `Content-Type`
        if _content_type:
            _header_params['Content-Type'] = _content_type
        else:
            _default_content_type = (
                self.api_client.select_header_content_type(
                    [
                        'application/json'
                    ]
                )
            )
            if _default_content_type is not None:
                _header_params['Content-Type'] = _default_content_type

        # authentication setting
        _auth_settings: List[str] = [
            'ApiKeyTPV1'
        ]

        return self.api_client.param_serialize(
            method='POST',
            resource_path='/api/rest/v1/whitelists/addresses/reject',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )


