// Code generated by protoc-gen-ts_proto. DO NOT EDIT.
// versions:
//   protoc-gen-ts_proto  v1.181.2
//   protoc               v6.33.4
// source: health-service.proto

/* eslint-disable */
import Long from "long";
import _m0 from "protobufjs/minimal";
import { Health, HealthComponent, HealthGroup } from "./health";

export const protobufPackage = "tgvalidatord";

export interface GetHealthCheckRequest {
  group: string;
  healthCheck: string;
  tenantId: number;
  failIfUnhealthy: boolean;
}

export interface GetHealthCheckReply {
  health: Health | undefined;
}

export interface GetHealthChecksInGroupRequest {
  group: string;
  tenantId: number;
  failIfUnhealthy: boolean;
}

export interface GetHealthChecksInGroupReply {
  healths: Health[];
}

export interface GetHealthChecksRequest {
  tenantId: number;
  failIfUnhealthy: boolean;
}

export interface GetHealthChecksReply {
  groups: { [key: string]: HealthGroup };
}

export interface GetHealthChecksReply_GroupsEntry {
  key: string;
  value: HealthGroup | undefined;
}

export interface GetAllHealthChecksRequest {
  tenantId: number;
  failIfUnhealthy: boolean;
}

export interface GetAllHealthChecksReply {
  components: { [key: string]: HealthComponent };
}

export interface GetAllHealthChecksReply_ComponentsEntry {
  key: string;
  value: HealthComponent | undefined;
}

function createBaseGetHealthCheckRequest(): GetHealthCheckRequest {
  return { group: "", healthCheck: "", tenantId: 0, failIfUnhealthy: false };
}

export const GetHealthCheckRequest = {
  encode(message: GetHealthCheckRequest, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.group !== "") {
      writer.uint32(10).string(message.group);
    }
    if (message.healthCheck !== "") {
      writer.uint32(18).string(message.healthCheck);
    }
    if (message.tenantId !== 0) {
      writer.uint32(24).uint64(message.tenantId);
    }
    if (message.failIfUnhealthy !== false) {
      writer.uint32(32).bool(message.failIfUnhealthy);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): GetHealthCheckRequest {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetHealthCheckRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.group = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.healthCheck = reader.string();
          continue;
        case 3:
          if (tag !== 24) {
            break;
          }

          message.tenantId = longToNumber(reader.uint64() as Long);
          continue;
        case 4:
          if (tag !== 32) {
            break;
          }

          message.failIfUnhealthy = reader.bool();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetHealthCheckRequest {
    return {
      group: isSet(object.group) ? globalThis.String(object.group) : "",
      healthCheck: isSet(object.healthCheck) ? globalThis.String(object.healthCheck) : "",
      tenantId: isSet(object.tenantId) ? globalThis.Number(object.tenantId) : 0,
      failIfUnhealthy: isSet(object.failIfUnhealthy) ? globalThis.Boolean(object.failIfUnhealthy) : false,
    };
  },

  toJSON(message: GetHealthCheckRequest): unknown {
    const obj: any = {};
    if (message.group !== "") {
      obj.group = message.group;
    }
    if (message.healthCheck !== "") {
      obj.healthCheck = message.healthCheck;
    }
    if (message.tenantId !== 0) {
      obj.tenantId = Math.round(message.tenantId);
    }
    if (message.failIfUnhealthy !== false) {
      obj.failIfUnhealthy = message.failIfUnhealthy;
    }
    return obj;
  },

  create(base?: DeepPartial<GetHealthCheckRequest>): GetHealthCheckRequest {
    return GetHealthCheckRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<GetHealthCheckRequest>): GetHealthCheckRequest {
    const message = createBaseGetHealthCheckRequest();
    message.group = object.group ?? "";
    message.healthCheck = object.healthCheck ?? "";
    message.tenantId = object.tenantId ?? 0;
    message.failIfUnhealthy = object.failIfUnhealthy ?? false;
    return message;
  },
};

function createBaseGetHealthCheckReply(): GetHealthCheckReply {
  return { health: undefined };
}

export const GetHealthCheckReply = {
  encode(message: GetHealthCheckReply, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.health !== undefined) {
      Health.encode(message.health, writer.uint32(10).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): GetHealthCheckReply {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetHealthCheckReply();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.health = Health.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetHealthCheckReply {
    return { health: isSet(object.health) ? Health.fromJSON(object.health) : undefined };
  },

  toJSON(message: GetHealthCheckReply): unknown {
    const obj: any = {};
    if (message.health !== undefined) {
      obj.health = Health.toJSON(message.health);
    }
    return obj;
  },

  create(base?: DeepPartial<GetHealthCheckReply>): GetHealthCheckReply {
    return GetHealthCheckReply.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<GetHealthCheckReply>): GetHealthCheckReply {
    const message = createBaseGetHealthCheckReply();
    message.health = (object.health !== undefined && object.health !== null)
      ? Health.fromPartial(object.health)
      : undefined;
    return message;
  },
};

function createBaseGetHealthChecksInGroupRequest(): GetHealthChecksInGroupRequest {
  return { group: "", tenantId: 0, failIfUnhealthy: false };
}

export const GetHealthChecksInGroupRequest = {
  encode(message: GetHealthChecksInGroupRequest, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.group !== "") {
      writer.uint32(10).string(message.group);
    }
    if (message.tenantId !== 0) {
      writer.uint32(16).uint64(message.tenantId);
    }
    if (message.failIfUnhealthy !== false) {
      writer.uint32(24).bool(message.failIfUnhealthy);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): GetHealthChecksInGroupRequest {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetHealthChecksInGroupRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.group = reader.string();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.tenantId = longToNumber(reader.uint64() as Long);
          continue;
        case 3:
          if (tag !== 24) {
            break;
          }

          message.failIfUnhealthy = reader.bool();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetHealthChecksInGroupRequest {
    return {
      group: isSet(object.group) ? globalThis.String(object.group) : "",
      tenantId: isSet(object.tenantId) ? globalThis.Number(object.tenantId) : 0,
      failIfUnhealthy: isSet(object.failIfUnhealthy) ? globalThis.Boolean(object.failIfUnhealthy) : false,
    };
  },

  toJSON(message: GetHealthChecksInGroupRequest): unknown {
    const obj: any = {};
    if (message.group !== "") {
      obj.group = message.group;
    }
    if (message.tenantId !== 0) {
      obj.tenantId = Math.round(message.tenantId);
    }
    if (message.failIfUnhealthy !== false) {
      obj.failIfUnhealthy = message.failIfUnhealthy;
    }
    return obj;
  },

  create(base?: DeepPartial<GetHealthChecksInGroupRequest>): GetHealthChecksInGroupRequest {
    return GetHealthChecksInGroupRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<GetHealthChecksInGroupRequest>): GetHealthChecksInGroupRequest {
    const message = createBaseGetHealthChecksInGroupRequest();
    message.group = object.group ?? "";
    message.tenantId = object.tenantId ?? 0;
    message.failIfUnhealthy = object.failIfUnhealthy ?? false;
    return message;
  },
};

function createBaseGetHealthChecksInGroupReply(): GetHealthChecksInGroupReply {
  return { healths: [] };
}

export const GetHealthChecksInGroupReply = {
  encode(message: GetHealthChecksInGroupReply, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    for (const v of message.healths) {
      Health.encode(v!, writer.uint32(10).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): GetHealthChecksInGroupReply {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetHealthChecksInGroupReply();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.healths.push(Health.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetHealthChecksInGroupReply {
    return {
      healths: globalThis.Array.isArray(object?.healths) ? object.healths.map((e: any) => Health.fromJSON(e)) : [],
    };
  },

  toJSON(message: GetHealthChecksInGroupReply): unknown {
    const obj: any = {};
    if (message.healths?.length) {
      obj.healths = message.healths.map((e) => Health.toJSON(e));
    }
    return obj;
  },

  create(base?: DeepPartial<GetHealthChecksInGroupReply>): GetHealthChecksInGroupReply {
    return GetHealthChecksInGroupReply.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<GetHealthChecksInGroupReply>): GetHealthChecksInGroupReply {
    const message = createBaseGetHealthChecksInGroupReply();
    message.healths = object.healths?.map((e) => Health.fromPartial(e)) || [];
    return message;
  },
};

function createBaseGetHealthChecksRequest(): GetHealthChecksRequest {
  return { tenantId: 0, failIfUnhealthy: false };
}

export const GetHealthChecksRequest = {
  encode(message: GetHealthChecksRequest, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.tenantId !== 0) {
      writer.uint32(8).uint64(message.tenantId);
    }
    if (message.failIfUnhealthy !== false) {
      writer.uint32(16).bool(message.failIfUnhealthy);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): GetHealthChecksRequest {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetHealthChecksRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.tenantId = longToNumber(reader.uint64() as Long);
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.failIfUnhealthy = reader.bool();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetHealthChecksRequest {
    return {
      tenantId: isSet(object.tenantId) ? globalThis.Number(object.tenantId) : 0,
      failIfUnhealthy: isSet(object.failIfUnhealthy) ? globalThis.Boolean(object.failIfUnhealthy) : false,
    };
  },

  toJSON(message: GetHealthChecksRequest): unknown {
    const obj: any = {};
    if (message.tenantId !== 0) {
      obj.tenantId = Math.round(message.tenantId);
    }
    if (message.failIfUnhealthy !== false) {
      obj.failIfUnhealthy = message.failIfUnhealthy;
    }
    return obj;
  },

  create(base?: DeepPartial<GetHealthChecksRequest>): GetHealthChecksRequest {
    return GetHealthChecksRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<GetHealthChecksRequest>): GetHealthChecksRequest {
    const message = createBaseGetHealthChecksRequest();
    message.tenantId = object.tenantId ?? 0;
    message.failIfUnhealthy = object.failIfUnhealthy ?? false;
    return message;
  },
};

function createBaseGetHealthChecksReply(): GetHealthChecksReply {
  return { groups: {} };
}

export const GetHealthChecksReply = {
  encode(message: GetHealthChecksReply, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    Object.entries(message.groups).forEach(([key, value]) => {
      GetHealthChecksReply_GroupsEntry.encode({ key: key as any, value }, writer.uint32(10).fork()).ldelim();
    });
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): GetHealthChecksReply {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetHealthChecksReply();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          const entry1 = GetHealthChecksReply_GroupsEntry.decode(reader, reader.uint32());
          if (entry1.value !== undefined) {
            message.groups[entry1.key] = entry1.value;
          }
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetHealthChecksReply {
    return {
      groups: isObject(object.groups)
        ? Object.entries(object.groups).reduce<{ [key: string]: HealthGroup }>((acc, [key, value]) => {
          acc[key] = HealthGroup.fromJSON(value);
          return acc;
        }, {})
        : {},
    };
  },

  toJSON(message: GetHealthChecksReply): unknown {
    const obj: any = {};
    if (message.groups) {
      const entries = Object.entries(message.groups);
      if (entries.length > 0) {
        obj.groups = {};
        entries.forEach(([k, v]) => {
          obj.groups[k] = HealthGroup.toJSON(v);
        });
      }
    }
    return obj;
  },

  create(base?: DeepPartial<GetHealthChecksReply>): GetHealthChecksReply {
    return GetHealthChecksReply.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<GetHealthChecksReply>): GetHealthChecksReply {
    const message = createBaseGetHealthChecksReply();
    message.groups = Object.entries(object.groups ?? {}).reduce<{ [key: string]: HealthGroup }>((acc, [key, value]) => {
      if (value !== undefined) {
        acc[key] = HealthGroup.fromPartial(value);
      }
      return acc;
    }, {});
    return message;
  },
};

function createBaseGetHealthChecksReply_GroupsEntry(): GetHealthChecksReply_GroupsEntry {
  return { key: "", value: undefined };
}

export const GetHealthChecksReply_GroupsEntry = {
  encode(message: GetHealthChecksReply_GroupsEntry, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.key !== "") {
      writer.uint32(10).string(message.key);
    }
    if (message.value !== undefined) {
      HealthGroup.encode(message.value, writer.uint32(18).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): GetHealthChecksReply_GroupsEntry {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetHealthChecksReply_GroupsEntry();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.key = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.value = HealthGroup.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetHealthChecksReply_GroupsEntry {
    return {
      key: isSet(object.key) ? globalThis.String(object.key) : "",
      value: isSet(object.value) ? HealthGroup.fromJSON(object.value) : undefined,
    };
  },

  toJSON(message: GetHealthChecksReply_GroupsEntry): unknown {
    const obj: any = {};
    if (message.key !== "") {
      obj.key = message.key;
    }
    if (message.value !== undefined) {
      obj.value = HealthGroup.toJSON(message.value);
    }
    return obj;
  },

  create(base?: DeepPartial<GetHealthChecksReply_GroupsEntry>): GetHealthChecksReply_GroupsEntry {
    return GetHealthChecksReply_GroupsEntry.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<GetHealthChecksReply_GroupsEntry>): GetHealthChecksReply_GroupsEntry {
    const message = createBaseGetHealthChecksReply_GroupsEntry();
    message.key = object.key ?? "";
    message.value = (object.value !== undefined && object.value !== null)
      ? HealthGroup.fromPartial(object.value)
      : undefined;
    return message;
  },
};

function createBaseGetAllHealthChecksRequest(): GetAllHealthChecksRequest {
  return { tenantId: 0, failIfUnhealthy: false };
}

export const GetAllHealthChecksRequest = {
  encode(message: GetAllHealthChecksRequest, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.tenantId !== 0) {
      writer.uint32(8).uint64(message.tenantId);
    }
    if (message.failIfUnhealthy !== false) {
      writer.uint32(16).bool(message.failIfUnhealthy);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): GetAllHealthChecksRequest {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetAllHealthChecksRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.tenantId = longToNumber(reader.uint64() as Long);
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.failIfUnhealthy = reader.bool();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetAllHealthChecksRequest {
    return {
      tenantId: isSet(object.tenantId) ? globalThis.Number(object.tenantId) : 0,
      failIfUnhealthy: isSet(object.failIfUnhealthy) ? globalThis.Boolean(object.failIfUnhealthy) : false,
    };
  },

  toJSON(message: GetAllHealthChecksRequest): unknown {
    const obj: any = {};
    if (message.tenantId !== 0) {
      obj.tenantId = Math.round(message.tenantId);
    }
    if (message.failIfUnhealthy !== false) {
      obj.failIfUnhealthy = message.failIfUnhealthy;
    }
    return obj;
  },

  create(base?: DeepPartial<GetAllHealthChecksRequest>): GetAllHealthChecksRequest {
    return GetAllHealthChecksRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<GetAllHealthChecksRequest>): GetAllHealthChecksRequest {
    const message = createBaseGetAllHealthChecksRequest();
    message.tenantId = object.tenantId ?? 0;
    message.failIfUnhealthy = object.failIfUnhealthy ?? false;
    return message;
  },
};

function createBaseGetAllHealthChecksReply(): GetAllHealthChecksReply {
  return { components: {} };
}

export const GetAllHealthChecksReply = {
  encode(message: GetAllHealthChecksReply, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    Object.entries(message.components).forEach(([key, value]) => {
      GetAllHealthChecksReply_ComponentsEntry.encode({ key: key as any, value }, writer.uint32(10).fork()).ldelim();
    });
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): GetAllHealthChecksReply {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetAllHealthChecksReply();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          const entry1 = GetAllHealthChecksReply_ComponentsEntry.decode(reader, reader.uint32());
          if (entry1.value !== undefined) {
            message.components[entry1.key] = entry1.value;
          }
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetAllHealthChecksReply {
    return {
      components: isObject(object.components)
        ? Object.entries(object.components).reduce<{ [key: string]: HealthComponent }>((acc, [key, value]) => {
          acc[key] = HealthComponent.fromJSON(value);
          return acc;
        }, {})
        : {},
    };
  },

  toJSON(message: GetAllHealthChecksReply): unknown {
    const obj: any = {};
    if (message.components) {
      const entries = Object.entries(message.components);
      if (entries.length > 0) {
        obj.components = {};
        entries.forEach(([k, v]) => {
          obj.components[k] = HealthComponent.toJSON(v);
        });
      }
    }
    return obj;
  },

  create(base?: DeepPartial<GetAllHealthChecksReply>): GetAllHealthChecksReply {
    return GetAllHealthChecksReply.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<GetAllHealthChecksReply>): GetAllHealthChecksReply {
    const message = createBaseGetAllHealthChecksReply();
    message.components = Object.entries(object.components ?? {}).reduce<{ [key: string]: HealthComponent }>(
      (acc, [key, value]) => {
        if (value !== undefined) {
          acc[key] = HealthComponent.fromPartial(value);
        }
        return acc;
      },
      {},
    );
    return message;
  },
};

function createBaseGetAllHealthChecksReply_ComponentsEntry(): GetAllHealthChecksReply_ComponentsEntry {
  return { key: "", value: undefined };
}

export const GetAllHealthChecksReply_ComponentsEntry = {
  encode(message: GetAllHealthChecksReply_ComponentsEntry, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.key !== "") {
      writer.uint32(10).string(message.key);
    }
    if (message.value !== undefined) {
      HealthComponent.encode(message.value, writer.uint32(18).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): GetAllHealthChecksReply_ComponentsEntry {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetAllHealthChecksReply_ComponentsEntry();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.key = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.value = HealthComponent.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetAllHealthChecksReply_ComponentsEntry {
    return {
      key: isSet(object.key) ? globalThis.String(object.key) : "",
      value: isSet(object.value) ? HealthComponent.fromJSON(object.value) : undefined,
    };
  },

  toJSON(message: GetAllHealthChecksReply_ComponentsEntry): unknown {
    const obj: any = {};
    if (message.key !== "") {
      obj.key = message.key;
    }
    if (message.value !== undefined) {
      obj.value = HealthComponent.toJSON(message.value);
    }
    return obj;
  },

  create(base?: DeepPartial<GetAllHealthChecksReply_ComponentsEntry>): GetAllHealthChecksReply_ComponentsEntry {
    return GetAllHealthChecksReply_ComponentsEntry.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<GetAllHealthChecksReply_ComponentsEntry>): GetAllHealthChecksReply_ComponentsEntry {
    const message = createBaseGetAllHealthChecksReply_ComponentsEntry();
    message.key = object.key ?? "";
    message.value = (object.value !== undefined && object.value !== null)
      ? HealthComponent.fromPartial(object.value)
      : undefined;
    return message;
  },
};

export interface HealthService {
  GetHealthChecks(request: GetHealthChecksRequest): Promise<GetHealthChecksReply>;
  GetHealthCheck(request: GetHealthCheckRequest): Promise<GetHealthCheckReply>;
  GetHealthChecksInGroup(request: GetHealthChecksInGroupRequest): Promise<GetHealthChecksInGroupReply>;
  /** It is important that this is defined AFTER the more generic /api/rest/v1/health/{group} routes */
  GetAllHealthChecks(request: GetAllHealthChecksRequest): Promise<GetAllHealthChecksReply>;
}

export const HealthServiceServiceName = "tgvalidatord.HealthService";
export class HealthServiceClientImpl implements HealthService {
  private readonly rpc: Rpc;
  private readonly service: string;
  constructor(rpc: Rpc, opts?: { service?: string }) {
    this.service = opts?.service || HealthServiceServiceName;
    this.rpc = rpc;
    this.GetHealthChecks = this.GetHealthChecks.bind(this);
    this.GetHealthCheck = this.GetHealthCheck.bind(this);
    this.GetHealthChecksInGroup = this.GetHealthChecksInGroup.bind(this);
    this.GetAllHealthChecks = this.GetAllHealthChecks.bind(this);
  }
  GetHealthChecks(request: GetHealthChecksRequest): Promise<GetHealthChecksReply> {
    const data = GetHealthChecksRequest.encode(request).finish();
    const promise = this.rpc.request(this.service, "GetHealthChecks", data);
    return promise.then((data) => GetHealthChecksReply.decode(_m0.Reader.create(data)));
  }

  GetHealthCheck(request: GetHealthCheckRequest): Promise<GetHealthCheckReply> {
    const data = GetHealthCheckRequest.encode(request).finish();
    const promise = this.rpc.request(this.service, "GetHealthCheck", data);
    return promise.then((data) => GetHealthCheckReply.decode(_m0.Reader.create(data)));
  }

  GetHealthChecksInGroup(request: GetHealthChecksInGroupRequest): Promise<GetHealthChecksInGroupReply> {
    const data = GetHealthChecksInGroupRequest.encode(request).finish();
    const promise = this.rpc.request(this.service, "GetHealthChecksInGroup", data);
    return promise.then((data) => GetHealthChecksInGroupReply.decode(_m0.Reader.create(data)));
  }

  GetAllHealthChecks(request: GetAllHealthChecksRequest): Promise<GetAllHealthChecksReply> {
    const data = GetAllHealthChecksRequest.encode(request).finish();
    const promise = this.rpc.request(this.service, "GetAllHealthChecks", data);
    return promise.then((data) => GetAllHealthChecksReply.decode(_m0.Reader.create(data)));
  }
}

interface Rpc {
  request(service: string, method: string, data: Uint8Array): Promise<Uint8Array>;
}

type Builtin = Date | Function | Uint8Array | string | number | boolean | undefined;

export type DeepPartial<T> = T extends Builtin ? T
  : T extends globalThis.Array<infer U> ? globalThis.Array<DeepPartial<U>>
  : T extends ReadonlyArray<infer U> ? ReadonlyArray<DeepPartial<U>>
  : T extends {} ? { [K in keyof T]?: DeepPartial<T[K]> }
  : Partial<T>;

function longToNumber(long: Long): number {
  if (long.gt(globalThis.Number.MAX_SAFE_INTEGER)) {
    throw new globalThis.Error("Value is larger than Number.MAX_SAFE_INTEGER");
  }
  if (long.lt(globalThis.Number.MIN_SAFE_INTEGER)) {
    throw new globalThis.Error("Value is smaller than Number.MIN_SAFE_INTEGER");
  }
  return long.toNumber();
}

if (_m0.util.Long !== Long) {
  _m0.util.Long = Long as any;
  _m0.configure();
}

function isObject(value: any): boolean {
  return typeof value === "object" && value !== null;
}

function isSet(value: any): boolean {
  return value !== null && value !== undefined;
}
