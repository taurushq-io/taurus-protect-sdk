/*
Taurus-PROTECT APIs

Taurus-PROTECT APIs description

API version: 1.0
*/

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package openapi

import (
	"bytes"
	"context"
	"io"
	"net/http"
	"net/url"
	"reflect"
)


// BusinessRulesAPIService BusinessRulesAPI service
type BusinessRulesAPIService service

type ApiRuleServiceGetBusinessRulesRequest struct {
	ctx context.Context
	ApiService *BusinessRulesAPIService
	limit *string
	offset *string
	ids *[]string
	ruleKeys *[]string
	ruleGroups *[]string
	walletIds *[]string
	currencies *[]string
	addressIds *[]string
	level *string
}

func (r ApiRuleServiceGetBusinessRulesRequest) Limit(limit string) ApiRuleServiceGetBusinessRulesRequest {
	r.limit = &limit
	return r
}

func (r ApiRuleServiceGetBusinessRulesRequest) Offset(offset string) ApiRuleServiceGetBusinessRulesRequest {
	r.offset = &offset
	return r
}

func (r ApiRuleServiceGetBusinessRulesRequest) Ids(ids []string) ApiRuleServiceGetBusinessRulesRequest {
	r.ids = &ids
	return r
}

func (r ApiRuleServiceGetBusinessRulesRequest) RuleKeys(ruleKeys []string) ApiRuleServiceGetBusinessRulesRequest {
	r.ruleKeys = &ruleKeys
	return r
}

func (r ApiRuleServiceGetBusinessRulesRequest) RuleGroups(ruleGroups []string) ApiRuleServiceGetBusinessRulesRequest {
	r.ruleGroups = &ruleGroups
	return r
}

func (r ApiRuleServiceGetBusinessRulesRequest) WalletIds(walletIds []string) ApiRuleServiceGetBusinessRulesRequest {
	r.walletIds = &walletIds
	return r
}

// Filter on IDs or symbols of the currency
func (r ApiRuleServiceGetBusinessRulesRequest) Currencies(currencies []string) ApiRuleServiceGetBusinessRulesRequest {
	r.currencies = &currencies
	return r
}

func (r ApiRuleServiceGetBusinessRulesRequest) AddressIds(addressIds []string) ApiRuleServiceGetBusinessRulesRequest {
	r.addressIds = &addressIds
	return r
}

// one of &#39;&#39;, &#39;global&#39;, &#39;currency&#39;, &#39;address&#39;, &#39;wallet&#39;
func (r ApiRuleServiceGetBusinessRulesRequest) Level(level string) ApiRuleServiceGetBusinessRulesRequest {
	r.level = &level
	return r
}

func (r ApiRuleServiceGetBusinessRulesRequest) Execute() (*TgvalidatordGetBusinessRulesReply, *http.Response, error) {
	return r.ApiService.RuleServiceGetBusinessRulesExecute(r)
}

/*
RuleServiceGetBusinessRules List business rules

Deprecated - Use /api/rest/v2/businessrules instead - This endpoint returns a list of business rules.
 Required role: **Admin** or **AdminReadOnly**.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiRuleServiceGetBusinessRulesRequest

Deprecated
*/
func (a *BusinessRulesAPIService) RuleServiceGetBusinessRules(ctx context.Context) ApiRuleServiceGetBusinessRulesRequest {
	return ApiRuleServiceGetBusinessRulesRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return TgvalidatordGetBusinessRulesReply
// Deprecated
func (a *BusinessRulesAPIService) RuleServiceGetBusinessRulesExecute(r ApiRuleServiceGetBusinessRulesRequest) (*TgvalidatordGetBusinessRulesReply, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *TgvalidatordGetBusinessRulesReply
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "BusinessRulesAPIService.RuleServiceGetBusinessRules")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/rest/v1/businessrules"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.limit != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "limit", r.limit, "", "")
	}
	if r.offset != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "offset", r.offset, "", "")
	}
	if r.ids != nil {
		t := *r.ids
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "ids", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "ids", t, "form", "multi")
		}
	}
	if r.ruleKeys != nil {
		t := *r.ruleKeys
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "ruleKeys", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "ruleKeys", t, "form", "multi")
		}
	}
	if r.ruleGroups != nil {
		t := *r.ruleGroups
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "ruleGroups", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "ruleGroups", t, "form", "multi")
		}
	}
	if r.walletIds != nil {
		t := *r.walletIds
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "walletIds", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "walletIds", t, "form", "multi")
		}
	}
	if r.currencies != nil {
		t := *r.currencies
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "currencies", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "currencies", t, "form", "multi")
		}
	}
	if r.addressIds != nil {
		t := *r.addressIds
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "addressIds", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "addressIds", t, "form", "multi")
		}
	}
	if r.level != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "level", r.level, "", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["ApiKeyTPV1"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v map[string]interface{}
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v map[string]interface{}
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v map[string]interface{}
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v map[string]interface{}
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v map[string]interface{}
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 503 {
			var v map[string]interface{}
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
			var v GooglerpcStatus
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiRuleServiceGetBusinessRulesV2Request struct {
	ctx context.Context
	ApiService *BusinessRulesAPIService
	ids *[]string
	ruleKeys *[]string
	ruleGroups *[]string
	walletIds *[]string
	currencyIds *[]string
	addressIds *[]string
	level *string
	cursorCurrentPage *string
	cursorPageRequest *string
	cursorPageSize *string
	entityType *string
	entityIDs *[]string
}

func (r ApiRuleServiceGetBusinessRulesV2Request) Ids(ids []string) ApiRuleServiceGetBusinessRulesV2Request {
	r.ids = &ids
	return r
}

func (r ApiRuleServiceGetBusinessRulesV2Request) RuleKeys(ruleKeys []string) ApiRuleServiceGetBusinessRulesV2Request {
	r.ruleKeys = &ruleKeys
	return r
}

func (r ApiRuleServiceGetBusinessRulesV2Request) RuleGroups(ruleGroups []string) ApiRuleServiceGetBusinessRulesV2Request {
	r.ruleGroups = &ruleGroups
	return r
}

// Deprecated - Use EntityType and EntityID instead
func (r ApiRuleServiceGetBusinessRulesV2Request) WalletIds(walletIds []string) ApiRuleServiceGetBusinessRulesV2Request {
	r.walletIds = &walletIds
	return r
}

// Filter on currency ids
func (r ApiRuleServiceGetBusinessRulesV2Request) CurrencyIds(currencyIds []string) ApiRuleServiceGetBusinessRulesV2Request {
	r.currencyIds = &currencyIds
	return r
}

// Deprecated - Use EntityType and EntityID instead
func (r ApiRuleServiceGetBusinessRulesV2Request) AddressIds(addressIds []string) ApiRuleServiceGetBusinessRulesV2Request {
	r.addressIds = &addressIds
	return r
}

// Deprecated - Use EntityType instead  one of &#39;&#39;, &#39;global&#39;, &#39;currency&#39;, &#39;address&#39;, &#39;wallet&#39;
func (r ApiRuleServiceGetBusinessRulesV2Request) Level(level string) ApiRuleServiceGetBusinessRulesV2Request {
	r.level = &level
	return r
}

// Base64-encoded string representing the current window of data
func (r ApiRuleServiceGetBusinessRulesV2Request) CursorCurrentPage(cursorCurrentPage string) ApiRuleServiceGetBusinessRulesV2Request {
	r.cursorCurrentPage = &cursorCurrentPage
	return r
}

// The page to request, w.r.t the current page. Can be one of &#x60;FIRST&#x60;, &#x60;PREVIOUS&#x60;, &#x60;NEXT&#x60;, &#x60;LAST&#x60;
func (r ApiRuleServiceGetBusinessRulesV2Request) CursorPageRequest(cursorPageRequest string) ApiRuleServiceGetBusinessRulesV2Request {
	r.cursorPageRequest = &cursorPageRequest
	return r
}

// The size of the page requested. The handling service should impose a hard limit on this
func (r ApiRuleServiceGetBusinessRulesV2Request) CursorPageSize(cursorPageSize string) ApiRuleServiceGetBusinessRulesV2Request {
	r.cursorPageSize = &cursorPageSize
	return r
}

// Filters rules by what they apply to. This can be one of &#x60;global&#x60;, &#x60;currency&#x60;, &#x60;wallet&#x60;, &#x60;address&#x60;, &#x60;exchange&#x60;, &#x60;exchange_account&#x60;, &#x60;tn_participant&#x60;.
func (r ApiRuleServiceGetBusinessRulesV2Request) EntityType(entityType string) ApiRuleServiceGetBusinessRulesV2Request {
	r.entityType = &entityType
	return r
}

// Filters rules by the identifier of the affected entity. For wallets, addresses, and currencies this is their ID. For exchanges this is the exchange label. Leave this field blank for global rules.
func (r ApiRuleServiceGetBusinessRulesV2Request) EntityIDs(entityIDs []string) ApiRuleServiceGetBusinessRulesV2Request {
	r.entityIDs = &entityIDs
	return r
}

func (r ApiRuleServiceGetBusinessRulesV2Request) Execute() (*TgvalidatordGetBusinessRulesV2Reply, *http.Response, error) {
	return r.ApiService.RuleServiceGetBusinessRulesV2Execute(r)
}

/*
RuleServiceGetBusinessRulesV2 List business rules

This endpoint returns a list of business rules.
 Required role: **Admin** or **AdminReadOnly**.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiRuleServiceGetBusinessRulesV2Request
*/
func (a *BusinessRulesAPIService) RuleServiceGetBusinessRulesV2(ctx context.Context) ApiRuleServiceGetBusinessRulesV2Request {
	return ApiRuleServiceGetBusinessRulesV2Request{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return TgvalidatordGetBusinessRulesV2Reply
func (a *BusinessRulesAPIService) RuleServiceGetBusinessRulesV2Execute(r ApiRuleServiceGetBusinessRulesV2Request) (*TgvalidatordGetBusinessRulesV2Reply, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *TgvalidatordGetBusinessRulesV2Reply
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "BusinessRulesAPIService.RuleServiceGetBusinessRulesV2")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/rest/v2/businessrules"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.ids != nil {
		t := *r.ids
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "ids", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "ids", t, "form", "multi")
		}
	}
	if r.ruleKeys != nil {
		t := *r.ruleKeys
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "ruleKeys", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "ruleKeys", t, "form", "multi")
		}
	}
	if r.ruleGroups != nil {
		t := *r.ruleGroups
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "ruleGroups", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "ruleGroups", t, "form", "multi")
		}
	}
	if r.walletIds != nil {
		t := *r.walletIds
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "walletIds", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "walletIds", t, "form", "multi")
		}
	}
	if r.currencyIds != nil {
		t := *r.currencyIds
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "currencyIds", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "currencyIds", t, "form", "multi")
		}
	}
	if r.addressIds != nil {
		t := *r.addressIds
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "addressIds", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "addressIds", t, "form", "multi")
		}
	}
	if r.level != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "level", r.level, "", "")
	}
	if r.cursorCurrentPage != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "cursor.currentPage", r.cursorCurrentPage, "", "")
	}
	if r.cursorPageRequest != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "cursor.pageRequest", r.cursorPageRequest, "", "")
	}
	if r.cursorPageSize != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "cursor.pageSize", r.cursorPageSize, "", "")
	}
	if r.entityType != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "entityType", r.entityType, "", "")
	}
	if r.entityIDs != nil {
		t := *r.entityIDs
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "entityIDs", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "entityIDs", t, "form", "multi")
		}
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["ApiKeyTPV1"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v map[string]interface{}
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v map[string]interface{}
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v map[string]interface{}
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v map[string]interface{}
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v map[string]interface{}
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 503 {
			var v map[string]interface{}
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
			var v GooglerpcStatus
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiRuleServiceUpdateTransactionsEnabledBusinessRuleRequest struct {
	ctx context.Context
	ApiService *BusinessRulesAPIService
	body *TgvalidatordUpdateTransactionsEnabledBusinessRuleRequest
}

func (r ApiRuleServiceUpdateTransactionsEnabledBusinessRuleRequest) Body(body TgvalidatordUpdateTransactionsEnabledBusinessRuleRequest) ApiRuleServiceUpdateTransactionsEnabledBusinessRuleRequest {
	r.body = &body
	return r
}

func (r ApiRuleServiceUpdateTransactionsEnabledBusinessRuleRequest) Execute() (map[string]interface{}, *http.Response, error) {
	return r.ApiService.RuleServiceUpdateTransactionsEnabledBusinessRuleExecute(r)
}

/*
RuleServiceUpdateTransactionsEnabledBusinessRule Enable/disable requests

This endpoint toggles the requests enabling rule.
 Required role: **Admin**.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiRuleServiceUpdateTransactionsEnabledBusinessRuleRequest
*/
func (a *BusinessRulesAPIService) RuleServiceUpdateTransactionsEnabledBusinessRule(ctx context.Context) ApiRuleServiceUpdateTransactionsEnabledBusinessRuleRequest {
	return ApiRuleServiceUpdateTransactionsEnabledBusinessRuleRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return map[string]interface{}
func (a *BusinessRulesAPIService) RuleServiceUpdateTransactionsEnabledBusinessRuleExecute(r ApiRuleServiceUpdateTransactionsEnabledBusinessRuleRequest) (map[string]interface{}, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  map[string]interface{}
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "BusinessRulesAPIService.RuleServiceUpdateTransactionsEnabledBusinessRule")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/rest/v1/businessrules/transactions_enabled"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.body == nil {
		return localVarReturnValue, nil, reportError("body is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["ApiKeyTPV1"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v map[string]interface{}
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v map[string]interface{}
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v map[string]interface{}
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v map[string]interface{}
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v map[string]interface{}
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 503 {
			var v map[string]interface{}
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
			var v GooglerpcStatus
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}
